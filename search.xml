<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Horror Game闲谈01</title>
      <link href="/2023/09/05/Horror_Gam_%E9%97%B2%E8%B0%8801/"/>
      <url>/2023/09/05/Horror_Gam_%E9%97%B2%E8%B0%8801/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>突然有点想聊聊这段时间接触恐怖系列作品的一些感受</p><p>最初只是每天看看邓肯的灵异故事解说下下饭，后来看完了老戴和友利奈绪的港诡全流程实况，就算是入了门，算下来到现在也就只不过三个月的时间。这期间我也算是接触了一定数量的恐怖作品，但是越看越让我感受到的不是满足感，而是无聊</p><p>首先说明一下，我个人是很不喜欢追逐战、捉迷藏、复杂解密这一套的，因为他们在不能让我感受到“恐惧”的同时，还卡我的关让我受苦，所以我遇到黑暗欺骗、逃生、纸嫁衣这类作品基本直接pass，或者看一眼五分钟退款。只能说，感觉不如。。卡我在法兰不死队的魂3，卡屑一郎的只狼，和连第一章都没打过的AC6哈哈哈。不得不说有无脑法爷的老头环真是太仁慈了</p><p>影视作品我也接触了一些——老到《咒怨》《山村老尸》，近到《尸忆》《纸人回魂》，感觉少了个交互性又感受又更差一些了，所以基本也是看了个头，或者跳着看高能，目前唯一让我看完的有恐怖tag的片子还是盗墓题材的《巴黎地下墓地》。。。</p><p>如果是针对恐怖性，2D、2.5D的恐游作品基本也可以pass，毕竟他们有着天生短板的第三视角，很难让人有氛围沉浸感。所以我更看重这类作品的叙事性，比如月光蟑螂的《烟火》《三伏》，或是只有拿满所有线索才能到HE的逆天《过阴》。将这几部作品当作一个interactive media中的小说来看，还是非常不错的</p><p>先来说说《纸人》吧，是为数不多还不错的中式民俗恐游作品了，我个人也非常吃“纸人”这个民俗意象。它在开头有个非常不错的氛围塑造，以及车祸腿受伤、存档要上香的设定，初期体验还是不错的。但是从玩家体验上来讲，等你过了初期，了解了这游戏的封印纸人的ultimate goal，他完全就变成了一个冒险游戏。同样的问题还有设计上场景局限在一个基本不会有特殊变化的老屋，并且给你地图。从逻辑上来看，我估计制作组给这游戏的最初定位就是“冒险”恐怖游戏这个方向，但是感觉对于一个追求纯粹的民俗恐怖的玩家来说（我），就比较难以接受了。个人觉得这种设定基本上“纸人”这个意象就只被赋予了追逐战捉迷藏抓玩家，或是开柜突脸杀的任务，基本没有展现出他应该在民俗氛围塑造上应起到的诡谲感，给人以精神折磨，或是兴奋之感。所以我没有买《纸人2》，因为他和一代大差不差，还甚至加上了fps元素。。。</p><p>《层层恐惧重制版》：这个重制版实际上是层层恐惧一代+二代+2DLC+虚幻五重制版，所以从体量上来讲确实挺让人满足的。除了作为恐游根本吓不到人以外，他的场景、场地变化、叙事性、艺术性等等真的是一绝，我愿称之为恐游中的艺术品，嗯，除了根本吓不到人以外。对于他的讨论我打算放在下面跟《Visage》一块儿讲</p><p>《Visage》：老早就听说过他的大名，只是这段时间才买下来体验了一下。和《层层恐惧》一样，这游戏focus的也基本都是心理恐怖，which means里面基本没有突脸杀，主打的就是一个闹鬼，给玩家一种压抑、恐惧感，让他们从精神上时刻紧绷，有一种“想逃离但是却逃不开”的感觉。其实我最欣赏的就是心理恐怖一类的手法、题材，但是这两部声名远扬的作品确实让我挺失望的。可以发现层层恐惧我只玩了5h过了画家章节，演员篇玩了个开头就没什么动力继续玩下去：因为难以感受到恐怖的氛围，所以基本就是一路按着shift赶进度，而且又由于恐游背景，叙事是根据线索、碎片化进行的，在赶进度的前提下就又更没法去耐心读完每个线索内容。这样下去就会恶性循环，吓又吓不倒故事也看不清楚，不如直接退出来的舒服；《Visage》不到两个小时就感觉到了麻烦，非线性流程却要搞出线性流程的解密，且提示不够明显，卡关，卡关，还是卡关，就变成一直在房子里晃悠。里面所谓的“闹鬼”事件因为节奏不对不仅吓不到玩家，还会起到反作用——我每次遇到这种事件的感觉就是，“我才刚开的灯你怎么就又给我关上了。。”这种感觉[Facepalm] 又他的机制不鼓励在黑暗中探索，手电筒有使用周期，鬼帮你关了灯也不打开，次次电筒没电在黑暗中找开关就突出一个烦人，所以也没太多心思继续玩下去了</p><p>从上面的一些feedback我逐渐感受到什么叫”看不起突脸，理解突脸，成为突脸“，因为确实，突脸是最朴素且行之有效的吓人方案。此处点名之前提到过的《Welcome to Kowloon》，我觉得他最核心的地方就在于，”在每个你想不到的地方突你的脸“，让你每走一步都要犹豫半天，怕多走一步就会碰到一个trigger</p><p>不过我还是想说，吓人应该是”方法论“，恐怖应该是“世界观”，去深挖吓人的技巧没有错，只是若过于注重方法而忽视了恐怖本身，我个人还是不是很认可，这也是我觉得Welcome to Kowloon的问题所在。虽然前面有提到“成为突脸”这句话，但是我仍旧倾向于去将开发重心更偏向于心理恐怖，我也会更认可这一类的作品</p><p>可以发现前面总是在举反面例子，却鲜有提及正面例子。其实至今让我最印象深刻的还是我反复提及的《港诡实录》中二、三故事过渡的办公室闹鬼（如果忘记是哪个片段可以看看最后一张图的那个场景，不知还有没有印象）。只是非常可惜，我是先看的实况，才玩到的游戏，所以这里的吓人设计在我的反馈上就没有那么大，但是即便如此，我还是在这过程中感受到了些许瘆人，以及“兴奋感”</p><p>我一直在想心理恐怖要怎么做才能有好的效果，上面提到的港诡的片段也给了我一定的启发，虽然不知道是不是对的。上文我提到了”兴奋感“，说实话我不知道怎么形容这种感觉，就是有种你看到了诡谲之物所产生的些许畏惧、求知欲、以及满足感混合而成的。而这个”兴奋感“的激发我认为核心在于闹鬼以及场景变化所用到的叙事节奏——直至最后到黑屏，布满扭曲逝去人脸的红色房间达到高潮，开启下一个故事线。在这期间你会想离开，但又不舍，精神上会有一定的压力，却又有一定的动力，说实话挺矛盾的。所以我就在想，恐怖氛围的塑造是否不要只局限于压抑，而也要同时注重”兴奋感“？这意味着比起场景环境、事件触发这种表面层次的功夫，可能更需要打磨节奏这种玄乎的内部细节，并且从某种意义上来讲，这种节奏或许也需要有音游节奏带来的”不拖泥带水的爽快感“</p><p>其他的或许就是一些老生常谈的东西了，比如保持玩家的”未知感“，从而令其产生恐惧。这个未知感不仅是对场景的未知、对故事的未知，更是对”手法”、机制等等的未知，就比如上面提到的“在每个你想不到的地方突你的脸”，是对吓人方法论的未知。在我目前看来，对于一个很出色的恐怖游戏来说，他需要让玩家在完整通关整个游戏的过程中永远到达不了对游戏机制、手法、场景结构层次的理解（当然最基本的“探索”的游戏机制还是必须要知道的lol），而永远保持在所谓“一知半解”的状态，再加上“细思极恐”的结局，这样才能够持续保有其未知感，从而塑造恐怖氛围的一部分。</p><p>当然了，以上所有内容只是在没有经历过任何实践（恐游开发与测试）的我这段时间的想法，很多思考目前也难以找到完整的案例可以验证，所以我估计多半是有问题的哈哈</p><p>btw怎么在及格线以上的3D中式民俗恐游这么难找，逼着人自己做是吧 :D</p>]]></content>
      
      
      <categories>
          
          <category> Essays </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Essays </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System</title>
      <link href="/2023/08/30/Operating%20System/"/>
      <url>/2023/08/30/Operating%20System/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><h2 id="What-is-Operating-System"><a href="#What-is-Operating-System" class="headerlink" title="What is Operating System?"></a>What is Operating System?</h2><blockquote><p>It serves as an intermediary between computer <strong>User</strong> and computer <strong>Hardware</strong></p></blockquote><p>Specificlly,<br>$$<br>\text{User} \rightarrow (\text{use}) \text{Application Programs} \rightarrow (\text{needs}) \text{Operating System} \rightarrow {\text{(to connect to)}} \text{Hardware}<br>$$<br>Without operating systems, even doing the easiest things, for example using word processor, e.g.. Microsoft Word, to type something, we need to code to tell the hardware about how they should handling my inputs, and where should it be saved in the memory, etc.. Really tedious, isn’t it?</p><p>So the functions of operating systems are:</p><ul><li>Be an interface between User &amp; Hardware</li><li>Allocation of Resources</li><li>Management of Memory, Security, etc.</li></ul><h2 id="Basics-of-Operating-Systems"><a href="#Basics-of-Operating-Systems" class="headerlink" title="Basics of Operating Systems"></a>Basics of Operating Systems</h2><h3 id="Modern-Computer-System"><a href="#Modern-Computer-System" class="headerlink" title="Modern Computer System"></a>Modern Computer System</h3><blockquote><p>A modern general-purpose computer system consists of one or more CPUs and a number of device controllers connected through a common bus that provides access to shared memory</p></blockquote><p>The graph explanation of the sentence is as follows:</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2023/08/31/pPw20r4.png" alt="pPw20r4.png"></p><p>The line refers to the common bus</p><p>Then,</p><ul><li><p>Each <strong>device controller</strong> is in charge of a specific type of <strong>device</strong>. Each device controller maintains:</p><ul><li><p>Local Buffer Storage</p></li><li><p>Set of Special Purpose Registers</p><p>And OS has a <strong>device driver</strong> for each <strong>device controller</strong>. The purpose of device driver is to presents a uniform interface to allow the device controller to interact with the operating system</p></li></ul></li><li><p>The CPU and the device controllers can execute <strong>concurrently</strong>, competing for memory cycles.</p><p>  How to understand this word?</p><p>  First of all, we need to be clear that <strong>whenever something has to be executed or loaded, it has to be loaded into the main memory, i.e., RAM</strong>. And the power of system can be performed by “execute concurrently”, which ensures that your controls will not be responsed with lags.</p><p>  And to achieve this goal, it needs:</p></li><li><p>To ensure orderly access to the shared memory, a memory controller is provided whose function is to synchronize access to the memory</p></li></ul><hr><h3 id="Terms-You-Need-to-Know"><a href="#Terms-You-Need-to-Know" class="headerlink" title="Terms You Need to Know"></a>Terms You Need to Know</h3><ul><li><p>Throughput:</p><ul><li>Throughput is a measure of how many units of information a system can process in a given amount of time, i.e., a measure of the performance of the system</li><li>Higher throughput, better the performance</li></ul></li><li><p>Bootstrap Program:</p><ul><li><p>The initial program that runs when the computer is powered up or rebooted</p></li><li><p><strong>It is stored in ROM (Read Only Memory)</strong></p></li><li><p>It must know how to load the OS and start executing that system</p><p>  <em>Explanation:</em> OS is also a program, and is stored in the <strong>secondary memory</strong> intially. And since the bootstrap program is the first program executed when starting the computer, it must know where the OS program is and invoke it</p></li><li><p>It must locate and load the OS Kernel into memory</p><p>  <em>Explanation:</em> What is <strong>Kernel</strong>? It is the main part of operating system. It is the software of first level in OS</p></li></ul></li><li><p>Interrupt:</p><ul><li><p>The occurence of an event is usually signalled by an Interrupt <strong>from Hardware or Software</strong></p><p>  <em>Explanation:</em> CPU is always working on some tasks. But sometimes a hardware or software may tell the CPU that “pls do this task first, for it is more important”. It is called <em>Interrupt</em></p></li><li><p><strong>Hardware</strong> may trigger an interrupt at any time <strong>by sending a signal to the CPU</strong>, usually <strong>by the way of the system bus</strong></p></li></ul></li><li><p>System Call (Monitor Call):</p><ul><li><strong>Software</strong> may trigger an interrupt by executing a special operation called System Call</li></ul></li></ul><p>So for hardware, we usually call it <em>Interrupt</em>, and for software is <em>System Call</em></p><p>Then how will the CPU react to interrupts?</p><ul><li><p>When the CPU is interrupted, it <strong>stops what it is doing</strong> and immediately <strong>transfers execution to a fixed location</strong></p><ul><li><p>Fixed Location: The fixed location usually contains the starting address where the Service Routine of the interrupt is located</p><ul><li>Service Routine: What the interrupt wants to do is written in the Service Routine. Sometimes Interrupt Service Routine is known as <strong>I.S.R.</strong></li></ul><p>So the fixed location indicates the address where CPU should start executing what the interrupt wants to do</p></li></ul></li><li><p>Then, the I.S.R. executes</p></li><li><p>On completion, the CPU resumes the interrupted computation, i.e., goes back to where it comes from and resumes the original work</p></li></ul><hr><h3 id="Storage-Structure"><a href="#Storage-Structure" class="headerlink" title="Storage Structure"></a>Storage Structure</h3><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2023/08/31/pPw4FAJ.png" alt="pPw4FAJ.png"></p><ul><li>Register: The smallest storage device. It only stores data in bits, i.e., 0’s or 1’s. Therefore, it can be accessed quickly</li><li>Cache: A little bigger than the register, but slower</li><li>Main Memory: RAM (Random Access Memory)</li><li>Secondary Storage Devices: It refers to Electronic Disks, Magnetic Disks, Optical Disks, and Magnetic Tapes</li></ul><h4 id="Main-Memory-RAM"><a href="#Main-Memory-RAM" class="headerlink" title="Main Memory (RAM)"></a>Main Memory (RAM)</h4><p>Everything needed for execution will be loaded into main memory</p><p>So things are stored in secondary memory, but loaded in main memory for execution purpose</p><p>Although the main memory is fast, its size is limited (which means you cannot store all your programs &amp; data in main memory) and is also volatile in nature. And that’s why we need secondary memory to save unused stuff</p><blockquote><p>Volatile: Loses its contents when power is removed</p><p>Non-Volatile: Retains its contents even when power is removed</p></blockquote><p>So if you have a bigger main memory, your computer works faster because it saves time on taking some data out from secondary memory and put into main memory</p><hr><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><h4 id="Working-of-an-I-O-Structure"><a href="#Working-of-an-I-O-Structure" class="headerlink" title="Working of an I/O Structure"></a>Working of an I/O Structure</h4><ul><li><p>To start an I/O operation, the device driver loads the appropriate registers (those which are required for performing a paticular I/O operation) within the device controller</p><p>  These required registers have the information or data about what is the action, or what is the exact I/O operation that has to be performed</p></li><li><p>The device controller, in turn, examines the contents of these registers to determine what action to take</p></li><li><p>The controller starts the transfer of data <strong>from the device</strong> to its local buffer</p></li><li><p>Once the transfer of data is complete, the device controller informs the device driver via an interrupt that it has finished its operation</p></li><li><p>The device driver returns control to the operating system</p></li></ul><p>The graph of this process is as follows (without <em>DMA</em>):</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2023/09/01/pP0YCE4.png" alt="pP0YCE4.png" style="zoom: 25%;" /><p>As you can see, <strong>we always need to pass through CPU to store our data into memory during I/O process</strong></p><p><em>This form of interrupt-drive I/O is fine for moving small amounts of data, but can produce high overhead when used for bulk data movement, for CPU is always interrupted over here, which means it takes up too much of the CPU and time.</em></p><p><em>To solve this problem, Direct Memory Access (DMA) is used.</em></p><blockquote><p><em>DMA:</em> After setting up buffers, pointers, and counters for the I/O device, the device controller transfers an entire block of data directly to or from its own buffer storage to memory, with no intervention by the CPU</p></blockquote><p>And with DMA, we can send data in blocks instead sending through CPU respectively</p><p>Only one interrupt is generated per block, to tell the device driver that the operation has completed</p><p>While the device controller is performing these operations, the CPU is available to accomplish other works</p><hr><h3 id="Computer-System-Architecture"><a href="#Computer-System-Architecture" class="headerlink" title="Computer System Architecture"></a>Computer System Architecture</h3><p>Computer systems can be categorized based on number of General Purpose Processors:</p><ul><li>Single Processor System</li><li>Multiprocessor System</li><li>Clustered System: Two or more system are clustered to perform certain tasks</li></ul><h4 id="Single-Processor-System"><a href="#Single-Processor-System" class="headerlink" title="Single Processor System"></a>Single Processor System</h4><ul><li><p>One main CPU capable of executing a general purpose instruction set including instructions from user processes</p></li><li><p>In fact, apart from the main GPU, there are still other special purpose processors in single processor system, but they do not do general purpose tasks but perform some device specific tasks</p></li></ul><h4 id="Multiprocessor-System"><a href="#Multiprocessor-System" class="headerlink" title="Multiprocessor System"></a>Multiprocessor System</h4><ul><li>Also known as  <em>parallel systems</em> or <em>tightly coupled systems</em></li><li>Has two or more processors in close communication, sharing the computer bus and sometimes the clock, memory, and peripheral devices</li></ul><h5 id="Types-of-Multiprocessor-System"><a href="#Types-of-Multiprocessor-System" class="headerlink" title="Types of Multiprocessor System"></a>Types of Multiprocessor System</h5><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2023/09/01/pP02379.png" alt=""></p><ul><li>Symmetric Multiprocessing: All CPU are similar, together working on the sams set of processes</li><li>Asymmetric Muliprocessing: One CPU acts as the master, others as slaves. Master assigns tasks to slaves to let them do their works on their own</li></ul><h4 id="Clustered-System"><a href="#Clustered-System" class="headerlink" title="Clustered System"></a>Clustered System</h4><ul><li>Like multiprocessor systems, clustered systems gather together multiple CPUs to accomplish computational work</li><li>They are composed of two or more individual systems coupled together</li><li>Provides high availibility</li><li>Can be structrued asymmetrically or symmetrically</li></ul><hr><h3 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h3><p>Operating systems vary greatly in their makeup internally, but they need to have some commonalities:</p><ul><li>Multiprogramming</li><li>Multitasking (Time Sharing)</li></ul><h4 id="Multiprogramming"><a href="#Multiprogramming" class="headerlink" title="Multiprogramming"></a>Multiprogramming</h4><blockquote><p>Multiprogramming means the capbility of running multiple programs by the CPU</p></blockquote><ul><li><p>With multiprogramming, in general, keep either the CPU or the I/O devices busy at all times</p><p>  <em>It also means without multiprogramming, they can be busy at all times</em></p></li><li><p>Multiprogramming increases CPU utilization by organizing jobs (code and data) so that the CPU always has one to execute</p></li></ul><p>Now we discuss it by graph:</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2023/09/01/pP0fOjf.png" alt=""></p><p>Suppose now we have some jobs to be executed, and they are all in a <em>Job Pool.</em> Since the memory(RAM) is not unlimited, we can only load a part of jobs in the Job Pool into it</p><p>If without multiprogramming, the CPU can only be used by Job 2 until Job 1 is finished, even though Job 1 may only make use of I/O devices instead of CPU itself</p><p>With multiprogramming, Job 2 should be able to use the CPU when Job 1 is only using I/O devices</p><p>Therefore, in conclusion, multiprogramming enables that whenever a particular job does not want to use the CPU, the CPU can be utilized by another job</p><h4 id="Multitasking-Time-Sharing"><a href="#Multitasking-Time-Sharing" class="headerlink" title="Multitasking (Time Sharing)"></a>Multitasking (Time Sharing)</h4><ul><li><p>CPU executes multiple jobs by switching among them</p></li><li><p>Switches occur so frequently that the users can interact with each program while it is running</p></li><li><p>Time sharing requires an interactive (or hands-on) computer system which provides direct communication between the user and the system</p></li><li><p>A time-shared operating system allows many users to share the computer simultaneously</p><p>  <em>It is because the system switches so fast that users don’t realize they are sharing the system</em></p></li></ul><p>Suppose we have multiple users sharing the same system right now</p><p>In the time-shared system, it uses CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared system</p><p>Each user has at least one separate program to be executed</p><p><strong>A program loaded into memory and executing is called a PROCESS</strong></p><hr><h3 id="Operating-System-Services"><a href="#Operating-System-Services" class="headerlink" title="Operating System Services"></a>Operating System Services</h3><p>An OS provides an environment for the execution of programs</p><p>It provides certain services to programs and to users of those programs</p><p>Below are services provided by the OS listed</p><h4 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h4><ul><li>Commend Line Interface (CLI)</li><li>Graphicla User Interface (GUI)</li></ul><h4 id="Program-Execution"><a href="#Program-Execution" class="headerlink" title="Program Execution"></a>Program Execution</h4><p>OS should be able to load the program into memory, and then run the program</p><p>Process of program execution:<br>$$<br>\text{Source Code $\rightarrow$ Compiler $\rightarrow$ Object Code $\rightarrow$ Executor $\rightarrow$ Output}<br>$$</p><h4 id="I-O-Operations"><a href="#I-O-Operations" class="headerlink" title="I/O Operations"></a>I/O Operations</h4><p>Although you feel like you’re using the input devices like mouse &amp; keyboard directly, but in fact it is OS that actually controls the usage of the I/O devices</p><h4 id="File-System-Manipulation"><a href="#File-System-Manipulation" class="headerlink" title="File System Manipulation"></a>File System Manipulation</h4><p>For example, sometimes you need to create or delete files. These operations are as well controlled by the operating system</p><p>And also it  controls the permission that is given to certain programs or users for the access to certain files</p><h4 id="Communications"><a href="#Communications" class="headerlink" title="Communications"></a>Communications</h4><p><em>Communication between processes</em></p><p>Communication (e.g. information exchange) between processes (in same computer or between different computers) is controlled by the OS</p><h4 id="Error-Detection"><a href="#Error-Detection" class="headerlink" title="Error Detection"></a>Error Detection</h4><p>If some error occurs the system must not break down completely and it should not just seize your computing ability completely. The OS must have a way in which it manages those errors so that your computing is consistent and it is still carried on even if some errors are encountered</p><h4 id="Resource-Allowcation"><a href="#Resource-Allowcation" class="headerlink" title="Resource Allowcation"></a>Resource Allowcation</h4><p>The OS must allocate the resources in an efficient way such that all the processes get the resources that they need and no process keeps waiting for it and never gets it. And there also should not be a scenario where a resource is held by a particular process but never released</p><h4 id="Accounting"><a href="#Accounting" class="headerlink" title="Accounting"></a>Accounting</h4><p>The OS keeps track of which user use how much and what kind of resources. This record keeping may be used for accounting or simply for accumulating usage statistics</p><h4 id="Protection-and-Security"><a href="#Protection-and-Security" class="headerlink" title="Protection and Security"></a>Protection and Security</h4><ul><li><p>Protection:</p><ul><li><p>When several different processes are executing at the same time, it should not be possible for one process to interfere with the others or with the OS itself</p></li><li><p>Protection means access to the system resources must be controlled</p></li></ul></li><li><p>Security</p><ul><li>The system should not be accessible to outsiders who are not allowed to access the system</li></ul></li></ul><hr><h3 id="User-Operating-System-Interface"><a href="#User-Operating-System-Interface" class="headerlink" title="User Operating System Interface"></a>User Operating System Interface</h3><p>Two fundamental approaches for users to interact with the operating system:</p><ul><li>CLI, also as known as <em>Command Interpreter</em></li><li>GUI</li></ul><h4 id="Command-Interpreter"><a href="#Command-Interpreter" class="headerlink" title="Command Interpreter"></a>Command Interpreter</h4><ul><li><p>Some operating systems include the command interpreter in the kernel</p></li><li><p>Others, such as Windows XP and UNIX, treat the command interpreter as a program</p></li><li><p>On systems with multiple command interpreters to choose from, the interpreters are known as shells. For example,</p><ul><li>Bourne shell</li><li>C shell</li><li>Bourne-Again Shell (BASH)</li><li>Korn Shell</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABOUT ME</title>
      <link href="/2023/07/14/ABOUT%20ME/"/>
      <url>/2023/07/14/ABOUT%20ME/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>You can call me <strong><em>Hardy</em></strong></p><p><em>HKUST</em> (Hong Kong University of Science and Technology) undergraduate</p><p><strong><em>FRONT-END</em></strong> work showcase: <a href="https://seryol.github.io/">Colythme</a></p><h3 id="Personal-TECH-STACK"><a href="#Personal-TECH-STACK" class="headerlink" title="Personal TECH STACK"></a>Personal <em>TECH STACK</em></h3><hr><ul><li>Programming Languages - C++ | C# | Python | Html | JavaScript | CSS | Solidity | MIPS</li><li>Framework - OpenCV | Vue.js | Three.js | Flask | Pomelo.js</li><li>Game Engine - Unity | Unreal Engine</li><li>Various algorithm including - Dynamic Programming | Math Theory | Graph Theory | Data Structure | etc..</li><li>Social Information Network Analysis and Engineering</li><li>Machine Learning including - CV | NLP | RL | Generator | Transformer | GNN</li><li>Computer Organization - ALU | ISA | Processor (datapath &amp; control) pipeline | memory hierarchy</li><li>Cloud Server usage | Docker usage</li><li>Web3 -  Blockchain principles | Cryptography | Solidity Smart Contract (SC) programming</li><li>Finance - Intermediate Investment | Python Quantitative Trading programming</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP - LSTM Code &amp; Annotations (Paddle)</title>
      <link href="/2023/07/14/NLP%20-%20LSTM%20Code%20&amp;%20Annotations%20(Paddle)/"/>
      <url>/2023/07/14/NLP%20-%20LSTM%20Code%20&amp;%20Annotations%20(Paddle)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>NLP&#x0020;Learning&#x0020;Notes#02</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">from</span> psutil <span class="keyword">import</span> sensors_battery</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> paddle.nn <span class="keyword">import</span> LSTM, Embedding, Dropout, Linear</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> dropout</span><br><span class="line"></span><br><span class="line">use_gpu = <span class="literal">True</span></span><br><span class="line">paddle.set_device(<span class="string">&#x27;gpu:0&#x27;</span>) <span class="keyword">if</span> use_gpu <span class="keyword">else</span> paddle.set_device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># download IMDB dataset</span></span><br><span class="line"><span class="string">def download_IMDB ():</span></span><br><span class="line"><span class="string">    url = &quot;https://dataset.bj.bcebos.com/imdb%2FaclImdb_v1.tar.gz&quot;</span></span><br><span class="line"><span class="string">    web = requests.get (url)</span></span><br><span class="line"><span class="string">    corpus = web.content</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    with open (&#x27;./Practice/NLP/IMDB.tar.gz&#x27;, &#x27;wb&#x27;) as f:</span></span><br><span class="line"><span class="string">        f.write (corpus)</span></span><br><span class="line"><span class="string">    f.close ()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">download_IMDB ()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Loading IMDB...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in IMDB dataset, pos folder saves comments with positive emotion, neg negative</span></span><br><span class="line"><span class="comment"># the returned dataset contains elements with format (sentence, label) \</span></span><br><span class="line"><span class="comment"># where label = 0 and 1 indicates positive and negative respectively</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_IMDB</span> (<span class="params">atype</span>):</span> <span class="comment"># type = 0: test, type = 1: </span></span><br><span class="line">    dataset = []</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> [<span class="string">&#x27;pos&#x27;</span>, <span class="string">&#x27;neg&#x27;</span>]:</span><br><span class="line">        <span class="keyword">with</span> tarfile.<span class="built_in">open</span> (<span class="string">&#x27;./aclImdb.tar.gz&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            path = <span class="string">&#x27;aclImdb/train/&#x27;</span> + label + <span class="string">&#x27;/.*\.txt$&#x27;</span> <span class="keyword">if</span> atype == <span class="string">&#x27;train&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;aclImdb/test/&#x27;</span> + label + <span class="string">&#x27;/.*\.txt$&#x27;</span></span><br><span class="line">            path_compiler = re.<span class="built_in">compile</span> (path)</span><br><span class="line">            <span class="comment"># f.next () returns a &#x27;tarfile info&#x27; type value</span></span><br><span class="line">            <span class="comment"># every time we use f.next (), we would reach next file in the corresponding tar file</span></span><br><span class="line">            <span class="comment"># which means we can use this command to traverse all the files in it</span></span><br><span class="line">            <span class="comment"># when f reaches its end, tf would be None</span></span><br><span class="line">            tf = f.<span class="built_in">next</span> ()</span><br><span class="line">            <span class="keyword">while</span> tf != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">bool</span> (path_compiler.match (tf.name))):</span><br><span class="line">                    <span class="comment"># extractfile returns a io.BufferedReader object</span></span><br><span class="line">                    <span class="comment"># therefore, we need to move on with read () function</span></span><br><span class="line">                    <span class="comment"># then decode with UTF-8 in default</span></span><br><span class="line">                    content = f.extractfile (tf).read ().decode ()</span><br><span class="line">                    ctype = <span class="number">1</span> <span class="keyword">if</span> label == <span class="string">&#x27;pos&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    dataset.append ((content, ctype))</span><br><span class="line">                </span><br><span class="line">                tf = f.<span class="built_in">next</span> ()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line">train_dataset = load_IMDB (<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = load_IMDB (<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Loading IMDB&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Data Preprocessing...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># divide the sentence into words by spaces</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_division</span> (<span class="params">corpus</span>):</span></span><br><span class="line">    dataset = []</span><br><span class="line">    <span class="keyword">for</span> sentence, label <span class="keyword">in</span> corpus:</span><br><span class="line">        sentence = sentence.strip ().lower ()</span><br><span class="line">        sentence = sentence.split (<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        dataset.append ((sentence, label))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line">train_dataset = word_division (train_dataset)</span><br><span class="line">test_dataset = word_division (test_dataset)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dict</span> (<span class="params">corpus</span>):</span></span><br><span class="line">    word_freq = <span class="built_in">dict</span> ()</span><br><span class="line">    <span class="keyword">for</span> sentence, label <span class="keyword">in</span> corpus:</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word <span class="keyword">in</span> word_freq:</span><br><span class="line">                word_freq[word] = <span class="number">0</span></span><br><span class="line">            word_freq[word] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    word_freq = <span class="built_in">sorted</span> (word_freq.items (), key = <span class="keyword">lambda</span> dic: dic[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    word2id_dict = <span class="built_in">dict</span> ()</span><br><span class="line">    id_freq = <span class="built_in">dict</span> ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># [oov] means &#x27;out of vocabulary&#x27;, which indicates those words showing up in test data \</span></span><br><span class="line">    <span class="comment"># but not existing in the training data</span></span><br><span class="line">    word2id_dict[<span class="string">&#x27;[oov]&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    id_freq[<span class="number">0</span>] = <span class="number">1e10</span></span><br><span class="line">    <span class="comment"># &#x27;[blank]&#x27; is used for fulfilling those blank positions</span></span><br><span class="line">    word2id_dict[<span class="string">&#x27;[blank]&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    id_freq[<span class="number">1</span>] = <span class="number">1e10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word, freq <span class="keyword">in</span> word_freq:</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">len</span> (word2id_dict)</span><br><span class="line">        word2id_dict[word] = <span class="built_in">id</span></span><br><span class="line">        id_freq[<span class="built_in">id</span>] = freq</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> id_freq, word2id_dict</span><br><span class="line"></span><br><span class="line">id_freq, word2id_dict = build_dict (train_dataset)</span><br><span class="line">vocab_size = <span class="built_in">len</span> (word2id_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_sentence2id</span> (<span class="params">corpus, word2id_dict</span>):</span></span><br><span class="line">    dataset = []</span><br><span class="line">    <span class="keyword">for</span> sentence, label <span class="keyword">in</span> corpus:</span><br><span class="line">        sentence = [word2id_dict[word] <span class="keyword">if</span> word <span class="keyword">in</span> word2id_dict \</span><br><span class="line">                    <span class="keyword">else</span> word2id_dict[<span class="string">&#x27;[oov]&#x27;</span>] <span class="keyword">for</span> word <span class="keyword">in</span> sentence]</span><br><span class="line">        dataset.append ((sentence, label))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line">train_dataset = convert_sentence2id (train_dataset, word2id_dict)</span><br><span class="line">test_dataset = convert_sentence2id (test_dataset, word2id_dict)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Data Preprocessing&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Building Batch...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># return [batch_size, max_len] tensors</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dataloader</span> (<span class="params">word2id_dict, corpus, EPOCH_NUM, batch_size, maxlen, shuffle = <span class="literal">True</span></span>):</span></span><br><span class="line">    sentence_batch = []</span><br><span class="line">    label_batch = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (EPOCH_NUM):</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            random.shuffle (corpus)</span><br><span class="line">        <span class="keyword">for</span> sentence, label <span class="keyword">in</span> corpus:</span><br><span class="line">            sample_sentence = sentence[:<span class="built_in">min</span> (<span class="built_in">len</span> (sentence), maxlen)]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span> (sample_sentence) &lt; maxlen:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (maxlen - <span class="built_in">len</span> (sample_sentence)):</span><br><span class="line">                    sample_sentence.append (word2id_dict[<span class="string">&#x27;[blank]&#x27;</span>])</span><br><span class="line">            </span><br><span class="line">            sentence_batch.append ([[<span class="built_in">id</span>] <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> sample_sentence])</span><br><span class="line">            label_batch.append ([label])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span> (sentence_batch) == batch_size:</span><br><span class="line">                <span class="keyword">yield</span> np.array (sentence_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">                      np.array (label_batch).astype (<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line">                sentence_batch = []</span><br><span class="line">                label_batch = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span> (sentence_batch) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> np.array (sentence_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">              np.array (label_batch).astype (<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">EPOCH_NUM = <span class="number">5</span></span><br><span class="line">maxlen = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">train_dataloader = build_dataloader (word2id_dict, train_dataset, batch_size = batch_size, \</span><br><span class="line">                                EPOCH_NUM = EPOCH_NUM, maxlen = maxlen, shuffle = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Building Batch&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in LSTM, hidden states are stored in array &#x27;h&#x27;, cell states are stored in array &#x27;c&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;h&#x27; saves those &#x27;short-term memories&#x27;, and &#x27;c&#x27; is able to save those &#x27;long-term memories&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTMClass</span> (<span class="params">paddle.nn.Layer</span>):</span></span><br><span class="line">    <span class="comment"># time steps indicates &quot;how long we remember&quot;, e.g., for &quot;ABCDEFG&quot;, \</span></span><br><span class="line">    <span class="comment"># if time steps equals to three, and input is &#x27;D&#x27;, \</span></span><br><span class="line">    <span class="comment"># then what is to be predicted from &#x27;D&#x27; will be involved with &#x27;B&#x27; &amp; &#x27;C&#x27;, for time steps equals to three</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self, embedding_size, vocab_size, hidden_size, init_scale = <span class="number">0.1</span>, class_num = <span class="number">2</span>, time_steps = <span class="number">128</span>, \</span></span></span><br><span class="line"><span class="params"><span class="function">                    num_layers = <span class="number">1</span>, dropout_rate = <span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span> (LSTMClass, self).__init__ ()</span><br><span class="line">        self.embedding_size = embedding_size</span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.init_scale = init_scale</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.class_num = class_num</span><br><span class="line">        self.time_steps = time_steps</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.dropout_rate = dropout_rate</span><br><span class="line"></span><br><span class="line">        self.embedding = Embedding (num_embeddings = self.vocab_size, embedding_dim = self.embedding_size, sparse = <span class="literal">False</span>, \</span><br><span class="line">                                    weight_attr = paddle.ParamAttr (</span><br><span class="line">                                        initializer = paddle.nn.initializer.Uniform (</span><br><span class="line">                                            low = - init_scale, high = init_scale)))</span><br><span class="line">        self.LSTM = LSTM (input_size = self.hidden_size, hidden_size = self.hidden_size, num_layers = self.num_layers)</span><br><span class="line">        self.fc = Linear (in_features = self.hidden_size, out_features = self.class_num)</span><br><span class="line">        self.dropout = Dropout (p = self.dropout_rate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dataset indicates input texts with size of [batch_size, maxlen]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span> (<span class="params">self, dataset</span>):</span></span><br><span class="line">        batch_size = dataset.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we use stop_gradient here cuz it can prevent these values from being updated</span></span><br><span class="line">        init_hidden = np.zeros ((self.num_layers, batch_size, self.hidden_size), dtype = <span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">        init_hidden = paddle.to_tensor (init_hidden)</span><br><span class="line">        init_hidden.stop_gradient = <span class="literal">True</span></span><br><span class="line">        init_cell = np.zeros ((self.num_layers, batch_size, self.hidden_size), dtype = <span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">        init_cell = paddle.to_tensor (init_cell)</span><br><span class="line">        init_cell.stop_gradient = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        x = self.embedding (dataset)</span><br><span class="line">        x = paddle.reshape (x, shape = [batch_size, self.time_steps, self.embedding_size])</span><br><span class="line">        <span class="keyword">if</span> self.dropout_rate != <span class="literal">None</span> <span class="keyword">and</span> self.dropout_rate &gt; <span class="number">0</span>:</span><br><span class="line">            x = self.dropout (x)</span><br><span class="line">        </span><br><span class="line">        _, (ret_hidden, _) = self.LSTM (x, (init_hidden, init_cell))</span><br><span class="line">        ret_hidden = ret_hidden[- <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        result = self.fc (ret_hidden)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">dropout_rate = <span class="number">0.2</span></span><br><span class="line">num_layers = <span class="number">3</span></span><br><span class="line">hidden_size = <span class="number">256</span></span><br><span class="line">embedding_size = <span class="number">256</span></span><br><span class="line">vocab_size = <span class="built_in">len</span> (id_freq)</span><br><span class="line"></span><br><span class="line">model = LSTMClass (embedding_size, vocab_size, hidden_size, num_layers = num_layers, dropout_rate = dropout_rate)</span><br><span class="line">optimizer = paddle.optimizer.Adam (learning_rate = <span class="number">0.0001</span>, parameters = model.parameters ())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Training...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span> (<span class="params">model</span>):</span></span><br><span class="line">    model.train ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> step, (sentence, label) <span class="keyword">in</span> <span class="built_in">enumerate</span> (train_dataloader):</span><br><span class="line">        sentence = paddle.to_tensor (sentence)</span><br><span class="line">        label = paddle.to_tensor (label)</span><br><span class="line"></span><br><span class="line">        result = model (sentence)</span><br><span class="line"></span><br><span class="line">        loss = F.cross_entropy (result, label)</span><br><span class="line">        loss = paddle.mean (loss)</span><br><span class="line"></span><br><span class="line">        loss.backward ()</span><br><span class="line">        optimizer.step ()</span><br><span class="line">        optimizer.clear_grad ()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;step %d, loss %.3f&quot;</span> % (step, loss.numpy ()[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">train (model)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Training&quot;</span>)</span><br><span class="line">paddle.save (model.state_dict (), <span class="string">&#x27;./LSTM.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Testing...&quot;</span>)</span><br><span class="line"></span><br><span class="line">param_dict = paddle.load (<span class="string">&#x27;./LSTM.pt&#x27;</span>)</span><br><span class="line">model.load_dict (param_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span> ():</span></span><br><span class="line">    model.<span class="built_in">eval</span> ()</span><br><span class="line"></span><br><span class="line">    test_dataloader = build_dataloader (word2id_dict, test_dataset, <span class="number">1</span>, batch_size, maxlen, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    correct, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> sentence, label <span class="keyword">in</span> test_dataloader:</span><br><span class="line">        sentence = paddle.to_tensor (sentence)</span><br><span class="line">        label = paddle.to_tensor (label)</span><br><span class="line"></span><br><span class="line">        predict = model (sentence)</span><br><span class="line">        predict = F.softmax (predict)</span><br><span class="line"></span><br><span class="line">        total += <span class="built_in">len</span> (label)</span><br><span class="line">        predict = predict.numpy ()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span> (label)):</span><br><span class="line">            <span class="keyword">if</span> label[i][<span class="number">0</span>] == <span class="number">1</span>: <span class="comment"># shape of label is [batch_size, 1]</span></span><br><span class="line">                <span class="keyword">if</span> predict[i][<span class="number">1</span>] &gt; predict[i][<span class="number">0</span>]:</span><br><span class="line">                    correct += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> predict[i][<span class="number">0</span>] &gt; predict[i][<span class="number">1</span>]:</span><br><span class="line">                    correct += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    accuracy = correct / total</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Accuracy %.3f:&quot;</span> % accuracy)</span><br><span class="line"></span><br><span class="line">evaluate ()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Testing&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three.js - Self-built Tokyo Miniature City Wandering</title>
      <link href="/2023/07/14/Three.js%20-%20Self-built%20Tokyo%20Miniature%20City%20Wandering/"/>
      <url>/2023/07/14/Three.js%20-%20Self-built%20Tokyo%20Miniature%20City%20Wandering/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>Hope&#x0020;someday&#x0020;I&#x0020;can&#x0020;build&#x0020;my&#x0020;own&#x0020;world&#x0020;like&#x0020;this.</p></blockquote><p>Existing bug: When animations are added, we cannot add moving objects with a collision volume, still donno how to solve it.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Chill<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">background-color</span>: white; &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript">&#123; <span class="string">&quot;imports&quot;</span>: &#123; <span class="string">&quot;three&quot;</span>: <span class="string">&quot;../build/three.module.js&quot;</span> &#125; &#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 开启阴影投射的条件</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1. 首先需要有能够造成阴影的光(比如directional light)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 2. 其次renderer.shadowMap需要开启(即renderer.shadowMap.enabled = true)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 3. 为了使阴影更舒缓，需要调整其类型(即renderer.shadowMap.type = ...)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 4. 物体本身需要开启castShadow(即mesh.castShadow = true, mesh.receiveShadow = true)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Stats <span class="keyword">from</span> <span class="string">&#x27;./jsm/libs/stats.module.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/OrbitControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; FirstPersonControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/FirstPersonControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; PointerLockControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/PointerLockControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 设置室内光环境</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; RoomEnvironment &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/environments/RoomEnvironment.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; GLTFLoader &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/loaders/GLTFLoader.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; DRACOLoader &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/loaders/DRACOLoader.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Capsule &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/math/Capsule.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Octree &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/math/Octree.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; OctreeHelper &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/helpers/OctreeHelper.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> stats = <span class="keyword">new</span> Stats ();</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild (stats.dom);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer (&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;);</span></span><br><span class="line"><span class="javascript">renderer.setPixelRatio (<span class="built_in">window</span>.devicePixelRatio);</span></span><br><span class="line"><span class="javascript">renderer.setSize (<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="javascript">renderer.outputEncoding = THREE.sRGBEncoding;</span></span><br><span class="line"><span class="javascript">renderer.shadowMap.enabled = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">renderer.shadowMap.type = THREE.VSMShadowMap;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild (renderer.domElement);</span></span><br><span class="line"><span class="javascript"><span class="comment">// renderer.setClearColor (0xffffff, 1.0);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> pmremGenerator = <span class="keyword">new</span> THREE.PMREMGenerator (renderer);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene ();</span></span><br><span class="line"><span class="javascript">scene.background = <span class="keyword">new</span> THREE.Color (<span class="number">0x88ccee</span>);</span></span><br><span class="line"><span class="javascript">scene.fog = <span class="keyword">new</span> THREE.Fog (<span class="number">0x88ccee</span>, <span class="number">0</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="javascript">scene.environment = pmremGenerator.fromScene (<span class="keyword">new</span> RoomEnvironment (), <span class="number">0.4</span>).texture;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera (<span class="number">70</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// camera.position.set (0, 0.35, 0);</span></span></span><br><span class="line"><span class="javascript">camera.rotation.order = <span class="string">&#x27;YXZ&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.requestPointerLock ();</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.addEventListener (<span class="string">&#x27;mousemove&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">document</span>.pointerLockElement == <span class="built_in">document</span>.body) &#123;</span></span><br><span class="line"><span class="javascript">camera.rotation.y -= event.movementX / <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">camera.rotation.x -= event.movementY / <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> velocity = <span class="keyword">new</span> THREE.Vector3 ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> direction = <span class="keyword">new</span> THREE.Vector3 ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> moveForward = <span class="literal">false</span>, moveBackward = <span class="literal">false</span>, moveLeft = <span class="literal">false</span>, moveRight = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">const pointerControls = new PointerLockControls (camera, renderer.domElement);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">document.body.addEventListener( &#x27;click&#x27;, function () &#123; // 必须要lock状态下才可移动视角</span></span></span><br><span class="line"><span class="comment"><span class="javascript">pointerControls.lock();</span></span></span><br><span class="line"><span class="comment"><span class="javascript">&#125; );</span></span></span><br><span class="line"><span class="comment"><span class="javascript">*/</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> playerOnFloor = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onKeyDown = <span class="function"><span class="keyword">function</span> (<span class="params"> event </span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">switch</span> ( event.code ) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowUp&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyW&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveForward = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowLeft&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyA&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveLeft = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowDown&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyS&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveBackward = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowRight&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyD&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveRight = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;Space&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (playerOnFloor == <span class="literal">true</span>) velocity.y = <span class="number">8.0</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onKeyUp = <span class="function"><span class="keyword">function</span> (<span class="params"> event </span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">switch</span> ( event.code ) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowUp&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyW&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveForward = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowLeft&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyA&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveLeft = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowDown&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyS&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveBackward = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowRight&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyD&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveRight = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;keydown&#x27;</span>, onKeyDown);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;keyup&#x27;</span>, onKeyUp);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> playerCollider = <span class="keyword">new</span> Capsule (<span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">0.35</span>, <span class="number">0</span>), <span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.35</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// 初步理解：假设变量Capsule (start, end, radius)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 那么end - start指定了该capsule的视角位置，一般也就指明了最高低点</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> worldOctree = <span class="keyword">new</span> Octree ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">forwardDirection</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.getWorldDirection (direction); <span class="comment">// 获取当前camera朝向方向的向量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> direction;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sideDirection</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.getWorldDirection (direction);</span></span><br><span class="line"><span class="javascript">direction.cross (<span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span></span><br><span class="line"><span class="javascript"><span class="comment">// 两个方向向量的乘积为他们的法向量，即返回我们正侧面的方向向量</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> direction;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updatePlayerVelocity</span> (<span class="params">delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.x -= velocity.x * 4.0 * delta;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.z -= velocity.z * 4.0 * delta;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// if (! playerOnFloor)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.y -= 9.8 * 2.0 * delta;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> damping = <span class="built_in">Math</span>.exp (- <span class="number">4</span> * delta) - <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (! playerOnFloor) &#123;</span></span><br><span class="line"><span class="javascript">velocity.y -= <span class="number">25</span> * delta;</span></span><br><span class="line"><span class="javascript">damping *= <span class="number">0.1</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">velocity.addScaledVector (velocity, damping);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> addspeed = playerOnFloor ? <span class="number">20.0</span> : <span class="number">8.0</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveForward)</span></span><br><span class="line"><span class="javascript">velocity.add (forwardDirection ().multiplyScalar (addspeed * delta)); <span class="comment">// multiplyScalar使向量乘以一个标量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveBackward)</span></span><br><span class="line"><span class="javascript">velocity.add (forwardDirection ().multiplyScalar (- addspeed * delta));</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveLeft)</span></span><br><span class="line"><span class="javascript">velocity.add (sideDirection ().multiplyScalar (- addspeed * delta));</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveRight)</span></span><br><span class="line"><span class="javascript">velocity.add (sideDirection ().multiplyScalar (addspeed * delta));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">playerCollision</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = worldOctree.capsuleIntersect (playerCollider);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">playerOnFloor = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (result) &#123;</span></span><br><span class="line"><span class="javascript">playerOnFloor = result.normal.y &gt; <span class="number">0</span>; <span class="comment">// 注意跳起的时候result实际为undefined 因为没有与物体相交</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// console.log (result.normal);</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (! playerOnFloor) &#123;</span></span><br><span class="line"><span class="javascript">velocity.addScaledVector (result.normal, - result.normal.dot (velocity));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">playerCollider.translate (result.normal.multiplyScalar (result.depth));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updatePlayer</span> (<span class="params">delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">updatePlayerVelocity (delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// start processing collision portion</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> deltapos = <span class="keyword">new</span> THREE.Vector3 (velocity.x * delta, velocity.y * delta, velocity.z * delta);</span></span><br><span class="line"><span class="javascript">playerCollider.translate (deltapos); <span class="comment">// start, end加上deltapos的值</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">playerCollision ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">camera.position.copy (playerCollider.end);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> dracoloader = <span class="keyword">new</span> DRACOLoader ();</span></span><br><span class="line"><span class="javascript">dracoloader.setDecoderPath(<span class="string">&#x27;./js/libs/draco/gltf/&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mixer;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> loader = <span class="keyword">new</span> GLTFLoader ();</span></span><br><span class="line"><span class="javascript">loader.setDRACOLoader (dracoloader);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> model;</span></span><br><span class="line"><span class="javascript">loader.load (<span class="string">&#x27;./models/gltf/LittlestTokyo.glb&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">gltf</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">model = gltf.scene;</span></span><br><span class="line"><span class="javascript">model.position.set (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">model.scale.set (<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>);</span></span><br><span class="line"><span class="javascript">scene.add (model);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">worldOctree.fromGraphNode (model);</span></span><br><span class="line"><span class="javascript">model.traverse (<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (child.isMesh) &#123;</span></span><br><span class="line"><span class="javascript">child.castShadow = <span class="literal">true</span>; <span class="comment">// 当前mesh开启阴影投射</span></span></span><br><span class="line"><span class="javascript">child.receiveShadow = <span class="literal">true</span>; <span class="comment">// 当前mesh可以接收到别人的阴影</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">mixer = <span class="keyword">new</span> THREE.AnimationMixer (model);</span></span><br><span class="line"><span class="javascript">mixer.clipAction (gltf.animations[<span class="number">0</span>]).play ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">animate ();</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log (error);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.aspect = <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight;</span></span><br><span class="line"><span class="javascript">camera.updateProjectionMatrix ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">renderer.setSize (<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// moveControls.handleResize ();</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">requestAnimationFrame (animate);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> delta = clock.getDelta ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">mixer.update (delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// orbitControls.update (delta);</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// moveControls.update (delta);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">updatePlayer (delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">stats.update ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">renderer.render (scene, camera);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreeJS </tag>
            
            <tag> Web3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three.js - Self-built Collision World</title>
      <link href="/2023/07/14/Three.js%20-%20Self-built%20Collision%20World/"/>
      <url>/2023/07/14/Three.js%20-%20Self-built%20Collision%20World/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>Learn&#x0020;to&#x0020;use&#x0020;Three.js</p></blockquote><p>Refer to the Collision World project in Three.js official examples to learn Three.js.</p><p>Existing problem: do not really know the calculation process of velocity in the sphere-sphere collision portion because of my physics level.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Chill<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">background-color</span>: white; &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript">&#123; <span class="string">&quot;imports&quot;</span>: &#123; <span class="string">&quot;three&quot;</span>: <span class="string">&quot;../build/three.module.js&quot;</span> &#125; &#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 开启阴影投射的条件</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1. 首先需要有能够造成阴影的光(比如directional light)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 2. 其次renderer.shadowMap需要开启(即renderer.shadowMap.enabled = true)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 3. 为了使阴影更舒缓，需要调整其类型(即renderer.shadowMap.type = ...)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 4. 物体本身需要开启castShadow(即mesh.castShadow = true, mesh.receiveShadow = true)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 如何解决碰撞问题？方法其一(Octree)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1. 将模型octree化</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 2. 使用capsule类来建立一个“我”，设定高度及碰撞半径</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 3. 之后通过其内置的capsuleIntersect函数来判定周围物体位置</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 4. 将velocity修改回退(result.normal * depth)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 那么实现一个正确的碰撞与什么有关？</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// - camera的near和far</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// - capsule的radius</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// - velocity的增加delta量与减少delta量(仍未清楚如何计算是否正确)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Stats <span class="keyword">from</span> <span class="string">&#x27;./jsm/libs/stats.module.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/OrbitControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; FirstPersonControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/FirstPersonControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; PointerLockControls &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/controls/PointerLockControls.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 设置室内光环境</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; RoomEnvironment &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/environments/RoomEnvironment.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; GLTFLoader &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/loaders/GLTFLoader.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; DRACOLoader &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/loaders/DRACOLoader.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Capsule &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/math/Capsule.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Octree &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/math/Octree.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; OctreeHelper &#125; <span class="keyword">from</span> <span class="string">&#x27;./jsm/helpers/OctreeHelper.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> stats = <span class="keyword">new</span> Stats ();</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild (stats.dom);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer (&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;);</span></span><br><span class="line"><span class="javascript">renderer.setPixelRatio (<span class="built_in">window</span>.devicePixelRatio);</span></span><br><span class="line"><span class="javascript">renderer.setSize (<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="javascript">renderer.outputEncoding = THREE.sRGBEncoding;</span></span><br><span class="line"><span class="javascript">renderer.shadowMap.enabled = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">renderer.shadowMap.type = THREE.VSMShadowMap;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild (renderer.domElement);</span></span><br><span class="line"><span class="javascript"><span class="comment">// renderer.setClearColor (0xffffff, 1.0);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> pmremGenerator = <span class="keyword">new</span> THREE.PMREMGenerator (renderer);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene ();</span></span><br><span class="line"><span class="javascript">scene.background = <span class="keyword">new</span> THREE.Color (<span class="number">0x88ccee</span>);</span></span><br><span class="line"><span class="javascript">scene.fog = <span class="keyword">new</span> THREE.Fog (<span class="number">0x88ccee</span>, <span class="number">0</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// scene.environment = pmremGenerator.fromScene (new RoomEnvironment (), 0.4).texture;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight( <span class="number">0xffffff</span>, <span class="number">0.8</span> );</span></span><br><span class="line"><span class="javascript">directionalLight.position.set( - <span class="number">5</span>, <span class="number">25</span>, - <span class="number">1</span> );</span></span><br><span class="line"><span class="javascript">directionalLight.castShadow = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.near = <span class="number">0.01</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.far = <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.right = <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.left = - <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.top= <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.camera.bottom = - <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.mapSize.width = <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.mapSize.height = <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.radius = <span class="number">4</span>;</span></span><br><span class="line"><span class="javascript">directionalLight.shadow.bias = - <span class="number">0.00006</span>;</span></span><br><span class="line"><span class="javascript">scene.add( directionalLight );</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera (<span class="number">70</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// camera.position.set (0, 0.35, 0);</span></span></span><br><span class="line"><span class="javascript">camera.rotation.order = <span class="string">&#x27;YXZ&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> light = <span class="keyword">new</span> THREE.HemisphereLight (<span class="number">0x4488bb</span>, <span class="number">0x002244</span>, <span class="number">0.5</span>);</span></span><br><span class="line"><span class="javascript">light.position.set (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">scene.add (light);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.requestPointerLock ();</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">document</span>.pointerLockElement != <span class="literal">null</span>)</span></span><br><span class="line"><span class="javascript">sphereShooting ();</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.addEventListener (<span class="string">&#x27;mousemove&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">document</span>.pointerLockElement == <span class="built_in">document</span>.body) &#123;</span></span><br><span class="line"><span class="javascript">camera.rotation.y -= event.movementX / <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">camera.rotation.x -= event.movementY / <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> velocity = <span class="keyword">new</span> THREE.Vector3 ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> direction = <span class="keyword">new</span> THREE.Vector3 ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> moveForward = <span class="literal">false</span>, moveBackward = <span class="literal">false</span>, moveLeft = <span class="literal">false</span>, moveRight = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">const pointerControls = new PointerLockControls (camera, renderer.domElement);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">document.body.addEventListener( &#x27;click&#x27;, function () &#123; // 必须要lock状态下才可移动视角</span></span></span><br><span class="line"><span class="comment"><span class="javascript">pointerControls.lock();</span></span></span><br><span class="line"><span class="comment"><span class="javascript">&#125; );</span></span></span><br><span class="line"><span class="comment"><span class="javascript">*/</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> playerOnFloor = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onKeyDown = <span class="function"><span class="keyword">function</span> (<span class="params"> event </span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">switch</span> ( event.code ) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowUp&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyW&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveForward = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowLeft&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyA&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveLeft = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowDown&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyS&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveBackward = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowRight&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyD&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveRight = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;Space&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (playerOnFloor == <span class="literal">true</span>) velocity.y = <span class="number">15.0</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onKeyUp = <span class="function"><span class="keyword">function</span> (<span class="params"> event </span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">switch</span> ( event.code ) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowUp&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyW&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveForward = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowLeft&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyA&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveLeft = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowDown&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyS&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveBackward = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;ArrowRight&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="string">&#x27;KeyD&#x27;</span>:</span></span><br><span class="line"><span class="javascript">moveRight = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;keydown&#x27;</span>, onKeyDown);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener (<span class="string">&#x27;keyup&#x27;</span>, onKeyUp);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> playerCollider = <span class="keyword">new</span> Capsule (<span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">0.35</span>, <span class="number">0</span>), <span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.35</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// Capsule (start, end, radius)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// start指代该capsule最低位，end为最高位，radius为半径</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> worldOctree = <span class="keyword">new</span> Octree ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">forwardDirection</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.getWorldDirection (direction); <span class="comment">// 获取当前camera朝向方向的向量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> direction;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sideDirection</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.getWorldDirection (direction);</span></span><br><span class="line"><span class="javascript">direction.cross (<span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span></span><br><span class="line"><span class="javascript"><span class="comment">// 两个方向向量的乘积为他们的法向量，即返回我们正侧面的方向向量</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> direction;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updatePlayerVelocity</span> (<span class="params">delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.x -= velocity.x * 4.0 * delta;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.z -= velocity.z * 4.0 * delta;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// if (! playerOnFloor)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// velocity.y -= 9.8 * 2.0 * delta;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> damping = <span class="built_in">Math</span>.exp (- <span class="number">4</span> * delta) - <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (! playerOnFloor) &#123;</span></span><br><span class="line"><span class="javascript">velocity.y -= <span class="number">30</span> * delta;</span></span><br><span class="line"><span class="javascript">damping *= <span class="number">0.1</span>;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">velocity.addScaledVector (velocity, damping);</span></span><br><span class="line"><span class="javascript"><span class="comment">// 注意，这里用乘的速度才会无限趋近于0</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> addspeed = playerOnFloor ? <span class="number">20.0</span> : <span class="number">8.0</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveForward)</span></span><br><span class="line"><span class="javascript">velocity.add (forwardDirection ().multiplyScalar (addspeed * delta)); <span class="comment">// multiplyScalar使向量乘以一个标量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveBackward)</span></span><br><span class="line"><span class="javascript">velocity.add (forwardDirection ().multiplyScalar (- addspeed * delta));</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveLeft)</span></span><br><span class="line"><span class="javascript">velocity.add (sideDirection ().multiplyScalar (- addspeed * delta));</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (moveRight)</span></span><br><span class="line"><span class="javascript">velocity.add (sideDirection ().multiplyScalar (addspeed * delta));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">playerCollision</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = worldOctree.capsuleIntersect (playerCollider);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">playerOnFloor = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (result) &#123;</span></span><br><span class="line"><span class="javascript">playerOnFloor = result.normal.y &gt; <span class="number">0</span>; <span class="comment">// 注意跳起的时候result实际为undefined 因为没有与物体相交</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// console.log (result.normal);</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (! playerOnFloor) &#123;</span></span><br><span class="line"><span class="javascript">velocity.addScaledVector (result.normal, - result.normal.dot (velocity));</span></span><br><span class="line"><span class="javascript"><span class="comment">// 空中撞墙原速反弹，若不加可能在空中会“粘”在天花板上</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">playerCollider.translate (result.normal.multiplyScalar (result.depth));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updatePlayer</span> (<span class="params">delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">updatePlayerVelocity (delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// start processing collision portion</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> deltapos = <span class="keyword">new</span> THREE.Vector3 (velocity.x * delta, velocity.y * delta, velocity.z * delta);</span></span><br><span class="line"><span class="javascript">playerCollider.translate (deltapos); <span class="comment">// start, end加上deltapos的值</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">playerCollision ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">camera.position.copy (playerCollider.end);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> spheres = [];</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> n = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphere_num = <span class="number">100</span>, sphere_radius = <span class="number">0.2</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry (sphere_radius); <span class="comment">// 二十面体，但第二参数大于1时为球体</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial (&#123; <span class="attr">color</span>: <span class="number">0x00ffff</span> &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= sphere_num; i ++) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphereMesh = <span class="keyword">new</span> THREE.Mesh (sphereGeometry, sphereMaterial);</span></span><br><span class="line"><span class="javascript">sphereMesh.shadow = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">sphereMesh.receiveShadow = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">scene.add (sphereMesh);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">spheres.push (&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">mesh</span>: sphereMesh,</span></span><br><span class="line"><span class="javascript"><span class="attr">collider</span>: <span class="keyword">new</span> THREE.Sphere (<span class="keyword">new</span> THREE.Vector3 (<span class="number">0</span>, - <span class="number">100</span>, <span class="number">0</span>), sphere_radius), <span class="comment">// (pos of center, radius)</span></span></span><br><span class="line"><span class="javascript"><span class="attr">velocity</span>: <span class="keyword">new</span> THREE.Vector3 ()</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sphereShooting</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphere = spheres[n];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">camera.getWorldDirection (direction);</span></span><br><span class="line"><span class="javascript">sphere.collider.center.copy (playerCollider.end).addScaledVector (direction, playerCollider.radius * <span class="number">1.5</span>);</span></span><br><span class="line"><span class="javascript">sphere.velocity.copy (direction).multiplyScalar (<span class="number">30</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">n = (n + <span class="number">1</span>) % spheres.length;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateSphereVelocity</span> (<span class="params">sphere, delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> damping = <span class="built_in">Math</span>.exp (- <span class="number">1.5</span> * delta) - <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">sphere.velocity.addScaledVector (sphere.velocity, damping);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sphereWallCollision</span> (<span class="params">sphere, delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = worldOctree.sphereIntersect (sphere.collider);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (result) &#123;</span></span><br><span class="line"><span class="javascript">sphere.velocity.addScaledVector (result.normal, - result.normal.dot (sphere.velocity) * <span class="number">1.5</span>);</span></span><br><span class="line"><span class="javascript">sphere.collider.center.add (result.normal.multiplyScalar (result.depth));</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span> sphere.velocity.y -= <span class="number">30</span> * delta;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> vec1 = <span class="keyword">new</span> THREE.Vector3 (), vec2 = <span class="keyword">new</span> THREE.Vector3 (), vec3 = <span class="keyword">new</span> THREE.Vector3 ();</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">playerSphereCollision</span> (<span class="params">sphere</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> playerCenter = vec1.addVectors (playerCollider.start, playerCollider.end).multiplyScalar (<span class="number">0.5</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// 人的中心在start与end之间</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> r = playerCollider.radius + sphere.collider.radius;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> rSquared = r * r;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">const</span> point <span class="keyword">of</span> [playerCollider.start, playerCollider.end, playerCenter]) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> dist = point.distanceToSquared (sphere.collider.center);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (dist &lt; rSquared) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 碰撞与物理有关，搞不懂</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> normal = vec1.subVectors (point, sphere.collider.center).normalize ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> v1 = vec2.copy (normal).multiplyScalar (normal.dot (velocity));</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> v2 = vec3.copy (normal).multiplyScalar (normal.dot (sphere.velocity));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">velocity.add (v2).sub (v1);</span></span><br><span class="line"><span class="javascript">sphere.velocity.add (v1).sub (v2);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> d = (r - <span class="built_in">Math</span>.sqrt (dist)) / <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">playerCollider.start.addScaledVector (normal, d);</span></span><br><span class="line"><span class="javascript">playerCollider.end.addScaledVector (normal, d);</span></span><br><span class="line"><span class="javascript">sphere.collider.center.addScaledVector (normal, - d);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sphereSphereCollision</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sphere_num; i ++) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphere1 = spheres[i];</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (sphere1.collider.center.y == - <span class="number">100</span>) <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; sphere_num; j ++) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> sphere2 = spheres[j];</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (sphere2.collider.center.y == - <span class="number">100</span>) <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> dist = sphere1.collider.center.distanceToSquared (sphere2.collider.center);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> r = sphere1.collider.radius + sphere2.collider.radius;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> rSquared = r * r;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (dist &lt; rSquared) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 碰撞与物理有关，搞不懂</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> normal = vec1.subVectors (sphere1.collider.center, sphere2.collider.center).normalize ();</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> v1 = vec2.copy (normal).multiplyScalar (normal.dot (sphere1.velocity));</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> v2 = vec3.copy (normal).multiplyScalar (normal.dot (sphere2.velocity));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">sphere1.velocity.add (v2).sub (v1);</span></span><br><span class="line"><span class="javascript">sphere2.velocity.add (v1).sub (v2);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> d = (r - <span class="built_in">Math</span>.sqrt (dist)) / <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">sphere1.collider.center.addScaledVector (normal, d);</span></span><br><span class="line"><span class="javascript">sphere2.collider.center.addScaledVector (normal, - d);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateSpheres</span> (<span class="params">delta</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">spheres.forEach (<span class="function"><span class="params">sphere</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">sphere.collider.center.addScaledVector (sphere.velocity, delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">updateSphereVelocity (sphere, delta);</span></span><br><span class="line"><span class="javascript">sphereWallCollision (sphere, delta);</span></span><br><span class="line"><span class="javascript">playerSphereCollision (sphere);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript">sphereSphereCollision ();</span></span><br><span class="line"><span class="javascript">spheres.forEach (<span class="function"><span class="params">sphere</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">sphere.mesh.position.copy (sphere.collider.center);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// -------------main-------------</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> dracoloader = <span class="keyword">new</span> DRACOLoader ();</span></span><br><span class="line"><span class="javascript">dracoloader.setDecoderPath(<span class="string">&#x27;./js/libs/draco/gltf/&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> loader = <span class="keyword">new</span> GLTFLoader ();</span></span><br><span class="line"><span class="javascript">loader.setDRACOLoader (dracoloader);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> model;</span></span><br><span class="line"><span class="javascript">loader.load (<span class="string">&#x27;./models/gltf/collision-world.glb&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">gltf</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">model = gltf.scene;</span></span><br><span class="line"><span class="javascript">scene.add (model);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">worldOctree.fromGraphNode (gltf.scene);</span></span><br><span class="line"><span class="javascript">model.traverse (<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (child.isMesh) &#123;</span></span><br><span class="line"><span class="javascript">child.castShadow = <span class="literal">true</span>; <span class="comment">// 当前mesh开启阴影投射</span></span></span><br><span class="line"><span class="javascript">child.receiveShadow = <span class="literal">true</span>; <span class="comment">// 当前mesh可以接收到别人的阴影</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">const octreeHelper = new OctreeHelper (worldOctree);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">octreeHelper.visible = false;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">scene.add (octreeHelper);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">*/</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">animate ();</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log (error);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera.aspect = <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight;</span></span><br><span class="line"><span class="javascript">camera.updateProjectionMatrix ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">renderer.setSize (<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// moveControls.handleResize ();</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">requestAnimationFrame (animate);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> delta = clock.getDelta ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// orbitControls.update (delta);</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// moveControls.update (delta);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">updatePlayer (delta);</span></span><br><span class="line"><span class="javascript">updateSpheres (delta);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">stats.update ();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">renderer.render (scene, camera);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreeJS </tag>
            
            <tag> Web3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于UE及iClone的数字人驱动</title>
      <link href="/2023/07/14/%E5%9F%BA%E4%BA%8EUE%E5%8F%8AiClone%E7%9A%84%E6%95%B0%E5%AD%97%E4%BA%BA%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/14/%E5%9F%BA%E4%BA%8EUE%E5%8F%8AiClone%E7%9A%84%E6%95%B0%E5%AD%97%E4%BA%BA%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>实习阶段性项目及学习成果报告</p></blockquote><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>在基于应用软件<em>Unreal Engine<em>与</em>iClone<em>的数字人(</em>MetaHuman</em>)生成与驱动中，有两种解决方案：第一种是驱动<em>iClone</em>系列产品<em>Character Creator</em>自定义捏脸生成的<em>character</em>；第二种是驱动<em>Unreal Engine</em>系列产品<em>MetaHuman Creator</em>自定义捏脸生成的<em>metahuman</em>，两种方式各有优劣，当依据实际情况自行选择。</p><h3 id="2-Live-Link"><a href="#2-Live-Link" class="headerlink" title="2. Live Link"></a>2. Live Link</h3><p><em>Live Link</em>作为联通<em>Unreal Engine</em>与<em>iClone</em>的桥梁插件，在整个过程中起到至关重要的作用。通过<em>Live Link</em>插件，可以实现<em>Model Transfer</em>、<em>Model Synchronization</em>的功能。</p><p>操作方式亦十分简单，将<em>Live Link for Unreal</em>插件下载好后分别导入当前<em>UE</em>项目及<em>iClone</em>软件中即可使用，之后于<em>iClone</em>中选定要<em>Transfer / Link</em>的对象，点击<em>Transfer file / Activate Link</em>按键后即可自动实现模型的传输。</p><h3 id="3-Character-Creator-Based-Solution"><a href="#3-Character-Creator-Based-Solution" class="headerlink" title="3. Character Creator-Based Solution"></a>3. Character Creator-Based Solution</h3><p>该方案为简单涉及，故仅笼统介绍。</p><h4 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a>3.1 Description</h4><p>在<strong>对应版本</strong>(<em>iClone7 - CC3</em>, <em>iClone8 - CC4</em>)的<em>Character Creator(CC)</em>中通过捏脸系统将虚拟人形象生成好后，通过<em>Export to iClone</em>功能将虚拟人模型导入<em>iClone</em>作进一步处理，包括但不限于<em>Lip Sync</em>、<em>Motion Setup</em>、<em>Create Script</em>等驱动处理。之后便可通过<em>Live Link</em>插件功能将模型<em>transfer</em>至<em>Unreal Engine</em>对应场景中（若本身在<em>iClone</em>中不方便操作场景的话），驱动<em>iClone</em>中的虚拟人，<em>UE</em>中对应的虚拟人形象也会同步运动。</p><h4 id="3-2-Pros-amp-Cons"><a href="#3-2-Pros-amp-Cons" class="headerlink" title="3.2 Pros &amp; Cons"></a>3.2 Pros &amp; Cons</h4><p><strong>Pros</strong>. 该方案优势在于操作简单，且可以选择在<em>iClone</em>中布置场景完成驱动，机动性高。</p><p><strong>Cons</strong>. 在该方案中总共经历过两次模型传输，一次为<em>CC to iClone</em>，一次为<em>iClone to Unreal Engine</em>，每一次模型传输都会造成模型精确度下降，以至于最后传输至<em>UE</em>的模型已经与原初<em>character</em>相去甚远，故若需要最后在<em>UE</em>中显示驱动效果，不推荐此法。</p><h3 id="4-MetaHuman-Creator-Based-Solution"><a href="#4-MetaHuman-Creator-Based-Solution" class="headerlink" title="4. MetaHuman Creator-Based Solution"></a>4. MetaHuman Creator-Based Solution</h3><p>注意，此法必须下载安装<strong>完整版</strong>的<em>Live Link Kit</em>，否则将无法进行面部及身体驱动。相应所有插件安装完成后，<em>Unreal Engine</em>中当于插件栏出现<em>CC Setup</em>及<em>iClone Live Link</em>字样及图标。</p><h4 id="4-1-Description"><a href="#4-1-Description" class="headerlink" title="4.1 Description"></a>4.1 Description</h4><p>该方案通过在官网远程操作<em>MetaHuman Creator<em>自定义对应</em>UE<em>版本的</em>MetaHuman<em>后，通过</em>Quxiel Bridge<em>将模型导入（注意，在进入</em>MetaHuman Creator<em>后弹出的第一个界面中必须选择为对应版本，否则将无法导入）。之后在打开的*</em>对应版本*<em>(</em>UE4 - iClone7, UE5 - iClone8</em>)的<em>iClone</em>中选择一个拥有完善面部表情及建模的<em>character</em>用于面部驱动（如原生存在的<em>ExPlus Facial Demo</em>项目，或是<em>Character Creator</em>生成的数字人），再选择一个<em>Live Link Kit</em>中自带的对应体型的身体模型（如<em>f_med_nrw_body</em>文件）用于驱动身体。</p><h5 id="4-1-1-Face-Synchronization"><a href="#4-1-1-Face-Synchronization" class="headerlink" title="4.1.1 Face Synchronization"></a>4.1.1 Face Synchronization</h5><p>驱动面部表情需要对<em>UE</em>中的<em>MetaHuman</em>进行相应的参数配置，假设我们使用<em>MetaHuman BP_Pia</em>。</p><p>首先选中<em>BP_Pia</em>，在其<em>Details</em>所展现的身体结构中选中<em>Face(Inherited)</em>，找到<em>Animation</em>对应下拉栏，其中<em>Animation Mode</em>与<em>Anim_Class</em>分别选中<em>Use Animation Blueprint</em>与<em>Face_AnimBP_C</em>。此举旨在告诉<em>Unreal Engine</em>我们使用<em>Live Link</em>插件中内置的<em>Blueprint</em>来驱动<em>BP_Pia</em>的面部。</p><p>接着在<em>iClone</em>中<em>Activate Link</em>，选择<em>Debra</em>将其传输至<em>UE</em>（此处假设<em>iClone</em>中使用上述<em>ExPlus Facial Demo</em>作面部驱动），再于<em>UE</em>中<em>Live Link</em>窗口中加入对应<em>port</em>的<em>source</em>，看见<em>Subject Name Role</em>中接收到<em>Debra</em>即为传输成功。接着选中<em>BP_Pia</em>身体结构中的<em>BP_Pia(self)</em>，于相应<em>Default</em>下拉栏中将<em>LLink Face Subj</em>改为<em>Debra</em>，同时勾起<em>LLink Face Head</em>框（若希望头部亦随<em>Debra</em>运动）。此时在<em>UE</em>中以<em>Simulation</em>模式运行程序，并同时于<em>iClone</em>运行<em>Debra</em>输入好的面部运动程序，即可发现<em>BP_Pia</em>面部随<em>Debra</em>同步运动。若此时未达成期望效果，当检查本机<em>Face_AnimBP</em>程序是否完整。</p><p>此后便可通过<em>UE</em>内置的<em>Recorder</em>系统录制<em>MetaHuman</em>的面部动作，以<em>Level Sequence</em>的形式存储下来。</p><p><strong>LIVE FACE</strong>. 实际上，该方案可以实现基于<em>iClone LIVE FACE</em>插件的实时面捕驱动<em>MetaHuman</em>。不过，由于该插件基于<em>Apple</em>的<em>ARKit</em>系统，故只支持搭载<em>ARKit</em>的<em>Apple</em>系列产品。假设此时我们拥有一台搭载<em>ARKit</em>的<em>iPhone</em>手机，那么我们需要于<em>App Store</em>下载<em>LIVE FACE</em>软件，打开后可以发现该软件在对我们的面部做实时面部捕捉，并显示对应的面部位置参数。</p><p>打开<em>iPhone</em>热点，让电脑连接对应热点网络同步<em>IP</em>（即使电脑额外连接网线亦可成功），再于<em>iClone</em>打开<em>Motion LIVE</em>插件，将<em>LIVE FACE</em>栏的<em>Connection</em>改为<em>iPhone LIVE FACE</em>软件中显示的<em>IP Address</em>，后尝试打开<em>LIVE FACE</em>插件连接<em>iPhone</em>。成功后于<em>Character List</em>下拉栏对应<em>character</em>的<em>Face</em>栏中点击感叹号按键，选择<em>LIVE FACE</em>，再选中<em>Preview</em>，此时即可发现<em>Debra</em>面部随着我们本人面部参数变化而变化。注意，经过实验，在该过程中必须由手机开启热点，电脑连接对应热点，其他方案如手机连接电脑热点，或仅使手机和电脑处于同一网络下的方案皆不可行。</p><p><strong>Create Script &amp; Face Key</strong>. 此为<em>iClone</em>中内置的功能，可以实现<em>TTS(Text-to-Speech)</em>功能，同时根据文本实现<em>Lip Sync</em>，若用户不满意<em>AI</em>生成的结果，亦可手动调整相应音节口型，使<em>character</em>说话更加自然与流畅。</p><h5 id="4-1-2-Motion-Synchronization"><a href="#4-1-2-Motion-Synchronization" class="headerlink" title="4.1.2 Motion Synchronization"></a>4.1.2 Motion Synchronization</h5><p>动作驱动相比于面部驱动会稍微复杂一些，因为他需要修改一些内部<em>Blueprint</em>。依旧以<em>MetaHuman BP_Pia</em>为例，在<em>UE</em>中，第一个需要修改的<em>Blueprint</em>即为<em>f_med_nrw_animbp</em>，如<em>Figure. 1</em>所示，加上<em>Live Link Pose</em>与<em>Live Link Subject Name</em>即可；第二处为<em>BP_Pia</em>本身的<em>Blueprint</em>，如图<em>Figure. 2</em>所示，加上如上代码，且<em>Variable</em>处新增变量<em>LLink Body Subj</em>即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/08/18/vD5iaq.png" style="zoom:30%;" /><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/08/18/vD5FI0.png" style="zoom: 25%;" /></p><p><center><font color = "grey">Figure. 1 & Figure. 2</font></center></p><p>值得注意的是，第一处需要修改的<em>Blueprint</em>需要由使用角色的体型而定，此例子中<em>BP_Pia</em>使用<em>f_med_nrw_body</em>体型生成，若其为<em>f_tal_nrw_body</em>生成，则需修改<em>f_tal_nrw_animbp</em>。</p><p>之后于<em>BP_Pia</em>的<em>Body(Inherited)</em>身体部分<em>detail</em>中找到<em>Animation</em>下拉栏，使<em>Animation Mode</em>与<em>Anim Class</em>分别为<em>Use Animation Blueprint</em>与<em>f_med_nrw_animbp_C</em>，同时再将<em>BP_Pia(self)</em>中<em>Default</em>下拉栏新增的<em>LLink Body Subj</em>更改为<em>f_med_nrw</em>即可，此时<em>Play in Simulation mode</em>，再启动<em>iClone</em>对应动作模组动画，则会发现<em>MetaHuman</em>随之运动。</p><p>事实证明，在<em>Live Link<em>同时传输面部数据(</em>Debra</em>)和动作数据(<em>f_med_nrw</em>)的情况下，并不会起冲突，即<em>MetaHuman</em>面部和身体可以分别运动，若出现只有一方能够运动的情况，当检查配置，或是电脑卡顿问题，或是未<em>Play in Simulation mode</em>。</p><p>那么之后若希望保存<em>MetaHuman</em>的运动数据，使其在无需<em>Live Link</em>的情况下也能实现相应运动有两种方法：一种即是类似<em>Face Sync</em>那样录制下来，这也是最省事的，但在灵活性上较弱；另一种即是<em>Retarget</em>方法，下面会进行介绍。</p><p><strong>Retarget</strong>. <em>retarget</em>，指的是将一个<em>character</em>的动作通过骨骼绑定将其应用到另一个<em>character</em>上。为实现这个，我们首先需要将<em>iClone</em>中设定好的动作模组以<em>fbx</em>形式导出，再由<em>UE</em>导入。导入后我们需要找到该模型对应的骨骼，找到<em>Retarget Manager</em>，在<em>Select Rig</em>中选择<em>Humanoid</em>模式，使用<em>AutoMap</em>或是自己手动将模型骨骼对应到相应部位(如<em>spine, clavicle, UpperArm</em>之类的)，再于<em>Skeleton Tree</em>的<em>Options</em>中选择<em>Show Retargeting Options</em>，将需要<em>retarget</em>的骨骼设定为<em>Recursively Set Translation Retargeting Skeleton</em>，一般来讲我们会将<em>pelvis</em>以下的部分全部如此设定。同样地，对<em>BP_Pia</em>重复上述操作。都准备好后右键导入动作模组中名字含<em>TempMotion</em>（即最主要的那个）的文件，选择<em>Retarget to Another Skeleton</em>，打开后选择<em>BP_Pia</em>的模型，点击<em>Retarget</em>即可，此时它便会生成关于<em>BP_Pia</em>的动作文件，可直接放入<em>Sequencer</em>查看效果。</p><p>但值得注意的是，可能由于目前<em>UE</em>本身内置的<em>retarget</em>算法的原因，得到的效果并不是很理想，即使保证体型相同，与原动作也明显存在差异，且其自身展现十分不自然，需要人力调整，相对繁琐，若是方法一可以实现需求，并不是很推荐此法。</p><h4 id="4-2-Pros-amp-Cons"><a href="#4-2-Pros-amp-Cons" class="headerlink" title="4.2 Pros &amp; Cons"></a>4.2 Pros &amp; Cons</h4><p><strong>Pros</strong>. <em>MetaHuman Creator-Based Solution</em>相比于<em>Character Creator-Based Solution</em>更能保证数字人在最终呈现效果的质量，且由于<em>UE</em>本身强大的场景等制作能力、泛用性，以及良好适配的可编程系统，使用该方案更加迎合市场需求，且机动性更强。</p><p><strong>Cons</strong>. 使用本方案意味着需要购买<em>Live Link Kit</em>，同时操作细节更为繁琐，需要对<em>Blueprint</em>有一定了解，且目前版本的<em>MetaHuman Creator</em>相较于<em>Character Creator</em>捏脸可操作范围更小，生成的角色比较局限，可移植性也相对较差。</p><h3 id="5-Discussion"><a href="#5-Discussion" class="headerlink" title="5. Discussion"></a>5. Discussion</h3><p>若要基于<em>Unreal Engine</em>与<em>iClone</em>来驱动数字人，考虑到泛用性与效果展现，一般还是会选择<em>MetaHuman Creator-Based Solution</em>，其即使在近镜头下也能展现较为逼真的人物皮肤等细节，适合<em>CG</em>场景等制作。该数字人方案可应用范围相对广阔，除去<em>CG</em>制作，亦可配合<em>OBS</em>等软件用于<em>Live</em>实时面捕直播。且听闻已有通过<em>ARKit</em>直接控制<em>MetaHuman</em>的解决方案，那么在通过<em>iClone</em>做好动作模组后，便可直接摒弃<em>iClone</em>，仅使用<em>Unreal Engine</em>进行直播等操作，符合目前市场虚拟主播(无动捕)的技术要求，或是打包为应用程序更进一步开发。动捕方面<em>iClone</em>也存在相应插件，但鉴于个人没有动捕设备便无法进行下一步操作，但若有条件使用，更可扩展其应用空间。</p>]]></content>
      
      
      <categories>
          
          <category> 3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE </tag>
            
            <tag> iClone </tag>
            
            <tag> DigitalHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Basic</title>
      <link href="/2023/07/14/C++%20Basic/"/>
      <url>/2023/07/14/C++%20Basic/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>感觉多少有点复杂</p></blockquote><h3 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h3><ul><li><p>A dangling pointer is a pointer that points to a location whose memory is deallocated.</p></li><li><p>dynamic objects are managed by <strong>heap</strong>, and <strong>stack</strong> vice versa. <strong>Temporary</strong> objects are managed by <strong>stack</strong>. And rvalue reference is an alias of a temporary object/value.</p></li></ul><p><code>const int*</code> is different from <code>int* const</code>. <code>int* const</code>相当于我们让一个const变量成为指针，比如<code>int* const ptr = &amp; x</code>，那么实际上ptr作为一个const变量是不可变的，但是他指向的x的值是可变的，即<code>* x = 5</code>编译是可以通过的。相较之下，<code>const int* ptr = &amp; x</code>则是ptr是changeable，x是unchangeable。</p><blockquote><p>我告诉你一个小的技巧，就是c++keyword修饰它前边的东西，这个是一定成立的。 ——whs</p></blockquote><p>比如，<code>const int* const p</code>则分为两个部分理解，一个是<code>int*</code>这个指针指向一个<code>const int</code>变量，另一个则是第二个<code>const</code>管着<code>int*</code>，即这个指针也是unchangeable的。注意，int const* a也指的是值不变的指针。</p><p>a[<a href="file:///Users/colythme/Library/CloudStorage/OneDrive-HKUSTConnect/Courses/Courses/COMP2012H/2022Fall/Note.md#">i</a>][j]的地址可以被这么表达：<code>*((*(a+i)) + j)</code></p><p>指针在32位机器中占4byte，在64位机器中占8byte。</p><p>数组是连续的：即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">cout &lt;&lt; * (a + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; * (a + <span class="number">4</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出为<code>1, 4</code></p><p>那么关于<code>a</code>、<code>&amp;a</code>与<code>&amp;a[0]</code>的差别，一下子有一篇博客阐释的较为清楚：</p><p>在探讨这个问题之前，我们首先来看一道笔试题，如下：<br>　　【<strong>摘自牛客网</strong>】下列代码的结果是：（正确答案是 C）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> *ptr=(<span class="keyword">int</span> *)(&amp;a+<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>,*(a+<span class="number">1</span>),*(ptr<span class="number">-1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A、3,5　　　B、2,4　　　C、2,5　　　D、3,4<br>　　下面我们来分析一下选择C的原因，解释清楚这个题的正确答案，你就能清楚数组中&amp;a与&amp;a[0]存在什么区别了。<br>　　题目中首先定义了存放5个int类型空间大小的内存，然后初始化5个数。我们知道直接使用数组的名字a表示的是一个指向数组首地址的指针，所以直接a与&amp;a[0]是相同的意思，都表示数组的首地址。所以<em>(a+1)很好理解，假设a地址是0x1000，就是取（0x1000+sizeof(int)）地址的数，由于数组的物理地址是连续的，当然就是取2。<br>　　那&amp;a表示什么意思呢，相当于取存放指向数组首地址的指针的存储地址，话有些绕，但是细细品味你就会发现，它就相当于二维指针，假设每个一维指针指向一排数组（当然除了第一个一维数组的指针之外实际都没有申请，但是在访问野指针之前计算机也不知道那块地址是否存在，但的确可以由物理地址连续性来获取这块地址的表示），所以简言之&amp;a表示第一排数组，&amp;a+1就是表示第二排数组（就是5<em>sizeof(int)=5</em>4=20空间大小后一段空间的首地址）。<br>　　有了上面的介绍就好理解了，</em>(ptr-1)是表示取(0x1000+5*sizeof(int)-sizeof(int))地址中的数，算得为5。<br>　　总结：<br>　　&amp;a[0]表示数组的首地址，与直接a相同意义。而&amp;a表示存储指向数组首地址的指针的地址，可以用二维指针来理解。</p><p>For dynamic 2D array:</p><ul><li><code>x == &amp;x[0] != &amp;x[0][0]</code></li><li><code>&amp;x[j] = x + j</code></li><li><code>x[j] == &amp;x[j][0]</code></li></ul><p><strong>Homogeneous</strong></p><p>“homo-“ means same, “hetero-“ means different.</p><p>In any case if a single Java array <strong>can only store one type</strong>, say, only numbers, or only strings then it is <strong>homogeneous</strong>.</p><p>If <strong>multiple types</strong> then <strong>heterogeneous</strong>. In the above case, since collection is of Object type and can hold any type</p><p>Let’s take Javascript for understanding this better eg. arrays are heterogeneous, because I can make an array that holds [5, “hello”, new Object()], and in Java that’s not possible.</p><p>static member v.s. non-static member</p><p>static member可以不通过instance就直接call，而non-static member则需要先创建一个Helper instance g在经由g去call</p><p>return by value: return a copy of the original object.</p><p>return by reference:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">FUNC</span> <span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>The original object is passed back, which means further operations on returned value would affect the original object.</p><p>conversion constructor: a constructor accepting single para。值得注意的是，A constructor may have multiple arguments; if all but one argument have default values, it is still a conversion constructor. which means <code>Word (const char *s, int k = 1)</code>这种虽然两个变量但是实际上只有一个是unknown的也是conversion</p><p>implicit conversion: 指通过形似Word movie = “James”赋值，这种赋值方式实际上是先开一个新object with initial value “James”，然后再赋值给movie，故为implicit</p><p>copy constructor: 实际上就是初始化值变成了其他的同类型object。比如Word (const Word&amp; W) {}。A constructor that has exactly one argument of the same class passed by its const reference.注意exactly one arg</p><p>Function</p><p>Formal-parameter-list指函数def那边的参数列表；Actual-parameter-list指的是调用的参数列表</p><p>define a function: int Func (int, int); 这里(int, int)被叫做signature。</p><p>function prototype: 1. function name. 2. return data type. 3. the number of formal parameters. 4. the data type of the formal parameters.</p><p>function declaration指的是写下他的interface (its function prototype)，而function definition则是将其header和body都写出来。</p><p>function resolution: 实际上就是指compiler判断到底用哪个overloaded function的过程。</p><p>default arguments必须写在变量之后，即void func (int x, int y, int z = 0, int p = 0);</p><p>Scope for an identifier is determined by the location of its <strong>declaration</strong>.</p><p>FIle scope: global scope. Local scope: function scope, block scope(即比如for () { int a; })那么a就在个block里面。</p><p>同一个scope不能重名，但不同scope里可以。重名的话编译器编译时会选择innermost enclosing scope的变量。</p><p>使用最基础的方法穿array到function里是pass-by-value的，但是这array的elements确实pass-by-reference，也就是说在func里对array进行修改，是会影响到原数组的。对于多维数组，值得注意的是，void func (int a[][]) {}这种写法是不行的，只有第一维能为空，其他必须制定大小。</p><p>Class:</p><p>保护成员的可访问范围比私有成员大，比公有成员小。能访问私有成员的地方都能访问保护成员。保护成员扩大的访问范围表现在：基类的保护成员可以在派生类的成员函数中被访问。</p><p>CONSTRUCTOR member functions: constructors</p><p>ACCESSOR member functions: functions that will not modify data members (i.e. funct () const {})</p><p>MUTATOR member functions: 反之</p><p>After compilation, 代码中一个pointer指向的function将会被转化成unique global function by adding a new argument. e.g., x.set (a)编译后将会被转化为Class::set (&amp; x, a)</p><p>A const object can only call const member functions.</p><p>Keyword: private可以被member functioin及friend class访问；protected可以被member functions、friend class及friend class的derived class访问。</p><p>Constructor &amp; Destructor</p><p>总结：1. static变量不会在主动constructor里面被访问去create。2. 对于继承关系，比如B继承A，那么construct B之前一定会先construct A，同理，destruct B之后也一定会destruct A。3. 对于<code>A** a = new A*[2] &#123; new A(1), new B(b) &#125;;</code>的情况a不会经过constructor。4. 有一个方法就是可以看作stack，即destruct的过程完全和construct过程反过来。</p><p>A constructor accepting a <strong>single argument</strong> specifies a conversion from its argument type to the type of its class:</p><p>如果存在user-defined constructor但是在定义object的时候没有指定constructor，那么会报错而不会自动调用default constructor. default constructor只有在没有user-defined constructor的时候才会被自动调用。</p><p>explicit关键字before constructor指定了必定只能显式转换（对于JAVA：隐式转换也叫自动类型转换，指的是不需要调用函数，JVM自动将类型转换的一种方式）。</p><p>term: braced initializtion指的是int z{3}这种用大括号的初始化方法。</p><p>func () : () {} 这玩意儿叫做member initializer list (MIL).</p><p><strong>const or reference members must be initialized using member initializer list if they don’t have default initializers.</strong></p><p>construction order和destruction order分别类似于先序遍历和后序遍历。</p><p>A ‘has’ B: A的member里有B的object；A ‘owns’ B: A的member里有B的指针</p><p>Objects must be passed by reference in copy constructors. i.e. Copy constructor of class X must have the following signature: X::X(const X&amp; copiee). It cannot be X::X(const X copiee)</p><p>A conversion constructor can be called anywhere when the type of the single argument is assigned to the object. 也就是说conversion constructor可以被call大于一次。</p><p>Inheritance</p><p>私有继承：使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，只可以在派生类的成员函数中使用</p><p>保护继承：基类的public和protected成员：都以protected身份出现在派生类中；</p><p>Def: Polymorphic or Liskov Substitution Principle 指的是inheritance中derived class可以调用base class的所有东西，but not vice versa的原则。</p><p>Problems:</p><ul><li>Slicing: 将子类object的值赋给一个父类object</li><li>Name Conflict</li></ul><p>如果一个data member在base class中是private，那么他不可以被derived class的object访问，还是只能被base class’ own member function访问（除非friend）。</p><p>那么此时就要将他们改为protected，这种状态下they are accessible to member function in the base class as well as member functions in the derived class.</p><p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定</strong>。</p><p>Polymorphism in C++ means that we can work with objects without knowing their precise type at compile time. We say that uperson exhibits polymorphism, because the object can take on multiple “shapes” (Student, Teacher, PG_Student, etc.). <strong>A pointer or reference must be used to take advantage of polymorphism.</strong> 至于为什么不能pass-by-value，也跟object slicing有关，因为当你pass-by-value传进去的时候，If the base-class object is not legit合法的 (e.g. it has pure virtual functions in it), you can’t even declare or call this function.</p><p>在基类中仅仅给出声明，不对虚函数实现定义，而是在派生类中实现。这个虚函数称为纯虚函数。普通函数如果仅仅给出它的声明而没有实现它的函数体，这是编译不过的。纯虚函数没有函数体，纯虚函数需要在声明之后加个=0；</p><p>Override is not possible if the member function is not virtual.</p><p>virtual destructor: 为了防止诸如UPerson* p = s而s是derived Student类，delete p却只调用UPerson的destructor而不是Student的destructor的情况，那么加上了virtual就可以通过object本身的类型来选择destructor了。</p><p>ABC: Abstract Base Class</p><ul><li><p>No objects of ABC can be created</p></li><li><p>抽象类不能直接实例化，并且对抽象类使用 new 运算符会导致编译时错误；</p><p>  抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们；</p><p>  重要的是抽象类可以包括抽象方法，这是普通类所不能的，但同时也能包括普通的方法。</p></li></ul><p>Keyword ‘final’ 意味着该类无法被继承</p><p>Generic Programming</p><p>fucntion template会自动deduce template arguments（即typename），但是class template必须要明确定义。</p><p>加号的函数用法实际上是operator+(a, b)</p><p>ostream is the base class for all possible output streams. cout, cerr都是该类中的object</p><p>overload operator []需要一个constant overloading和non-constant overloading。若不存在non-constant overloading，那么对那些non-constant的object的访问可以使用constant overloading的函数；但是若不存在constant overloading的话，那些constant的object就没法使用non-constant overloading的函数。但是注意，即使可以non-constant object可以调用constant的，也会产生lvalue和rvalue的问题，即constant overloading返回的是rvalue，不能用于赋值。</p><p>overload operator ++的时候，要注意overload的是lvalue还是rvalue。如果是lvalue，即++ a，那么写作Vector&amp; Vector::operator ++ () {}；若是rvalue，即a ++，那么写作Vector Vector::operator ++ (int)。</p><p>STL</p><p>Containers: Sequence containers；Associate containers是非线性的，存key/value pairs；Container adapters adopted containers that support a limited set of container operatioins；Near containers</p><p>Sequence: vector, list, deque；Associative: map, multimap, multiset, set；Adapters: priority_queue, queue, stack；Near-containers: bitset, valarray, string</p><p>A predicate is <strong>a C++ function returning a boolean or an object having a bool operator() member</strong>.</p><p>function pointer: <code>inline const T (*) (const T&amp;, const T&amp;);</code>。用法诸如<code>int (* f)(int x, int y) = larger</code>，<code>int (* f[])(int x) = &#123; func1, func2, func3 &#125;</code></p><p>Tree</p><p>Preorder：根左右；Inorder：左根右；Postorder：左右根</p><p>lvalue/rvalue reference</p><p>Temporary object/value在什么时候会存在呢？1. const reference initialization; 2. argument passing (e.g. type conversion或者诸如类似func (“pass_value”)的情况); 3. function returned value (by copying); 4. evaluatioin of expressions (e.g., result of sub-expressions比如int e = a + c + d中生成了temporary object来承载a + c + d).</p><p><strong>Temporary</strong> objects are managed by <strong>stack</strong>. And rvalue reference is an alias of a temporary object/value.</p><p>lvalue reference only binds to another lvalue，即int&amp; b = 4会报错，因为让lvalue reference等于一个rvalue。但是const lvalue reference可以接受rvalue，因为此时temporary value已经被created了，即const int&amp; c = 5是正确的。</p><p>值得注意的是，rvalue ref必须被initialized，即int&amp;&amp; b是错误的；且他不能承接lvalue，即int a; int&amp;&amp; c = a是错的。</p><p>rvalue reference once bound, cannot be re-bound to another temporary object.</p><p>std::move () only does static casting.</p><p>C++11 new feature</p><p>{} initializer is more restrictive: it doesn’t allow conversions that lose information — narrowing conversions（即int a {0.5}）这种写法是不允许的（double值通过{} initializer赋值给一个int object）。</p><p>注意，lambda function中假如[]里面是value，那么他实际上只会在该lambda function被定义的时候copy一次，which means这样的写法int a = 1; auto f = [<a href="file:///Users/colythme/Library/CloudStorage/OneDrive-HKUSTConnect/Courses/Courses/COMP2012H/2022Fall/int%20x">a</a>](int x) mutable { return a *= x; }; cout &lt;&lt; f (20) &lt;&lt; ‘ ‘ &lt;&lt; f (400) &lt;&lt; endl;输出是20 400而不是20 20。</p><p>explicit关键字可以让函数拒绝implicit conversion</p><p>enum里面的identifier name必须在整个程序中唯一，即enum { ABC }; int ABC = 0之类的都是不合法的。且comparision between enum不合法。但C++11中引入了enum classes可以一定程度上避免这些问题。</p><p>Static</p><p>加了static关键字的全局变量我们就可以称为“内部”变量，这里的“内部”指的是static全局变量的作用域范围，<strong>“内部”作用域是指变量所在的文件作用域</strong>，也就是说static全局变量的作用域仅限于所在文件内部，工程内的其他文件不可见。</p><p>class里的static variable会让所有该class的object share同一个。Static variables cannot be initialized in the class definition (except for const int/enum static data). Static variables must be defined outside the class definition, usually in the class implementation (.cpp) file.（注意是define不是declare）</p><p>class中的static member function是属于class的所有object的，所以不存在this关键字，并且可以在不存在class object的时候使用，但是只可以对class中的static data member进行操作，且不能为const或者virtual functions，且不能被一个non-static member function of the same prototype overload。</p><p>AVL Tree</p><p>An AVL tree is a BST where the height of the two sub-trees of ANY of its nodes may differ by at most one. Each node stores a height value, which is used to check if the tree is balanced or not. 也被称作高度平衡树。</p><p>Insertion may violate the AVL tree property in 4 cases:</p><ol><li><p>Right-Right (RR)<br> Left (anti-clockwise) rotation [single rotation]:<br>  Insertion into the right sub-tree of the right child of a node</p></li><li><p>Left-Left (LL)<br> Right (clockwise) rotation [single rotation]:<br>  Insertion into the left sub-tree of the left child of a node</p></li><li><p>Left-Right (LR)<br> Left-right rotation [double rotation]:<br>  Insertion into the right sub-tree of the left child of a node</p></li><li><p>Right-Left (RL)<br> Right-left rotation [double rotation]:<br>  Insertion into the left sub-tree of the right child of a node</p></li></ol><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20221208153341046.png" alt="image-20221208153341046" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20221208153358855.png" alt="image-20221208153358855" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20221203212930617.png" alt="image-20221203212930617" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20221203212941360.png" alt="image-20221203212941360" style="zoom:50%;" /><p>Similar to node deletion in BST, 3 cases need to be considered</p><ol><li><p>The node to be removed is a leaf node</p><p> ⇒ Delete the leaf node immediately</p></li><li><p>The node to be removed has 1 child</p><p> ⇒ Adjust a pointer to bypass the deleted node</p></li><li><p>The node to be removed has 2 children</p><p> ⇒ Replace the node to be removed with either the</p><p> • maximum node in its left sub-tree, or</p><p> • minimum node in its right sub-tree Then remove the max/min node depending on the choice above.</p></li></ol><p>Removing a node can render multiple ancestors unbalanced ⇒ every sub-tree affected by the deletion has to be re-balanced.</p><p>Constexpr:</p><p>Restrictions of constexpr function</p><ol><li><p>In C++11, a constexpr function should contain only ONE return statement. (Relaxed in C++14)</p></li><li><p>Each of its parameters must be a literal type.</p></li><li><p>Its return type should not be void type and other operator like prefix</p><p> increment are not allowed in constexpr function. It must be a literal</p><p> type (e.g. scalar type, reference type, an array of literal type).</p></li><li><p>A constexpr function should refer only constant global variables.</p></li><li><p>A constexpr function can call only other constexpr functions.</p></li><li><p>A constexpr function has to be non-virtual.</p></li></ol><p>Hashing</p><p>For any key K, h2 (K) must be relatively prime to the table size m</p><p>Like separate chaining, open addressing is <strong>a method for handling collisions</strong>. In Open Addressing, all elements are stored in the hash table itself. So at any point, the size of the table must be greater than or equal to the total number of keys</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">compute L = ( <span class="built_in">h</span>(K) + i ) % m;</span><br><span class="line"><span class="keyword">if</span> T[L] is empty, put K there <span class="keyword">and</span> stop</span><br></pre></td></tr></table></figure><p>Quadratic Probing:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">compute L = ( <span class="built_in">h</span>(K) + i*i ) % m;</span><br><span class="line"><span class="keyword">if</span> T[L] is empty, put K there <span class="keyword">and</span> stop</span><br></pre></td></tr></table></figure><p>Double Hashing:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">H</span>(Ki, <span class="number">0</span>) = <span class="built_in">h</span>(Ki)</span><br><span class="line"><span class="built_in">H</span>(Ki, <span class="number">1</span>) = (<span class="built_in">H</span>(Ki, <span class="number">0</span>) + <span class="built_in">h2</span>(Ki)) mod m</span><br><span class="line"><span class="built_in">H</span>(Ki, <span class="number">2</span>) = (<span class="built_in">H</span>(Ki, <span class="number">1</span>) + <span class="built_in">h2</span>(Ki)) mod m</span><br><span class="line">. . .</span><br><span class="line"><span class="built_in">H</span>(Ki,m) = (<span class="built_in">H</span>(Ki,m−<span class="number">1</span>) +<span class="built_in">h2</span>(Ki)) mod m</span><br></pre></td></tr></table></figure><p>Main</p>]]></content>
      
      
      <categories>
          
          <category> AMP Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D Human Reconstruction Notes</title>
      <link href="/2023/07/14/3D%20Human%20Reconstruction%20Notes/"/>
      <url>/2023/07/14/3D%20Human%20Reconstruction%20Notes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>重建个自己的avatar放metaverse里面跑</p></blockquote><h1 id="Human-Face-Reconstruction-Reference"><a href="#Human-Face-Reconstruction-Reference" class="headerlink" title="Human Face Reconstruction Reference"></a>Human Face Reconstruction Reference</h1><h2 id="PIFu"><a href="#PIFu" class="headerlink" title="PIFu"></a>PIFu</h2><p><em>PIFu</em>分为<em>single-view surface reconstruction</em>及<em>multi-view surface reconstruction</em>，但是实际上<em>multi-view surface reconstruction</em>就是对多个<em>single-view</em>的一个整合(比如简单粗暴的取平均值之类的)，故不多赘述。</p><p><em>PIFu</em>，全称<em>Pixel-Aligned Implicit Function</em>，顾名思义，它与之前的做human digitalization的算法的不同之处在于两点，一个是<em>Pixel-Aligned</em>，一个是<em>implicit function</em>。关于<em>pixel-aligned</em>，之前的算法大多都是<em>voxel-aligned</em>，也就是将一个三维的数据，即<em>voxel</em>，放到model中训练，显然，这费时又费空间，而<em>PIFu</em>只先关注二维数据，再利用<em>implicit function</em>的优势，将深度参数$z(X)$放进隐式函数中求解。</p><p>首先声明一下<em>implicit function</em> $f$的定义，<br>$$<br>f(F(x), z(X)) = s : s \in R<br>$$<br>其中，$x$表示一个二维点，$X$表示一个三维点，并且$x = \pi (X)$，表示$x$是$X$的一个二维projection，$z(X)$上面有说过，存储是$X$的深度参数，$F(x) = g(I(x))$是一个函数，其中$g(\cdot)$是一个<em>encoder</em>，之后由神经网络训练得到。而$f(\cdot)$得到的值$s$是个<em>binary</em>，即只有$0$和$1$，分别表示该点在mesh surface的外面和里面。</p><center><font color = "grey">fig. 1   structure pic from PIFu essay</font></center><p><em>fig. 1<em>是</em>PIFu<em>的流程图，如图所示，对于</em>surface reconstruction<em>，在计算机得到图像之后，将其放入</em>image encoder<em>，得到其特征向量$F_V(x)$，注意这里的下标$V$仅是用于将</em>surface<em>和</em>texture reconstruction<em>得到的特征向量区分开，即这依旧表示的是上文公式的$F(\cdot)$。得到必要的$F_V(x)$、$z(X)$作为参数后，便可以训练隐式函数$f_V(\cdot)$了， *loss function</em>为<br>$$<br>\mathcal L_V = \frac1n\sum\limits_{i = 1}^n |f_v(F_V(x_i), z(X_i)) - f^</em>_v(X_i)^2|<br>$$<br>其中，$f^*_v(X_i)$指的是由给定训练集中的训练数据可以得到的$f(\cdot)$函数。</p><p>知道了训练方法，那么现在问题就是如何获取训练样本，毕竟对于一个模型，我们可以从它身上取的点是无数个。一个最简单的想法就是，在模型的bounding box里随机取样，然而<em>PIFu<em>研究者经过实验，证明这种方式并不是很理想，他们决定再加上另一种采样方式: 随机在模型表面采样，并且给予其扰动，该扰动距离符合</em>Gauss Function</em> $\mathcal N(0, \sigma)(\sigma = 0.5cm)$。最终研究者确定在这两种取样方法比例为$1: 16$时为最佳。</p><p>解决了<em>Surface Reconstruction</em>，<em>Texture Reconstruction</em>同理，在其基础上，修改其$f(\cdot)$函数的表示方法，即$f_c(\cdot) = RGB$，并且更改损失函数为<br>$$<br>\mathcal L_C = \frac1n\sum\limits_{i = 1}^n |f_c(F_C(x’<em>i, F_V), X’</em>{i, z}) - C(X_i)|<br>$$<br>其中，$X’_i = X_i + \epsilon, \epsilon \sim \mathcal N(0, d), d = 1.0cm$，$x_i’ = \pi (X_i’)$</p><p>之所以<em>loss function</em>需要改成这样，是因为若保持原样，相当于在<em>surface</em>特征上又加上一个<em>color</em>的特征，而这样一般来讲，并且研究者经过实验，发现容易<em>overfitting</em>，那么不如在原有已得特征$F_V$的基础上加以改进，这样就可以省掉一个特征了，即$F_C (x_i’, F_V)$。而添加offset是为了让得到颜色的范围更广一些，毕竟我们无法对那无数个点都做训练，所以只能够让一个颜色存在于一定范围内来实现<em>texture inference</em>。</p><p>之后使用<em>Marching Cube</em>方法实现模型重建。</p><p>更细节一些，求解$F(\cdot)$的<em>encoder</em>使用的是<em>Stacked Hourglass Network</em>，而训练$f(\cdot)$使用的是多重$MLP$。</p><h2 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h2><p><em>U-Net</em> 一般是用来处理<em>semantic segmentation</em>类问题用的，而此类问题即是指将存在于一张图像的不同物体标注出来，其最终呈现效果实际上有点类似于<em>thermal image</em>，但是又不尽相同。传统处理<em>semantic segmentation</em>的方法一般都是通过<em>CV</em>实现，比如基于<em>threshold</em>或者<em>edge detection</em>的实现，之后Jonathan Long等人提出了基于<em>FCN(Fully Convolutional Network)</em>的实现，2015年，在<em>U-Net</em>这篇论文中，它基于<em>FCN</em>，提出一种能够适应小训练集的网络方案。</p><p>首先说说<em>FCN</em>，其实<em>FCN</em>和<em>CNN</em>的网络结构基本一致，泛泛而谈，只是将最后的<em>Fully Connected Layer</em>改成了一个全卷积网络，实际上顾名思义，<em>FCN</em>本身即全部是由卷积组成的。那么为什么要做这样的处理？因为在<em>CNN</em>中，要通过<em>FCL</em>，我们必须将之前的tensor全部化为一个$1 \times n$的vector，也就是说，最终我们得到的只有对图像全局的一个分类参数，而若我们要做<em>semantic segmentation</em>，显然这样是行不通的，那么此时将<em>FCL</em>改为全卷积，我们就可以获得每个pixel的分类信息，从而获取全局的分割信息。</p><p><em>Subsampling</em>的过程实际上是提取特征，level较低的layer用于提取小特征，level较高的layer用于抽象全局特征，即类似于classification的特征就是由这一块得到的，因为其<em>receptive field</em>较大，但是这也造成了其<em>resolution</em>较低。那么经过<em>subsampling</em>后，可以提高<em>resolution</em>并还原特征。其中，<em>FCN</em>在与前文的联系上采用<em>skip-layer</em>中逐pixel做加法的方法，即类似于<em>fig. 2</em>中的灰色箭头。</p><p>了解了<em>FCN</em>，<em>U-Net</em>理解起来就比较容易了，generally speaking，不去细究其内部网络详情，一如每个kernel的大小之类的，它实际上就是在与context连接的部分将逐pixel相加改为直接重叠，即将两个tensor重叠在一起，形成一个新的tensor，再进行下一步处理。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/09/01/v5sKzt.png" style="zoom:40%;" /><center><font color = "grey">fig. 2   network structure pic from U-Net essay</font></center><p>至于<em>U-Net</em>为何能在只有小训练集的时候也能很好的训练出一个不错的model，这归功于<em>Overlap-tile strategy</em>，实际上就是将一个大的图片分为很多较小的训练样本，那么对于关键词<em>overlap-tile</em>，这实际上就是扩大<em>padding</em>，来让我们选定的小范围区域的边缘部分也能被计入训练集进行训练。</p><h2 id="I-M-Avatar"><a href="#I-M-Avatar" class="headerlink" title="I M Avatar"></a>I M Avatar</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>PCA: 一种将多维变量在尽可能保留featrue的情况下降维的方法。</p><h2 id="ARCH"><a href="#ARCH" class="headerlink" title="ARCH"></a>ARCH</h2><p>Animatable Reconstruction of Clothed Humans</p><h3 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h3><ul><li><p>rigging：指的应当是建骨架的过程</p></li><li><p>![image-20221230103831196](/Users/colythme/Library/Application Support/typora-user-images/image-20221230103831196.png)</p></li><li><p>cv提到语义，一般指的是图像中像素点或目标本身的含义、性质等。</p><p>  比如cv的语义分割，指的是按照目标的种类性质进行图像分割，同一种物体分为一类。实际就是对每个像素点做分类任务。</p><p>  SemDF is a vector field represented by a vector-valued function V that accomplishes the transformation.v</p></li><li><p>SemS S = {(p, sp) : p ∈ R3} is a space consist- ing of 3D points where each point p ∈ S is associated to semantic information sp enabling the transformation opera- tion. SemDF is a vector field represented by a vector-valued function V that accomplishes the transformation,</p></li><li><p>pose-normalization我觉得指的应当是将project后得到的3D model normalize为基础动作或表情</p></li><li><p>In computer vision and graphics, 3D human models have been widely represented by a kinematic structure mimick- ing the anatomy that serves to control the pose, and a surface mesh that represents the human shape and geometry. Skin- ning is the transformation that deforms the surface given the pose.  It is parameterized by skinning weights that individ- ually influence body part transformations.</p><p>  其中，kinematic structure指的是运动学结构，即通过关节等的运动来表达。</p><p>  skinning是根据skinning wieghts来构建的，即比如一个手的weight是多少，我就让他倾斜多少度等（当然这个例子只是方便理解，实际并不一定是这样）。Skinning is the process of binding the actual <a href="http://www.digitaltutors.com/subject/3d-tutorials"><a href="http://www.digitaltutors.com/subject/3d-tutorials">3D</a></a> mesh to the joint setup you created.</p></li><li><p>weight: 一个joint可以管到一片区域，但是很明显，对于某个特定位置，可能会影响到该点的joint对他的影响程度是不同的，这也就有了weight的概念，即一个weight $w_{i, p}$表示某个joint $i$对某个点$p$的影响程度。而若对于某个点$p$，他所拥有的weight和为1的话，则称这个weight是被normalized的。</p><p>  那么LBS实际上就是对于一个点$p$，先算出每个joint对其进行linear transformation之后这个点应该在哪里，之后再将求出的每个点按照各自joint对$p$的权重乘起来并累加，类似于加权平均，得到最终$p$在经过某个变换应该所在的位置。</p></li><li><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20221231103922306.png" alt="image-20221231103922306" style="zoom:67%;" /><p>  可以发现对于点$v_i$，求$v_i’$实际上就是对于每个joint，累加其对于$v_i$的影响权重$w_{k, i}$乘上（经过canonical rest pose纠正过的vector仿射变换乘以$v_i$），实际上和LBS的步骤差不多。</p></li><li><p>Occupacy map中的某个点$p$的occupacy $o_p$是个0到1之间的数，表示该点被占据的概率是多少。</p></li></ul><p>Dataset: Our <strong>training</strong> dataset is composed of 375 3D scans from the RenderPeople dataset, and 207 3D scans from the AXYZ dataset. Our <strong>test</strong> dataset contains 64 scans from the RenderPeople dataset, 207 scans from the AXYZ dataset, 26 scans from the BUFF dataset, and 2D images from the DeepFashion dataset, representing clothed people with a large variety of complex clothing.</p><p>For each 3D scan, we pro- duce 360 images by rotating a camera around the vertical axis with intervals of 1 degree.</p><p>3D scan -&gt; fit a rigged 3D body template to the scan mesh (detect regions of self-contact and topology changes and cut the mesh before pose-normalization) -&gt; do pose-normalization</p><p>Comparison: We reconstruct the results on the same test set and repose them back to the original poses of the input images and compare the reconstructions with the ground truth surfaces in the original poses.</p><p>We report the average point-to-surface Euclidean distance (P2S) in centimeters, the Chamfer distance in centimeters, and the L2 normal reprojection error in Tab. 1.</p><p>Canonical Space: <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230101115134759.png" alt="image-20230101115134759" style="zoom:50%;" /></p><h3 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h3><p><em>we introduce the Semantic Space (SemS) and Semantic Deformation Field (SemDF) to handle implicit function representation of clothed humans in arbitrary poses.</em></p><p>那么他使用的方法就是先给定一个template model，假定他的semantic space是$S = \{(p, \{w_{i, p}\}^{N_K}<em>{i = 1}) : p \in \mathbb{R}^3\}$。那么根据skinning的方法比如LBS，对于一个任意pose的model，其上一点$p’$都肯定可以被template model上某个点$p$转化到，换言之，$p’$ is a linear combination of $\{w</em>{i, p}\}$。</p><p>那么问题就到了如何求$\mathcal{V}$。</p><p><em>we propose opacity-aware differentiable rendering to refine our human representation via Granular Render-and-Compare</em></p><p><em>we demonstrate how reconstructed avatars can directly be rigged and skinned for animation. In addition, we learn per-pixel normals to obtain high-quality surface details, and surface albedo for relighting applications.</em></p><p>![image-20230102173751432](/Users/colythme/Library/Application Support/typora-user-images/image-20230102173751432.png)</p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p><em>ARCH contains three components, after 3D body es- timation by [51] (see Fig. 2): pose-normalization using Semantic Space (SemS) and Semantic Deformation Field (SemDF), implicit surface reconstruction, and refinement using a differentiable renderer by Granular Render-and- Compare (see Sec. 3.4).</em></p><h2 id="ARCH-1"><a href="#ARCH-1" class="headerlink" title="ARCH++"></a>ARCH++</h2><h3 id="Contribution-1"><a href="#Contribution-1" class="headerlink" title="Contribution"></a>Contribution</h3><p><em>First, we introduce an end-to-end point based geometry en- coder to better describe the semantics of the underlying 3D human body, in replacement of previous hand-crafted features.</em></p><p><em>Second, in order to address the occupancy ambiguity caused by topological changes of clothed humans in the canonical pose, we propose a co-supervising framework with cross-space consistency to <strong>jointly</strong> estimate the occupancy in both the posed and canonical spaces.</em></p><p>这里的joint实际上就是将posed space和canonical space的点$p_a, p_b$合起来看，同时假设他们的occupacy为$o_a, o_b$，那么组成一个四维pair $(p_a, p_b, o_a, o_b)$，然后在marching cubes找isosurface的时候找$o_a = o_b = \tau$。实际上这样就某种程度避免了手在袋子里导致的reconstruction失误，因为$o_a, o_b$分别是小于0和大于0的。</p><p><em>Last, we use image-to-image translation networks to further refine detailed geometry and texture on the reconstructed surface, which improves the fidelity and consistency across arbitrary viewpoints.</em></p><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>end-to-end: 深度学习提供了一种端到端的学习范式，整个学习的流程并不进行人为的子问题划分，而是完全交给深度学习模型直接学习从原始数据到期望输出的映射。对深度模型而言，其输入数据是未经任何人为加工的原始样本形式，后续则是堆叠在输入层上的众多操作层，这些操作层整体可以看作一个复杂的函数FCNN， 最终的损失函数由数据损失data loss和模型参数的正则化损失（regularization loss)共同组成, 模型深度的训练则是在最终损失驱动下对模型进行参数更新并将误差反向传播至网络各层。</p><p>PointNet++: 做<strong>Point Set Segmentation and Classification</strong></p><h2 id="SMPLicit"><a href="#SMPLicit" class="headerlink" title="SMPLicit"></a>SMPLicit</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>SDF: 首先，我们可以用SDF（Signed Distance Function）这样一个函数来隐式地表示一个三维物体，输入是空间中点的三维坐标，输出是这个点离我们想表示的物体表面的最近距离，如果在外部就是正，内部就是负。显然只要SDF找的好，从理论上来说，我们就能够简单粗暴地表示任意复杂且连续的物体，这也是物体的隐式表示方式与用点云、体素、网格等表示方式相比最大的好处。</p><p>这样就万事大吉了吗？并没有，因为如果用这种方法，并不是数据驱动的，而更像是一种数学的方法，我们每次进行重建的时候都得重新训练一个神经网络得到表示这个物体的专属SDF，比如给我一个轿车的若干采样点，我给训练出来了，你要是再给我一个卡车的采样点，我还得重新训练，虽说这样我们根本不需要数据集，但是缺点显而易见：我是希望在神经网络中引入对三维数据集的一些先验来辅助拟合，以便于更好地进行三维重建的，比如你就给我8个采样点，分别代表正方体的8个顶点，如果不引入数据集（如汽车数据集）的先验的话，最终拟合出来的东西肯定就是一个正方体（或者是个球体）之类的东西，而不是像个汽车的样子。</p><p>假定数据集中的某个数据被编码成latent code进行表示，这样我将这个latent code和三维坐标同时丢入神经网络查询得到sdf值，其实就能够得到某个具体的三维物体的SDF函数表示了</p><p>而有了SDF表示，我们就可以通过ray marching来render。</p><h3 id="Process-1"><a href="#Process-1" class="headerlink" title="Process"></a>Process</h3><p>SMPLicit本质上是要独立生成SMPL模型表面的衣服，而不用生成human body本身。</p><p>Clothing Cut: 这个clothing cut指的不是衣服裁剪问题，而是defined as the body area occluded by clothing。 for each garment-body pair in the training set, we compute a UV body <em>occlusion image</em> denoted as $U$. That is, we set every pixel in the SMPL body UV map to 1 if the corresponding body vertex is occluded by the garment, and 0 otherwise。然后再用一个image encoder从$U$ map到latent vector $z_{cut}$。注意，$U$是根据ground truth算出来的。</p><p>Clothing Styles: 我认为他使用DeepSDF去做$z_{style}$的拟合，本质上是因为每个衣服的特征是不同的，而DeepSDF的功能就是可以找不不同物体的SDF，那么这个$z_{style}$实际上是用来表示衣服的SDF的？</p><p>Body Shape: 由于在不同shape下衣服的表现是不同的，比如胖的人衣服就会膨胀起来，那么还要针对shape来进行编码训练。所以$P_{\beta}$本质上是表达衣服表面和body中vertex cluster的关系的参数，然后他记录的是衣服和body的距离（广义理解的话）。而$P_{\beta}$是$\mathbb{R}^3$中的一个3D点$p$ map的结果。</p><p>Output Representation: 实际上就是一个decoder network $C$，把$(P_{\beta}, z)$解码成为predicted unsigned distance $D (p)$。</p><p>Training</p><p>Loss: 可以理解为$D (p)$的prediction和ground truth的作差。</p><p>但是实际上上述操作都是在T-pose的前提下进行的，所以不能直接应用于3D reconstruction。</p><p>在3D human reconstruction的应用：</p><p>We first detect people and obtain an estimate of each person’s pose and shape [52], as well as a 2D cloth semantic segmentation [67]. We then fit SMPLicit to every detection to obtain layered 3D clothing.</p><p>接着在T-pose的SMPL模型上均匀采样，并且将这些sample point deform到当前pose下他们应当在的位置，再删除那些occluded的点。假定这些点为$p$，再将它们投影到2D平面，和原照片比对，如果点在clothes的semantic segmentation出来的块内则$s_p = 1$，反之为0。之后由损失函数处理。</p><h2 id="ARAH"><a href="#ARAH" class="headerlink" title="ARAH"></a>ARAH</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p>Differentiable Rendering: 三维的物体渲染成二维图像的时候，其实本质上是进行了一系列矩阵变换，插值等操作，这和神经网络有一定的相似之处，渲染相当于前向传播，得到渲染图，而渲染图和输入图像相比较可以定义loss，从而进行反向传播，去优化三维物体的形状与纹理，从而实现基于单张图像的三维重建，并且不再受3D数据集依赖。</p><h3 id="Process-2"><a href="#Process-2" class="headerlink" title="Process"></a>Process</h3><p>他的关键在于root-finding algorithm的改进。</p><p>整个流程</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DigitalHuman </tag>
            
            <tag> Avatar </tag>
            
            <tag> 3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Social Information Network Analysis and Engineering</title>
      <link href="/2023/07/14/Social%20Information%20Network%20Analysis%20and%20Engineering/"/>
      <url>/2023/07/14/Social%20Information%20Network%20Analysis%20and%20Engineering/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>有趣的内容</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>Key takeaways:</em></p><ul><li><em>Network</em> defines the <strong>interactions</strong> between the components</li><li>How do we reason about networks?<ul><li>Empirical: Study network data to find organizational principles</li><li>Mathematical models: Probabilistic, graph theory</li><li>Algorithms for analyzing graphs</li></ul></li><li>我们study network是为了achieve什么？<ul><li>Paterns and statistical properites of network data</li><li>Design principles and models</li><li>Understand why networks are organized the way they are (Predict behavior of networked systems)</li></ul></li><li>我们要学习network的什么？<ul><li>Structure &amp; Evolution</li><li>Processes (Networks provide ‘skeleton’ for spreading of information) &amp; Dynamics (information是怎么传播的)</li></ul></li></ul><h2 id="Social-Media"><a href="#Social-Media" class="headerlink" title="Social Media"></a>Social Media</h2><h3 id="Graph-amp-Sociology"><a href="#Graph-amp-Sociology" class="headerlink" title="Graph &amp; Sociology"></a>Graph &amp; Sociology</h3><p>这部分定义的def包括strong / weak ties, bridge等，都在下面出现过，故此处略。</p><p>那么，通过观察图像以及bridge的def我们可以发现，communities之间都有weak ties (bridges)，那么可以说明实际上，bridge是一种将communities联系起来，构成一个society的key item</p><p>而且也跟bridge处在communities中间这个位置有关，下文也有简述，就是bridge must necessarily carry any new information，直观的体现就是下文的job finding</p><h3 id="Theorems"><a href="#Theorems" class="headerlink" title="Theorems"></a>Theorems</h3><ul><li><p>“The Small World Problem”: 若在US随机sample两个人，他们认识的概率有多大？</p></li><li><p>Neocortex (新皮层): 这个brain的一个组织，根据调查，neocortex的大小和当前primate(灵长类动物)的group大小有紧密关系</p><p>  根据这个可以得出一些推论:</p><ul><li>Each individual只能maintain一定数量的relationship，因为bounded by neocortex size</li></ul></li></ul><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p><em>Key Takeaways:</em></p><ul><li><p>Bridge Edge: 割边; Articulation Point: 割点</p></li><li><p>Largest Component我们也管它叫<strong>Giant Component</strong>。管那些游离，无degree的点叫做Isolated node</p></li><li><p>Weakly connected directed graph: 和强连通图不同，他不是strongly connected，但是假如把所有的direction去掉变成undirected graph，他应该要是连通的</p></li><li><p>DAG全称Directed Acyclic Graph</p></li><li><p>Adjacency Matrix 邻接矩阵。注意，邻接矩阵里面存的是weight，而不是是否连通 (0 / 1)。只能说在unweighted graph里面 $A$ 的元素值都是 0 / 1</p></li><li><p>Node degree:</p><ul><li>Average degree: $\bar{k} = \left&lt;k\right&gt; = \frac1{N}\sum\limits_{i = 1}^N k_i = \frac{2E}{N}$</li><li>$\overline{k^{in}} = \overline{k^{out}}$</li></ul></li><li><p>Bipartite Graph: 二分图</p></li><li><p>Degree Distribution $P(k)$: Probability that a randomly chosen node has degree $k$</p><p>  $P(k) = \frac{N_k}{N}$，其中 $N_k$ 是度数为 $k$ 的node的个数</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230330175415780.png" alt="image-20230330175415780" style="zoom:30%;" /></li><li><p>如果两个node没有连接，那么他们之间的距离通常被认为是infinite</p></li><li><p>Diameter: 图的直径</p></li><li><p>Average Path Length: $\bar h = \frac1{2E_{max}} \sum\limits_{i, j \neq i} h_{ij}$ where $h_{ij}$ is the distance(shortest-path, geodesic) from node $i$ to node $j$</p><p>  这里 $E_{max}$ 指的是maximum number of edges in an undirected complete graph，即 $E_{max} = \frac{N(N - 1)}{2}$</p><p>  $\bar h$ 下面要除以2是因为我们会把pair $(i, j)$ and $(j, i)$都算一遍</p></li><li><p>$h_u (v)$ 指的是以 $u$ 为源点，到 $v$ 的距离</p></li><li><p><strong>Clustering Coefficient</strong> 是用来衡量群聚程度的measure，值越高越群聚</p><p>  Computation:<br>  $$<br>  C_i = \frac{2e_i}{k_i (k_i - 1)}<br>  $$<br>  其中，$e_i$ is the number of edges between the neighbors of node $i$</p><p>  <em>Average CC:</em> $C = \frac1N \sum\limits_i^N C_i$</p></li><li><p>Web as a grph (此处应该是指的网页操作逻辑，以及通过链接的互相访问)</p><ul><li><p>Nodes = Web pages</p></li><li><p>Edges = Hyperlinks</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230330203253661.png" alt="image-20230330203253661" style="zoom:30%;" /><p>上面是web的真实结构，其中T、endrils指那些能从IN和OUT到达，但是不能反过来的web pages；Tubes指能从IN到达，最终能到达OUT的web pages</p></li></ul></li></ul><h2 id="Small-World"><a href="#Small-World" class="headerlink" title="Small World"></a>Small World</h2><h3 id="Random-Graph-Model"><a href="#Random-Graph-Model" class="headerlink" title="Random Graph Model"></a>Random Graph Model</h3><p><em>Erdös-Renyi Random Graphs:</em> $G_{n, p}$ is a undirected graph with $n$ nodes, and all edges apprear i.i.d. with probability $p$</p><p>根据上面的def，我们也可以得到 $G_{n, p}$ generates exactly $E$ edges的概率<br>$$<br>P(E) = { E_{max} \choose E } p^E (1 - p)^{E_{max} - E}<br>$$<br>那么说完了edge数，关于每个点的期望degree又如何？</p><p>Let $X_v$ be a random variable measuring the degree of node $v$, and $X_{v, u}$ be a $\{0, 1\}$-random variable which tells if edge $(v, u)$ exists or not。显然，$X_v = X_{v, 1} + X_{v, 2} + \cdots X_{v, n - 1}$<br>$$<br>E[X_v] = \sum\limits_{j = 0}^{n - 1} jP (X_v = j) = \sum_u E[X_{v, u}] = (n - 1)p<br>$$<br>因为 $v$ 向每个 $u$ 有edge的概率是 $p$</p><p>现在来考虑graph整体的degree distribution。让 $P (k)$ be the fraction of nodes with degree $k$<br>$$<br>P(k) = { n - 1 \choose k } p^k (1 - p)^{n - 1 - k}<br>$$<br>我们可以发现，degree distribution实际上是bionomial的，并且上面计算 $P(k)$ 的逻辑也是和计算单独node的expected degree是一样的。</p><p>因为他的分布是bionomial的，所以也很容易可以得到degree distribution的mean和variance<br>$$<br>\bar k = (n - 1)p \<br>s^2 = (n - 1)p(1 - p)<br>$$<br>而且对于random graph，要计算他的clustering coefficient<br>$$<br>E[e_i] = p \frac{k_i(k_i - 1)}{2}<br>$$<br>这个是因为对于点 $i$，他一共有 $\frac{k_i(k_i - 1)}{2}$ 个neighbor点对，每个点对有 $p$ 的概率连接，那么其CC值则为<br>$$<br>C = \frac{pk_i (k_i - 1)}{k_i(k_i - 1)} = p<br>$$<br>可以看得出在random graph中，node的CC都是很小的，说明群聚程度不高</p><p>而且根据 $\bar k$，即mean degree distribution，我们还可以大致确定这个random graph的components大小</p><ul><li>$(n - 1)p &lt; 1 \Rightarrow \text{components are small}$</li><li>$(n - 1)p &gt; 1 \Rightarrow \text{a giant component emerges}$</li></ul><p>上面这个叫做 <strong>phase transition</strong></p><hr><h3 id="Small-World-Evolution-Watts-amp-Strogatz"><a href="#Small-World-Evolution-Watts-amp-Strogatz" class="headerlink" title="Small World Evolution (Watts &amp; Strogatz)"></a>Small World Evolution (Watts &amp; Strogatz)</h3><p>事实上，real world social networks are</p><ul><li>High clustering</li><li>Small dismeter <strong>(“Small World”)</strong></li></ul><p>那么，我们要怎样才能构造出这样的graph呢？</p><p>先start from a <strong>low-dimentional regular lattice</strong></p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230402174424263.png" alt="image-20230402174424263" style="zoom:20%;" /><p>这张图中，each node is connected to its $\alpha$ nearest neightbors，从结果上来看，它是</p><ul><li>High clustering</li><li>High diameter $O (n)$，以及average distance也是 $O (n)$</li></ul><p>但是如果我们有一张随机图，</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230402174542426.png" alt="image-20230402174542426" style="zoom:30%;" /><p>它是</p><ul><li>Small clustering</li><li>Small diameter $O (\log n)$。注意，random graph的diameter和average distance都是log级别的</li></ul><p>那么我们要怎么样将我们的regular lattice向这个random graph转换？我们需要rewire</p><ul><li>每次对一个node，遍历他开始的每条edge，我们有 $p$ 的概率将其rewire到一个uniformly chosen node at random over the entire ring</li></ul><p>在对每个node都做完后，这个rewire就完成了，那么显然，里面有 $p$ fraction of nodes被rewire了</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230402175050720.png" alt="image-20230402175050720" style="zoom:30%;" /><p>如上图，就visualize了这个过程</p><p>若我们将过程中的CC和diameter图表化，可以得到</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230402175220650.png" alt="image-20230402175220650" style="zoom:30%;" /><p>从上图我们可以发现，clustering coefficient在 $p$ 小的那段区间里变化很小，但是对于mean distance来说变化就十分巨大，所以说</p><blockquote><p>It takes a lot of randomness to ruin the clustering, but a very small amount (of long-range edges) to create shortcuts.</p></blockquote><p>那么从上图我们就可以发现，比如在 $p \in [0.01, 0.1]$ 的区间中任选一个 $p$，就可以得到high clustering coefficient but small diameter的图了</p><p>上述过程是由Watts-Strogatz提出的</p><p>但是值得注意的是，这个model <strong>does not lead to the correct degree distribution</strong>，因为<strong>most nodes have similar degrees due to the underlying lattice</strong></p><h2 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h2><p>Friendship可以被分为两种情况来进行讨论</p><ul><li>Structual，这部分讨论的实际上就是人际网，即graph structure</li><li>Interpersonal，这部分讨论的是人与人之间的羁绊，人和人有亲疏之分，所以分为weak or strong ties。weak指疏，strong则指亲</li></ul><p>我们一般称graph里的connection为structural的，而interpersonal，或是说是现实意义的关系connection为social connection。所以一般weak和strong都描述的是social connection。</p><p>Granovetter也给structural和social的connection建立了联系，这个联系包含两部分：</p><ul><li><p><strong><em>Embeddedness</em> of an edge:</strong> number of common neighbors the two endpoints have</p><p>  Edges spanning different parts of the network are socially weak。这句话的structural理解是，比如这个edge可以是两个连通块中间的bridge，那么就会给人一种摇摇欲坠之感，因为感性理解一下，一般连通块内的connection是比较strong的。那么socially speaking，这个bridge相当于表示两撮人中间正好有两个人认识，但是一般来讲他们不会那么熟悉，所以可以generally认为是weak的。</p></li><li><p>The long range edges allow you to gather information from different parts of the network and get a job. Structurally embedded edges are heavily redundant in terms of information access</p><p>  这两句话主要是在阐述，在获得新information方面，比如job information，weak ties会比strong ties更有用。虽然你的close friends更乐意于为你提供信息，但是因为the environment you exposed十分类似，所以经常并不能为你提供什么有效信息；反之，acquaintance，即你的weak ties，因为和你的环境差很多，倒是经常能为你提供你们圈子所不知道的信息，所以在information access方面是更有效的。</p></li></ul><hr><h3 id="Triadic-Closure"><a href="#Triadic-Closure" class="headerlink" title="Triadic Closure"></a>Triadic Closure</h3><p>从一个简单的模型开始看起，Triadic Closure</p><blockquote><p><em>Theorem:</em> If two people in a network have a friend in common, there is an increase likelihood they will become firends themselves</p><p><em>Example:</em> B - A - C. Then B is more likely to meet C</p></blockquote><h4 id="Explanation-from-social-perspective"><a href="#Explanation-from-social-perspective" class="headerlink" title="Explanation from social perspective"></a>Explanation from social perspective</h4><ul><li>B and C trust each other since they have a friend A in common</li><li>A has an incentive to bring B and C together</li></ul><h4 id="Explanation-from-structural-perspective-Granovetter’s-Explanation"><a href="#Explanation-from-structural-perspective-Granovetter’s-Explanation" class="headerlink" title="Explanation from structural perspective (Granovetter’s Explanation)"></a>Explanation from structural perspective (Granovetter’s Explanation)</h4><ul><li><p>这种情况下，clustering coefficient一般都比较大</p></li><li><p>首先给出几个定义:</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329154602085.png" alt="image-20230329154602085" style="zoom:30%;" /><p>  Bridge edge就是割边，local bridge就是不是bridge，但是endpoints没有公共friend的边，所以他们的span会大于2。</p><p>  Strong triadic closure就是B - A - C的案例中，如果B - A和A - C都是strong tie，那么B、C之前应该也要有一条边，即他们应该会认识。</p><p>  那么对于最后一条Fact，也可以prove by contradiction，首先a在一个strong triadic closure里面，也就是说他至少有两个strong ties，假如上图a - b是strong tie，那么很明显，根据triadic closure，a的某个friend和b之间应该是要认识的，至少有一条edge；然而根据local bridge的定义，a &amp; b have no friends in common，所以命题为假。</p></li></ul><hr><h3 id="Neighborhood-Overlap"><a href="#Neighborhood-Overlap" class="headerlink" title="Neighborhood Overlap"></a>Neighborhood Overlap</h3><p>$$<br>O_{i, j} = \frac{N (i) \cap N (j)}{N (i) \cup N (j)}<br>$$</p><p>where $O_{i, j}$ 是用来measure overlap的值，$N (i)$ 表示node $i$ 的neighbor集合，所以这个公式实际上就是$i, j$公共neighbor和所有neighbor的个数比</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329163214958.png" alt="image-20230329163214958" style="zoom:20%;" /><p>从上图我们可以看出，当 $O_{i, j} = 0$，则说明 $(i, j)$ 是local bridge</p><hr><h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><p>当我们通过cell-phone network画图比对，可以发现一个现象</p><blockquote><p><strong>Edge strenghth increases with neighborhood overlap</strong></p></blockquote><p>而在观察图的时候，我们还可以发现一个现象</p><blockquote><p><strong>Weak ties serve to link different tightly-knit communities that each contain a large number of stronger ties</strong></p></blockquote><p>那么要怎么验证这个结论呢？一种方法是比较用strength或者overlap值给node排序，然后按照low-to-high和high-to-low的顺序移除node，看看graph中最大连通块的size会怎么变化 (即看连通性怎么变化)。</p><p>结论是我们会发现这size确实在low-to-high的顺序中下降的更快，说明我们破坏weak ties更容易破坏graph的整体结构与连通性，特别是当用overlap值排序的情况下。所以可以发现weak ties在maintain graph structure这块起了很大的作用。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329164103932.png" alt="image-20230329164103932" style="zoom:20%;" /><p>那么我们现在可以得到一个conceptual picture of networks:</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329164214685.png" alt="image-20230329164214685" style="zoom:20%;" /><blockquote><p><strong>Weak ties are crucial for maintaining the network’s structural integrity, but strong ties are for maintaining local communities</strong></p></blockquote><hr><h3 id="Passive-Engagement"><a href="#Passive-Engagement" class="headerlink" title="Passive Engagement"></a>Passive Engagement</h3><p>但是你会发现，我们虽然称那些close friends为strong ties，但真正有持续交流的又有多少？事实证明，没有多少，因为对于一个strong tie，你就要invest很多time &amp; efforts to maintain the relationship。所以调查发现，一直维持联系的，特别是mutual的联系的friend特别少，虽然他们名义上是strong tie。</p><p>所以就有了这个词语: <strong>Passive Engagement</strong></p><blockquote><p><strong><em>Passive engageme:</em> keep up with friends by reading about them even in the absence of communication</strong></p></blockquote><hr><h3 id="How-to-find-communities"><a href="#How-to-find-communities" class="headerlink" title="How to find communities?"></a>How to find communities?</h3><p>上面关于communities的一些基础概念都聊完了，那么现在聊一些更practical的东西，就是我们要怎么找到这些communities呢？</p><p>首先给出一个关于Edge Betweenness的定义，它表示number of shortest paths passing over the edge。</p><p>而且注意，edge betweenness的定义还有一条: <strong>If there is more than one shortest path between a pair of nodes, each path is assigned equal weight such that the total weight of all of the paths is equal to unity.</strong></p><h4 id="Compute-Edge-Betweenness"><a href="#Compute-Edge-Betweenness" class="headerlink" title="Compute Edge Betweenness"></a>Compute Edge Betweenness</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Downloads/IMG_F6BEAC74C034-1.jpeg" alt="IMG_F6BEAC74C034-1" style="zoom:30%;" /><p>此处只展示从某个源点 $s$ 开始的计算，要得到最终答案再把其他点全部过一遍就好了。该过程分为两部分，上图展示了整个计算流程</p><p>Part I，计算 $s$ 到每个点的最短路径数，用 $w_i$ 指的是从 $s$ 到点 $i$ 的最短路径数</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230330121616148.png" alt="image-20230330121616148" style="zoom:30%;" /><p>就是个普通BFS的过程。</p><p>Part II，计算每个edge的betweenness，这部分需要着重注意，这是个从下往上倒推的过程</p><ul><li><p>Find every ‘‘leaf’’ vertex $t$, i.e., a vertex such that no paths from $s$ to other vertices go though $t$. 比如在上图中，leaf就是最底下的 $F, G$</p></li><li><p>For each vertex $i$ neighboring $t$, assign a score to the edge from $t$ to $i$ of $\frac{w_i}{w_t}$</p><p>  比如在上图中，就是 $(D, F) = \frac23, (E, F) = \frac13, (E, G) = \frac11 = 1$</p></li><li><p>Now, starting with the edges that are farthest from the source vertex $s$ — lower down in a diagram such as Fig. 4(b)—work up towards $s$. To the edge from vertex $i$ to vertex $j$, with $j$ being farther from $s$ than $i$, assign a score that is $1$ plus the sum of the scores on the neighboring edges immediately below it (i.e., those with which it shares a common vertex), all multiplied by $\frac{w_i}{w_j}$</p><p>  我的理解实际上就是你每次找离 $s$ 最远的边进行更新，比如像上图还未更新的最远的边就是 $BD, CD, CE$。假设一条边是 $(i, j)$，并且 $j$ 到 $s$ 的距离比 $i$ 更远，即 $j$ 更“深”，那么最终 $(i, j)$ 的edge betweenness就是1 + 素描of $j$下面的边的edge betweenness，最终再乘上一个 $\frac{w_i}{w_j}$</p></li><li><p>Repeat from step (iii) until vertex $s$ is reached.</p></li></ul><h4 id="Girvan-Newman"><a href="#Girvan-Newman" class="headerlink" title="Girvan-Newman"></a>Girvan-Newman</h4><p>那么现在就有一个GN算法可以解决finding communities的问题了，他的流程很简单:</p><ul><li>首先我们的network是undirected &amp; unweighted的</li><li>Calculate betweenness of edges</li><li>Remove the edge with the highest betweenness (如果有两条最大betweenness的边，全部remove)</li><li>重复上述操作知道no edges left</li></ul><p>在每一步拆解的过程中，那些connected components就是communities</p><p>这本质上是在做network的hierarchical decomposition</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230330155604507.png" alt="image-20230330155604507" style="zoom:25%;" /><h4 id="Modularity"><a href="#Modularity" class="headerlink" title="Modularity"></a>Modularity</h4><p>但是我们会发现，我们根本不知道要把communities拆成多少个，所以必须要有一个度量的方法，那么现在就有一个measure指标，叫做<strong><em>Modularity</em></strong> $Q$</p><blockquote><p><strong>Modularity</strong> $Q$: A measure of how well a network is partitioned into communities</p></blockquote><p>一个community如果划分的好那么他们的内部similarity是比较高的，而外部则要比较低</p><p>同时我们还需要一个参照物来判断我们当前的划分到底如何，那么就可以使用random graph，用这个random的期望来作参照，我们他叫做<strong><em>Null Model</em></strong></p><blockquote><p><strong>Null Model: Same degree distribution but random conections</strong></p></blockquote><p>假设 $m$ 是network的总edge数，the expected number of edge between nodes $i$ and $j$ of degree $k_i$ and $k_j$ equals to $\frac{k_ik_j}{2m}$</p><p>同时假设我们的original graph是 $G$，拥有邻接矩阵 $A$，分割完后当前community集合是 $S$，要计算Modularity，Mathematically<br>$$<br>\begin{aligned}<br>Q (G, S) &amp;= \frac{1}{2m} \sum_{i, j} \left(A_{ij} - \frac{k_ik_j}{2m}\right)[\text{$i$, $j$ belong to the same community}] \<br>&amp;= \frac1{2m} \sum_{s \in S}\sum_{i \in s}\sum_{j \in s} \left(A_{ij} - \frac{k_ik_j}{2m}\right)<br>\end{aligned}<br>$$<br>如果 $Q = 0$，就说明我们当前的划分和random graph没区别，说明分的比较差，$Q$ 值要越高越好</p><p>And it is positive if the number of edges within groups exceeds the expected number</p><p>最后给出一张division &amp; modularity的同步图</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230330161640239.png" alt="image-20230330161640239" style="zoom:30%;" /><h2 id="Centrality"><a href="#Centrality" class="headerlink" title="Centrality"></a>Centrality</h2><p>Centrality指的是一种measure中心的办法，方法有很多，比如计算Betweenness Centrality</p><h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>实际上就是每个点的degree除以$N - 1$</p><p>Normalization的意义:</p><ul><li>可以让我们compare graphs with different sizes</li></ul><hr><h3 id="Betweenness-Centrality"><a href="#Betweenness-Centrality" class="headerlink" title="Betweenness Centrality"></a>Betweenness Centrality</h3><p>计算方法是计算每个点被几条shortest path经过。Concretely,</p><ul><li>Find all pairs of nodes</li><li>Determine shortest paths</li><li>Count shortest paths through a node</li></ul><p>Mathematically<br>$$<br>C_B (i) = \sum_{j \neq k} g_{j, k} (i)<br>$$<br>where $g_{j, k} (i)$ refers to the number of shortest paths connecting $j$ and $k$ passing through $i$<br>$$<br>C_B (i) \in [0, \frac{(n - 1)(n - 2)}{2}]<br>$$<br>根据Betweenness centrality计算得到结果较大的node的意义是，they are individuals controlling the flow around a network。并且也是individuals whose removal from the network will disrupt interactions the most。</p><p>我们可以也将其normalized:<br>$$<br>C’_B (i) = \frac{C_B (i)}{\frac{(n - 1)(n - 2)}{2}}<br>$$</p><h3 id="Closeness-Centrality"><a href="#Closeness-Centrality" class="headerlink" title="Closeness Centrality"></a>Closeness Centrality</h3><p>这个centrality关注的不是一个点多么“中间”，没有那么多interactive friends，而是central if it can quickly interact with all others, which measures the ‘average’ distance to the other nodes in the netwrok.</p><p>Closeness centrality = ‘average’ distance = 1 / farness = 1 / sum geodesic distance = 1 / sum length shortest path    </p><p>Mathematically<br>$$<br>C_c (i) = \frac{1}{\sum\limits_{j = 1}^N d (i, j)}<br>$$<br>where $d (i, j)$ refers to the shortest path distance between $i$ and $j$</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329110540099.png" alt="image-20230329110540099" style="zoom:20%;" /><p>Range of closeness centrality:<br>$$<br>C_c (i) \in [0, \frac1{N - 1}]<br>$$<br>Normalization:<br>$$<br>C’<em>c (i) = \left[\frac{\sum\limits</em>{j = 1}^N d (i, j)}{N - 1}\right]^{- 1}<br>$$<br>如果normalization后某个$i$的$C’_c (i) = 1$，则说明他connect to all other nodes</p><hr><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329111921706.png" alt="image-20230329111921706" style="zoom:30%;" /><hr><h3 id="Eigenvector-Centrality"><a href="#Eigenvector-Centrality" class="headerlink" title="Eigenvector Centrality"></a>Eigenvector Centrality</h3><p>Eigenvector centrality的衡量标准是，你和important的人的connection越多，你自己越important。</p><hr><h3 id="Freeman’s-Network-Centrality-Overall-Centrality-of-the-Graph"><a href="#Freeman’s-Network-Centrality-Overall-Centrality-of-the-Graph" class="headerlink" title="Freeman’s Network Centrality (Overall Centrality of the Graph)"></a>Freeman’s Network Centrality (Overall Centrality of the Graph)</h3><p>Formula<br>$$<br>C = \frac{\sum\limits_{i = 1}^g [C (n^<em>) - C (i)]}{\max \sum\limits_{i = 1}^g [C (n^</em>) - C (i)]}<br>$$<br>这里的 $C$ 可以是任何centrality的measurement，比如可以是$C_D$ (degree centrality)，$C_B$之类的。</p><p>$C (n^*)$ refers to largest value of $C (n)$ for any node in the network.</p><p>$g$ 是graph的node个数，分母是any graph with $g$ nodes可以整出的最大$C (n^*) - C (i)$的sigma值，比如对于degree centrality分母值为$(N - 1)(N - 2)$，即菊花图<br>$$<br>C \in [0, 1]<br>$$</p><blockquote><p>$C = 0$ when al nodes have exactly the same centrality index<br>$C = 1$ if one node completely dominates the other nodes</p></blockquote><hr><h3 id="Prestige-of-a-node"><a href="#Prestige-of-a-node" class="headerlink" title="Prestige of a node"></a>Prestige of a node</h3><p>相较于Centrality focuses on both入度和出度，Prestige只focus入度，即当前节点作为recipient的情况，generally，一个点的入度越多，它越prestigious</p><h3 id="Degree-Prestige"><a href="#Degree-Prestige" class="headerlink" title="Degree Prestige"></a>Degree Prestige</h3><p>Formula<br>$$<br>P_D (i) = \frac{d_I (i)}{n - 1}<br>$$<br>这里 $d_I (i)$ 指的是 $i$ 的入度</p><h3 id="Closeness-Pretige"><a href="#Closeness-Pretige" class="headerlink" title="Closeness Pretige"></a>Closeness Pretige</h3><p>$$<br>P_C (i) = \frac{|I_i|}{\sum_{j \in I_i} d (i, j)}<br>$$</p><p>此处 $I_i$ refers to nodes that can reach $i$，$d (i, j)$ refers to the length of shortest path between $i$ and $j$</p><p>For example,</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329115054241.png" alt="image-20230329115054241" style="zoom:30%;" /><h3 id="Betweenness-Prestige"><a href="#Betweenness-Prestige" class="headerlink" title="Betweenness Prestige"></a>Betweenness Prestige</h3><p>$$<br>C_B (i) = \sum\limits_{j \neq k}\frac{g_{j, k} (i)}{g_{j, k}}<br>$$</p><p>这里和betweenness centrality不同的是，$g_{j, k}$ 指的是所有paths between $j$ and $k$，而不是仅包括shortest path了。</p><p>同时要注意的是，若要对其做normalization，要除以的是$(n - 1)(n - 2)$而不是$\frac{(n - 1)(n - 2)}{2}$</p><hr><h3 id="Directed-Geodesics"><a href="#Directed-Geodesics" class="headerlink" title="Directed Geodesics"></a>Directed Geodesics</h3><p>Geodesics实际上指的就是shortest path。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230329121402212.png" alt="image-20230329121402212" style="zoom:30%;" /><h2 id="PowerLaw"><a href="#PowerLaw" class="headerlink" title="PowerLaw"></a>PowerLaw</h2><p>Surprisingly, real world networks的degree distribution实际上是power law的而不是类似于bell-shaped那种近似normal distribution的，即power law distribution。这个distribution在log-log plot里面是一条直线。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230430152627227.png" alt="image-20230430152627227" style="zoom:50%;" /><p>这其中大部分的点都是small degree的，但是也存在degree非常大的点。</p><p>那么他和exponential distribution又有什么差别呢？实际上从图表中来看可以发现，对于power-law，$\log (p_k) \sim -\alpha k$，即他在log-log plot中log (x)和log (y)成正比；而对于exponential，则变成了$p_k \sim e^{-ak}$。其中，$p_k = \frac{|\{u | d_u = k\}|}{N}$。要究其区别，就是exponential是$e^{-x}$，而power-law是$x^{-\alpha}$</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230430152906806.png" alt="image-20230430152906806" style="zoom:30%;" /><p>从结论上来讲，power-law distribution的PMF是<br>$$<br>p (k) = Pr (deg (v) = k) = Z \cdot k^{- \alpha}<br>$$<br>我们称这个 $Z$ 为normalizing constant，而这个 $\alpha$ 一般来说是满足 $2 &lt; \alpha &lt; 3$</p><p>其PDF为，<br>$$<br>Pr (X \le k) = \int_{x_{min}}^{\infin} p(x) \text{d}x = 1 \Rightarrow Z = (\alpha - 1)x_{min}^{\alpha - 1}<br>$$<br>Therefore,<br>$$<br>p(x) = \frac{\alpha - 1}{x_{m}} \left(\frac{x}{x_{m}}\right)^{- \alpha}<br>$$<br>其中 $x_m$ 就是 $x_{min}$。同理也可以得到，<br>$$<br>E[x] = \frac{\alpha - 1}{\alpha - 2}x_{m}<br>$$<br>从结果可以发现，对于 $\alpha \le 2$，$E[x] = \infin$；对于$\alpha \le 3$，$Var[x] = \infin$，那么显然对于real network，$E[x] = \text{constant}$ &amp; $Var[x] = \infin$</p><p>我们管这种满足power-law的network叫做<strong>Scale-free (power-law) network</strong></p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230430171909351.png" alt="image-20230430171909351" style="zoom: 20%;" /><hr><p>那么怎么去estimate $\alpha$呢？</p><ul><li>Plot a CCDF (Complementary CDF) $P (X \ge x)$</li><li>Compute $\alpha’$ —— the slope of $P (X &gt; x)$，注意，这个 $\alpha’$ 是正数，即signed slope的绝对值</li><li>Estimate $\alpha = 1 + \alpha’$</li></ul><p>为什么能这么计算呢，因为实际上 $P (X \ge x) \varpropto x^{- (\alpha - 1)}$</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230430171602992.png" alt="image-20230430171602992" style="zoom:20%;" /><hr><p>我们称一个distribution是heavily tailed if:<br>$$<br>\lim\limits_{x \rightarrow \infin} \frac{P (X &gt; x)}{e^{- \lambda x}} = \infin<br>$$<br><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230430165820617.png" alt="image-20230430165820617" style="zoom:20%;" /></p><hr><h3 id="Model-Preferential-Attachment"><a href="#Model-Preferential-Attachment" class="headerlink" title="Model: Preferential Attachment"></a>Model: Preferential Attachment</h3><p>现在的问题是，我们能不能找到一个model, which can generate a power-law distribution network</p><p>那么preferential attachment model就是其中一个能满足这个性质的model，他的构造过程是这样的:</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501150322489.png" alt="image-20230501150322489" style="zoom:30%;" /><p>其中 $\sum_j k_j$ 指的是所有node的degree总和</p><p>这个model是在陈述一个fact，<strong>New nodes are more likely to link to nodes that already have high degrees</strong>，即rich get richer</p><hr><h3 id="Model-Copying-Model"><a href="#Model-Copying-Model" class="headerlink" title="Model: Copying Model"></a>Model: Copying Model</h3><p>另一种model叫做copying model，他的流程如下:</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501181925484.png" alt="image-20230501181925484" style="zoom:20%;" /><p>后面的copy the i-th link of the prototype node应当指的是edge的另一端和i-th link一样（不确定，保有疑问）</p><p>该模型可以generate出来的network满足<br>$$<br>P (d_i = k) \varpropto k^{- (1 + \frac1{1 - p})}<br>$$<br>从此可以得到 $\alpha = 1 + \frac1{1 - p}$</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501200313886.png" alt="image-20230501200313886" style="zoom:20%;" /><h2 id="Cascading"><a href="#Cascading" class="headerlink" title="Cascading"></a>Cascading</h2><p>When people are connected in networks to each other then they can influence each other’s behavior and decisions. This is called Cascading Behavior in Networks.</p><p>这种diffusion的现象可以构造出几个model</p><ul><li><p>Probabilistic models:</p><p>  Models of influence or disease spreading —— An infected node tries to “push” the contagion to an uninfected node</p></li><li><p>Decision based models:</p><p>  A node observes decisions of its neighbors and makes its own decision</p></li></ul><p>为什么我们要discuss diffusion现象？拿现实生活中的事件为例，我们就是在探讨tendency when people engage in activities such as: forwarding message, joining groups…</p><p>接下来重点讲解decision based models</p><hr><p>首先，要make decision是，我们需要两个最基本的前提ingredients</p><ul><li>一个是<strong>Payoffs</strong>, i.e., utility of making a particular choice，即做出这个选择得到的效用</li><li>另一个是<strong>Signals</strong>，他包括两块<ul><li><em>Public information:</em> What your network neighbors have done</li><li><em>Private information:</em> Something you know or Your belief</li></ul></li></ul><hr><h4 id="Game-Theoretic-Model-of-Cascades"><a href="#Game-Theoretic-Model-of-Cascades" class="headerlink" title="Game Theoretic Model of Cascades"></a>Game Theoretic Model of Cascades</h4><p>这是一个最简单的情况，每个node只有两个behavior的选择，A &amp; B</p><p>You gain more payoff if your friend has adopted the <strong>same</strong> behavior as you. Concretely,</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230502154458940.png" alt="image-20230502154458940" style="zoom:20%;" /><p>那么对于一个node $v$ 的payoff我们可以这样计算:</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230502154556368.png" alt="image-20230502154556368" style="zoom:20%;" /><p>假设 $v$ 有 $d$ 个neighbor，然后其中 $p$ fraction选择了behavior A，剩下B，那么<br>$$<br>\text{Payoff}_v =<br>\left\{<br>\begin{aligned}<br>&amp; apd <del>~ \text{if $v$ choose A} \<br>&amp; b(1 - p)d ~</del> \text{if $v$ choose B}<br>\end{aligned}<br>\right.<br>$$<br>所以 $v$ choose A if $apd &gt; b(1 - p)d \Rightarrow p &gt; \frac{b}{a + b}$</p><h2 id="Contagion"><a href="#Contagion" class="headerlink" title="Contagion"></a>Contagion</h2><p>这边探讨的是probability model</p><p>我们拿virus传播为例，假设每个病毒点传播virus的概率是 $\beta$，自己heal的概率是 $\delta$</p><h3 id="SIR-Model"><a href="#SIR-Model" class="headerlink" title="SIR Model"></a>SIR Model</h3><p>在该模型中，每个点有三个阶段:</p><ul><li><p>Susceptible: 如果一个点的neighbor染上了virus，那么他是一个潜在感染点</p><p>  $S$ 指number of susceptible individuals</p></li><li><p>Infected: 指被感染的点</p><p>  $I$ 指number of infected individuals</p></li><li><p>Recoverd: 指被感染，但heal了的点</p><p>  $R$ 指number of recovered individuals</p></li></ul><p>Total population $N = S + I + R$</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230526211438947.png" alt="image-20230526211438947" style="zoom:33%;" /><p>这是固定当前是某个时间点，那么number of individuals who become infected per unit of time = $\beta SI = pcSI$</p><p>Therefore,<br>$$<br>\frac{\mathcal{d} S}{\mathcal{d} t} = - \beta SI, \frac{\mathcal{d}I}{\mathcal{d}t} = \beta SI - \delta I, \frac{\mathcal{d} R}{\mathcal{d} t} = \delta I<br>$$<br><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230526214807716.png" alt="image-20230526214807716" style="zoom:33%;" /></p><p>其中 $I (t)$ 也可以是单调递减的，上面的凸峰状是另一种情况</p><h3 id="SIS-Model"><a href="#SIS-Model" class="headerlink" title="SIS Model"></a>SIS Model</h3><blockquote><p><strong>Susceptible-Infective-Susceptible</strong></p></blockquote><p>即一个infected node在heal了后即刻转化为susceptible node</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230526220310858.png" alt="image-20230526220310858" style="zoom: 25%;" /><hr><h3 id="Epidemic-Threshold"><a href="#Epidemic-Threshold" class="headerlink" title="Epidemic Threshold"></a>Epidemic Threshold</h3><p>Epidemic Threshold $\tau = \frac{1}{\lambda_{1, A}}$，其中，$\lambda_{1, A}$ 是adjacent matrix $A$的最大eigenvalue。$A$ 是graph的邻接矩阵</p><p>有一个性质，$d_{ave} \le \lambda_{1, A} \le d_{max}$。这里 $d_{ave}$ 是图 $G$ 的average degree，$d_{max}$ 是max degree</p><p>Virus Strength $s = \frac{\beta}{\delta}$</p><p>Epidemic threshold是一个衡量当前virus能否导致epidemic的标准。对于一个virus，</p><ul><li>如果 $s &lt; \tau$，那么这个virus将会die out quickly</li><li>如果 $s \ge \tau$，那么这个virus将会导致epidemic</li></ul><h2 id="Influence"><a href="#Influence" class="headerlink" title="Influence"></a>Influence</h2><h3 id="Independent-Cascade-Model"><a href="#Independent-Cascade-Model" class="headerlink" title="Independent Cascade Model"></a>Independent Cascade Model</h3><p>现在假设我们有一个directed graph $G$，edge $(v, w)$之间的边权 $p_{vw}$ 代表着 $v$ 如果被activated，他有 $p_{vw}$ 的概率向 $w$ 传递。这就是independent cascade model</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230527003112715.png" alt="image-20230527003112715" style="zoom:25%;" /><h3 id="Influence-Set"><a href="#Influence-Set" class="headerlink" title="Influence Set"></a>Influence Set</h3><p>在独立级联模型中，一个节点的影响力集合（influence set）是指激活该节点后，通过信息传播网络可以激活的所有节点的集合。</p><p>具体来说，当一个节点被激活时，它会尝试将信息传递给它的邻居节点。如果邻居节点的阈值大于等于当前传递信息的节点的随机数，则该邻居节点也会被激活，并且传递信息给它的邻居节点。这个过程会一直持续，直到没有新的节点被激活为止。</p><p>因此，如果我们知道一个节点的阈值和邻居节点的信息，我们就可以计算出激活该节点后，可以通过信息传播网络传递到的所有节点。这个集合就是该节点的影响力集合。</p><p>在实际应用中，我们可以使用影响力集合来评估节点的影响力大小，以及预测信息在社交网络中的传播规模和传播速度。</p><p>我们称一个node $u$的influence set为 $X_u$</p><p>$S$ is initial active set.    $f(S):$ The expected size of final active set</p><p>一个initial active set $S$ 的 $f(S)$ 越大，他的影响力越大</p><hr><p>现在有一个问题，我们要怎么找到一个大小为 $k$ 的initial set $S$，使得他的cascade size $f (S)$最大呢？</p><p>事实上，我们没法直接算出来，但是可以approximate</p><h4 id="Hill-Climbing"><a href="#Hill-Climbing" class="headerlink" title="Hill Climbing"></a>Hill Climbing</h4><ul><li>Start with $𝑆_0 =\{\}$</li><li>For $𝑖 = 1 … 𝑘$<ul><li>Take node $u$ that max $f (S_{i - 1} \cup \{u\})$</li><li>Let $S_i = S_{i - 1} \cup \{u\}$</li></ul></li></ul><p>最红hill climbing得到的solution $S$会满足 $f (S) \ge (1 - \frac1e) \times \text{optimal answer}$</p><p>他会满足这个条件是因为，</p><ul><li><p>$f$ 是单调的 (monotone)，即我新增一个节点不会让他变小</p></li><li><p>$f$ is submodular，即我加入一个新node获得的收益越来越少</p><p>  Mathematically，$\forall S \subseteq T$，$f (S \cup \{u\}) - f (S) \ge f (T \cup \{u\}) - f (T)$</p><p>  我们也可以管他叫做diminishing returns</p></li></ul><hr><h4 id="How-to-measure-f-S"><a href="#How-to-measure-f-S" class="headerlink" title="How to measure $f (S)$?"></a>How to measure $f (S)$?</h4><p>但是可以发现我们现在还有个最basic的问题没有解决，那就是怎么计算 $f (S)$</p><p>Repeating the diffusion process often enough (10000 times in the experiment)</p><h2 id="Signed-Network"><a href="#Signed-Network" class="headerlink" title="Signed Network"></a>Signed Network</h2><p>Signed network实际上就是用边权符号的正负来表示两个person的是友好还是敌对关系，正数越大表示越友好，负数越小表示越敌对，整个signed network里面最basic的component叫做signed triangle</p><hr><p>首先我们考虑undirected graph，那么里面的basic component就是undirected signed triangle，有几个最基本的intuition:</p><ul><li>Friend of my friend is my friend</li><li>Enemy of enemy is my friend</li><li>Enemy of friend is my enemy</li></ul><p>我们称满足这三条定律的triangle是<strong>balanced</strong>的，反之则是<strong>unbalanced</strong></p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501201032863.png" alt="image-20230501201032863" style="zoom:20%;" /><p>可以发现实际上这当中的排列组合非常少，所以我们可以表达的更直白一些并且扩展到整张graph</p><p>Graph is <strong>balanced</strong> if every connected triple of nodes has:</p><ul><li>All 3 edges labeled +, <em>or</em></li><li>Exactly 1 edge labeled +</li></ul><p>但实际上这个定律还能再次简化，最终变为</p><p>If <strong>all triangles are balanced</strong>, then either:</p><ul><li>The network contains only positive edges, or</li><li>Nodes can be split into 2 sets where negative edges only point between the sets</li></ul><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501201720664.png" alt="image-20230501201720664" style="zoom:20%;" /><hr><h3 id="Predicting-Edge-Signs"><a href="#Predicting-Edge-Signs" class="headerlink" title="Predicting Edge Signs"></a>Predicting Edge Signs</h3><p>实际上，若一个graph不是complete的，我们还可以predict未知边的positive or negative</p><p>我们要做的实际上就是fill in edges从而使得我们的graph变成balanced的，这可以从local view和global view来看</p><ul><li><strong>Local view:</strong> Fill in the missing edges to achieve balance</li><li><strong>Global view:</strong> Divide the graph into two coalitions</li></ul><p>这两种view最后得到的结果是一样的</p><p>Concretely,</p><ul><li><p><strong>Local view:</strong></p><ul><li>After filling in all missing edges, we have a signed complete graph</li><li>Apply the balance theorem</li><li>Obtains a division of the network into two sets that satisfies the second definition</li></ul></li><li><p><strong>Global view:</strong></p><ul><li>Fill in positive edges inside X and inside Y, and fill in negative edges between X an Y</li><li>Easy to see that all triangles will be balanced</li></ul></li></ul><p>对于local view来说，那么我们又如何快速判断一个graph是否balanced呢？</p><blockquote><p>Graph is <strong>balanced</strong> if and only if it contains <strong>no cycle with an odd number of negative</strong> edges</p></blockquote><p>对于global view来说，</p><ul><li><p>缩点，使得每个supernode (就是缩出来的大点)中不存在negative edges</p></li><li><p>得到缩点后的图后，使用点叉法，寻找是否存在一个supernode是点也是叉</p><p>  若存在，则说明unbalanced</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501203623189.png" alt="image-20230501203623189" style="zoom:20%;" /></li></ul><p>之后我们需要怎么才能将这些node分为X和Y两个set呢？</p><p>使用BFS跑一边分层:</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230501204320421.png" alt="image-20230501204320421" style="zoom:20%;" /><ul><li><p>If there is no edge connecting two nodes in the same layer 即若不存在上图AB这样的edge</p><ul><li>Produce the desired division into X and Y by putting alternate layers in different sets</li></ul></li><li><p>If there is an edge (negative edge) connecting two nodes in the same layer 即若存在上图AB这样的edge</p><ul><li><p>Take two paths of the same length leading to the two ends of the end</p></li><li><p>Together with the edge itself forms an odd cycle</p><p>即这种情况必定会存在odd cycle</p></li></ul></li></ul><hr><h3 id="Signed-Graph中的embeddedness"><a href="#Signed-Graph中的embeddedness" class="headerlink" title="Signed Graph中的embeddedness"></a>Signed Graph中的embeddedness</h3><ul><li>Positive ties tend to be <strong>more</strong> embedded</li><li>Positive ties tend to be more clumped together</li></ul><hr><ul><li><p>All-positive network</p><ul><li>The subgraph consisting only of the positive links</li></ul></li><li><p>All-negative network</p><ul><li>The subgraph consisting only of the negative links</li></ul></li><li><p>Randomized baseline</p><ul><li>First randomly shuffle the edge signs in the full network</li><li>and then extract the all-positive and all-negative networks</li></ul></li></ul><p>现在给出一个定义</p><blockquote><p> <strong>Clustering:</strong> fraction of A-B-C paths in which the A-C edge is also present (thus forming a “closed” triad)</p><p> 即看看有多少个closed triangle</p></blockquote><p>他们之间的clustering大小是 all-positive &gt; baseline &gt; all-negative</p><h2 id="Recommender"><a href="#Recommender" class="headerlink" title="Recommender"></a>Recommender</h2><h3 id="Formal-Model"><a href="#Formal-Model" class="headerlink" title="Formal Model"></a>Formal Model</h3><p>$C = $ set of costomers</p><p>$S$ = set of items</p><p>Utility function $u: C \times S \rightarrow R$，前面这个公式表示他是一个 $C \times S$，然后value表示 $R$ 的矩阵。其中 $R = $ set of ratings，即比如0～5星的评价</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230527164920861.png" alt="image-20230527164920861" style="zoom:15%;" /><p>但我们可以发现这个model有一个key problem，就是这个utility matrix $U$ 是sparse的，即很多人没有rate most items</p><p>基于这个matrix我们可以给出三种推荐方式：</p><ul><li>Content-based</li><li>Collaborative</li><li>Hybrid</li></ul><hr><h4 id="Content-based-Recommender"><a href="#Content-based-Recommender" class="headerlink" title="Content-based Recommender"></a>Content-based Recommender</h4><p>基于内容的推荐系统通过分析项目的特征和用户的偏好，将相似的项目归为同一类别，然后向用户推荐与其之前喜欢的项目类似的项目（即类似且在utility matrix中highly rated的项目）。这种方法需要对项目的特征进行精细的分析和处理，以便准确地描述项目的属性和特征。</p><p>为了实现分类目的，我们首先需要给每个item create an <strong><em>item profile</em></strong></p><p>Profile is a set of features</p><ul><li>movies: author, title, actor, director,…</li><li>text: set of “important” words in document</li></ul><p>那么我们要怎么样才能提取出important words呢？</p><p>Usual heuristic is TF.IDF (Term Frequency times Inverse Doc Frequency)</p><h5 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF.IDF"></a>TF.IDF</h5><p>TF-IDF的思想是：如果某个词语在一篇文档中出现频率高，并且在其他文档中出现频率低，则认为这个词语具有很好的区分能力，是该文档的关键词。</p><p>TF-IDF的计算分为两步：首先计算词语的TF值（Term Frequency），然后计算词语的IDF值（Inverse Document Frequency）。</p><p>词语的TF值表示该词语在文档中出现的频率，可以用以下公式计算：</p><p>$f_{ij} = $ 某个item $t_i$ 在document $d_j$ 中出现的次数<br>$$<br>TF_{ij} = \frac{f_{ij}}{\max_k f_{kj}}<br>$$<br>词语的IDF值表示该词语在文档集合中的区分能力，可以用以下公式计算：</p><p>$n_i = $ mention item $i$ 的doc个数</p><p>$N = $ total number of docs<br>$$<br>IDF_i = \log \frac{N}{n_i}<br>$$<br>最后计算TF.IDF score<br>$$<br>w_{ij} = TF_{ij} \times IDF_i<br>$$<br>那么此时text的profile，即那些important words就是TF.IDF score最高的那些words，同时我们还要记录他们的score</p><h5 id="User-Prediction-Heuristic"><a href="#User-Prediction-Heuristic" class="headerlink" title="User Prediction Heuristic"></a>User Prediction Heuristic</h5><p>这时我们可以根据上面的数据来进行预测，叫做predictioin heuristic</p><p>对于一个user profile $c$ &amp; item profile $s$，estimate $u (c, s) = \cos (c, s) = \frac{c \times s}{|c||s|}$</p><hr><h4 id="Collaborative-Filtering-Recommender"><a href="#Collaborative-Filtering-Recommender" class="headerlink" title="Collaborative Filtering Recommender"></a>Collaborative Filtering Recommender</h4><p>基于用户的协同过滤推荐系统通过分析用户之间的相似性，来推荐与其相似用户喜欢的项目。具体来说，该方法首先计算用户之间的相似度，然后<strong>基于相似度来为目标用户</strong>推荐与其相似用户喜欢的项目（即不是根据current user的feature来进行推荐）。该方法的主要优点是易于理解和实现，但其缺点是存在冷启动问题（对于新用户没有足够的历史数据来计算相似度）和可扩展性问题（随着用户数量增加，计算相似度的复杂度会呈指数增长）。</p><p>Collaborative Filtering的recommend过程分为两个步骤：</p><ul><li>计算用户之间的相似度 (<strong>similarity</strong> with active user)</li><li>预测目标用户对某个物品的评分</li></ul><p>或者更detail一些：</p><ul><li>Select a subset of the users (neighbors) to serve as predictors</li><li>Normalize ratings并根据所选邻居评级的加权组合计算预测</li><li>将具有最高predicted rating的项目作为推荐</li></ul><h5 id="Similarity-Weighting"><a href="#Similarity-Weighting" class="headerlink" title="Similarity Weighting"></a>Similarity Weighting</h5><p>我们使用Pearson correlation coefficient between ratings for active $a$ &amp; another user $u$ 来进行计算<br>$$<br>c_{a, u} = \frac{\text{cov} (r_a, r_u)}{\sigma_{r_a}\sigma_{r_u}}<br>$$<br>其中 $r_a, r_u$ 表示rating vectors，$\text{cov} (x, y)$ 是计算 $x, y$ 的协方差 (covarience)</p><p>评分向量通常是一个m维向量，其中m是物品的数量，每个元素表示用户对某个物品的评分值，评分值通常是一个实数，表示用户对该物品的喜好程度或重要程度。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230527185738062.png" alt="image-20230527185738062" style="zoom:25%;" /><p>我们还需要 <strong><em>Significance Weighting</em></strong> 来优化一下</p><p>Significance Weighting是协同过滤推荐算法中常用的一种加权方法，用于提高相似度计算的准确性和鲁棒性。他主要解决以下的scenario：有些用户或物品只评分了很少的物品，这些用户或物品的评分向量通常非常稀疏，导致相似度计算不准确或不可靠。</p><p>为解决这个问题，可以采用Significance Weighting方法，将那些评分较少的用户或物品的相似度计算结果进行加权处理。具体来说，可以使用以下公式计算两个用户 $u$ 和 $v$ 之间的相似度，其中，$s_{a, u}$ 是<em>significance weights</em><br>$$<br>w_{a, u} = s_{a, u}c_{a, u} \<br>s_{a, u} =<br>\left\{<br>\begin{aligned}<br>&amp;1 <del>~ \text{if} ~</del> m &gt; 50 \<br>&amp;\frac{m}{50} <del>~ \text{if} ~</del> m \le 50<br>\end{aligned}<br>\right.<br>$$</p><h5 id="Neighbor-Selection"><a href="#Neighbor-Selection" class="headerlink" title="Neighbor Selection"></a>Neighbor Selection</h5><p>之后就是<em>neighbor selection</em>，这一步就是对于一个active user $a$，将 $w_{a, u}$ 排序，找到the most similar $n$ users。或者也可以设定一个threshold，大于这个threshold都算similar</p><h5 id="Rating-Prediction"><a href="#Rating-Prediction" class="headerlink" title="Rating Prediction"></a>Rating Prediction</h5><p>假设我们现在已经选定了 $n$ 个neighbor，那么就可以通过下面的公式来predict user $a$ 对item $i$ 的rating $p_{a, i}$ 了，<br>$$<br>p_{a, i} = \bar{r}<em>a + \frac{\sum\limits</em>{u = 1}^n w_{a, u} (r_{u, i} - \bar{r}<em>u)}{\sum\limits</em>{u = 1}^n w_{a, u}}<br>$$<br>其中 $u \in \{1, 2, …, n\}$</p><hr><h4 id="Matrix-Factorization"><a href="#Matrix-Factorization" class="headerlink" title="Matrix Factorization"></a>Matrix Factorization</h4><p>但是上述方法还是有一些弊端，我们需要用Matrix Factorization来解决。那么为什么我们需要Matrix Factorization呢？</p><p>我们需要矩阵分解（Matrix Factorization）的原因有以下几点：</p><ul><li><p>处理稀疏矩阵：在推荐系统中，用户-物品评分矩阵通常是非常稀疏的，即大多数用户和物品之间没有评分记录。传统的基于相似度计算的协同过滤算法在稀疏矩阵上表现不佳，因为相似度计算会受到缺失值的影响。矩阵分解可以将稀疏矩阵分解为两个低维度的矩阵，从而捕捉用户和物品之间的潜在关系和特征，避免了稀疏矩阵的问题。</p></li><li><p>解决冷启动问题：在推荐系统中，新用户和新物品通常没有评分记录，即存在冷启动问题。传统的基于相似度计算的协同过滤算法无法准确地为新用户和新物品进行推荐。矩阵分解可以利用潜在因子的特征表示新用户和新物品，从而在没有评分记录的情况下进行推荐。</p></li><li><p>提高推荐效果：矩阵分解可以捕捉用户和物品之间的潜在关系和特征，提高推荐效果。相比传统的基于相似度计算的协同过滤算法，矩阵分解能够更好地挖掘用户和物品的隐含特征，从而提高推荐的准确性和个性化程度。</p></li><li><p>支持增量学习：在实际应用中，评分数据通常是动态变化的，需要支持增量学习。矩阵分解可以通过优化算法实现增量学习，即在新数据到来时，只需更新部分参数，而不需要重新训练整个模型。</p></li></ul><p>实际上本质上就是Matrix Factorization里能表达出的潜在因子起了主要作用</p>]]></content>
      
      
      <categories>
          
          <category> Social Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphTheory </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP - Skip-gram Code &amp; Annotations (Paddle)</title>
      <link href="/2023/07/14/NLP%20-%20Skip-gram%20Code%20&amp;%20Annotations%20(Paddle)/"/>
      <url>/2023/07/14/NLP%20-%20Skip-gram%20Code%20&amp;%20Annotations%20(Paddle)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>NLP&#x0020;Learning&#x0020;Notes#01</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle.nn <span class="keyword">import</span> Embedding</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> paddle.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------data loading part-------------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># load text8 dataset, which is appropriate for corpus training</span></span><br><span class="line"><span class="string">def download_text8 ():</span></span><br><span class="line"><span class="string">    url = &quot;https://dataset.bj.bcebos.com/word2vec/text8.txt&quot;</span></span><br><span class="line"><span class="string">    # use &#x27;requests&#x27; lib to &#x27;get&#x27; the data</span></span><br><span class="line"><span class="string">    web = requests.get (url)</span></span><br><span class="line"><span class="string">    corpus = web.content</span></span><br><span class="line"><span class="string">    with open (&#x27;./Practice/NLP/text8.txt&#x27;, &#x27;wb&#x27;) as f:</span></span><br><span class="line"><span class="string">        f.write (corpus)</span></span><br><span class="line"><span class="string">    f.close ()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">download_text8 ()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Loading Text8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_text8</span> ():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&#x27;./Practice/NLP/text8.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># strip function delete the corresponding string on head and tail</span></span><br><span class="line">        corpus = f.read ().strip (<span class="string">&quot;\n&quot;</span>).strip ()</span><br><span class="line">    f.close ()</span><br><span class="line">    <span class="keyword">return</span> corpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># corpus indicates the content of text8</span></span><br><span class="line">corpus = load_text8 ()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Loading Text8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pre-processing, split the words</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_split</span> (<span class="params">corpus</span>):</span></span><br><span class="line">    <span class="comment"># normalization: turn all character to lowercase</span></span><br><span class="line">    <span class="comment"># then split by spaces</span></span><br><span class="line">    corpus = corpus.lower ().split (<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> corpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># it is a list now</span></span><br><span class="line">corpus = word_split (corpus)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Building Dictionary&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dictionary construction &amp; ID assignment</span></span><br><span class="line"><span class="comment"># higher frequency, lower ID (frequency of occurrence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dict</span> (<span class="params">corpus</span>):</span></span><br><span class="line">    word_freq = <span class="built_in">dict</span> ()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> corpus:</span><br><span class="line">        <span class="comment"># remember to initialize, or it would be corrupt</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word <span class="keyword">in</span> word_freq:</span><br><span class="line">            word_freq[word] = <span class="number">0</span></span><br><span class="line">        word_freq[word] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sort by frequency (dictionary could as well been sorted)</span></span><br><span class="line">    <span class="comment"># dict.items () returns a list of tuples like [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), ...]</span></span><br><span class="line">    <span class="comment"># key = lambda dic: dic[1] means we sort by dic[1] which indicates the frequency</span></span><br><span class="line">    word_freq = <span class="built_in">sorted</span> (word_freq.items (), key = <span class="keyword">lambda</span> dic: dic[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># three mappings</span></span><br><span class="line">    word2id_dict = <span class="built_in">dict</span> ()</span><br><span class="line">    id_freq = <span class="built_in">dict</span> ()</span><br><span class="line">    id2word_dict = <span class="built_in">dict</span> ()</span><br><span class="line">    <span class="keyword">for</span> word, freq <span class="keyword">in</span> word_freq:</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">len</span> (word2id_dict)</span><br><span class="line">        word2id_dict[word] = <span class="built_in">id</span></span><br><span class="line">        id_freq[<span class="built_in">id</span>] = freq</span><br><span class="line">        id2word_dict[<span class="built_in">id</span>] = word</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> word2id_dict, id_freq, id2word_dict</span><br><span class="line"></span><br><span class="line">word2id_dict, id_freq, id2word_dict = build_dict (corpus)</span><br><span class="line">vocab_size = <span class="built_in">len</span> (word2id_dict)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Building Dictionary&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Converting to ID&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace words with their corresponding id s.t. nn could deal with data more easily</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_corpus2id</span> (<span class="params">corpus, word2id_dict</span>):</span></span><br><span class="line">    corpus = [word2id_dict[word] <span class="keyword">for</span> word <span class="keyword">in</span> corpus]</span><br><span class="line">    <span class="keyword">return</span> corpus</span><br><span class="line"></span><br><span class="line">corpus = convert_corpus2id (corpus, word2id_dict)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Converting to ID&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Subsampling&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># !important</span></span><br><span class="line"><span class="comment"># subsampling: discard high-frequency words in corpus to enhance training</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsampling</span> (<span class="params">corpus, id_freq</span>):</span></span><br><span class="line">    <span class="comment"># randomly dicard words in corpus</span></span><br><span class="line">    <span class="comment"># higher frequency, higher probability to be abondaned</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discard</span> (<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">        <span class="comment"># random.uniform (a, b) returns a random real number between a &amp; b</span></span><br><span class="line">        <span class="keyword">return</span> random.uniform (<span class="number">0</span>, <span class="number">1</span>) &lt; <span class="number">1</span> - math.sqrt (<span class="number">1e-4</span> / id_freq[<span class="built_in">id</span>] * <span class="built_in">len</span> (corpus))</span><br><span class="line">    </span><br><span class="line">    corpus = [word <span class="keyword">for</span> word <span class="keyword">in</span> corpus <span class="keyword">if</span> <span class="keyword">not</span> discard (word)]</span><br><span class="line">    <span class="keyword">return</span> corpus</span><br><span class="line"></span><br><span class="line">corpus = subsampling (corpus, id_freq)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Subsampling&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------end data loading part-----------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use negative sampling to replace softmax s.t. training speed would increase</span></span><br><span class="line"><span class="comment"># max_window_size indicates the maximum size of the moving window</span></span><br><span class="line"><span class="comment"># neg_samp_num indicates how many words we are to pick in negative sampling as negative samples</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Building Dataset...&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dataset</span> (<span class="params">corpus, max_window_size = <span class="number">3</span>, neg_samp_num = <span class="number">4</span></span>):</span></span><br><span class="line">    dataset = []</span><br><span class="line">    <span class="comment"># format: (center_word, current_word, label(1 for positive, 0 for negative))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> center_word_idx <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span> (corpus)):</span><br><span class="line">        <span class="comment"># randomly pick a window_size to enhance training</span></span><br><span class="line">        window_size = random.randint (<span class="number">1</span>, max_window_size)</span><br><span class="line">        center_word = corpus[center_word_idx]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># select positive samples</span></span><br><span class="line">        posi_word_range = (<span class="built_in">max</span> (<span class="number">0</span>, center_word_idx - window_size), \</span><br><span class="line">                    <span class="built_in">min</span> (<span class="built_in">len</span> (corpus) - <span class="number">1</span>, center_word_idx + window_size))</span><br><span class="line">        posi_word_set = [corpus[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (posi_word_range[<span class="number">0</span>], posi_word_range[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">if</span> i != center_word_idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> posi_word <span class="keyword">in</span> posi_word_set:</span><br><span class="line">            dataset.append ((center_word, posi_word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># randomly pick negative samples</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cnt &lt; neg_samp_num:</span><br><span class="line">                neg_word = random.randint (<span class="number">0</span>, vocab_size - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> neg_word <span class="keyword">in</span> posi_word_set:</span><br><span class="line">                    dataset.append ((center_word, neg_word, <span class="number">0</span>))</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line">corpus = corpus[:<span class="built_in">int</span> (<span class="built_in">len</span> (corpus) * <span class="number">0.2</span>)]</span><br><span class="line">dataset = build_dataset (corpus, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Building Dataset&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_batch</span> (<span class="params">dataset, batch_size, epoch_num</span>):</span></span><br><span class="line">    center_batch = [] <span class="comment"># save center words</span></span><br><span class="line">    target_batch = [] <span class="comment"># save target words</span></span><br><span class="line">    label_batch = [] <span class="comment"># save labels</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (epoch_num):</span><br><span class="line">        <span class="comment"># remember to shuffle the dataset every epoch</span></span><br><span class="line">        random.shuffle (dataset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> center_word, target_word, label <span class="keyword">in</span> dataset:</span><br><span class="line">            center_batch.append ([center_word])</span><br><span class="line">            target_batch.append ([target_word])</span><br><span class="line">            label_batch.append (label)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span> (center_batch) == batch_size:</span><br><span class="line">                <span class="keyword">yield</span> np.array (center_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">                      np.array (target_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">                      np.array (label_batch).astype (<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">                center_batch = []</span><br><span class="line">                target_batch = []</span><br><span class="line">                label_batch = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span> (center_batch) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> np.array (center_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">              np.array (target_batch).astype (<span class="string">&#x27;int64&#x27;</span>), \</span><br><span class="line">              np.array (label_batch).astype (<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipGram</span> (<span class="params">paddle.nn.Layer</span>):</span></span><br><span class="line">    <span class="comment"># init_scale define the range of initial values of word embeddings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self, vocab_size, embed_size, init_scale = <span class="number">0.1</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span> (SkipGram, self).__init__ ()</span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.embed_size = embed_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># note that actually self.embedding_in is the same as self.embedding_out</span></span><br><span class="line">        <span class="comment"># but in skip-gram network graph we see that the shape of self.embedding_out is supposed to be \</span></span><br><span class="line">        <span class="comment"># [embedding_size, vocabulary_size]</span></span><br><span class="line">        <span class="comment"># however, it is not used in actual programming</span></span><br><span class="line">        <span class="comment"># cuz we do not do matrix multiplication in order</span></span><br><span class="line">        <span class="comment"># we do it for center word&#x27;s one-hot embedding and the same time for target words&#x27;</span></span><br><span class="line">        <span class="comment"># then mix them up</span></span><br><span class="line">        self.embedding_in = Embedding (num_embeddings = self.vocab_size, embedding_dim = self.embed_size, \</span><br><span class="line">                                weight_attr = paddle.ParamAttr (</span><br><span class="line">                                    initializer = paddle.nn.initializer.Uniform (</span><br><span class="line">                                        low = - init_scale, high = init_scale)))</span><br><span class="line">        self.embedding_out = Embedding (num_embeddings = self.vocab_size, embedding_dim = self.embed_size, \</span><br><span class="line">                                weight_attr = paddle.ParamAttr (</span><br><span class="line">                                    initializer = paddle.nn.initializer.Uniform (</span><br><span class="line">                                        low = - init_scale, high = init_scale)))</span><br><span class="line">        <span class="comment"># about paddle.nn.embedding API</span></span><br><span class="line">        <span class="comment"># we do not need to input one-hot encoding tensor</span></span><br><span class="line">        <span class="comment"># what is supposed to be input is batches of word index</span></span><br><span class="line">        <span class="comment"># Let&#x27;s see an example given by PP&#x27;s official website</span></span><br><span class="line">        <span class="comment"># ---------------------------------------</span></span><br><span class="line">        <span class="comment"># x是Tensor， 且padding_idx = -1.</span></span><br><span class="line">        <span class="comment">#     padding_idx = -1</span></span><br><span class="line">        <span class="comment">#     x.data = [[1, 3], [2, 4], [4, 127]]</span></span><br><span class="line">        <span class="comment">#     x.shape = [3, 2]</span></span><br><span class="line">        <span class="comment">#     weight.shape = [128, 16]</span></span><br><span class="line">        <span class="comment"># 输出是Tensor:</span></span><br><span class="line">        <span class="comment">#     out.shape = [3, 2, 16]</span></span><br><span class="line">        <span class="comment">#     out.data = [[[0.129435295, 0.244512452, ..., 0.436322452],</span></span><br><span class="line">        <span class="comment">#                 [0.345421456, 0.524563927, ..., 0.144534654]],</span></span><br><span class="line">        <span class="comment">#                 [[0.345249859, 0.124939536, ..., 0.194353745],</span></span><br><span class="line">        <span class="comment">#                 [0.945345345, 0.435394634, ..., 0.435345365]],</span></span><br><span class="line">        <span class="comment">#                 [[0.945345345, 0.435394634, ..., 0.435345365],</span></span><br><span class="line">        <span class="comment">#                 [0.0,         0.0,         ..., 0.0        ]]]  # padding data</span></span><br><span class="line">        <span class="comment"># 输入的padding_idx小于0，则自动转换为padding_idx = -1 + 128 = 127, 对于输入id为127的词，进行padding处理。</span></span><br><span class="line">        <span class="comment"># ---------------------------------------</span></span><br><span class="line">        <span class="comment"># it can be seen that words are directly converted to their word embeddings</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span> (<span class="params">self, center_words, target_words</span>):</span></span><br><span class="line">        center_words_emb = self.embedding_in (center_words)</span><br><span class="line">        target_words_emb = self.embedding_out (target_words)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># note that it should be matter with cosine distance instead of Euclidean distance</span></span><br><span class="line">        <span class="comment"># cosine distance = (x1y1 + x2y2) / sqrt((sigma(x^2)sigma(y^2))</span></span><br><span class="line">        word_eval = paddle.multiply (center_words_emb, target_words_emb)</span><br><span class="line">        word_eval = paddle.<span class="built_in">sum</span> (word_eval, axis = - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># when shape = [- 1], no matter how many dimensions a tensor has</span></span><br><span class="line">        <span class="comment"># they&#x27;ll all be turned to a sequence, e.g. [1, 2, 3, 4, ...]</span></span><br><span class="line">        word_eval = paddle.reshape (word_eval, shape = [- <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> word_eval</span><br><span class="line"></span><br><span class="line"><span class="comment"># used for evaluating synonym</span></span><br><span class="line"><span class="comment"># return the first k-th possible words</span></span><br><span class="line"><span class="comment"># current_embedding saves the word embedding table trained so far</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_synonym</span> (<span class="params"><span class="built_in">id</span>, k, current_embedding</span>):</span></span><br><span class="line">    W = current_embedding.numpy ()</span><br><span class="line">    x = W[word2id_dict[<span class="built_in">id</span>]]</span><br><span class="line">    <span class="comment"># calculate cosine dist between current node and remaining nodes</span></span><br><span class="line">    cos_dist = np.dot (W, x) / np.sqrt (np.<span class="built_in">sum</span> (W * W, axis = <span class="number">1</span>) * np.<span class="built_in">sum</span> (x * x) + <span class="number">1e-9</span>)</span><br><span class="line">    <span class="comment"># flatten function is used as the same as paddle.reshape (x, shape = [- 1])</span></span><br><span class="line">    cos_dist = cos_dist.flatten ()</span><br><span class="line">    <span class="comment"># np.argpartition can place values lower then the k-th value to left side and higher ones to right side</span></span><br><span class="line">    <span class="comment"># the same as the partition done in quick sort</span></span><br><span class="line">    <span class="comment"># return indices instead of real values</span></span><br><span class="line">    <span class="comment"># - k means sort in decreasing order</span></span><br><span class="line">    <span class="comment"># [- k:] picks the largest k elements</span></span><br><span class="line">    indices = np.argpartition (cos_dist, - k)[- k:]</span><br><span class="line">    <span class="comment"># argsort is a general sort function</span></span><br><span class="line">    <span class="comment"># negative symbol is used to sort from highest to lowest</span></span><br><span class="line">    indices = indices[np.argsort (- cos_dist[indices])]</span><br><span class="line">    <span class="comment"># for i in indices:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;for word %s, the similar word is %s&#x27; % (query_token, str(id2word_dict[i])))</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">512</span></span><br><span class="line">epoch_num = <span class="number">3</span></span><br><span class="line">embedding_size = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Start Building Batch...&quot;</span>)</span><br><span class="line">train_loader = build_batch (dataset, batch_size, epoch_num)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;End Building Batch&quot;</span>)</span><br><span class="line"></span><br><span class="line">model = SkipGram (vocab_size, embedding_size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span> (<span class="params">model</span>):</span></span><br><span class="line">    <span class="comment"># use gpu</span></span><br><span class="line">    use_gpu = <span class="literal">False</span></span><br><span class="line">    paddle.set_device(<span class="string">&#x27;gpu:0&#x27;</span>) <span class="keyword">if</span> use_gpu <span class="keyword">else</span> paddle.set_device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    optimizer = paddle.optimizer.Adam (learning_rate = <span class="number">0.001</span>, parameters = model.parameters ())</span><br><span class="line">    <span class="keyword">for</span> center_words, target_words, labels <span class="keyword">in</span> train_loader:</span><br><span class="line">        center_words = paddle.to_tensor (center_words)</span><br><span class="line">        target_words = paddle.to_tensor (target_words)</span><br><span class="line">        labels = paddle.to_tensor (labels)</span><br><span class="line"></span><br><span class="line">        word_eval = model (center_words, target_words)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print (word_eval, labels)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># directly use &#x27;binary_cross_entropy_with_logits&#x27; to handle binary classification problem</span></span><br><span class="line">        <span class="comment"># the function would automatically pass para through sigmoid function</span></span><br><span class="line">        <span class="comment"># therefore, we only need to input values before sigmoid(ed)</span></span><br><span class="line">        loss = F.binary_cross_entropy_with_logits (word_eval, labels)</span><br><span class="line">        avg_loss = paddle.mean (loss)</span><br><span class="line"></span><br><span class="line">        avg_loss.backward ()</span><br><span class="line">        optimizer.step ()</span><br><span class="line">        optimizer.clear_grad ()</span><br><span class="line"></span><br><span class="line">train (model)</span><br><span class="line">paddle.save (model.state_dict (), <span class="string">&#x27;./Practice/NLP/skipgram.pt&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Blockchain</title>
      <link href="/2023/02/08/Introduction%20to%20Blockchain/"/>
      <url>/2023/02/08/Introduction%20to%20Blockchain/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Lecture-2-Cryptographic-Hash-Function-Example-SHA256"><a href="#Lecture-2-Cryptographic-Hash-Function-Example-SHA256" class="headerlink" title="Lecture 2: Cryptographic Hash Function (Example: SHA256)"></a>Lecture 2: Cryptographic Hash Function (Example: SHA256)</h2><p>$\sum$指所有可能出现的字符. $\sum^* = \sum^0 \cup \sum^1 \cup …$。上面的数字指的是字符序列长度</p><p>$f: \sum^* \rightarrow \sum^n$    <em>map from infinite to finite</em></p><p>Hash function characteristic:</p><ul><li><p><strong>Collision-resistance</strong>: It is hard to find $x, y \in \sum^*$, s.t., $x \neq y$ and $f(x) = f(y)$</p></li><li><p><strong>Hiding</strong>: Given a hash value $h$, it is hard to find same $x$ s.t. $f(x) = h$</p></li><li><p><strong>Puzzle friendliness</strong></p></li></ul><hr><p><em>Problem</em>: Finding Files</p><p>I have huge files $F_1, F_2, …, F_n$. Given a new file, find if it exists in my files ($\exist F_i, F_i = F_{new}$)</p><p>Solution: Save $Hash(F_i)$ the same time when saving $F_i$</p><hr><p><em>Problem</em>: Ledger with hash pointers</p><p>node $o_1$ save the pointer to $Hash(o_2)$, then I can find $o_2$ by table. But it need to guarantee the immutability or if $o_2$ changes, we can no longer access it.</p><p>Create a link list of all the transactions.</p><p>$Tx_1$. When another transaction occurs, $Tx_1 \leftarrow Tx_2$. Bank creates $Tx_2$, and points to $Tx_1$. Then bank sends me an email of the information $Tx_2$  and hash of $Tx_2$. The pointer is $Hash (Tx_1)$. 这可以用来证明你进行了$Tx_2$，因为可以根据指针追溯到最本源的交易。</p><p>当银行想要更改$Tx_1$，那么$Hash (Tx_1)$需要改变，接着因为$Tx_2$ saves $Hash (Tx_1)$, $Hash (Tx_2)$ has to change, therefore $Tx_3$ has to change…</p><hr><h4 id="Commitment-Scheme"><a href="#Commitment-Scheme" class="headerlink" title="Commitment Scheme"></a>Commitment Scheme</h4><p>Players $p_1, p_2, …, p_n$ have bids $b_1, b_2, …, b_n$ respectively</p><p>rule: No other ppl can see my bid and I can no longer change my bid.</p><p>Assume the cheater is powerful enough, he can know any bid of players.</p><p>We need to design a protocol to prevent cheating:</p><ul><li>Make sure the highest $b_i$ is found (需要知道谁胜出)</li><li>No player can change their bid after seeing other players’ bids.</li><li>Auditability: make sure every player can check through the protocol</li></ul><p><em>Solution</em>:</p><p>Hash function: $h$</p><p>Step 1: Every player computes his hash $h_i = h (b_i)$</p><p>Step 2 (commit): $p_i$ publishes $h_i$</p><p>Step 3 (reveal): After everyone commits, $p_i$ publishes $b_i$</p><p>保证所有人都commit且reveal，否则出局</p><p>Dealer可以根据reveal的$b_i$ compute $h_i$，防止有人两个publish的不是一个东西</p><p><em>Problem</em>:</p><ul><li>When doing hashing, the domain should be larger (不然domain太小容易被猜出来)</li></ul><p><em>Improvement</em>:</p><p>Step 1: Every player $p_i$ chooses a random nonce $n_i$. $h_i = h (b_i | n_i)$</p><p>Step 2 (commit): $p_i$ publishes $h_i$</p><p>Step 3 (reveal): After everyone commits, $p_i$ publishes $b_i$ <strong>and</strong> $n_i$</p><p>但是dealer不是必须的，可以做成decentralized的。</p><hr><h2 id="Lecture-3-Merkle-Trees"><a href="#Lecture-3-Merkle-Trees" class="headerlink" title="Lecture 3: Merkle Trees"></a>Lecture 3: Merkle Trees</h2><hr><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>I am running a bank. The bank has two branches, HK and SH.</p><p>Let’s say there’s no internet but has computers and hash function.</p><p>Have a bunch of transactions (deposit) at HK branch, then they want ot get their money back in SH branch with their <em>deposit proof</em></p><p>I can just send <strong>a short message</strong> from HK to SH to <strong>prove the deposit proof is true</strong> and 钱没被取出来过</p><p>And any leak of the short message should not have someone know the information about the deposits.</p><p><em>Assume the original channel is unsafe and expensive. 并且可能存在A存钱，但是B会copy A的存折去取钱的情况</em></p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>First step, be clear about the properties.</p><p><strong>Properties:</strong></p><ul><li>Every deposit can be taken back</li><li>No one can reclaim the same deposit twice</li><li>Message $m$ going from HK to SH is really short</li><li>$m$ does not leak any data</li><li>Every depositor $i$ receives a proof $p_i$</li><li>It is possible to verify every $p_i$ using $m$</li><li><em>Additional property: short proof</em></li><li><em>Additional property: privacy for depositor (一个depositor不会看到其他depositor的内容)</em></li></ul><p>Suppose we have a ledger(账本)</p><p>When Alice deposits, she gives me a random number $n_1$. So Bob and Carol $n_2, n_3$ respectively. 此时我们将每个transaction的内容(name, amount of money…) hash起来而不是明确地表示出来，即$Tx_1$存储的是hash (Alice || \$100 || $n_1$)，那么此时就无法读取别人的内容了。</p><p>那么此时HK只需要向SH传输hash ($Tx_3$)，然后Carol带着$Tx_3$去SH取钱，SH计算$Tx_3$的hash值，并与$m$进行比对，同时Carol再提供自己的name以及amount of money，SH再将这些信息进行hash，并与$Tx_3$内的hash (Carol || \$150 || $n_3$)进行比对，则可以确定这笔钱确实是Carol的。</p><p>那么对于Alice，她则需要提供$Tx_3, Tx_2, Tx_1$，SH先分别验证$Tx_3, Tx_2$的真实性，最后通过Alice提供的name与amount of money数据来匹配$Tx_1$。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230524120323084.png" alt="image-20230524120323084" style="zoom:33%;" /><p>可以发现，上述过程每个人都不知道其他人的transaction的具体内容，都是hash。  </p><p>However, 当transaction很多的时候，Alice要存的内容就非常多了，要存所有人的数据，那怎么解决这个问题呢？需要用Merkle Trees。</p><p>![image-20230311162808715](/Users/colythme/Library/Application Support/typora-user-images/image-20230311162808715.png)</p><p>Merkle Trees正如图中所示，实际上就是一个二叉搜索树，将transaction的hash存作叶子结点的value，然后两个子节点的父节点的value是两个字节的value的hash，即比如子节点$l_1, l_2$，其father node的value即为$hash (l_1 || l_2)$。此时需要传输的message $m$即为根节点的value。</p><p>那么现在的问题就是，我们并没有传输整棵树，要怎么traverse这个Merkle Tree来判断$l_1$是否存在于树中呢？所以实际上，Alice需要给定$b_1, b_2, l_1, l_2, D_1$，SH将$b_1, b_2$进行hash，来判断他们是不是$m$的子节点；同样的，她需要提供$l_1, l_2$来判断他们是不是$b_1$的子节点。这样才能最终判断$D_1$在不在树中。</p><p>那么此时对于一个depositor，他需要存储的最多信息的长度就是$2\log n$</p><h2 id="Lecture-4-Symmetric-Encryption"><a href="#Lecture-4-Symmetric-Encryption" class="headerlink" title="Lecture 4: Symmetric Encryption"></a>Lecture 4: Symmetric Encryption</h2><p>Scenario: two people <em>Alice</em> &amp; <em>Bob</em>. They want to communicate, but only with unsafe channel. Someone else may can read the messages. Suppose the ‘someone else’ is <em>Eve</em>.</p><p>Send a message $m$. The encrypted message $e$.</p><p>那么实际上Eve能看到的就是encrypted message $e$</p><p>在课程中红色标记的表示private，蓝色的是public</p><p><strong>Definition:</strong></p><p>A key $k \in \sum^*$ which is only known to Alice &amp; Bob.</p><p>Alice knows a function $Enc_k: \sum^* \rightarrow \sum^*$ (编码器encrypte function)</p><p>Bobo knows a function $Dec_k: \sum^* \rightarrow \sum^*$ (解码器decrypte function)</p><p>$\forall m \in \sum^*, Dec_k (Enc_k (m)) = m$ (即解码编码后的message会得到原信息)</p><p>这叫做<em>symmetric encryption</em></p><p>在当前时代下，我们认为这个编码器和解码器的function都是已知的，唯一未知的是key $k$</p><p><strong>One-time Pad:</strong></p><p>因为message实际上是二进制的，我们用$\oplus$表示xor，使得 $e = Enc_k (m) = m \oplus k$，$Dec_k (e) = e\oplus k$</p><p>$Dec_k (Enc_k (m)) = Dec_k (m \oplus k) = m$</p><p><strong>Property:</strong></p><p>Eve cannot figure out any message in $m$ from $e$, even one bit of $m$.</p><p><strong>Security Analysis:</strong></p><p>How to show Eve cannot find anything about $m$?</p><p>Eve sees $e$, $|e| = n$</p><p>For evey possible message of length $n$, there exists key $k_m \in \sum^n$, $Enc_k (m) = e$，此时 $k_m = m \oplus e$。这个性质是要保证他不是一对一映射，也就是说我拿到一个$e$，但是他有很多个可能的$m$和$k_m$的组合，以至于我几乎没法通过枚举猜出来。</p><p>但是，do not reuse the keys。因为比如我发两个message，$e_1 = m_1 \oplus k, e_2 = m_2 \oplus k$，那么Eve通过计算$e_1 \oplus e_2 = m_1 \oplus m_2$，那么Eve虽然不知道具体信息，但是可以gain some information about the messages，之后便可以通过枚举等方法尝试，所以是不那么safe的。</p><hr><p><strong>Key Exchange</strong></p><p>首先Scenario和上面差不多。还是Alice，Bob传输message，Eve来intercept。</p><p>Alice has a secret $a$, Bob has a secret $b$. 他们想相互传输（exchange）secret。</p><p>他们目前想通过加密函数来互相传输以至于不被窃听。</p><ul><li>Alice computes $f(a)$ and sends it to Bob</li><li>Bob computes $f(b)$ and sends it to Alice</li><li>此时Alice knows $a, f(b)$，Bob knows $b, f(a)$，Eve knows $f(a), f(b)$</li><li>那么此时，我们需要解决的就是，define $k$ to be a value that it is easy to compute $b$ by $a ~ \&amp; ~ f(b)$, or compute $a$ by $b ~ \&amp; ~ f(a)$, but impossible to compute $a$ or $b$ by $f(a) ~ \&amp; ~ f(b)$</li><li>所以实际上Alice和Bob还额外知道一个$k$</li></ul><p>这个算法叫做Diffie-Hellman Merkle Exchange</p><p><strong>DH Exchange:</strong></p><ul><li><p>Alice or Bob chooses a large prime number $p$ (这个$p$是public的) and sends it over。这个$p$在二进制下要尽可能长，要比你可能发送的最长信息的长度还要长。</p></li><li><p>同时他们再choose一个number $g \in \{0, …, p - 1\}$ s.t. $\{g^0, g^1, g^2, …, g^{p - 2}\} = \{1, 2, …, p - 1\}$。也将这个$g$相互发送。</p><p>  这个 $g$ 叫做<em>primitive root</em></p></li><li><p>Alice choose a secret $a \in \{0, 1, …, p - 2\}$</p><p>  Bob chooses another secret $b \in \{0, 1, …, p - 2\}$</p></li><li><p>Alice computes $g^a \mod p$ and sends it to Bob</p><p>  Bob computes $g^b \mod p$ and sends it to Alice</p></li><li><p>Alice computes $k = (g^b)^a = g^{ab} \mod p$</p><p>  Bob computes $k = (g^a)^b = g^{ab} \mod p$</p></li></ul><p>Alice and Bob compute the shared secret they can use it as an encryption key, known only to them, for sending messages across the same open communications channel.</p><p>Now eve knows $p, g, g^a, g^b$ but needs to compute $k = g^{ab} \mod p$</p><h2 id="Lecture-5-Basic-Number-Theory-and-ElGamal-Encryption"><a href="#Lecture-5-Basic-Number-Theory-and-ElGamal-Encryption" class="headerlink" title="Lecture 5: Basic Number Theory and ElGamal Encryption"></a>Lecture 5: Basic Number Theory and ElGamal Encryption</h2><h4 id="Fermat’s-little-theorem"><a href="#Fermat’s-little-theorem" class="headerlink" title="Fermat’s little theorem"></a>Fermat’s little theorem</h4><p>$a^{p - 1} \equiv 1 \pmod p, a \in [1, p - 1]$</p><h4 id="Computing-Primitive-Roots"><a href="#Computing-Primitive-Roots" class="headerlink" title="Computing  Primitive Roots"></a>Computing  Primitive Roots</h4><p>$p$ is a large prime number</p><p>find $g$ s.t. $\{g^0, g^1, …, g^{p - 2}\} = \{1, 2, …, p - 1\}$</p><p><strong>How to check if $g$ a primitive root?</strong></p><p>compute $g^0, g^1, …$ until a cycle is found. 但是显然，当 $p$ 很大的时候，是不可行的。</p><p>$o(g)$ = length of the cycle of powers of $g$ = smallest positive $i$ s.t. $g^i = 1 \pmod p$</p><p>我们需要证明的是，$o(g) = p -1$，而不是$o(g) &lt; p - 1$。Apparently, 不管在什么情况下， $o(g) | p - 1$</p><p>facterize: $p - 1 = q_1^{\alpha_1}q_2^{\alpha_2}…q_r^{\alpha_r}$</p><p>那么实际上 $g$ 若不是primitive root的情况只有 $o(g) | \frac{p - 1}{q_1} <del>\text{or}</del> o(g) | \frac{p - 1}{q_2} <del>\text{or}</del> … $，因为这说明$o(g)$肯定小于$p - 1$。此时只需检查是否$g^{\frac{p - 1}{q_1}} \equiv 1 \pmod {p - 1} <del>\text{or}</del> g^{\frac{p - 1}{q_2}} \equiv 1 \pmod {p - 1} <del>\text{or}</del> …$即可，若其中一个同余1，则说明cycle提前结束了。</p><p><strong>Fast Modular Exponentiation</strong></p><p>接下来我们需要考虑如何compute $a^b <del>\text{mod}</del> c$</p><p>快速幂</p><p>现在则要回归最初始的问题——怎么找primitive root $g$？</p><p>Method: Choose a random value $g$, then check if it is a primitive root.</p><p>为什么这个随机算法可行呢？因为原根有很多个。I know there is at least one primitive root $g$，假设我们现在随机选了个数，他是$g^i$， 并且 if $i \perp p - 1$ then 我通过枚举 $i$ 来循环 $g^i$，最终会把所有数都循环一遍。</p><p>（找原根这部分目前没太懂，需补）</p><h4 id="Modular-Multiplicative-Inverse"><a href="#Modular-Multiplicative-Inverse" class="headerlink" title="Modular Multiplicative Inverse"></a>Modular Multiplicative Inverse</h4><p>Fermat: $a \neq 0 \pmod p \Rightarrow a^{p - 1} \equiv 1 \pmod p$</p><p>which means $a \cdot a^{p - 2} \equiv 1 \pmod p$，这说明 $a^{p - 2}$ 是 $a$ 的乘法逆元 $\pmod p$</p><p><strong>How to compute $a^{- 1} \text{mod} ~ n$ ?</strong></p><p>If gcd (a, n) $\neq$ 1, then $a$ has no inverse.</p><h4 id="重回正题"><a href="#重回正题" class="headerlink" title="重回正题"></a>重回正题</h4><p>现在我们假设Alice或者Bob其中一人是offline的，即不需要一直online等待别人sending message</p><p>为什么会有这个问题呢？因为Alice有$p, g$数据，而Bob的$p, g$数据是Alice发给他的，所以当Alice offline时，Bob就没法decode发来的message了</p><p>Process:</p><ul><li>Alice generates $p, g, a, g^a$ and <strong>broadcast</strong> $(p, g, g^a)$。因为此时Alice不知道谁会要与她交流，所以是broadcast。之后，Alice turns her computer off (offline)</li><li>现在Bob want to send a message to Alice。Bob generates a random secret $b$ and computes $g^{ab} = (g^a)^b$。</li><li>Bob sends $(g^b, e = m + g^{ab})$ to Alice …之后跟上面的操作一样就好了，因为Alice已经能算出 $k$ 了</li><li>When Alice is back online, Alice computes $g^{ab} = (g^b)^a$</li><li>Alice computes $m = e - g^{ab}$</li></ul><p>注意，上述过程都是基于$\text{mod} ~ p$的情况</p><h2 id="Lecture-6-The-RSA-Cryptosystem"><a href="#Lecture-6-The-RSA-Cryptosystem" class="headerlink" title="Lecture 6: The RSA Cryptosystem"></a>Lecture 6: The RSA Cryptosystem</h2><p><strong>Requirements:</strong></p><p>I need to have two functions: an encryption function $Enc_k: \sum^* \rightarrow \sum^<em>$ &amp; a decryption function $Dec_k: \sum^</em> \rightarrow \sum^*$</p><p>And I also need a key pair $(e, d)$。这里$e$是public，$d$是private。</p><p>同时也需要满足，$\forall m, Dec_d (Enc_e (m)) = m$</p><p><strong>Security Requirements:</strong></p><p>If the adversary knows $e$ &amp; $Enc_e(m)$ &amp; $Enc$ algorithm &amp; $Dec$ algorithm, they cannot find any information about $m$(private).</p><hr><p><strong>Rivest-Shamir-Adleman (RSA)</strong></p><p>前提：I have a number $n$ and all calculations are $\text{mod} ~ n$. And $e, d \in [0, n)$</p><p>$Enc_e (m) = m^e \mod n$</p><p>$Dec_d (m’) = m’^d \mod n$。这里$m’$代指加密后message</p><p>$Des_d (Enc_e (m)) = Dec_d (m^e) = m^{ed}$</p><p>所以我们现在需要考虑的是，how do I generate key $e, d$，s.t.，$m \equiv m^{ed} \pmod n$</p><p><em>Key Generation:</em></p><p>What happens if $n$ is prime?</p><p>$\forall m, m^{ed} \equiv m \pmod n \Leftrightarrow \forall m, m^{ed - 1} \equiv 1 \pmod n$</p><p>要满足上面的式子，只需要使得 $n - 1 | ed - 1$ 即可 (by Fermat’s Little Theorem)</p><p>$ed - 1 \equiv 0 \pmod {n - 1} \Leftrightarrow ed \equiv 1 \pmod{n - 1} \Leftrightarrow d \equiv e^{- 1} \pmod{n - 1}$</p><p><em>What does Eve see?</em></p><p>$e, n, m^e$.</p><p>Eve can compute $d = e^{- 1} \mod{n - 1}$. Then Eve can decrypte the message like us: $m = Dec_d (m^e)$</p><p>那么会造成这种结果的原因实际上就是计算key $d$的成本太低了，只需要知道$n - 1$就行，所以我们需要修改这个。也就是说，单纯让$n$是个prime number太简单了。</p><p><em>Key Generation (Attempt 2)</em></p><p>Alice chosses two large primes $p, q$ and set $n = pq$. 这里$n$是public，但是$p, q$是private。</p><p>I need to generate $d, e$, s.t., $\forall m, m^{ed} \equiv m \pmod n$</p><p>这里我们需要用到Chinese Remainder Theorem</p><p>根据CRT，可以得到<br>$$<br>m^{ed} \equiv m x\pmod n \Rightarrow<br>\left\{<br>\begin{aligned}<br>m^{ed} \equiv m \pmod p \<br>m^{ed} \equiv m \pmod q<br>\end{aligned}<br>\right.<br>\Leftrightarrow<br>\left\{<br>\begin{aligned}<br>m^{ed - 1} \equiv 1 \pmod p \<br>m^{ed - 1} \equiv 1 \pmod q<br>\end{aligned}<br>\right.<br>$$<br>We make sure that $ed - 1$ is a multiple of both $p - 1$ and $q - 1$.</p><p>所以我们可以直接计算$l = lcm (p - 1, q - 1)$. 之后Alice chooses $e, d$, s.t., $l | ed - 1$</p><p>推导一下，得到$ed - 1 \equiv 0 \pmod l \Leftrightarrow e = d^{- 1} \mod l$</p><p><em>What does Eve see?</em></p><p>$e, n, m^e$</p><p>此时我们的$d = e^{- 1} \mod l$。会发现此时Eve不知道$p, q$，所以她没法知道$l$。但是实际上，Eve可以factorize $n$，毕竟$n$就是两个prime的结合，但假若$p, q$足够大，所以此处我们暂且认定Eve cannot find $p, q, l = lcm (p - 1, q - 1), d, m$</p><hr><p><strong>RSA Assumption</strong></p><p>Given $e, n, m^e$, one cannot find $m$.</p><p>We do not have a proof to it, but it actually works.</p><h2 id="Lecture-7-Digital-Signatures"><a href="#Lecture-7-Digital-Signatures" class="headerlink" title="Lecture 7: Digital Signatures"></a>Lecture 7: Digital Signatures</h2><p>In one-time pad, we use our key $k$ only once, or it would be figured out if being multiplely used.</p><p>However, in RSA with key pair $(e, d)$, we always keep them the same.</p><p><strong>Homomorphic property of RSA</strong></p><p>$Enc_e (m_1) \cdot Enc_e (m_2) = Enc_e (m_1 \cdot m_2)$</p><h4 id="Digital-Signatures"><a href="#Digital-Signatures" class="headerlink" title="Digital Signatures"></a>Digital Signatures</h4><p>Definition:</p><p>Alice wants to send messages to Bob in the Internet.</p><p>Meanwhile, Charlie can <strong>change</strong> the message Alice sends in the middle.</p><p>所以问题就是，how can Bob be sure the message is originally from Alice?</p><p>这时Alice除了send message $m$，还要send a signature $sgn(m)$，并且要满足，everyone including Bob is able to verify this signature.</p><p>A signature function $sgn_d: \sum^* \rightarrow \sum^<em>$ with a *</em>secret key** $d$.</p><p>A verification function $ver_e: \sum^* \times \sum^* \rightarrow \{0, 1\}$ with a <strong>public key</strong> $e$. 这里的0，1指的是确认是假的或真的。同时还要有个 $\overline{ver_e}: \sum^* \rightarrow \sum^*$，这个函数是返回originial message来check if it is the same msg用的。</p><p><strong>Validity Property:</strong></p><p>$\forall m, ver_e (m, sgn_d(m)) = 1$</p><p>$\forall m, \overline{ver_e} (sgn_d (m)) = m$</p><p><strong>Security Property:</strong></p><p>Only Alice can sign.</p><p>If Charlie knows $m, e, sgn, \overline{ver}$, he should not be able to compute $sgn_d (m)$.</p><p><strong>RSA Signatures</strong></p><ul><li>Alice creates RSA keys $n = pq, e, d$, s.t., $\forall m, m^{ed} = m \pmod n$</li><li>We assume everyone knows $n, e$</li><li>Alice computes $s = sgn_d (m) = dec_d (m) = m^d$ and sends it to Bob</li><li>Bob verifies Alice’s signature by computing $\overline{ver_e}(s) = enc_e(s) = s^e = m^{ed}$</li></ul><p>If $s$ is really Alice’s signature on $m$, then $s = m^d$ so $m^{de} \equiv m \pmod n$</p><p><em>What does Charlie knows?</em></p><p>$m, m^d, n, e$</p><p>But he cannot forge a signature. Because to forge a signature on $m’$, Charlie must compute $m’^d$, which is the same as decryption (因为Charlie需要解码得到$d$来重新根据自己欲修改的信息$m’$得到$sgn_d(m’)$再发给Bob) which the RSA assumpltion rules out.</p><p><strong>Homomorphic Property</strong></p><p>Alice signs $m_1, m_2$ and sends $sgn_d (m_1) = m_1^d, sgn_d (m_2) = m_2^d$ to Bob.</p><p>Charlie knows $m_1^d$ and $m_2^d$, so he comptues $(m_1m_2)^d$.</p><p>$\forall m_1, m_2, sgn_d(m_1) \cdot sgn_d(m_2) = sgn_d (m_1 \cdot m_2)$</p><p><strong>Simple and important:</strong> Never sign a message $m$. Always sign $hash (m)$.</p><p>这么说是因为Charlie肯定能得到$sgn_d (m_1 \cdot m_2)$，我们需要保证他得到的东西必须是个garbage message，故要sign $hash (m)$而不是$m$。</p><h2 id="Lecture-8-Transactions-and-Double-spending"><a href="#Lecture-8-Transactions-and-Double-spending" class="headerlink" title="Lecture 8: Transactions and Double-spending"></a>Lecture 8: Transactions and Double-spending</h2><p>现在将上面讲的两个做一个整合。还是假设Alice send to Bob，中间有Eve和Charlie分别劫持message和digital signature</p><p>![image-20230305201636691](/Users/colythme/Library/Application Support/typora-user-images/image-20230305201636691.png)</p><p>Alice wants to send $m$ o Bob:</p><ul><li>Alice computes the signature $s = sgn_{d_2} (hash (m))$</li><li>Alice encrypts $(s, m)$ to obtain $x = Enc_{e_3} (s, m)$ and sends $x$ to Bob</li><li>Bob decrypts $x$ to get $Dec_{d_3}(x) = (s, m)$</li><li>Bob verifies Alice’s signature by checking if $\overline{ver_{e2} (s)}$ equals to $hash (m)$</li></ul><h3 id="Creating-a-Cryptocurrency-Public-Keys-as-Identities"><a href="#Creating-a-Cryptocurrency-Public-Keys-as-Identities" class="headerlink" title="Creating a Cryptocurrency (Public Keys as Identities)"></a>Creating a Cryptocurrency (Public Keys as Identities)</h3><p>Creating an account = generating keys $(e, d)$</p><p>$e$ = my public identity</p><p>$d$ = used for signatures</p><h4 id="Make-Transactions"><a href="#Make-Transactions" class="headerlink" title="Make Transactions"></a>Make Transactions</h4><p>Required information:</p><ul><li>Sender’s identity = pubic key</li><li>Recipient’s identity</li><li>Amount</li><li>Proof of ownership <strong>(hash pointer to the transaction that paid sender)</strong> 来证明sender有足够的钱来做transaction</li><li>Proof of consent <strong>(signature from the sender)</strong> 证明sender确认转账</li></ul><p>![image-20230305203624263](/Users/colythme/Library/Application Support/typora-user-images/image-20230305203624263.png)</p><h4 id="How-to-verify-a-transaction"><a href="#How-to-verify-a-transaction" class="headerlink" title="How to verify a transaction?"></a>How to verify a transaction?</h4><p><em>Assumption: Everyone knows what the previous transactions were.</em></p><ul><li>Verify the signature to make sure Tx is approved by the sender</li><li>Check identities of all inputs of Tx</li><li>The amount of money counted by the inputs should be greater than the amount counted by the outputs.</li><li><strong>Every output can be spent at most once</strong></li></ul><h3 id="Double-Spending"><a href="#Double-Spending" class="headerlink" title="Double Spending"></a>Double Spending</h3><h2 id="Lecture-9-A-Centralized-Ledger"><a href="#Lecture-9-A-Centralized-Ledger" class="headerlink" title="Lecture 9: A Centralized Ledger"></a>Lecture 9: A Centralized Ledger</h2><p>double spending affects consensus，因为我们不知道对方到底可不可信。</p><p>那么结局这个consensus问题的最简单的方法当然就是有一个centralized的entity，那么大家信任这个entity就好了。</p><p>There is a central bank B which keeps track of the history of all the transactions and also publishes it.</p><p>为了接下来实现decentralized，Let’s first try somehow limit the power of centralizd bank.</p><p>Group our tansactions into bunch of blocks, i.e., block: a sequence(有order) of Txs of size at most $b$ (one million bites).</p><p>每个后面的block有个hash pointer to the previous block.</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230308211108886.png" alt="image-20230308211108886" style="zoom:25%;" /><p>When the bank has enough Txs, it creates a new block, it has a lot of Txs in it, and a pointer to the previous block. 那么我们会存在以下问题，以及解决方法。</p><ul><li>How to know if some block $B_i$ was created by the central bank? (<em>ANS:</em> The bank signs every block, i.e., everyone should know the bank’s public key s.t. everyone can check if the blocks were created)</li><li>How to make sure the bank does not change the history? (<em>ANS:</em> If the bank want to change sth in the block 1, then everything will change until the very last one. 所以这是bank不能change的保证。)</li><li>What is the history of Txs? What Txs has taken place? (<em>ANS:</em> Any Tx in the chain is considered to be already processed / done / finalized)</li></ul><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230314203557813.png" alt="image-20230314203557813" style="zoom:50%;" /><h5 id="Viewpoint-of-a-user"><a href="#Viewpoint-of-a-user" class="headerlink" title="Viewpoint of a user:"></a><em>Viewpoint of a user:</em></h5><ul><li>Form a Tx (参考Lec8)</li><li>Publish Tx (Send Tx to all of my neighbours)</li><li>Wait until the Tx gets into the blockchain (wait and listen for new blocks)</li></ul><p><strong>The Tx is finalized when I see a valid block containing the Tx.</strong></p><h5 id="Viewpoint-of-a-node"><a href="#Viewpoint-of-a-node" class="headerlink" title="Viewpoint of a node:"></a><em>Viewpoint of a node:</em></h5><ul><li><p>Keep track of the blockchain</p></li><li><p>Listen for Txs and blocks</p><ul><li>Case 1: If I hear a <strong>new</strong> Tx (not process the same Tx twice)<ul><li>Check the validity of the Tx (<strong>This check applies to everyone except the bank</strong>)<ul><li>Pass signature verification (Anyone who’s sending some money in this Tx should have signed this Tx)</li><li>The sum of inputs in the Tx should $\ge$ output</li><li>No double spending (There is no coin/input that is spent in this Tx and also in another Tx that is on the blockchain)</li></ul></li><li>If Tx is valid, send it to all neighbours</li></ul></li><li>Case 2: If I hear a block $B_i$<ul><li>Check the validity of $B_i$<ul><li>Verify bank signature (if it is signed by the bank)</li><li>Validate every Tx in $B_i$ w.r.t $B_0, …, B_{i - 1}$ and previous Txs in $B_i$ (比如看看跟之前block里的有没有double spending)</li><li>$B_i$ points to $B_{i - 1}$</li></ul></li><li>If $B_i$ is valid<ul><li>Add it to my blockchain</li><li>Send it to neighbours</li></ul></li></ul></li></ul></li></ul><h5 id="Viewpoint-of-the-bank"><a href="#Viewpoint-of-the-bank" class="headerlink" title="Viewpoint of the bank"></a><em>Viewpoint of the bank</em></h5><ul><li><p>Maintain a copy of the blockchain $B_0, …, B_{i - 1}$</p></li><li><p>Maintain a new block $B_i$</p></li><li><p>Listen for Txs</p><p>  When I hear a Tx</p><ul><li><p>Verify the Tx w.r.t. $B_0, …, B_{i - 1}, B_i$</p><p>  If Tx is valid then $B_i \leftarrow B_i \cup \{\text{Tx}\}$ (add Tx to $B_i$)</p><p>When $B_i$ is large enough (has enough Tx in it)</p></li><li><p>Make $B_i$ point to $B_{i - 1}$</p></li><li><p>Sign $B_i$</p></li><li><p>Publish $B_i$ with signature</p></li></ul></li></ul><h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><ul><li>I don’t need to disclose my identity. I only need to create an account (a public and private key pair). Then just make Tx using this account.</li><li>不需要直接与bank communicate，因为你可以随便给人发Tx的信息然后他们继续向neighbour发送最终都会reach the bank.</li><li>Bank cannot create Tx invalid或者挪用你的coin，因为如果bank想spend coin，必须要有valid signature喝valid Tx，但是这些只有你本人有权利发布</li></ul><p>那么有个最原始的问题，最开始的coin是哪里来的？</p><p>所以我们需要给bank ability to create money. 这也是为什么上面viewpoint of node case 1 Check the validity of the Tx后面有括号补充的原因</p><h2 id="Lecture-10-Bitcoin-and-Proof-of-Work"><a href="#Lecture-10-Bitcoin-and-Proof-of-Work" class="headerlink" title="Lecture 10: Bitcoin and Proof of Work"></a>Lecture 10: Bitcoin and Proof of Work</h2><p>The central bank’s power in centralized ledger:</p><ul><li>Extend the blockchain</li><li>Print money</li></ul><hr><h3 id="Decentralization"><a href="#Decentralization" class="headerlink" title="Decentralization"></a>Decentralization</h3><blockquote><p>Every node has the same permissions.</p></blockquote><h4 id="How-to-extend-the-chain-while-preserving-consensus-for-honest-nodes"><a href="#How-to-extend-the-chain-while-preserving-consensus-for-honest-nodes" class="headerlink" title="How to extend the chain, while preserving consensus for honest nodes?"></a>How to extend the chain, while preserving consensus for honest nodes?</h4><blockquote><p>Extend the chain: <strong>Mining</strong></p><p>Person who extends the chain: <strong>Miner</strong></p></blockquote><p>这边我们不考虑fairness，只考虑consensus，即是不是chain上所有人都认可新加的block。</p><p>Method: Ask everyone to solve a really hard mathematical puzzle, the first one who solves is able to add it. 这叫做 <strong>Proof of work</strong></p><h5 id="Property-1"><a href="#Property-1" class="headerlink" title="Property"></a>Property</h5><ul><li>Hard to solve</li><li>Easy to verify</li><li>Impossible to steal (比如我再通知我neighbor的时候不会让他们知道solution以至于steal我的sol来说新block是他们的)</li></ul><p>那么如何得到第三个property呢？</p><h4 id="Hash-based-Proof-of-Work-PoW"><a href="#Hash-based-Proof-of-Work-PoW" class="headerlink" title="Hash-based Proof of Work (PoW)"></a>Hash-based Proof of Work (PoW)</h4><p>Structure of a block (what does it contain)</p><ul><li>Number (ID)</li><li>Pointer to the previous block ($prevB$)</li><li>Transactions (以Merkle Tree形式储存)</li><li>Nonce (A number that is chosen by the <em>miner</em>)</li></ul><p>For B to be valid $h(B)$ should be small, e.g., $h(B) = 0000…0…$ 最少60个0.</p><p>所以实际上，这个puzzle就是你怎么找到一个nonce，使得$h(B)$很小，而当你找出来后publish你的block，别人是能通过你的nonce验证的。而实际上，你的$hash (B)$ hash的是你的block，即你的number, prevB, Txs, etc..，所以别人在里面这些参数不同的情况下，是没法steal你的nonce来encode他们的block使得hash value很小的。这也就满足了第三条性质。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230326212009190.png" alt="image-20230326212009190" style="zoom:30%;" /><h4 id="How-the-whole-protocol-works"><a href="#How-the-whole-protocol-works" class="headerlink" title="How the whole protocol works"></a>How the whole protocol works</h4><ul><li>Every node is equal (decentralization)<ul><li>Everyone can be a transactor: Create new transactions (<strong>exactly as in centralized ledger (CL)</strong>)</li><li>Everyone is a node on the network</li><li>Everyone can be a miner: Create new blocks (<strong>does anything the central bank does, and at the same time do PoW</strong>)</li></ul></li></ul><h4 id="Viewpoint-of-nodes"><a href="#Viewpoint-of-nodes" class="headerlink" title="Viewpoint of nodes"></a>Viewpoint of nodes</h4><p><em>A node keeps track of</em></p><ul><li>Blockchain</li><li>Mempool (the set of all valid Txs I have seen now, but have not been published to the blockchain (not finalized))</li></ul><p><em>If the node hears a new Tx</em></p><ul><li><p>Verify its validity</p><ul><li>Verify signatrues</li><li>Verify if $\sum inpts \ge \sum outputs$</li><li>Verify no double-spending w.r.t. the blockchain &amp; <strong>mempool</strong></li></ul></li><li><p>If Tx is valid</p><ul><li><p>Send Tx to all neighbours</p></li><li><p>Add Tx to mempool</p></li></ul></li></ul><p><em>If the node hears a new block $B$</em></p><ul><li>Verify the validity of $B$<ul><li>$h(B)$ is smaller than $d$</li><li>All Txs in $B$ are valid<ul><li>Signatures</li><li>$\sum inputs \ge \sum output$</li><li>No double-spending w.r.t. blockchain $\cup$ $B$ (no mempool，因为mempool的是没有finalized的，所以我们可以允许这个miner在这种情况下double-spending，即在blockchain上发布一个新的block) </li></ul></li></ul></li><li>If the block is valid<ul><li>Add it to blockchain (my own copy of blockchain)</li><li>Update my mempool</li><li>Send $B$ to all neighbours</li></ul></li></ul><h3 id="What-happens-if-two-valid-blocks-are-found-at-approximately-the-same-time"><a href="#What-happens-if-two-valid-blocks-are-found-at-approximately-the-same-time" class="headerlink" title="What happens if two valid blocks are found at approximately the same time?"></a>What happens if two valid blocks are found at approximately the same time?</h3><blockquote><p>这个situation也被称作<strong><em>fork</em></strong></p></blockquote><p>Consensus rule of bitcoin:</p><ul><li>Miners get to choose which chain to extend</li><li>取最长的链作为正确的链</li></ul><p>所以实际上一个node会keep track of <strong>all valid forks</strong></p><h2 id="Lecture-11-Mining-Rewards-and-Forks"><a href="#Lecture-11-Mining-Rewards-and-Forks" class="headerlink" title="Lecture 11: Mining Rewards and Forks"></a>Lecture 11: Mining Rewards and Forks</h2><h3 id="How-to-cerate-new-units-of-currency"><a href="#How-to-cerate-new-units-of-currency" class="headerlink" title="How to cerate new units of currency"></a>How to cerate new units of currency</h3><h3 id="Why-should-anyone-be-a-miner"><a href="#Why-should-anyone-be-a-miner" class="headerlink" title="Why should anyone be a miner"></a>Why should anyone be a miner</h3><blockquote><p><strong>Block rewards</strong>: Any valid block can include a transasction that has no input and a single output paying the miner</p><p>比如block reward = 25 BTC</p></blockquote><p>In bitcoin, the block reward gets halved after every 210000 blocks (~ 4 years). 这可以control the amount of bitcoin currency以防止他不是无限膨胀的。</p><h3 id="Why-should-a-miner-mines-a-non-empty-block"><a href="#Why-should-a-miner-mines-a-non-empty-block" class="headerlink" title="Why should a miner mines a non-empty block"></a>Why should a miner mines a non-empty block</h3><p>作为一个miner，我可以只mine empty block to obtain block rewards</p><h4 id="Transaction-fees-可以理解为手续费"><a href="#Transaction-fees-可以理解为手续费" class="headerlink" title="Transaction fees (可以理解为手续费)"></a>Transaction fees (可以理解为手续费)</h4><ul><li>In every valid Tx, $\sum inputs \ge \sum outputs$</li><li>The difference $\sum inputs - \sum outputs$ is paid to the miner <strong>who adds this Tx to the blockchain</strong> as a transaction fee</li></ul><blockquote><p>If you want to add your Tx sooner to the blockchain, pay more Tx fees</p></blockquote><p>In Bitcoin, each block is at most $10^6$ bytes 来防止在run protocol时出现delay。</p><p>所以有了size的限制以及transaction fee的竞争，我在通过mining获得了block rewards后能够大概率保证让它上链的最佳办法就是pay more transaction fees</p><blockquote><p>Question: <em>What if the block created by a miner is not in the longest chain, will the miner still gets rewards?</em></p><p>Answer: <em>No. Any Tx outside the consensus chain is ignored.</em></p></blockquote><h3 id="Double-spending-attack"><a href="#Double-spending-attack" class="headerlink" title="Double-spending attack"></a>Double-spending attack</h3><p>Scenario: Suppose a bitcoin-based vending machine (bitcoin-based自动售货机)</p><ul><li>Merchant provides their identity (public key)</li><li>Customer creates a Tx paying the merchant</li><li>Customer gives Tx to the merchant</li><li>Merchant verifies the validity of the Tx<ul><li>If valid<ul><li>Publish Tx</li><li>Provide item</li></ul></li></ul></li></ul><p>但里面有些问题：</p><h4 id="First-attack-Immediate-double-spending"><a href="#First-attack-Immediate-double-spending" class="headerlink" title="First attack: Immediate double-spending"></a><em>First attack:</em> Immediate double-spending</h4><p>Suppose a Tx on blockchain, which pays 1 BTC to Alice. Now Alice creates a new Tx $Tx_1$, and takes the 1 BTC as the input of $Tx_1$, and set output as 0.99 BTC (不可能是1，因为有Tx fee) to the vending machine. Suppose now she creates another $Tx_2$ immediately and uses the same input, and pay 0.95 BTC to Alice (herself). 比如这两个Tx是在不同地方发生的，比如HK和US，那么可能HK的人先看见$Tx_1$，但是US的人先看见$Tx_2$，那么这笔double-spending可能就会成功</p><p>If the miner includes $Tx_2$ in a block, then the attck will be successful.</p><p>另一种更聪明的方法是Alice can bribe the miner to increase her chances，即让$Tx_2$的Tx fee更高，而这笔钱是付给其他miner的。</p><h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h5><p>Wait for $Tx_1$ to be mined (added to the blockchain)</p><h4 id="Second-attack-Double-spending-in-a-fork"><a href="#Second-attack-Double-spending-in-a-fork" class="headerlink" title="Second attack: Double-spending in a fork"></a><em>Second attack:</em> Double-spending in a fork</h4><p>这时用上面的方法就行不通了，因为如果我要等$Tx_1$被finalized，就需要等下一个block be mined to contruct a longer chain。然而这个时间可能会是10min甚至更久，而vending machine要的就是实时付款实时交货，所以不可行。</p><h5 id="What-the-merchant-sees"><a href="#What-the-merchant-sees" class="headerlink" title="What the merchant sees"></a>What the merchant sees</h5><ul><li>$Tx_1$ that is paying merchant</li><li>Wait for almost 10 min until a block in the blockchain that contains $Tx_1$</li></ul><p>那么问题来了，some blocks can be reverted (it used to be in the consensus chain, but now no longer in) and $Tx_1$ might be removed from the consensus chain</p><h5 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h5><p>Wait for confirmation (一般来讲是6 confirmations)</p><p>这里的confirmation指的是比如$B_n$是要pay给我的那个Tx，它的后继有一个新的block added，那么这个新的block就相当于一个confirmation，因为它认可了$B_n$作为the last block的地位；如果后面又接了一个block，那么就是second confirmation…</p><p>但这样就需要等待~ 1h了。所以vending machine并不适合bitcoin。</p><h3 id="Adjusting-difficulty"><a href="#Adjusting-difficulty" class="headerlink" title="Adjusting difficulty"></a>Adjusting difficulty</h3><blockquote><p>In Bitcoin, a new block is mined ~ 10 minutes</p></blockquote><p>PoW: Find a valid block $B$ s.t. $h(B) \le d$</p><p>Suppose a hash function $h: \sum^* \rightarrow \sum^{256}$</p><p>Let’s assume $h$ behaves like a uniformly randomed function</p><p>What is a miner’s success probability if they try $k$ blocks?</p><p>Every time I have a prob of $\frac{d}{2^{256}} \ge \frac{kd}{2^{256}}$ to succeed</p><p>那么try $k$次成功的概率就是$1 - (1 - \frac{d}{2^{256}})^k$</p><p>Now, here’s the thing. I can dynamically change the number $d$ 来让我的problem变得harder</p><p>All Bitcoin blocks have a timestamp。太久远或者未来的timestamp就不用管了</p><p>然后我根据这些timestamps选出最近的1000个，find the avg mining time $\mu$</p><ul><li>If $\mu &gt; 10$, increase $d$, decrease difficulty</li><li>If $\mu &lt; 10$, decrease $d$, increase difficulty</li></ul><p>从而保证期望新增一个block的时间是10min</p><h2 id="Lecture-12-Centralization-and-Scripts"><a href="#Lecture-12-Centralization-and-Scripts" class="headerlink" title="Lecture 12: Centralization and Scripts"></a>Lecture 12: Centralization and Scripts</h2><h3 id="Bitcoin’s-honesty-assumption"><a href="#Bitcoin’s-honesty-assumption" class="headerlink" title="Bitcoin’s honesty assumption"></a>Bitcoin’s honesty assumption</h3><blockquote><p>Majority of the computational power is honest</p></blockquote><h4 id="What-if-the-assumption-does-not-hold"><a href="#What-if-the-assumption-does-not-hold" class="headerlink" title="What if the assumption does not hold?"></a>What if the assumption does not hold?</h4><p><em>Imagine a malicious miner with more than half of the hash power</em></p><p>Suppose block B1 &lt;- B2 &lt;- B3</p><p>假如我是个honest miner，那么我会extend B3。反之，若是malicious，我会extend B2，并让这个dishonest chain不断延长，使得B3不复存在</p><p>那么现在因为我有more than half of the hash power，所以我有能力做到作假</p><p>这种attack方式叫做51% attack</p><p>own more than 50% computational power的另一种作弊的方法: Double-spending，本质上和上面的是差不多的，</p><hr><h3 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h3><p>Tx:</p><p>Input:</p><ul><li>Value &amp; <strong>parameters(Scripts) to spend the coins</strong> (与下面的conditions to use coins对应)</li></ul><p>Output:</p><ul><li>Value &amp; <strong>Conditions(Scripts) to use these coins</strong> (比如condition可以是require signs from A &amp; B，就是加一些使用条件)</li><li></li></ul><h4 id="Micropayments-Scripts的用处"><a href="#Micropayments-Scripts的用处" class="headerlink" title="Micropayments (Scripts的用处)"></a>Micropayments (Scripts的用处)</h4><blockquote><p>Scenario:</p><p>Alice is a customer &amp; Bob is a mobile network</p><p>Alice makes a phone call and pays 0.1 HKD per min</p><p>Neither side trusts the other</p><p>Alice does not trust Bob, she wants service first</p><p>Bob does not trust Alice, he wants payment first</p><p>且我们不想pay every minute，即不想有很多的transaction</p></blockquote><ul><li><p>Alice puts down a deposit of 100 HKD，现在她不想直接付钱</p><p>  She creates a Tx1, putting 100 HKD as input, and an output of 100 HKD (conditions: needs signatures from both Alice &amp; Bob)</p><p>  The Alice publishes the block to the blockchain. And wait until it is completely on the blockchain.</p></li><li><p>Alice starts her phone call。但是要能打Alice必须先pay 1 HKD</p><p>  那么现在Alice将Tx1的output连到一个新的block，并给Tx1签名，这个block的output有两个: 1 HKD to Bob &amp; 99 HKD to Alice。</p><p>  到了second minute，Alice再create一个new Tx，taking the same deposit as input, but paying 2 HKD to Bob &amp; 98 HKD to Alice。</p><p>  以此类推</p><p>  上面的Tx目前都是invalid的，但是只要Bob给Tx1签名，再选择一个出来的block publish，就可以收到钱了。当然，假如Alice打了k分钟电话，那么Bob选的肯定是第k个block。因为如果Bob cheat publish多个，那就是double-spending。</p></li><li><p>Bob signs the last Tx and publishes it to the blockchain</p></li></ul><p>但是上述protocol有一个问题，就是在Alice publish Tx1后，她的这100 HKD实际上是被locked的，也就是说，只要Bob不签名，她这100 HKD就相当于存进去取不出来了。所以此时Bob就有机会去extort Alice，threaten她说如果你不给我50 HKD，then I’ll not sign any of these transactions，让她的钱被永久冻结。</p><p>解决方法是在最开始的condition那儿加上一句(<strong>or signature from Alice and block number &gt; $c$</strong>)，即多少天后</p><h2 id="Lecture-13-Two-way-Payment-Channels"><a href="#Lecture-13-Two-way-Payment-Channels" class="headerlink" title="Lecture 13: Two-way Payment Channels"></a>Lecture 13: Two-way Payment Channels</h2><h3 id="One-way-Payment-Channel"><a href="#One-way-Payment-Channel" class="headerlink" title="One-way Payment Channel"></a>One-way Payment Channel</h3><ul><li><p>Alice publishes $Tx_1$</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419160840029.png" alt="image-20230419160840029" style="zoom:33%;" /><p>  右上角是timeline，$Tx_0$ 是Alice发起transaction的时间，被括弧框住的时间区间是Alice能pay Bob的时间，最后的 $t$ 就是Bob经过这么长的时间不sign不accept，Alice把自己的钱收回来的时间。</p><p>  那么Bob的ddl和 $t$ 之前的时间段又代表着什么呢？它代表着Bob publishes the last transaction but still waiting for the confirmation。</p></li><li><p>Alice creates a series of $Tx_1$ which takes the output of $Tx_0$ as input, and output 1 unit to Bob &amp; 99 unit back to Alice</p><p>  Alice creates and signs $Tx_1$ and sends it to Bob. 其他unit to Bob以此类推</p></li><li><p>Bob signs $Tx_k$ and publishes it on the network (and finalized on the blockchain)</p></li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><p>Money flows in one direction (Alice $\rightarrow$ Bob)</p><p>  Alice can only increase the total payment to Bob (因为Bob总会选择自己获益最大的那个block)</p></li><li><p>Bob can close the channel</p></li><li><p>The channel expires at time $t$</p></li><li><p>The channel has a fixed capacity</p></li></ul><p>Only two Txs are added to the blockchain $\Rightarrow$ only two Tx fees paid for $k$ payments</p><p>Payments are instant，原因是对于Alice，我构造出了$Tx_0$之后只需要直接sign，然后再构造出$Tx_1, Tx_2, …$，之后就不用管了，是instant就可以结束了；对于Bob，我也是直接sign一个新构造的block就可以了。</p><h3 id="Two-way-Payment-Channel"><a href="#Two-way-Payment-Channel" class="headerlink" title="Two-way Payment Channel"></a>Two-way Payment Channel</h3><p>Scenerio: Alice &amp; Bob are friends，他们直接经常需要进行transaction，并且不想每次都pay transaction fee。</p><h4 id="Simple-Solution"><a href="#Simple-Solution" class="headerlink" title="Simple Solution"></a>Simple Solution</h4><ul><li>Create two one-way channels (Alice $\rightarrow$ Bob &amp; Bob $\rightarrow$ Alice)</li></ul><p>但是这样有几个问题：</p><ul><li><p>Alice can only increase the total payment to Bob</p></li><li><p>A created channel has a capacity</p><p>  比如说，Alice creates a block跟上面的 $Tx_0$ 一样，那么他的capacity就是100 (100 + 1，其中1是transaction fee)，因为这钱花完了就没了，除非你重新给$Tx_k$接入一个新的input，那么这又需要重新构造新的block。</p></li></ul><h4 id="Second-Attempt-Let-money-flow-in-both-directions"><a href="#Second-Attempt-Let-money-flow-in-both-directions" class="headerlink" title="Second Attempt: Let money flow in both directions"></a>Second Attempt: Let money flow in both directions</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419163640145.png" alt="image-20230419163640145" style="zoom:33%;" /><p>如果Bob cheat就触发后面的$\text{Alice} \cap c$，降钱还给Alice，没有的话就正常给Bob after time $t$。</p><p>那么proof $c$怎么生成呢？</p><p>Here the <em>cheat</em> means Bob has published $Tx_i$ but $\exist Tx_j, j &gt; i$ that pays less to Bob，即他publish的不是最后的block，因为最后的block总是代表着Alice要给Bob钱数的最终想法。</p><p>Change in protocol: Bob has to sign the index of every transaction, and sends the signatures to Alice。其中index指的是上图每个block中间的小方框中的 $1, 2, 3, …$</p><p>那么此时，$c = $ Bob’s signature on an index $&gt;$ current transaction’s index</p><h4 id="One-way-Channel-with-Refunds"><a href="#One-way-Channel-with-Refunds" class="headerlink" title="One-way Channel with Refunds"></a>One-way Channel with Refunds</h4><ul><li><p>Alice puts down a deposit</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419165019587.png" alt="image-20230419165019587" style="zoom:33%;" /></li><li><p>When Alice wants to pay Bob</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419165209448.png" alt="image-20230419165209448" style="zoom:33%;" /></li><li><p>When Bob wants to refund</p>  <img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419165511810.png" alt="image-20230419165511810" style="zoom:33%;" /></li></ul><h4 id="Two-way-Channel"><a href="#Two-way-Channel" class="headerlink" title="Two-way Channel"></a>Two-way Channel</h4><p>Alice creates a one-way channel with refunds $c_1$ to Bob ($\text{Alice} \rightarrow \text{Bob}$)</p><p>Bob creates a one-way channel with refunds $c_2$ to Alice ($\text{Bob} \rightarrow \text{Alice}$)</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419170639721.png" alt="image-20230419170639721" style="zoom:33%;" /><p>可以发现上面的操作只需要一个操作create a block，跟之前的比起来好很多</p><h2 id="Lecture-15-Escrows-and-Ethereum-like-Smart-Contracts"><a href="#Lecture-15-Escrows-and-Ethereum-like-Smart-Contracts" class="headerlink" title="Lecture 15: Escrows and Ethereum-like Smart Contracts"></a>Lecture 15: Escrows and Ethereum-like Smart Contracts</h2><p>Scenario: Alice wants to buy a physical good from Bob and pay BTC, and they do not trust each other</p><p>Awful solution: Use a third-party Carol</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419205936577.png" alt="image-20230419205936577" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419210002349.png" alt="image-20230419210002349" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419210026542.png" alt="image-20230419210026542" style="zoom:33%;" /><p>Problem: Bribery</p><p>A rational Carol signs and publishes $Tx_m$ (You are rational iff you only care about maximizing your own payoff)</p><p>存在这个问题的话，我们也无法信任Carol。</p><h4 id="Next-step-Remove-Carol-from-the-protocol"><a href="#Next-step-Remove-Carol-from-the-protocol" class="headerlink" title="Next step: Remove Carol from the protocol"></a>Next step: Remove Carol from the protocol</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419213947435.png" alt="image-20230419213947435" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419215157440.png" alt="image-20230419215157440" style="zoom:33%;" /><p>因为Bob可以wait for Alice to put down the deposit and don’t send the item，之后跟Alice说我可以不sign，那么你就会lose 100 ETH，以此来进行extortion。</p><p>所以我们需要两边都put down deposits</p><h4 id="Solution-Change-the-deposit-Tx"><a href="#Solution-Change-the-deposit-Tx" class="headerlink" title="Solution: Change the deposit $Tx$"></a>Solution: Change the deposit $Tx$</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230419223414654.png" alt="image-20230419223414654" style="zoom:33%;" /><p>这个方法叫做bithalo</p><h3 id="Problem-with-Bitcoin-Scripts"><a href="#Problem-with-Bitcoin-Scripts" class="headerlink" title="Problem with Bitcoin Scripts"></a>Problem with Bitcoin Scripts</h3><ul><li>Scripts are attached to outputs</li><li>Limited language<ul><li>complete and unambiguous semantics</li><li>All scripts must terminate in $O (1)$</li><li>Bitcoin miners have script whitelists</li></ul></li></ul><h3 id="Ethereum-like-Smart-Contract"><a href="#Ethereum-like-Smart-Contract" class="headerlink" title="Ethereum-like Smart Contract"></a>Ethereum-like Smart Contract</h3><p>The consensus in bitcoin is on a sequence of transactions</p><p>Let Txs do moreL</p><ul><li><p>Deploy a program (i.e., smart contract)</p><p>  The code now reaches consensus, and now everyone knows what exactly my code was</p><p>  <em>data:</em> program’s code</p></li><li><p>Invoke functions of a previously-deployed smart contract</p><p>  <em>data:</em></p><ul><li>pointer to the contract</li><li>function name $f$</li><li>parameters of $f$</li></ul></li></ul><p><strong>Every contract can receive and manage money</strong></p><h2 id="Lecture-14-Basics-of-Solidity-and-Ethereum-Smart-Contracts"><a href="#Lecture-14-Basics-of-Solidity-and-Ethereum-Smart-Contracts" class="headerlink" title="Lecture 14: Basics of Solidity and Ethereum Smart Contracts"></a>Lecture 14: Basics of Solidity and Ethereum Smart Contracts</h2><h3 id="Gas-amp-Fees"><a href="#Gas-amp-Fees" class="headerlink" title="Gas &amp; Fees"></a>Gas &amp; Fees</h3><p>这个东西的出现是因为可能会出现以下的情况，</p><p>一个malicious actor写了一个never terminate的function，并且publish到了blockchain，且让一个block去invoke它，让它形成consensus，那么此时chain上的所有人都得一个个function调用，总是会调用到这个导致never terminate，从而cause a denial of service attack</p><blockquote><p>Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the Ethereum network.</p></blockquote><p>它实际上就是一个约束，你的function运行时间越长，你的transaction fee要交的越多</p><h2 id="Lecture-19-Secret-Sharing"><a href="#Lecture-19-Secret-Sharing" class="headerlink" title="Lecture 19: Secret Sharing"></a>Lecture 19: Secret Sharing</h2><h3 id="Commitment-Schemes"><a href="#Commitment-Schemes" class="headerlink" title="Commitment Schemes"></a>Commitment Schemes</h3><p>A <strong>commitment scheme</strong> is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later.</p><p>下面来讲解几个commitment schemes的用的area</p><h4 id="Random-Number-Genenration"><a href="#Random-Number-Genenration" class="headerlink" title="Random Number Genenration"></a>Random Number Genenration</h4><ul><li><strong>Phase 1:</strong> Player $i$ first commits to the hash of $r_i$. i.e., $h (r_i)$, and wait for other players to commit</li><li><strong>Phase 2:</strong> Player $i$ reveals $r_i$</li><li>Output random number $r = \oplus_{i = 1}^n r_i$</li></ul><p><em>Problem:</em></p><ul><li><p>It is in an honest player’s best interest not to reveal their value $r_i$ in phase 1</p></li><li><p>What if a malicious player does not reveal in phase 2?</p><p>改进版:</p></li><li><p><strong>Phase 1:</strong> Player $i$ first commits to the hash of $r_i$. i.e., $h (r_i)$ <strong>and pay a deposit $d_i$</strong>, and wait for other players to commit</p></li><li><p><strong>Phase 2:</strong> Player $i$ reveals $r_i$, <strong>if he does not reveal then he will lose the deposit</strong></p></li><li><p>Output random number $r = \oplus_{i = 1}^n r_i$</p></li></ul><p>而且我们要保证的是malicious player lose的比可能win的多，否则他会选择这局放弃deposit然后restart，在下一局赚回来，或是继续重复restart，直到赚回钱, i.e., $d &gt; \sum tickets$</p><p> 我们可以发现，这一切extortion的源头都是因为总是回存在一个人在别人后面publish，即不是simultaneous的。所以commitment schemes实际上就是在simulate simultaneous information publishment</p><p>但是实际上，commitment scheme是有弱点的，在对方，Bob intentionally leak他自己的choice的时候，commitment scheme就失去了意义，他仍然可以extort Alice。这个跟Escrow的例子是一样的</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230503172145567.png" alt="image-20230503172145567" style="zoom:33%;" /><p>在这个例子中，Alice deposit 2 ETH，Bob deposit 1 ETH，Bob claim他已经把货发给了Alice，即 $r_i = fulfilled$，但实际上没有。他就此extort Alice。如果Alice接受extortion，她会get 1 ETH back，Bob得到2 ETH。反之，Alice gets nothing back，Bob也gets nothing back。作为一个rational player，Alice会accept extortion。</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230503172342907.png" alt="image-20230503172342907" style="zoom:33%;" /><hr><h3 id="Random-Number-Generation"><a href="#Random-Number-Generation" class="headerlink" title="Random Number Generation"></a>Random Number Generation</h3><p>Main flaw(缺陷): A player can choose not to reveal</p><p>Solution: Design a protocol in which $r_i$ is revealed even if player $i$ doesn’t want to</p><h4 id="Secret-Sharing"><a href="#Secret-Sharing" class="headerlink" title="Secret Sharing"></a>Secret Sharing</h4><p>Alice has a secret $s \in [0, p)$, $p$ 是模数</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230503173816709.png" alt="image-20230503173816709" style="zoom:33%;" /><p><strong>注意这里需要学习拉格朗日插值</strong></p><p>我们可以发现拉格朗日插值和我们要的结果很像，就是我们能够根据 $t$ 个information构建一个polynomial，但是 $t - 1$ 个就不行</p><p>所以一个很直接的想法就是，Alice可以把她的secret encode成coefficients of the polynomial</p><ul><li><p>Alice creates a polynomial $g$ of degree $t -1$</p><p>  $g(x) = a_0 + a_1x + … + a_{t - 1}x^{t - 1}$</p><p>  $a_0 = g (0) = s$, $a_1, a_2, …$ chosen randomly</p></li><li><p>Alice computes $s_i = g (i)$ and gives it to $f_i$</p></li></ul><p>现在回到原来的问题，怎么样才能让别人能够compute $r_i$呢</p><p>一个方法便是，在你choose你的 $r_i$ 的时候你也必须要告诉别人你的share of $r_i$，这样若你refuse to reveal，别人也能够compute your $r_i$</p><p>所以，overall的方法便是，(首先假设everyone knows a prime number $p$)</p><ul><li><p>Players sign up with smart contract and pay deposit $d$</p><p>  Assume $n$ people sign up</p></li><li><p>Each player $i$ chooses $r_i$</p><p>  Player $i$ forms $g_i$ of degree $t - 1$ and gives shares to everyone $j \neq i$</p></li><li><p>Player $i$ commits to $h (r_i, n_i)$ on the smart contract</p></li><li><p>Player $i$ reveals $r_i, n_i$</p></li><li><p>If a player $i$ fails to reveal, then other players come together and compute $r_i$</p></li><li><p>$r = \sum r_i \mod p$</p></li></ul><p>Constraints:</p><ul><li>At least $t$ honest players，不然没法计算出准确的 $r_i$</li><li>At most $t - 1$ dishonest players，若dishonest的players有大于等于 $t$ 个，那么他们就足以伪造一个 $r_i$</li></ul><blockquote><p>注意，在这种情况下，如果你想cheat，那么你不得不在phase 1进行cheat，但是此时you know nothing about $r$，所以cheating is pointless</p></blockquote><h2 id="Lecture-20-Random-Number-Generation-via-Verifiable-Delay-Functions"><a href="#Lecture-20-Random-Number-Generation-via-Verifiable-Delay-Functions" class="headerlink" title="Lecture 20: Random Number Generation via Verifiable Delay Functions"></a>Lecture 20: Random Number Generation via Verifiable Delay Functions</h2><p>Goal: Gneerate a random number $r = \{0, 1, …, n - 1\}$</p><p>Desired properties:</p><ul><li>Uniform Distribution: 只要我的任意一个player is honest并且给我generate了一个random number from uniform distribution，那么我最后计算得到的 $r$ 一定是from uniform distribution的</li><li>Tamper-resistance<ul><li>Commitment Scheme: Need deposits &gt; $\sum tickets$</li><li>Secret sharing: Need &gt; half of the players are honest</li></ul></li></ul><h4 id="Ideal-Protocol"><a href="#Ideal-Protocol" class="headerlink" title="Ideal Protocol"></a>Ideal Protocol</h4><ul><li>Phase 1: Every player $i$ chooses $r_i$ and computes $c_i = commit (r_i)$ and records it in smart contract + <strong>paying deposit $d$</strong></li><li>Phase 2: Every player $i$ reveals $r_i$ to the smart contract &amp; SC verifies that $c_i = commit (r_i)$</li><li>Phase 3: For every player $i$ who has not revealed $r_i$ other players can compute $r_i$</li></ul><h4 id="Properties-of-Commmit-hash-function"><a href="#Properties-of-Commmit-hash-function" class="headerlink" title="Properties of Commmit (hash function)"></a>Properties of Commmit (hash function)</h4><ul><li><p>Collision-free: It is impossible to find $x \neq y$ s.t. $commit (x) = commit (y)$</p></li><li><p><strong>Time-consuming</strong> to invert: Given a commitment $c_i = commit (r_i)$, it takes <strong>at least $T$ units of time no matter how many cores/threads you have</strong> to compute $r_i$</p><p>  假设我们phase 1 + phase 2总共加起来需要 $\frac{T}2$ 的时间，那么commit就可被视作无法被解密</p></li><li><p>Easy to compute</p></li></ul><p>但是你会发现有一个问题，就是实际上hash function不可能是one-to-one的，这就和time-consuming to invert冲突了，因为malicious player就可以在游戏开始前花费时间 $T$ 预先算好两个 $x, y$, s.t., $commit (x) = commit (y)$。那么在提交相同commit的情况下，第二次publish的结果却不同了</p><p>所以我们需要一个close to上述所有条件的function</p><hr><h3 id="VDF-Verifiable-Delay-Function"><a href="#VDF-Verifiable-Delay-Function" class="headerlink" title="VDF: Verifiable Delay Function"></a>VDF: Verifiable Delay Function</h3><ul><li><p>Evaluation function: $Eval (x) = (y, \pi)$，其中 $f(x) = y$，而 $\pi$ 指的是 the proof that shows $y$ is really $x$ 根据函数 $f$ 得到的hash结果</p><p>  <strong>Takes at least $T$ time</strong></p></li><li><p>Verification: $Verify (x, y, \pi) \rightarrow \{true, false\}$</p><p>  <strong>Fast</strong></p></li></ul><p>Uniqueness: $\forall x !\exist y \exist \pi, verify (x, y, \pi) = true$，这里 $!\exist$ 指的是exist exactly one</p><p>$\epsilon$-sequentiality: Given $x$ and spending $T (1 - \epsilon)$ time, you cannot find anything about $y$</p><hr><h3 id="VDF-Based-RNG"><a href="#VDF-Based-RNG" class="headerlink" title="VDF-Based RNG"></a>VDF-Based RNG</h3><ul><li>Phase 1: Every player $i$ submites $r_i$ to SC</li><li>Phase 2: $h = \sum r_i \mod n$</li><li>Phase 3: $r = VDF_T (h)$</li></ul><p>Phase 1 + Phase 2 = $\frac{T}{10}$ of time</p><ul><li>Phase 4: Someone submits $r$ and $\pi$ to the SC, then SC does $verify (h, r, \pi)$</li></ul><h2 id="Lecture-21-Mixing-and-Blind-Signatures"><a href="#Lecture-21-Mixing-and-Blind-Signatures" class="headerlink" title="Lecture 21: Mixing and Blind Signatures"></a>Lecture 21: Mixing and Blind Signatures</h2><p>Bitcoin identities are public keys &amp; not connected to real-world identity</p><p>But can someone find my real-world identity if I use bitcoin?</p><p>We need to answer some questions</p><ul><li>Where do I get my bitcoins?<ul><li>Mine —— Safe but not practical</li><li>Buy —— Leaks your real-world identity (you need to identify yourself through legal procedures to buy bitcoins)</li></ul></li><li>Where do I spend my bitcoins?<ul><li>When you pay you disclose<ul><li>Your public key</li><li>Your real-world identity (for example government asks you to do)</li></ul></li></ul></li><li>Why care?<ul><li>Even if one public key is leaked, all future Txs are deanonymized</li><li>Even if one public key is leaked, all past Txs are deanonymized</li></ul></li></ul><hr><h3 id="How-to-Keep-the-IDs-Private"><a href="#How-to-Keep-the-IDs-Private" class="headerlink" title="How to Keep the IDs Private?"></a>How to Keep the IDs Private?</h3><p>Break the link between your public key &amp; real-world ID</p><h4 id="First-Idea-Money-Landering"><a href="#First-Idea-Money-Landering" class="headerlink" title="First Idea: Money Landering"></a>First Idea: Money Landering</h4><p>Be chaotic:</p><ul><li>Create a lot of accounts</li><li>Randomly move money around</li></ul><blockquote><p>Gives you privacy w.r.t. small actors</p></blockquote><h4 id="Second-Idea-Use-a-Mixer"><a href="#Second-Idea-Use-a-Mixer" class="headerlink" title="Second Idea: Use a Mixer"></a>Second Idea: Use a Mixer</h4><p>Everyone can transfer money to the mixer. Pay in with the same amount, and the mixer pay to new accounts</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230503224401333.png" alt="image-20230503224401333" style="zoom:33%;" /><p>这样别人就无法找到input account和output account的联系了</p><p><em>Problems:</em></p><ul><li>This is centralized solution, we cannot trust the mixer who knoews both of my accounts</li><li>The mixer might steal my money and there is nothing I can do about it</li></ul><p><em>Solution:</em></p><p>I need these properties:</p><ul><li>trustlessness: wanna make sure the mixer cannot keep my money<ul><li>Sol: 把mixer的角色从一个account换成smart contract</li></ul></li><li>privacy from the mixer: make sure even the mixer itself cannot link between my old &amp; new account</li></ul><hr><h3 id="Blind-Signatures"><a href="#Blind-Signatures" class="headerlink" title="Blind Signatures"></a>Blind Signatures</h3><p>Scenario (in real world):</p><ul><li>Alice is a customer of the bank</li><li>Only the bank knows her balance</li><li>Bob is a customer, too</li><li>Alice wants to pay Bob</li></ul><p>但是Alice现在不想让知道bank我现在要pay的是Bob，即we want privacy w.r.t. the bank</p><p>所以bank需要知道的只有:</p><ul><li>Money leaves Alice’s account</li><li>Money enters Bob’s account</li></ul><p>在这种情况下没有serial number的banknotes就可以起到这个作用。Alice withdraw一个banknotes，然后给Bob，Bob再将其拿给bank兑换，那么bank knows nothing about the process</p><p>放到digital world也是同理，我们想要实现上面这样的功能</p><h4 id="Idea-Issue-Banknotes"><a href="#Idea-Issue-Banknotes" class="headerlink" title="Idea: Issue Banknotes"></a>Idea: Issue Banknotes</h4><p>$b = \text{“I am a banknote # … worth 100 HKD”}$</p><p>之后Alice将 $(b, sgn_{bank} (b))$ sends to Bob，Bob可以验证bank的signature来判断他是不是官方的</p><h5 id="How-to-avoid-double-spending"><a href="#How-to-avoid-double-spending" class="headerlink" title="How to avoid double-spending"></a>How to avoid double-spending</h5><p>Bob can avoid double-spending by depositing immediately。如果bank告诉他这个banknotes已经被用了，那么他就不接受Alice的这个banknote</p><p>但是你会发现这其中有很多问题，比如bank必须要track serial number来判断这个banknote是否已经被用掉了，这就与anonymous不符</p><p>而且bank可以be malicious，他可以issue different banknotes with <strong>same serial numbers</strong>，但Alice无法知道这件事</p><p><em>Solution:</em> <strong>Blind Signing</strong></p><p>Blind signing指的是the person who is signing doesn’t know what on earth he is signing</p><p>此处就相当于bank在不知道 $b$ 的情况下sign $b$</p><hr><h3 id="RSA-Blind-Signatures"><a href="#RSA-Blind-Signatures" class="headerlink" title="RSA Blind Signatures"></a>RSA Blind Signatures</h3><p>The bank has announced $e, N$ but not the secret key $d$ for RSA</p><ul><li>Alice creates a banknotes $b$</li><li>Alice hashes $b$ and obtains $h$</li></ul><p><em>Goal: Alice wants to obtain the signature $h^d$ but doesn’t want the bank to have any information on $h$</em></p><ul><li><p>Alice computes $h’ = h \cdot r^e \mod N$ where $r$ is a random number</p></li><li><p>Alice sends $h’$ to the bank</p></li><li><p>The bank signs $h’$ and sends the signature $(h’)^d$ bank to Alice</p></li><li><p>Alice has $(h’)^d = h^d \cdot r^{de} \equiv h^d \cdot r \pmod N$ according to RSA property: $r^{ed} \mod N = r \mod N$</p><p>  Alice computes $h^d = (h’)^d \cdot r^{- 1} \mod N$</p></li><li><p>Alice sends $(b, h^d)$ to Bob</p></li><li><p>Bob immediately sends $(b, h^d)$ to the bank</p></li><li><p>The bank verifies its own signature</p><ul><li>Increases Bob’s balance by 100 HKD</li><li>Adds the serial number of $b$ to the list of spent banknotes</li></ul></li></ul><hr><p>重新回到mixer，但是我们发现，因为SC里面的所有东西都是public的，所以我们没法将 $d$ 这样的private key存到里面，所以我们还需要一个extra actor —— bank (a real-world person)来做blind signature</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230504141548057.png" alt="image-20230504141548057" style="zoom:30%;" /><ul><li><p>The bank creates $N, e, d$ and sends $N, e$ to the mixer</p></li><li><p>Alice pays the mixer 1 ETH &amp; sends $h’ = h \cdot r^e$</p></li><li><p>The bank signs &amp; sends $(h’)^d$ to the mixer</p><p>  在这一步若bank sends一个假的 $(h’)^d$ 可以被mixer verify出来，因为他拥有 $N, e$</p></li><li><p>Bob sends $(b, h^d)$ to the mixer</p></li><li><p>The mixer transfers 1 ETH to Bob</p></li></ul><p><em>Attack:</em></p><p>The bank can issue extra banknotes. 即他可以issue some fake banknotes自己sign然后去当作Bob取钱</p><p><em>Solution:</em></p><p>Mixer可以在收到Bob的取钱banknote的时候不立即给他钱，而是等到一个ddl再给，如果比如现在我mixer总共存进去1000笔，而取出1001笔，那么就说明bank is cheating，就可以把bank给ban了，然后refund to Alice</p><h2 id="Goldwasser-Micali-Cryptosystem"><a href="#Goldwasser-Micali-Cryptosystem" class="headerlink" title="Goldwasser-Micali Cryptosystem"></a>Goldwasser-Micali Cryptosystem</h2><h3 id="Probabilistic-Encryption-amp-Signature"><a href="#Probabilistic-Encryption-amp-Signature" class="headerlink" title="Probabilistic Encryption &amp; Signature"></a>Probabilistic Encryption &amp; Signature</h3><p>之前我们见到的encryption或是signature全部都是deterministic的，比如RSA的encryption就是unique的。</p><h4 id="Goldwasser-Micali-Cryptosystem-1"><a href="#Goldwasser-Micali-Cryptosystem-1" class="headerlink" title="Goldwasser-Micali Cryptosystem"></a>Goldwasser-Micali Cryptosystem</h4><blockquote><p><strong><em>Quadratic Residual (二次剩余)</em></strong></p><p>$x \in \{0, \cdots, n - 1\}$ is a QR modulo $n$ if $\exists y, y^2 \equiv x \pmod n$</p><p><strong><em>Quadratic Residuosity Problem</em></strong></p><p>Given $n$ and $x$, is $x$ a QR mod $n$?</p><p>If $n$ is a prime $n = p$，根据fermat’s little theorem，$x = y^2 \Rightarrow x^{\frac{p - 1}2} \equiv 1 \pmod p$</p><p>If $n = pq$ and we know $p, q$，那么问题就变成了 $x$ 是否是 $p, q$ 的二次剩余</p></blockquote><p>GM crypto实际上就是based on QR，假如只有发件人Alice知道 $p, q$，那么别人都没法answer QR question，那么我要做的实际上就是达到一个目的: 如果你要decrypt，就必须要answer QR question</p><h5 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h5><ul><li><p>Alice picks two large primes $p, q$ and sets $n = pq$</p></li><li><p>Alice finds $x \in \{0, 1, \cdots, n - 1\}$ s.t.</p><ul><li>$x$ is not a QR mod $p$</li><li>$x$ is not a QR mod $q$</li></ul></li><li><p>Alice publishes $(x, n)$ as her public key and uses $(p, q)$ as her secret key</p></li><li><p>假设Bob有个message $m$ 想发给Alice，然后他将其encode为很多bit $m = m_1m_2…m_k$，之后他会encrypt each bit seperately，encrypt的方法如下</p><p>  对于一个bit $m_i$，如若 $m_i = 0$，那么Bob将会send Alice一个是 $p, q$ QR的数，反之则是send一个不是QR的数</p><p>  For every $i$, Bob picks $y_i \in \{0, 1, …, n - 1\}$ s.t. $\gcd (y_i, n) = 1$, $c_i = y_i^2 \cdot x^{m_i}$</p><p>  这样的话，因为 $x$ 不是QR，如果 $m_i = 0$ 那么 $c_i$ 就是QR，反之就不是</p></li></ul><h5 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h5><ul><li><p>For every $i$, Alice checks whether $c_i$ is a QR mod $n$</p><p>  If “yes”, then $m_i = 0$, else $m_i = 1$</p></li></ul><p>可以发现，same message可以有很多个encryption</p><h5 id="Homomorphic-Encryption"><a href="#Homomorphic-Encryption" class="headerlink" title="Homomorphic Encryption"></a>Homomorphic Encryption</h5><p><em>Homomorphic Property of GM</em></p><p>$Enc (b_1) \cdot Enc (b_2) = Enc (b_1 \oplus b_2)$</p><p>两个二次剩余的积还是一个二次剩余</p><p><em>Homomorphic Property of RSA</em></p><p>$Enc (m_1) \cdot Enc (m_2) = m_1^e \cdot m_2^e = (m_1m_2)^e = Enc (m_1 \cdot m_2)$</p><h3 id="ElGamal-Cryptosystem"><a href="#ElGamal-Cryptosystem" class="headerlink" title="ElGamal Cryptosystem"></a>ElGamal Cryptosystem</h3><ul><li><p>Alice chooses a prime number $p$ and a secret $a$, a primitive root $g$</p><p>  Public key of Alice is $(p, g^a)$</p></li><li><p>Bob has a message $m$, and chooses a secret $b$, then computes $g^{ab}$</p><p>  Send $(g^b, m + g^{ab})$ to Alice</p></li><li><p>Then Alice can obtain $m$</p></li></ul><p><strong>Zero-knowledge proof</strong></p><p>Alice wants to prove she knows $a$ s.t. $g^a \equiv x \pmod p$</p><p>这时这就可以通过encryption和decryption来实现了，只要Alice decrypt了Bob的message，那么Bob就知道Alice knows $a$</p><h2 id="Zero-Knowledge-Proofs"><a href="#Zero-Knowledge-Proofs" class="headerlink" title="Zero-Knowledge Proofs"></a>Zero-Knowledge Proofs</h2><h3 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h3><p>假设存在两个polynomial $p_1, p_2$, a problem $L$ is in NP if there exists an algorithm $V$ s.t.</p><ul><li><p>$\forall x \in L, \exists y \in \sum^{p_1 (x)}, V (x, y) = 1$</p><p>  即对任意满足problem $L$的condition的 $x$，一定存在某个proof $y$，这个proof的length是 $p_1 (x)$，algorithm $V$可以告诉我们 $y$ 是correct的</p></li><li><p>$\forall x \not\in L, \forall y \in \sum^{p_1 (x)}, V (x, y) = 0$</p></li><li><p>$T (V, x, y) \le p_2 (x + y)$</p><p>  Runtime of the verifier的最大值是 $p_2 (x + y)$</p></li></ul><p>总之就是可以在polynomial的时间内check</p><p><em>Claim:</em> I know the prime factorization of $N = pq$ ($pq$ 是private的，只有我知道)。我要怎么prove我know？</p><p>最简单的办法:</p><p><em>Proof:</em> Disclose $p$ and $q$</p><p><em>Verification:</em> Compute $pq$ and checks if $pq = N$</p><blockquote><p><em>Problem.</em> The prover (Peggy) wants to prove $\phi$ to the verifier (Victor) but she does not want to leak any extra information</p></blockquote><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1."></a>Example 1.</h4><p>Imagine Victor is color-blind and we have two identical balls 但是分别是green和red</p><p><em>Solution:</em> At each step, Victor randomly shows one ball and Peggy has to say if he swapped</p><h3 id="Zero-Knowledge-Proof"><a href="#Zero-Knowledge-Proof" class="headerlink" title="Zero-Knowledge Proof"></a>Zero-Knowledge Proof</h3><p>It must have these properties:</p><ul><li>If both Peggy &amp; Victor are honest and Peggy’s claim holds, then Victor would be convinced <strong>with high probability</strong></li><li>If Peggy is lying, she cannot convince Victor</li><li>Victor gains no extra knowledge apart from the fact that Peggy’s claim holds (<strong><em>Zero-knowledge property</em></strong>)</li></ul><h4 id="Prove-zero-knowledge-property"><a href="#Prove-zero-knowledge-property" class="headerlink" title="Prove zero-knowledge property"></a>Prove zero-knowledge property</h4><p>Observation: Imagine that Victor records all the interations and later plays the recording for Sarah. <strong>There should be no way to convince Sarah that the recording was not staged.</strong></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523174020607.png" alt="image-20230523174020607" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523174335116.png" alt="image-20230523174335116" style="zoom:33%;" /><p>其中，$y’$ 是Victor自己随便选的一个secret。这个证明的本质就是让Peggy证明自己能算出 $g^{yy’}$，这个是个shared secret，因为Victor也能通过 $x^{y’}$ 算出，所以他就能验证Peggy的claim是否为true</p><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523195323230.png" alt="image-20230523195323230" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523195343536.png" alt="image-20230523195343536" style="zoom:33%;" /><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>There is a graph $G$ and Peggy claims that she knows a Hamiltonian cycle (哈密顿回路) in $G$</p><ul><li><p>Peggy chooses a permutation and compute $H \approx G$</p></li><li><p>Peggy commits to every edge of $H$</p><p>  $e_i = (u, v)$ in H, and compute $h_i = hash (u | v | nonce)$ and publish it</p></li><li><p>Victor can ask for</p><ul><li>( i ) Prove isomorphism</li><li>( ii )A Hamiltonian cycle in $H$</li></ul></li><li><p>If Victor asked for ( i ), Peggy reveals every edge in $H$ and the permutation</p><p>  IVictor asked for ( ii ), Peggy only reveals the edges that are in Hamiltonian cycle</p></li></ul><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523201502033.png" alt="image-20230523201502033" style="zoom:33%;" /><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523201515622.png" alt="image-20230523201515622" style="zoom:33%;" /><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523211309310.png" alt="image-20230523211309310" style="zoom:33%;" /><h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523211337992.png" alt="image-20230523211337992" style="zoom:33%;" /><h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h4><img src= "/img/loading.gif" data-lazy-src="/Users/colythme/Library/Application Support/typora-user-images/image-20230523211358033.png" alt="image-20230523211358033" style="zoom:33%;" /><h2 id="Lecture-25-Be-Vindictive"><a href="#Lecture-25-Be-Vindictive" class="headerlink" title="Lecture 25: Be Vindictive"></a>Lecture 25: Be Vindictive</h2><h3 id="transfer-send-call"><a href="#transfer-send-call" class="headerlink" title="transfer, send, call"></a>transfer, send, call</h3><p>首先transfer和send都有gas limit，可能没有足够的gas去send成功</p><p>假设我们通过调用function $f$，$f$ 中使用了这些transfer money的函数</p><ul><li>transfer: 如果receiver在receive或者fallback上动手脚，比如throw an exception，那么整个 $f$ 会立刻停止运行，使其revert</li><li>send: 但是send并不会revert整个过程</li><li>call: <code>call</code> 不会遇到上述问题，但是receiver可能会intentionally waste gas，比如在fallback里面加入循环</li></ul><p><strong>所以其实最好的方法是，不要我们send他钱，而是让他自己withdraw</strong></p>]]></content>
      
      
      <categories>
          
          <category> Web3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RL - DQN &amp; FlappyBird Implementation</title>
      <link href="/2022/06/21/RL%20-%20DQN%20&amp;%20FlappyBird%20Implementation/"/>
      <url>/2022/06/21/RL%20-%20DQN%20&amp;%20FlappyBird%20Implementation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>First of all, let me give a basic intuition of $DQN$ (Deep Q-Network). It is composed of $D$ (deep learning) and $QN$ (Q-Network), among which the Q-Learning algorithm is the core and the neural network is just a tool to maintain the matrix in Q algorithm because of the memory limits (a $state \times actioin$ size of matrix is too big for most of the times).</p><h2 id="Algorithm-Description"><a href="#Algorithm-Description" class="headerlink" title="Algorithm Description"></a>Algorithm Description</h2><h3 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h3><p>It is explained in detail in this blog: <a href="http://mnemstudio.org/path-finding-q-learning-tutorial.htm">A Painless Q-Learning Tutorial</a></p><h3 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h3><p>Similar to dynamic programming, the state transition equation of Q array presented in Q-Learning:<br>$$<br>Q (s, a) = R(s, a) + \gamma \cdot \max_{\tilde{a}}\{Q (\tilde{s}, \tilde{a})\}<br>$$<br>Here $s, a$ indicates current state and action, $R$ indicates the reward matrix, $\gamma$ indicates learning rate (a coefficient), $\tilde{s}, \tilde{a}$ indicates state and action in the next time step.</p><p>Then comes the problem: how do we measure loss function? Easy. Remind that we are now using neural network to maintain the Q-Learning sheet, which means we need to have our network’s outputs approximate to Q values. Therefore, it can now be regarded as supervised learning with labels as Q values calculated by previous networks.<br>$$<br>L_i(\theta_i) = (r + \gamma \cdot (\max_{\tilde{a}}\{Q(\tilde{s}, \tilde{a} | \theta_{i - 1})\}) - Q(s, a | \theta_i))^2<br>$$<br>which is an MSE loss function, and $\theta$ means we need to use parametric approximations.</p><p>The training process is divided into three parts: observation period, exploration period, and training period</p><p>In practice, we define a replay memory to save those existed states and randomly pick up a batch of them as what we are to train in the exploration and training period, which can make the training more efficient. Meanwhile, we need to build two same networks, Q-Network and target Q-Network. Q-Network is what we are training, but target Q-Network is used to predict ‘label Q values’. And every certain episodes, we copy the parameters in Q-Network to target Q-Network.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paddle Learning Notebook</title>
      <link href="/2022/05/29/Paddle%20Learning%20Notebook/"/>
      <url>/2022/05/29/Paddle%20Learning%20Notebook/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Normalized-Training-Model"><a href="#Normalized-Training-Model" class="headerlink" title="Normalized Training Model"></a>Normalized Training Model</h2><h3 id="Stage-1-Load-Data"><a href="#Stage-1-Load-Data" class="headerlink" title="Stage 1: Load Data"></a>Stage 1: Load Data</h3><p>Divide the stage into four sub-stage:</p><ul><li><em>load data file</em></li><li><em>separate data into groups according to the number of features</em></li><li><em>divide the dataset into training &amp; test dataset</em></li><li><em>normalize data to the range of [0, 1]</em></li></ul><p><strong>1.1.1 load data file</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span> ():</span></span><br><span class="line">    <span class="comment"># load data file</span></span><br><span class="line">    datafile = <span class="string">&#x27;.../.../.../&#x27;</span></span><br><span class="line">    data = np.fromfile (datafile, sep = <span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>np.fromfile</code> is used for constructing data from a text or binary file, among which the <code>sep</code> para indicates the separator. Here we use spaces as the separator.</p><p><strong>1.1.2 separate data into groups according to the number of features</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># separate data to groups according to the number of features</span></span><br><span class="line">features = []</span><br><span class="line">feature_num = <span class="built_in">len</span> (features)</span><br><span class="line">data = data.reshape (data.shape[<span class="number">0</span>] // feature_num, feature_num)</span><br></pre></td></tr></table></figure><p><strong>1.1.3 divide the dataset into training &amp; test dataset</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># divide the dataset</span></span><br><span class="line">ratio = <span class="number">0.8</span></span><br><span class="line">offset = <span class="built_in">int</span> (data.shape[<span class="number">0</span>] * ratio)</span><br><span class="line">training_data = data[:offset]</span><br></pre></td></tr></table></figure><p>Here regard the previous $80\%$ data as the training data.</p><p><strong>1.1.4 normalization</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># normalize data to the range of [0, 1]</span></span><br><span class="line">maximum, minimum, avg = \</span><br><span class="line">                    training_data.<span class="built_in">max</span> (axis = <span class="number">0</span>), \</span><br><span class="line">                    training_data.<span class="built_in">min</span> (axis = <span class="number">0</span>), \</span><br><span class="line">                    training_data.<span class="built_in">sum</span> (axis = <span class="number">0</span>) / training_data.shape[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (feature_num): <span class="comment"># to range [0, 1]</span></span><br><span class="line">    data[:, i] = (data[:, i] - avg[i]) / (maximum[i] - minimum[i])</span><br></pre></td></tr></table></figure><p><code>axis = 0</code> means we process elements in rows. In contrast, <code>axis = 1</code> means in columns.</p><p><strong>1.1.5 end of the stage</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">training_data = data[:offset]</span><br><span class="line">test_data = data[offset:]</span><br><span class="line"><span class="keyword">return</span> training_data, test_data</span><br></pre></td></tr></table></figure><p><strong>ex 1.1.1 extract data</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">training_data, test_data = load_data ()</span><br><span class="line">x = training_data[:, :-<span class="number">1</span>]</span><br><span class="line">y = training_data[:, -<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h2 id="Basic-Intuition-About-CNN"><a href="#Basic-Intuition-About-CNN" class="headerlink" title="Basic Intuition About CNN"></a>Basic Intuition About CNN</h2><h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h3><ul><li><strong><em>Convolutional Layer</em></strong></li><li><strong><em>Pooling Layer</em></strong>: Process of <em>merging</em> (which means reducing the size of data). Used for reducing noise so that significant information could be extracted. </li><li>Layers above are used for feature extraction.</li><li><strong><em>Flattening Layer</em></strong>: Transform multi-dimensional output from convolutional layer to 1-dimensional vector that can be accepted by fully-connected layer.</li><li><strong><em>Fully-connected Layer</em></strong>: Main neural network section. $e.g. $ use <em>softmax</em> or <em>sigmoid</em> function to do classification</li></ul><h2 id="Number-Classifier-Classic-CNN-Paddle"><a href="#Number-Classifier-Classic-CNN-Paddle" class="headerlink" title="Number Classifier (Classic CNN, Paddle)"></a>Number Classifier (Classic CNN, Paddle)</h2><p>Input image size: $28 \times 28$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle.nn <span class="keyword">import</span> Linear, Conv2D, MaxPool2D</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># !important</span></span><br><span class="line"><span class="comment"># if we wanna extract values from data_loader</span></span><br><span class="line"><span class="comment"># we need to guarantee that all image data in it are in numpy format</span></span><br><span class="line"><span class="comment"># the below code is used for this</span></span><br><span class="line">paddle.vision.set_image_backend (<span class="string">&#x27;cv2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27; --------------------load data version 1------------------------</span></span><br><span class="line"><span class="comment"># load dataset MNIST</span></span><br><span class="line">train_dataset = paddle.vision.datasets.MNIST (mode = <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line"><span class="comment"># train_dataset[n][0] saves the n-th pic; train_dataset[n][1] saves its label</span></span><br><span class="line"><span class="comment"># note that we need to normalize them</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------ &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; -------------load data version 2 (self-wrapped load_data function)----------------</span></span><br><span class="line"><span class="string">def load_data (mode = &#x27;train&#x27;):</span></span><br><span class="line"><span class="string">    datafile = &#x27;./Practice/NumClassifier_Paddle/mnist.json.gz&#x27;</span></span><br><span class="line"><span class="string">    data = json.load (gzip.open (datafile))</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    train_set, val_set, eval_set = data</span></span><br><span class="line"><span class="string">    if mode == &#x27;train&#x27;:</span></span><br><span class="line"><span class="string">        images, labels = train_set[0], train_set[1]</span></span><br><span class="line"><span class="string">    elif mode == &#x27;valid&#x27;:</span></span><br><span class="line"><span class="string">        images, labels = val_set[0], val_set[1]</span></span><br><span class="line"><span class="string">    elif mode == &#x27;eval&#x27;:</span></span><br><span class="line"><span class="string">        images, labels = eval_set[0], eval_set[1]</span></span><br><span class="line"><span class="string">    else: # throw error message</span></span><br><span class="line"><span class="string">        raise Exception (&quot;invalid mode&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    assert len (images) == len (labels)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # shuffle the train data</span></span><br><span class="line"><span class="string">    index_list = list (range (len (images)))</span></span><br><span class="line"><span class="string">    random.shuffle (index_list)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    BATCHSIZE = 100</span></span><br><span class="line"><span class="string">    # a python generator (look up specific definition on websites)</span></span><br><span class="line"><span class="string">    def data_generator ():</span></span><br><span class="line"><span class="string">        img_list = label_list = []</span></span><br><span class="line"><span class="string">        for i in index_list:</span></span><br><span class="line"><span class="string">            img_list.append (np.array (images[i]).astype (&#x27;float32&#x27;))</span></span><br><span class="line"><span class="string">            label_list.append (np.array (labels[i]).astype (&#x27;float32&#x27;))</span></span><br><span class="line"><span class="string">            if len (img_list) == BATCHSIZE:</span></span><br><span class="line"><span class="string">                yield np.array (img_list), np.array (label_list)</span></span><br><span class="line"><span class="string">                img_list = label_list = []</span></span><br><span class="line"><span class="string">        # if there remains elements not wrapped</span></span><br><span class="line"><span class="string">        if len (img_list) &gt; 0:</span></span><br><span class="line"><span class="string">            yield np.array (img_list), np.array (label_list)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    return data_generator</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------------- &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># normalization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">norm_img</span> (<span class="params">images</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span> (images.shape) == <span class="number">3</span></span><br><span class="line">    batch_size, img_h, img_w = images.shape[<span class="number">0</span>], images.shape[<span class="number">1</span>], images.shape[<span class="number">2</span>]</span><br><span class="line">    images = images / <span class="number">255</span></span><br><span class="line">    <span class="comment"># reshape to 4-D</span></span><br><span class="line">    images = paddle.reshape (images, [batch_size, <span class="number">1</span>, img_h, img_w])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here values in images are all &#x27;paddle.float32&#x27; type (which is in tensor format)</span></span><br><span class="line">    <span class="comment"># therefore we need to convert them to normal &#x27;float32&#x27; type then</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNIST</span> (<span class="params">paddle.nn.Layer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span> (MNIST, self).__init__ ()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># CNN</span></span><br><span class="line">        self.conv1 = Conv2D (in_channels = <span class="number">1</span>, out_channels = <span class="number">20</span>, kernel_size = <span class="number">5</span>, stride = <span class="number">1</span>, padding = <span class="number">2</span>)</span><br><span class="line">        self.max_pool1 = MaxPool2D (kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>)</span><br><span class="line">        self.conv2 = Conv2D (in_channels = <span class="number">20</span>, out_channels = <span class="number">20</span>, kernel_size = <span class="number">5</span>, stride = <span class="number">1</span>, padding = <span class="number">2</span>)</span><br><span class="line">        self.max_pool2 = MaxPool2D (kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># fc is the abbreviate of fully-connected layer</span></span><br><span class="line">        <span class="comment"># 7 * 7 * 20 = 980</span></span><br><span class="line">        self.fc = Linear (in_features = <span class="number">980</span>, out_features = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span> (<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        x = self.conv1 (<span class="built_in">input</span>)</span><br><span class="line">        <span class="comment"># remember to activate</span></span><br><span class="line">        x = F.relu (x)</span><br><span class="line">        x = self.max_pool1 (x)</span><br><span class="line">        x = self.conv2 (x)</span><br><span class="line">        x = F.relu (x)</span><br><span class="line">        x = self.max_pool2 (x)</span><br><span class="line">        x = paddle.reshape (x, [x.shape[<span class="number">0</span>], - <span class="number">1</span>])</span><br><span class="line">        x = self.fc (x)</span><br><span class="line">        x = F.softmax(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = MNIST ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span> (<span class="params">model</span>):</span></span><br><span class="line">    <span class="comment"># set training mode</span></span><br><span class="line">    model.train ()</span><br><span class="line">    <span class="comment"># load train data with a batch size of 16</span></span><br><span class="line">    train_loader = paddle.io.DataLoader (train_dataset, batch_size = <span class="number">16</span>, shuffle = <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># train_loader = load_data (&#x27;train&#x27;)</span></span><br><span class="line">    <span class="comment"># define optimizer (parameters indicates elements we are to train)</span></span><br><span class="line">    <span class="comment"># like we need to tell it the list of elements needed to be updated in back-prop</span></span><br><span class="line">    <span class="comment"># opt = paddle.optimizer.SGD (learning_rate = 0.001, parameters = model.parameters ())</span></span><br><span class="line">    opt = paddle.optimizer.Adam (learning_rate = <span class="number">0.001</span>, parameters = model.parameters ())</span><br><span class="line">    EPOCH_NUM = <span class="number">2</span></span><br><span class="line">    <span class="comment"># actually, what extracted from train_loader are batches of images and labels</span></span><br><span class="line">    <span class="comment"># which means para &#x27;images&#x27; below should contain 16 images</span></span><br><span class="line">    <span class="comment"># therefore, its shape should be [16, 28, 28]</span></span><br><span class="line">    <span class="comment"># which means [batch_size, width, height]</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (EPOCH_NUM):</span><br><span class="line">        <span class="keyword">for</span> batch_id, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span> (train_loader ()):</span><br><span class="line">            <span class="comment"># &#x27;&#x27;&#x27; ---------used for paddle.Dataloader------------</span></span><br><span class="line">            images = norm_img (images).astype (<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">            labels = labels.astype (<span class="string">&#x27;int64&#x27;</span>) <span class="comment"># used for cross-entropy</span></span><br><span class="line">            <span class="comment"># ----------------------------------------------- &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># forward propagation</span></span><br><span class="line">            predicts = model (images)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute loss</span></span><br><span class="line">            loss = F.cross_entropy (predicts, labels)</span><br><span class="line">            avg_loss = paddle.mean (loss)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch_id % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;epoch_id: &#123;&#125;, batch_id: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="built_in">format</span> (epoch, batch_id, avg_loss.numpy()))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># back propagation, compute para in each layer</span></span><br><span class="line">            avg_loss.backward ()</span><br><span class="line">            <span class="comment"># update para</span></span><br><span class="line">            opt.step ()</span><br><span class="line">            <span class="comment"># clear old gradient data</span></span><br><span class="line">            opt.clear_grad ()</span><br><span class="line"></span><br><span class="line">train (model)</span><br><span class="line">paddle.save (model.state_dict (), <span class="string">&#x27;./Practice/NumClassifier_Paddle/mnist.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_dataset = paddle.vision.datasets.MNIST (mode = <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">test_loader = paddle.io.DataLoader (test_dataset, batch_size = <span class="number">16</span>, shuffle = <span class="literal">False</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluation</span> (<span class="params">model, dataset</span>):</span></span><br><span class="line">    <span class="comment"># set evaluation mode</span></span><br><span class="line">    model.<span class="built_in">eval</span> ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># list () create an empty list</span></span><br><span class="line">    acc_set = <span class="built_in">list</span> ()</span><br><span class="line">    <span class="keyword">for</span> batch_id, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span> (test_loader):</span><br><span class="line">        images = norm_img (images).astype (<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">        labels = labels.astype (<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        predict = model (images)</span><br><span class="line">        acc = paddle.metric.accuracy (<span class="built_in">input</span> = predict, label = labels)</span><br><span class="line">        acc_set.extend (acc.numpy ())</span><br><span class="line">    </span><br><span class="line">    acc_val_mean = np.array (acc_set).mean ()</span><br><span class="line">    <span class="keyword">return</span> acc_val_mean</span><br><span class="line"></span><br><span class="line">acc = evaluation (model, test_dataset)</span><br><span class="line"><span class="built_in">print</span> (acc)</span><br></pre></td></tr></table></figure><p>Single image judgement</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load model</span></span><br><span class="line">model = MNIST ()</span><br><span class="line">param_dict = paddle.load (<span class="string">&#x27;./Practice/NumClassifier_Paddle/mnist.pt&#x27;</span>)</span><br><span class="line">model.load_dict (param_dict)</span><br><span class="line">model.<span class="built_in">eval</span> ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span> (<span class="params">path</span>):</span></span><br><span class="line">    <span class="comment"># load image and convert to grayscale</span></span><br><span class="line">    img = Image.<span class="built_in">open</span> (path).convert (<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    <span class="comment"># Image.ANTIALIAS is a filter for resize function to keep quality</span></span><br><span class="line">    img = img.resize ((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)</span><br><span class="line">    <span class="comment"># reshape the image to a 1-dimensional vector ([1, n])</span></span><br><span class="line">    img = np.array (img).reshape (<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).astype (np.float32)</span><br><span class="line">    <span class="comment"># need to reverse black &amp; white to meet the MNIST format</span></span><br><span class="line">    img = <span class="number">1.0</span> - img / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line">tensor_img = load_image (<span class="string">&#x27;./Practice/NumClassifier_Paddle/zero.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># note that we need to convert the normalized image to tensor</span></span><br><span class="line">result = model (paddle.to_tensor (tensor_img))</span><br><span class="line"><span class="comment"># sort the probablilities, pick the maximum</span></span><br><span class="line">result = np.argsort (result.numpy ())</span><br><span class="line"><span class="built_in">print</span> (result[<span class="number">0</span>][- <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="Yolov3"><a href="#Yolov3" class="headerlink" title="Yolov3"></a>Yolov3</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h4 id="Anchor-Box"><a href="#Anchor-Box" class="headerlink" title="Anchor Box"></a><em>Anchor Box</em></h4><ul><li><p>Use a basic anchor box to generate a series of anchor boxes that keep the same area as the basic one.</p></li><li><p>Parameter <em>center</em>, <em>scale</em>, and <em>ratio</em> are all given previously in the input.</p></li><li><p><em>center</em> describes the position of the center pixel in the basic anchor box.</p></li><li><p><em>scale</em> describes the information of the basic anchor box’s size. </p></li><li><p><em>ratio</em> describes the aspect ratio.</p></li><li><p>Suppose the width and height of the basic anchor box and the finally generated box are $w, h$ and $W, H$ respectively with <em>ratio</em> equal to $k$. Then $wh = WH, \frac{H}{W} = k$. Therefore, $W = \sqrt{\frac{wh}{k}}, H = \sqrt{whk}$</p></li></ul><h4 id="IoU-Intersection-of-Union"><a href="#IoU-Intersection-of-Union" class="headerlink" title="IoU (Intersection of Union)"></a><em>IoU (Intersection of Union)</em></h4><p>$$<br>IoU = \frac{A \cap B}{A \cup B}<br>$$</p><p>Used for describing the coincidence degree between two boxes.</p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>The basic intuition about how yolo proceeds the data is that we first divide the picture into $n \times n$ (general $13 \times 13$, $26 \times 26$, and $52 \times 52$) grids, then assign a bounding box for each ground truth box, whose anchor has the highest $IoU$ value in respect to it.</p><p>Detailly speaking, for each anchor box, we need to predict a set of values $(P_{object}, t_x, t_y, t_w, t_h, P_{class_1}, P_{class_2}, …)$, where $P_{object}, P_{class_n}$ are the probability of the anchor box containing an object and it belongs to the class $n$ respectively. As for the reason for the existence of $t_x, t_y, t_w, t_h$ is that we need to slightly adjust the center and size of anchor boxes, for they are originally set with specified values.</p><p>Then how to predict $(t_x, t_y, t_w, t_h)$? We do regression.</p><p>For $t_x, t_y$,<br>$$<br>\begin{aligned}<br>b_x &amp;= c_x + \sigma(t_x) \<br>b_y &amp;= c_y + \sigma(t_y)<br>\end{aligned}<br>$$<br>where $b_x, b_y$ indicates the $x, y$ of ground truth boxes, $c_x, c_y$ indicates what grid we are in, $e.g.$ if the center of the ground truth box is in the $5$-th grid in a certain row, then $c_y$ should be $4$ (count from zero). And sigmoid function has a range of $(0, 1)$, which means $c_x + \sigma(t_x)$ would invariably lies between $c_x$ and $c_x + 1$, which meets the requirement.</p><p>For $t_w, t_h$,<br>$$<br>\begin{aligned}<br>b_w &amp;= c_we^{t_w} \<br>b_h &amp;= c_he^{t_h}<br>\end{aligned}<br>$$<br>It is because it is easier to do regression on ratio than the true value of $w, h$. Therefore, we need $e^{t_w}$ to keep the ratio positive.</p><p>Then it is clear that we only need to fill in<br>$$<br>\begin{aligned}<br>&amp;d^<em>_x = \sigma(t_x) = b_x - c_x \<br>&amp;d^</em>_y = \sigma(t_y) = b_y - c_y \<br>&amp;t^<em>_w = \ln{\frac{b_w}{c_w}} \<br>&amp;t^</em>_h = \ln{\frac{b_h}{c_h}}<br>\end{aligned}<br>$$<br>to the matrices as parameters to train.</p><p>Yolov3 uses network $Darknet53$ to train. And size of the output layer should be (for $13 \times 13$) $13 \times 13 \times batch<del>size \times (1 + 1 + 1 + 1 + 1 + number</del>of~classes)$, where $(1 + 1 + 1 + 1 + 1)$ saves $(P_{object}, x, y, w, h)$.</p><p>It uses binary cross-entropy as the loss function.</p><h2 id="NLP-Natural-Language-Processing"><a href="#NLP-Natural-Language-Processing" class="headerlink" title="NLP (Natural Language Processing)"></a>NLP (Natural Language Processing)</h2><h3 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h3><p>The conversion from words to high dimensional vectors. For instance, word <code>king</code> can be transformed to vector $[0.3, -0.35, …, 0.7]$ (values in the vector are all in the range of $[0, 1]$).</p><p>Actually, these transformed vectors can represent information of the words to some extent. What we need to do next is to calculate distance between vectors to find connections between them, $e.g.$, word <code>mother</code> and <code>son</code> are supposed to be near in the high dimensional coordinate system in general.</p><h3 id="One-Hot-Encoding"><a href="#One-Hot-Encoding" class="headerlink" title="One-Hot Encoding"></a>One-Hot Encoding</h3><p>Suppose we have a dictionary with $5000$ words, then what generated by one-hot encoding should be a $1 \times 5000$ vector with a one and $4999$ zeros. For example, work <code>king</code> is the $\text{3rd}$ word in the dictionary, then its one-hot-encoding should be $[0, 0, 1, 0, …, 0]$</p><h3 id="Conversion-from-words-to-vectors"><a href="#Conversion-from-words-to-vectors" class="headerlink" title="Conversion from words to vectors"></a>Conversion from words to vectors</h3><p>one-hot encoding $\times$ embedding lookup $=$ output vector</p><p>where embedding lookup indicates a $n \times m$ tensor (suppose we have $n$ words in the dictionary and each word can be converted to a $m$ dimensional vector). For example, here is a embedding lookup</p><table><thead><tr><th>word</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>king</td><td>0.3</td><td>0.5</td><td>- 0.1</td></tr><tr><td>queen</td><td>0.2</td><td>0.45</td><td>- 0.05</td></tr></tbody></table><h3 id="CBOW-amp-Skip-gram"><a href="#CBOW-amp-Skip-gram" class="headerlink" title="CBOW &amp; Skip-gram"></a>CBOW &amp; Skip-gram</h3><p>CBOW and Skip-gram are two typical models based on the word2vec algorithm.</p><p><strong>4.4.1 CBOW</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2022/06/08/XrnyI1.jpg" alt="XrnyI1.jpg"></p><p>The above is a basic network working on CBOW which is similar to the one in Skip-gram. We will illustrate it in detail in Skip-gram.</p><p><strong>4.4.2 Skip-gram</strong></p>]]></content>
      
      
      <categories>
          
          <category> AMP Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>It&#39;s Time To Learn PYTHON! (record of python challenges)</title>
      <link href="/2021/09/09/Time%20To%20Learn%20Python/"/>
      <url>/2021/09/09/Time%20To%20Learn%20Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="It’s-Time-To-Learn-PYTHON-record-of-python-challenges"><a href="#It’s-Time-To-Learn-PYTHON-record-of-python-challenges" class="headerlink" title="It’s Time To Learn PYTHON! (record of python challenges)"></a>It’s Time To Learn PYTHON! (record of python challenges)</h1><p>Sometimes refer to the solutions to all the passes: <a href="https://www.hackingnote.com/en/python-challenge-solutions/overview">HackingNote Python Challenges Solutions</a></p><h3 id="The-First-Pass"><a href="#The-First-Pass" class="headerlink" title="The First Pass"></a>The First Pass</h3><p>The gibberish displayed on the screen is a passcode which is coded with Caeser cipeher, one of the simplest encryption techniques. From the Wikipedia, we can know that</p><blockquote><p>It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on.</p></blockquote><p>So I first wrote a code like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">para = <span class="built_in">input</span> ()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> para:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span> (i) &gt;= <span class="built_in">ord</span> (<span class="string">&quot;a&quot;</span>) <span class="keyword">and</span> <span class="built_in">ord</span> (i) &lt;= <span class="built_in">ord</span> (<span class="string">&quot;z&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span> ((<span class="built_in">chr</span>)((<span class="built_in">ord</span> (i) + <span class="number">2</span> - <span class="built_in">ord</span> (<span class="string">&quot;a&quot;</span>)) % <span class="number">26</span> + <span class="built_in">ord</span> (<span class="string">&quot;a&quot;</span>)), end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="built_in">print</span> (i, end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>Apparently, it is quite cumbersome. After decoding, we can learn from the text that $string.maketrans ()$ is recommanded to be used when facing such problem. So I rewrote the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">intext = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">outext = <span class="string">&quot;cdefghijklmnopqrstuvwxyzab&quot;</span></span><br><span class="line">trans = <span class="built_in">str</span>.maketrans (intext, outext);</span><br><span class="line"></span><br><span class="line">para = <span class="built_in">input</span> ()</span><br><span class="line"><span class="built_in">print</span> (para.translate (trans))</span><br></pre></td></tr></table></figure><p>And the code is simpler now. Follow the tips translated, you only need to apply the encryption technique into the url “map” so that we can get “ocr”. After replacing “map” with “ocr”, we can get to the second pass.</p><h3 id="The-Second-Pass"><a href="#The-Second-Pass" class="headerlink" title="The Second Pass"></a>The Second Pass</h3><blockquote><p>recognize the characters. maybe they are in the book, but MAYBE they are in the page source.</p></blockquote><p>It hints us the solution hides in the page source. After opening the page source, we can see another hint and a long string containing various notations, that is</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/15/hrOlSE9UHZdxpW8.png" alt="psource.png" style="zoom:50%;" /><p>It hints us to find the characters. But how can we get the content of page source? There is a package named $\text{urllib}$, where we can import function <code>urllib.request.urlopen</code> to load raw html data. Then we use function  <code>read</code> and  <code>decode</code>to decode the html and use regular expression to extract the comment blocks.</p><p>Now we have transformed the comment blocks into a string without <code>\n</code>, so the solution is obvious now. We apply <code>re.findall</code> to the string again then we can find the answer $\text{equality}$</p><p>The code is shown below</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">myURL = urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/ocr.html&quot;</span>)</span><br><span class="line">url = myURL.read().decode()</span><br><span class="line">readl = re.findall (<span class="string">&quot;&lt;!--\s%[\s\S]*--&gt;&quot;</span>, url)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join (re.findall (<span class="string">&quot;[a-zA-Z]&quot;</span>, readl[<span class="number">0</span>])))</span><br></pre></td></tr></table></figure><h3 id="The-Third-Pass"><a href="#The-Third-Pass" class="headerlink" title="The Third Pass"></a>The Third Pass</h3><p>Nearly the same as the second pass.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">myURL = urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/equality.html&quot;</span>)</span><br><span class="line">url = myURL.read().decode()</span><br><span class="line">readl = re.findall (<span class="string">&quot;&lt;!--[\s\S]*--&gt;&quot;</span>, url)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join (re.findall (<span class="string">&quot;[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]&quot;</span>, readl[<span class="number">0</span>])))</span><br></pre></td></tr></table></figure><h3 id="The-Forth-Pass"><a href="#The-Forth-Pass" class="headerlink" title="The Forth Pass"></a>The Forth Pass</h3><p>From this pass I learn that we can use notation as <code>%s</code> to temporarily substitude a variable, and when you want to call the variable, you only need to add a <code>%</code> notation between two variables.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">findx = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">web = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s&quot;</span></span><br><span class="line"><span class="comment"># add = &quot;12345&quot;</span></span><br><span class="line">add = <span class="string">&quot;8022&quot;</span></span><br><span class="line"><span class="keyword">while</span> findx:</span><br><span class="line">    myURL = urlopen (web % add)</span><br><span class="line">    url = myURL.read().decode()</span><br><span class="line">    findx = re.findall (<span class="string">&quot;and the next nothing is (.*)&quot;</span>, url)</span><br><span class="line">    <span class="keyword">if</span> findx: add = findx[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> (add, url)</span><br></pre></td></tr></table></figure><h3 id="The-Fifth-Pass"><a href="#The-Fifth-Pass" class="headerlink" title="The Fifth Pass"></a>The Fifth Pass</h3><p>According to the page source, we replace the <code>peak.html</code> with <code>banner.p</code> and enter a page full of notations. But we find it difficult to recongnize the characters after decoding the notations in utf-8. In the meantime, we can see a hint in the original page, that is, $\text{pronounce it}$. The pronunciation of $\text{peak}$ is like a object serialization module in Python —— $\text{pickle}$. It hints that we need to decode in the form of pickle, namely,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myURL = urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/banner.p&quot;</span>)</span><br><span class="line">readl = pickle.load (myURL)</span><br></pre></td></tr></table></figure><p>Then it is easy to get to a banner like this:</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/16/8mBSWFRK4qU6cP3.png" alt="@2x.png" style="zoom:40%;" /><p>The problem is resolved right now. The full code is shown below:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">myURL = urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/banner.p&quot;</span>)</span><br><span class="line">readl = pickle.load (myURL)</span><br><span class="line">f = <span class="built_in">open</span> (<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> lst <span class="keyword">in</span> readl:</span><br><span class="line">    <span class="keyword">for</span> tup <span class="keyword">in</span> lst:</span><br><span class="line">        f.write (tup[<span class="number">0</span>] * tup[<span class="number">1</span>])</span><br><span class="line">    f.write (<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.close ()</span><br></pre></td></tr></table></figure><h3 id="The-Sixth-Pass"><a href="#The-Sixth-Pass" class="headerlink" title="The Sixth Pass"></a>The Sixth Pass</h3><p>Nearly the same as the previous passes, though the information in page sources is shifted to the zip. We only need to replace the module of urllib with zipfile</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile, re</span><br><span class="line">f = zipfile.ZipFile (<span class="string">&quot;channel.zip&quot;</span>) <span class="comment"># open the zip file</span></span><br><span class="line">add = <span class="string">&#x27;90052&#x27;</span>; findx = [<span class="string">&#x27;&#x27;</span>]; comment = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> findx:</span><br><span class="line">    readl = f.read(add + <span class="string">&#x27;.txt&#x27;</span>).decode() /<span class="comment"># before being decoded, the data is in binary</span></span><br><span class="line">    </span><br><span class="line">    findx = re.findall (<span class="string">&quot;Next nothing is (.*)&quot;</span>, readl)</span><br><span class="line">    comment += f.getinfo (add + <span class="string">&#x27;.txt&#x27;</span>).comment.decode()</span><br><span class="line">    <span class="keyword">if</span> findx: add = findx[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> (comment)</span><br></pre></td></tr></table></figure><p>The answer is <code>oxygen</code></p><h3 id="The-Seventh-Pass"><a href="#The-Seventh-Pass" class="headerlink" title="The Seventh Pass"></a>The Seventh Pass</h3><p>In this pass, we only have an image and do not know what to do. But there is a grey bar in the middle of the image, which may be the key. We use <code>urlopen</code> to load the image as binary, and use <code>BytesIO</code> to decode, then use the <code>open</code> function in <code>Image</code> module to obtain the data of the image.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span> (BytesIO (urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>).read()))</span><br></pre></td></tr></table></figure><p>After using the <code>getpixel</code> to get the data of certain pixel, we get a list of <code>(R, G, B, alpha)</code>. Then merge the seven same tuples, and get the representation in $ASCII$ of the integer of <code>(R, G, B)</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [img.getpixel ((x, img.height / <span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (img.width)][::<span class="number">7</span>]</span><br><span class="line">lst = [R <span class="keyword">for</span> R, G, B, alpha <span class="keyword">in</span> lst]</span><br></pre></td></tr></table></figure><p>Print the result, we now have another hint:</p><blockquote><p>smart guy, you made it. the next level is $[105, 110, 116, 101, 103, 114, 105, 116, 121]$pe_</p></blockquote><p>Following the hint, we do the same process again such that we can get the answer.</p><blockquote><p>$integrity$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment"># img = Image.open (BytesIO (requests.get (&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;).content))</span></span><br><span class="line">img = Image.<span class="built_in">open</span> (BytesIO (urlopen (<span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>).read()))</span><br><span class="line">lst = [img.getpixel ((x, img.height / <span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (img.width)][::<span class="number">7</span>]</span><br><span class="line">lst = [R <span class="keyword">for</span> R, G, B, alpha <span class="keyword">in</span> lst]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join (<span class="built_in">map</span> (<span class="built_in">chr</span>, lst)))</span><br></pre></td></tr></table></figure><h3 id="The-Eighth-Pass"><a href="#The-Eighth-Pass" class="headerlink" title="The Eighth Pass"></a>The Eighth Pass</h3><p>Decode the <code>username</code> and <code>password</code> in the page source in the form of <code>bzip2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line">un = bz2.decompress (<span class="string">b&#x27;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&#x27;</span>)</span><br><span class="line">pw = bz2.decompress (<span class="string">b&#x27;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (un, pw)</span><br></pre></td></tr></table></figure><p>Or you even can find the answer in the page source…</p><h3 id="The-Ninth-Pass"><a href="#The-Ninth-Pass" class="headerlink" title="The Ninth Pass"></a>The Ninth Pass</h3><p>The number datas in the page source are the coordinates of some dots, we need to use the <code>ImageDraw</code> module in <code>PIL</code> to draw.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">first = [<span class="number">146</span>,<span class="number">399</span>,<span class="number">163</span>,<span class="number">403</span>,<span class="number">170</span>,<span class="number">393</span>,<span class="number">169</span>,<span class="number">391</span>,<span class="number">166</span>,<span class="number">386</span>,<span class="number">170</span>,<span class="number">381</span>,<span class="number">170</span>,<span class="number">371</span>,<span class="number">170</span>,<span class="number">355</span>,<span class="number">169</span>,<span class="number">346</span>,<span class="number">167</span>,<span class="number">335</span>,<span class="number">170</span>,<span class="number">329</span>,<span class="number">170</span>,<span class="number">320</span>,<span class="number">170</span>,</span><br><span class="line"><span class="number">310</span>,<span class="number">171</span>,<span class="number">301</span>,<span class="number">173</span>,<span class="number">290</span>,<span class="number">178</span>,<span class="number">289</span>,<span class="number">182</span>,<span class="number">287</span>,<span class="number">188</span>,<span class="number">286</span>,<span class="number">190</span>,<span class="number">286</span>,<span class="number">192</span>,<span class="number">291</span>,<span class="number">194</span>,<span class="number">296</span>,<span class="number">195</span>,<span class="number">305</span>,<span class="number">194</span>,<span class="number">307</span>,<span class="number">191</span>,<span class="number">312</span>,<span class="number">190</span>,<span class="number">316</span>,</span><br><span class="line"><span class="number">190</span>,<span class="number">321</span>,<span class="number">192</span>,<span class="number">331</span>,<span class="number">193</span>,<span class="number">338</span>,<span class="number">196</span>,<span class="number">341</span>,<span class="number">197</span>,<span class="number">346</span>,<span class="number">199</span>,<span class="number">352</span>,<span class="number">198</span>,<span class="number">360</span>,<span class="number">197</span>,<span class="number">366</span>,<span class="number">197</span>,<span class="number">373</span>,<span class="number">196</span>,<span class="number">380</span>,<span class="number">197</span>,<span class="number">383</span>,<span class="number">196</span>,<span class="number">387</span>,<span class="number">192</span>,</span><br><span class="line"><span class="number">389</span>,<span class="number">191</span>,<span class="number">392</span>,<span class="number">190</span>,<span class="number">396</span>,<span class="number">189</span>,<span class="number">400</span>,<span class="number">194</span>,<span class="number">401</span>,<span class="number">201</span>,<span class="number">402</span>,<span class="number">208</span>,<span class="number">403</span>,<span class="number">213</span>,<span class="number">402</span>,<span class="number">216</span>,<span class="number">401</span>,<span class="number">219</span>,<span class="number">397</span>,<span class="number">219</span>,<span class="number">393</span>,<span class="number">216</span>,<span class="number">390</span>,<span class="number">215</span>,<span class="number">385</span>,</span><br><span class="line"><span class="number">215</span>,<span class="number">379</span>,<span class="number">213</span>,<span class="number">373</span>,<span class="number">213</span>,<span class="number">365</span>,<span class="number">212</span>,<span class="number">360</span>,<span class="number">210</span>,<span class="number">353</span>,<span class="number">210</span>,<span class="number">347</span>,<span class="number">212</span>,<span class="number">338</span>,<span class="number">213</span>,<span class="number">329</span>,<span class="number">214</span>,<span class="number">319</span>,<span class="number">215</span>,<span class="number">311</span>,<span class="number">215</span>,<span class="number">306</span>,<span class="number">216</span>,<span class="number">296</span>,<span class="number">218</span>,</span><br><span class="line"><span class="number">290</span>,<span class="number">221</span>,<span class="number">283</span>,<span class="number">225</span>,<span class="number">282</span>,<span class="number">233</span>,<span class="number">284</span>,<span class="number">238</span>,<span class="number">287</span>,<span class="number">243</span>,<span class="number">290</span>,<span class="number">250</span>,<span class="number">291</span>,<span class="number">255</span>,<span class="number">294</span>,<span class="number">261</span>,<span class="number">293</span>,<span class="number">265</span>,<span class="number">291</span>,<span class="number">271</span>,<span class="number">291</span>,<span class="number">273</span>,<span class="number">289</span>,<span class="number">278</span>,<span class="number">287</span>,</span><br><span class="line"><span class="number">279</span>,<span class="number">285</span>,<span class="number">281</span>,<span class="number">280</span>,<span class="number">284</span>,<span class="number">278</span>,<span class="number">284</span>,<span class="number">276</span>,<span class="number">287</span>,<span class="number">277</span>,<span class="number">289</span>,<span class="number">283</span>,<span class="number">291</span>,<span class="number">286</span>,<span class="number">294</span>,<span class="number">291</span>,<span class="number">296</span>,<span class="number">295</span>,<span class="number">299</span>,<span class="number">300</span>,<span class="number">301</span>,<span class="number">304</span>,<span class="number">304</span>,<span class="number">320</span>,<span class="number">305</span>,</span><br><span class="line"><span class="number">327</span>,<span class="number">306</span>,<span class="number">332</span>,<span class="number">307</span>,<span class="number">341</span>,<span class="number">306</span>,<span class="number">349</span>,<span class="number">303</span>,<span class="number">354</span>,<span class="number">301</span>,<span class="number">364</span>,<span class="number">301</span>,<span class="number">371</span>,<span class="number">297</span>,<span class="number">375</span>,<span class="number">292</span>,<span class="number">384</span>,<span class="number">291</span>,<span class="number">386</span>,<span class="number">302</span>,<span class="number">393</span>,<span class="number">324</span>,<span class="number">391</span>,<span class="number">333</span>,<span class="number">387</span>,</span><br><span class="line"><span class="number">328</span>,<span class="number">375</span>,<span class="number">329</span>,<span class="number">367</span>,<span class="number">329</span>,<span class="number">353</span>,<span class="number">330</span>,<span class="number">341</span>,<span class="number">331</span>,<span class="number">328</span>,<span class="number">336</span>,<span class="number">319</span>,<span class="number">338</span>,<span class="number">310</span>,<span class="number">341</span>,<span class="number">304</span>,<span class="number">341</span>,<span class="number">285</span>,<span class="number">341</span>,<span class="number">278</span>,<span class="number">343</span>,<span class="number">269</span>,<span class="number">344</span>,<span class="number">262</span>,<span class="number">346</span>,</span><br><span class="line"><span class="number">259</span>,<span class="number">346</span>,<span class="number">251</span>,<span class="number">349</span>,<span class="number">259</span>,<span class="number">349</span>,<span class="number">264</span>,<span class="number">349</span>,<span class="number">273</span>,<span class="number">349</span>,<span class="number">280</span>,<span class="number">349</span>,<span class="number">288</span>,<span class="number">349</span>,<span class="number">295</span>,<span class="number">349</span>,<span class="number">298</span>,<span class="number">354</span>,<span class="number">293</span>,<span class="number">356</span>,<span class="number">286</span>,<span class="number">354</span>,<span class="number">279</span>,<span class="number">352</span>,<span class="number">268</span>,</span><br><span class="line"><span class="number">352</span>,<span class="number">257</span>,<span class="number">351</span>,<span class="number">249</span>,<span class="number">350</span>,<span class="number">234</span>,<span class="number">351</span>,<span class="number">211</span>,<span class="number">352</span>,<span class="number">197</span>,<span class="number">354</span>,<span class="number">185</span>,<span class="number">353</span>,<span class="number">171</span>,<span class="number">351</span>,<span class="number">154</span>,<span class="number">348</span>,<span class="number">147</span>,<span class="number">342</span>,<span class="number">137</span>,<span class="number">339</span>,<span class="number">132</span>,<span class="number">330</span>,<span class="number">122</span>,<span class="number">327</span>,</span><br><span class="line"><span class="number">120</span>,<span class="number">314</span>,<span class="number">116</span>,<span class="number">304</span>,<span class="number">117</span>,<span class="number">293</span>,<span class="number">118</span>,<span class="number">284</span>,<span class="number">118</span>,<span class="number">281</span>,<span class="number">122</span>,<span class="number">275</span>,<span class="number">128</span>,<span class="number">265</span>,<span class="number">129</span>,<span class="number">257</span>,<span class="number">131</span>,<span class="number">244</span>,<span class="number">133</span>,<span class="number">239</span>,<span class="number">134</span>,<span class="number">228</span>,<span class="number">136</span>,<span class="number">221</span>,<span class="number">137</span>,</span><br><span class="line"><span class="number">214</span>,<span class="number">138</span>,<span class="number">209</span>,<span class="number">135</span>,<span class="number">201</span>,<span class="number">132</span>,<span class="number">192</span>,<span class="number">130</span>,<span class="number">184</span>,<span class="number">131</span>,<span class="number">175</span>,<span class="number">129</span>,<span class="number">170</span>,<span class="number">131</span>,<span class="number">159</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">134</span>,<span class="number">160</span>,<span class="number">130</span>,<span class="number">170</span>,<span class="number">125</span>,<span class="number">176</span>,<span class="number">114</span>,<span class="number">176</span>,</span><br><span class="line"><span class="number">102</span>,<span class="number">173</span>,<span class="number">103</span>,<span class="number">172</span>,<span class="number">108</span>,<span class="number">171</span>,<span class="number">111</span>,<span class="number">163</span>,<span class="number">115</span>,<span class="number">156</span>,<span class="number">116</span>,<span class="number">149</span>,<span class="number">117</span>,<span class="number">142</span>,<span class="number">116</span>,<span class="number">136</span>,<span class="number">115</span>,<span class="number">129</span>,<span class="number">115</span>,<span class="number">124</span>,<span class="number">115</span>,<span class="number">120</span>,<span class="number">115</span>,<span class="number">115</span>,<span class="number">117</span>,</span><br><span class="line"><span class="number">113</span>,<span class="number">120</span>,<span class="number">109</span>,<span class="number">122</span>,<span class="number">102</span>,<span class="number">122</span>,<span class="number">100</span>,<span class="number">121</span>,<span class="number">95</span>,<span class="number">121</span>,<span class="number">89</span>,<span class="number">115</span>,<span class="number">87</span>,<span class="number">110</span>,<span class="number">82</span>,<span class="number">109</span>,<span class="number">84</span>,<span class="number">118</span>,<span class="number">89</span>,<span class="number">123</span>,<span class="number">93</span>,<span class="number">129</span>,<span class="number">100</span>,<span class="number">130</span>,<span class="number">108</span>,<span class="number">132</span>,<span class="number">110</span>,</span><br><span class="line"><span class="number">133</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">107</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">140</span>,<span class="number">95</span>,<span class="number">138</span>,<span class="number">86</span>,<span class="number">141</span>,<span class="number">79</span>,<span class="number">149</span>,<span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">90</span>,<span class="number">165</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">109</span>,<span class="number">171</span>,<span class="number">107</span>,<span class="number">161</span>,</span><br><span class="line"><span class="number">111</span>,<span class="number">156</span>,<span class="number">113</span>,<span class="number">170</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">118</span>,<span class="number">208</span>,<span class="number">117</span>,<span class="number">223</span>,<span class="number">121</span>,<span class="number">239</span>,<span class="number">128</span>,<span class="number">251</span>,<span class="number">133</span>,<span class="number">259</span>,<span class="number">136</span>,<span class="number">266</span>,<span class="number">139</span>,<span class="number">276</span>,<span class="number">143</span>,<span class="number">290</span>,<span class="number">148</span>,<span class="number">310</span>,<span class="number">151</span>,</span><br><span class="line"><span class="number">332</span>,<span class="number">155</span>,<span class="number">348</span>,<span class="number">156</span>,<span class="number">353</span>,<span class="number">153</span>,<span class="number">366</span>,<span class="number">149</span>,<span class="number">379</span>,<span class="number">147</span>,<span class="number">394</span>,<span class="number">146</span>,<span class="number">399</span>]</span><br><span class="line">second = [<span class="number">156</span>,<span class="number">141</span>,<span class="number">165</span>,<span class="number">135</span>,<span class="number">169</span>,<span class="number">131</span>,<span class="number">176</span>,<span class="number">130</span>,<span class="number">187</span>,<span class="number">134</span>,<span class="number">191</span>,<span class="number">140</span>,<span class="number">191</span>,<span class="number">146</span>,<span class="number">186</span>,<span class="number">150</span>,<span class="number">179</span>,<span class="number">155</span>,<span class="number">175</span>,<span class="number">157</span>,<span class="number">168</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">157</span>,<span class="number">159</span>,</span><br><span class="line"><span class="number">157</span>,<span class="number">158</span>,<span class="number">164</span>,<span class="number">159</span>,<span class="number">175</span>,<span class="number">159</span>,<span class="number">181</span>,<span class="number">157</span>,<span class="number">191</span>,<span class="number">154</span>,<span class="number">197</span>,<span class="number">153</span>,<span class="number">205</span>,<span class="number">153</span>,<span class="number">210</span>,<span class="number">152</span>,<span class="number">212</span>,<span class="number">147</span>,<span class="number">215</span>,<span class="number">146</span>,<span class="number">218</span>,<span class="number">143</span>,<span class="number">220</span>,<span class="number">132</span>,<span class="number">220</span>,</span><br><span class="line"><span class="number">125</span>,<span class="number">217</span>,<span class="number">119</span>,<span class="number">209</span>,<span class="number">116</span>,<span class="number">196</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">114</span>,<span class="number">172</span>,<span class="number">114</span>,<span class="number">167</span>,<span class="number">112</span>,<span class="number">161</span>,<span class="number">109</span>,<span class="number">165</span>,<span class="number">107</span>,<span class="number">170</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">89</span>,<span class="number">164</span>,<span class="number">81</span>,<span class="number">162</span>,</span><br><span class="line"><span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">148</span>,<span class="number">87</span>,<span class="number">140</span>,<span class="number">96</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">141</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">111</span>,<span class="number">126</span>,<span class="number">113</span>,<span class="number">129</span>,<span class="number">118</span>,<span class="number">117</span>,<span class="number">128</span>,<span class="number">114</span>,<span class="number">137</span>,<span class="number">115</span>,<span class="number">146</span>,<span class="number">114</span>,<span class="number">155</span>,<span class="number">115</span>,</span><br><span class="line"><span class="number">158</span>,<span class="number">121</span>,<span class="number">157</span>,<span class="number">128</span>,<span class="number">156</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">136</span>,<span class="number">156</span>,<span class="number">136</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line">im = Image.new (<span class="string">&#x27;RGB&#x27;</span>, (<span class="number">500</span>, <span class="number">500</span>)) <span class="comment"># create a new image</span></span><br><span class="line">draw = ImageDraw.Draw (im) <span class="comment"># create a object</span></span><br><span class="line">draw.polygon (first, fill = <span class="string">&#x27;white&#x27;</span>) <span class="comment"># create a polygon, which is filled in white</span></span><br><span class="line">draw.polygon (second, fill = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">im.show ()</span><br></pre></td></tr></table></figure><h3 id="The-Tenth-Pass"><a href="#The-Tenth-Pass" class="headerlink" title="The Tenth Pass"></a>The Tenth Pass</h3><p>The sequence you get by clicking the bull is called $\text{look-and-say sequence}$. From $Google$, we can see that</p><blockquote><p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit.</p></blockquote><p>It is easy to use regular expression in $\text{Python}$  to obtain the target string.</p><p>However, I cannot understand I am supposed to regard my regular expression string as  <code>raw string</code>, instead of using it to find the characters straightly.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">strl = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">30</span>):</span><br><span class="line">    strl = <span class="string">&quot;&quot;</span>.join ([<span class="built_in">str</span> (<span class="built_in">len</span> (i + j)) + i <span class="keyword">for</span> i, j <span class="keyword">in</span> re.findall (<span class="string">&quot;(\d)(\\1*)&quot;</span>, strl)])</span><br><span class="line">    <span class="comment"># Why should I place another escape character ahead of &#x27;\1&#x27;??? Why????????</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span> (strl))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AMP Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A.F.O.心路历程&amp;NOI2020游记</title>
      <link href="/2021/07/19/A_F_O/"/>
      <url>/2021/07/19/A_F_O/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以一块 $Cu$ 结束了这么多年的 $\text{OI}$ 生涯</p><p>$Day ~ ~ 0$ 的笔试十分顺利地拿到了 $100$ 分满分，晚上一直在肝模板，但好像实际上并没有啥用，需要模板的部分分估摸着大多都快到正解了，咱也想不到</p><p>$Day ~ ~ 1$ 开始前，按照往年成绩，我给自己定下地分数目标大概是 $Day ~ ~ 1$ 要大于等于 $150$，$Day ~ ~ 2$ 大于等于 $130$ 左右，但我认为这样的目标间接造成了 $Day ~~ 1$ 比较大的失利</p><p>$T1$ 看了大概 $20min$ 左右就想到了 $O (kn^3\log n)$ 矩阵乘法的思路，但好像怎么算都最多只能过 $k = 0$ 的点，剩下的怎么算都过不去（实际上我认为这矩乘可以过 $k = 0$ 的时候时间也已经过去了很久），结合暴力这样就有 $65 pts$ 了，但由于给自己定下的目标，我一直在想后续解法，一直犹豫到想到了  $1h45min$ 左右也没啥想法，这时我算是比较慌张了，因为我本来是打算每题整个 $1.5h$，比较从容，但这么优柔寡断一下导致我最简单的暴力都一直打错，最后到 $2.5h$ 才勉勉强强写完了 $50 pts$，剩下 $15 pts$ 没办法了只能先晾一边</p><p>这时候开 $T2$，简单容斥很好想，但我卡在了如何高效的计算选出的每种集合包含的点数，想来想去感觉树剖比较合理，但过 $5e05$ 还是比较悬，本来想着能不能对每条边考虑来计算答案看看能不能拿更高，但好像搞不出来，此时已经又过了 $1h$，吸取了 $T1$ 的教训，我果断开始树剖，花了 $15 \sim 20min$ 左右敲完，发现每次会多覆盖一个 $lca$，本来想着每次跳完把 $lca$ 再删去，结果线段树部分死活写不出来，只好放弃，改 $bitset$ 直接暴力整集合然后取并，写完已经 $4h20min$ 了</p><p>于是只剩下 $40min$ 写 $T3$，看完题目用 $5 \sim 10min$ 写了 $24 pts$ 的暴力，开始想剩下的部分分，还以为 $Subtask 2$ 可以直接一个主席树了事，写完了主席树才发现假了，这个时候大概就 $4h45min$ 了，想放弃了，差点 <code>freopen</code> 没开直接见祖宗，想着今天只有 $102 pts$ 有点心态爆炸，于是在一片混沌之下过完了剩下的 $15min$</p><p>最终 $T1$ 写挂了环的部分，$T3$ 多了 $8 pts$，最终 $40 + 28 + 32 = 104$，比预期高了 $2 pts$，出来一看几乎所有人都是 $190+$，还有 $270+$ 甚至 $AK$ 的，发现 $T1$ 用 $1 \times n$ 的矩阵来乘，同时二进制拆分一下的 $trick$ 就可以 $O (kn^2\log n)$ 直接切掉，好像这是一个比较常规的 $trick$？不过我没见过，算了。$T2$ 的 $40 pts$ 直接考虑每条边的贡献然后子集和一下就好，剩下的 $60 pts$ 是树形 $dp$，可惜了没想到 $40 pts$，这肯定在我能力范围之内</p><p>晚上听讲评 $T3$ 是 $lxl$ 出的大分块题，原来 $NOI$ 也考 $YnOI$ 那些玩意儿啊。。反正我分块写的比较少，什么高维莫队第十三分块啥的我也不会，不过 $lxl$ 的头发好长。。<code>朝田诗乃</code> 过来写说不定能切？最后说了下大概的成绩分布，算上集训队和 $D、E$ 类，$240+$ 队线，$148$ 前 $200$，我估摸着去掉那些人大概 $125 \sim 130$ 应该是正统的前 $200$，可惜了</p><p>$Day ~ ~ 1$ 下午和晚上就颓，然后买了两本书，看了会儿，睡觉</p><p>$Day ~ ~ 2$ 想着能不能翻盘，但好像又没啥希望，于是就在两种思想中挣扎</p><p>进考场开 $T1$，花了 $15min$ 随便想了一个贪心，试了一下，好像能过 $n \le 4$ 和 $m = n - 1$ 的？说不定 $m \ge n$ 的也能过，然后就假装有 $35 pts$，开始想剩下的，一直觉得这题应该是一个网络流，但只能选 $1 \sim 2$ 个的限制就让我死活构不出图来，几次想到了几个图感觉没毛病，结果等费用流的敲完了才发现假的不能再假，于是就这样混沌地度过了 $1h45min$，去瞄了一眼 $T2$，题面贼长但挺有意思，理解完题意觉得这玩意儿一看就知道不是我会写的，瞥了眼部分分，$12 pts$ 一眼，剩下的都不会，于是我打算写 $12 pts$，剩下的直接加一些特判然后 $rand ()$，然后滚回 $T1$</p><p>$Day ~ ~ 2$ 由于题目对我比较自闭所以时间也懒得管了，反正都不会。。不知何时开了下 $T3$，发现连 $30 pts$ 都不会，想着玩球了，然后敲了个深搜再随便输出了个最短路骗分</p><p>于是 $Day ~ ~ 2$ 就在题目交叉混想（主要在想 $T1$ 网络流）中结束了（最后我 $T1$ 用贪心骗分）</p><p>$CCF$ 晚了 $1.5h$ 才开成绩，在场外手机都快看没电了。。最终 $35 + 4 + 0 = 39$，$T2$ 估计是后面魔改完忘记再测一下 $h_{max} \le 2$ 的数据结果翻车了，$T3$ 忘记输出 $- 1$ 不然能有 $5 pts$，事实证明你不能用脸翻盘，粉兔 $T1$ 随机化 $70 +$，$nealchen$ 达到了 $200$ 整，他们看着必进队啊，很厉害</p><p>讲评也挺不太懂，好像我 $T1$ 的 $35 pts$ 的贪心跟正解不是一回事？反正就是会的会，不会的还是不会，这样的话总分 $100 + 104 + 39 = 243$，这成绩看着炼铜术士稳了，但还抱有一线能给铜抛光上银的希望，最终队线 $447$，银牌 $274$，$FJ$ 四个进队，兔差 $1$ 分 $Au$，但队是肯定进了</p><p>今年 $Ag$ 数目增加了 $50$ 个，省选前大半年没搞了，多少还是会有些心里没底，但还是认为拿 $Ag$ 还是比较稳的，况且没拿到 $Ag$ 强基也不会有什么优惠，所以等到两天成绩出来的时候，还算是比较失望的（虽然后面逐渐佛系），想着如果我 $T1$ 没丢那 $10 pts$，再把 $k = 0$ 敲完，$T2$ 捡回 $13 pts$，好像能压 $Ag$ 线呢？感觉今年的题比较偏，对我这种刷题比较少的很不友好，这些类型题我都几乎没做过，如果换像去年常规一点的我应该也能 $Ag$？不过这都是后话，多少会有些不甘心，不过自己的水平就摆在那儿，技不如人，甘拜下风</p><p>这样算是给整个 $\text{OI}$ 生涯划上了个圆满的句号，虽然没有强基的优惠还是会失落，但毕竟进过了省队，来过了国赛，见到甚至认识了那些之前只闻其名可望而不可及的神仙，眼界也不一样了</p><p>考完之后和其它强校的教练交流了一下，他们也说了他们的教学指导和方法，各个部分连接紧凑，有理有据，大部分采用的是单或双教师统一管理，有历届高手传承，学术交流范围更广，不至于说就我们同级团队内部交流，水平顶天了也就那么多，交流来交流去不过还是那一回事，进展缓慢，他校从一定程度开始就经常有比较密集的队内或多校互测，在作为选手的同时，还有很多作为出题人与老师的机会，所谓 <code>教学相长</code> 也正是如此，除此以外还有更多指导方法，若是在当时停课的时候，甚至是从初中开始以这种模式训练，我相信我还是有能力去接近那些高手的水平</p><p>说实话，这次最遗憾的倒不是拿了 $Cu$，因为虽然有一定失误因素，但主要还是技不如人，最遗憾的其实便是我本来可能可以拥有那些高手的实力，却成了现在的样子</p><p>好了，$\text{OI}$ 生涯就此结束，该滚回去肝文化课了</p><p>$\text{A.F.O.}$ 快乐</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRT（中国剩余定理）及其扩展</title>
      <link href="/2021/07/19/CRT%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%89%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/"/>
      <url>/2021/07/19/CRT%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%89%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h2><p>用于求解类似<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2} \\<br>&amp;… \\<br>&amp;x \equiv a_n \pmod{m_n}<br>\end{aligned}<br>\right.<br>$$<br>其中，$\forall i, j, ~ (m_i, m_j) = 1$</p><p>设 $M = \prod_{i = 1}^n m_i, ~ M_i = \frac{M}{m_i}$，再设 $M_it_i \equiv 1 \pmod{m_i}$，其中 $1 \le i \le n$</p><p>则可构造一解 $x = \sum\limits_{i = 1}^n a_iM_it_i$，任意解 $x_0 = x + k \times M$</p><h2 id="ExCRT"><a href="#ExCRT" class="headerlink" title="ExCRT"></a>ExCRT</h2><p>用于求解类似<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2} \\<br>&amp;… \\<br>&amp;x \equiv a_n \pmod{m_n}<br>\end{aligned}<br>\right.<br>$$<br>其中，不一定满足 $\forall i, j, ~ (m_i, m_j) = 1$</p><p>考虑两个两个处理，然后合并</p><p>现在先考虑方程<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2}<br>\end{aligned}<br>\right.<br>$$<br>将同余去掉，再进行变换<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x = a_1 + k_1m_1 \\<br>&amp;x = a_2 + k_2m_2<br>\end{aligned}<br>\right. \\<br>\Rightarrow k_1m_1 - k_2m_2 = a_2 - a_1<br>$$</p><p>那么此时若 $(m_1, m_2) | (a_2 - a_1)$ 则有解，反之则无解</p><p>当然这时就可以用 $ExGCD$ 直接求解，但接下来把它化成逆元的形式会更容易解开也更不耗时</p><p>令 $d = (m_1, m_2)$，则<br>$$<br>\begin{aligned}<br>\frac{k_1m_1}d - \frac{k_2m_2}d &amp;= \frac{a_2 - a_1}d \\<br>\frac{k_1m_1}d &amp;\equiv \frac{a_2 - a_1}d \pmod{\frac{m_2}d} \\<br>k_1 &amp;\equiv inv (\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d \pmod{\frac{m_2}d} \\<br>k_1 &amp;= inv (\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d + t\frac{m_2}d \\<br>\end{aligned}<br>$$<br>其中 $inv (x, p)$ 表示 $x$ 在模 $p$ 意义下的逆元</p><p>此时将 $k_1$ 代入 $x = a_1 + k_1m_1$，则有<br>$$<br>x \equiv a_1 + m_1 \times inv(\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d \pmod{\frac{m_1m_2}d}<br>$$<br>然后合并 $n - 1$ 次即可</p><h2 id="Ex-ExCRT"><a href="#Ex-ExCRT" class="headerlink" title="Ex-ExCRT"></a>Ex-ExCRT</h2><p>If we suppose that our equation set is something like this:<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;b_1x \equiv a_1 \pmod{p_1} \\<br>&amp;b_2x \equiv a_2 \pmod{p_2} \\<br>&amp;… \\<br>&amp;b_nx \equiv a_n \pmod{p_n}<br>\end{aligned}<br>\right.<br>$$<br>then we need to change the way we process the equations</p><p>Suppose that we have got the answer of the first $i - 1$ congruence equations, we call it $ans$. And suppose $M$ to be the least common multiple of $\{p_1,p_2, p_3, …, p_n\}$, then obviously, the answer of the first $i$ congruence equations $ANS$ should be $ans + kM (k \in \mathbb Z)$. Let us start to derive:<br>$$<br>\begin{aligned}<br>&amp;ANS = ans + Mx \\<br>&amp;\Rightarrow b_i (ans + Mx) \equiv a_i \pmod{p_i} \\<br>&amp;\Rightarrow b_iMx \equiv a_i - b_i \times ans \pmod{p_i} \\<br>&amp;\Rightarrow b_iMx + p_iy = a_i - b_i \times ans<br>\end{aligned}<br>$$<br>Apparently, we can use $ExCRT$ to solve the last equation.</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRT/ExCRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说话</title>
      <link href="/2021/07/19/hello-world/"/>
      <url>/2021/07/19/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>终于搞完了。。</p><p>这是第三版的博客迁移</p><p>之前由于咕了一段时间OI</p><p>搞的原博客服务器过期域名过期数据全没了</p><p>然后就重新搞了这么一个玩意儿</p><p>至于原因</p><p>大概就是咕了半年后去省选摸个鱼一不小心进队了</p><p>于是就得准备NOI了</p><p>当然，这个“一不小心”不带有任何自傲的意思</p><p>我只是觉得自己的水平还没有达到标准。。</p><p>还有一个月，出去集训</p><p>希望到NOI的时候能达到自己想要的水平吧</p><p>保银争金</p><p>那么我的博客也得重新回来了</p><p>嗯</p><p>就这样</p><p>$\text{Upd:}$ <a href="https://colythme.github.io/2020/08/21/A_F_O/">A.F.O.心路历程&amp;NOI2020游记</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十六）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>$\text{OEIS}$ $trick$</p><p>$\text{score：100 + 0 + 0 = 100            rk：6/35}$</p><h2 id="Problem-A：数排列"><a href="#Problem-A：数排列" class="headerlink" title="Problem A：数排列"></a>Problem A：数排列</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/L1XrIYc2SMA5eDV.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>打表，然后 $\text{OEIS}$ 第 <a href="http://oeis.org/A005802" target="_blank" rel="noopener">A005802</a> 序列</p><p>本来想着题解可能会给出正解，然而他这么说</p><blockquote><p>问题是求一个数列的第 $n$ 项，但该数列显然不是线性递推数列， 但可以猜想该数列是整式递推数列。利用高斯消元或扩展 $BM$，可得……</p></blockquote><p>好了那估摸着正解就 $\text{OEIS}$ 吧</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e05</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; LL MOD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL vis[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[MAX] = power (fact[MAX], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAX - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) invfact[i] = invfact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>, a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt; (MAX &gt;&gt; <span class="number">1</span>); n ++) &#123;</span><br><span class="line">LL add = (<span class="number">10l</span>l * n % MOD * n % MOD + <span class="number">10l</span>l * n % MOD + <span class="number">3</span>) % MOD * a[n] % MOD;</span><br><span class="line">add = (add - <span class="number">9l</span>l * n % MOD * n % MOD * a[n - <span class="number">1</span>] % MOD + MOD) % MOD;</span><br><span class="line">a[n + <span class="number">1</span>] = add * power (<span class="number">1l</span>l * (n + <span class="number">1</span>) * (n + <span class="number">1</span>) % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* (n+1)^2 a(n+1) = (10*n^2+10*n+3) * a(n) - 9*n^2 * a(n-1). */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (vis, - <span class="number">1</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">T = getnum (); <span class="built_in">cin</span> &gt;&gt; MOD;</span><br><span class="line">init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = getnum ();</span><br><span class="line"><span class="keyword">if</span> (~ vis[n]) &#123; <span class="built_in">cout</span> &lt;&lt; vis[n] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">LL ans = ((<span class="number">18l</span>l * n + <span class="number">45</span>) % MOD * a[n]- (<span class="number">7l</span>l + <span class="number">2</span> * n) % MOD * a[n + <span class="number">1</span>] % MOD + MOD) % MOD;</span><br><span class="line">ans = ans * power (<span class="number">6l</span>l * (n + <span class="number">2</span>) % MOD * (n + <span class="number">2</span>) % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vis[n] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a(n) = 2 * Sum_&#123;k=0..n&#125; binomial(2*k, k) * (binomial(n, k))^2 * </span></span><br><span class="line"><span class="comment">  (3*k^2 + 2*k+1 - n - 2*k*n)/((k+1)^2 * (k+2) * (n-k+1)).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Problem-B：排列"><a href="#Problem-B：排列" class="headerlink" title="Problem B：排列"></a>Problem B：排列</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/IZAX16L2sirGPgw.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/rZMB8nmuJ1YoweS.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>第一次订正的交互题</p><p>大概记录一下交互题咋玩</p><ul><li>编译可以通过在电脑 $\text{path}​$ 中添加编译器路径，通过 $\text{cmd}​$ $\text{cd}​$ 到指定文件夹，输入题目给定编译语句编译，再运行 $\text{xxx.exe}​$ 运行，输入数据，最后在 $\text{cmd}​$ 中返回答案正确性及询问次数</li><li>编译运行简易方法，可直接加入头文件 <code>#include &quot;grader.cpp&quot;</code>，此时可直接编译运行</li></ul><p>回到正题</p><p>随机一个排列 $q​$，再随机地改变 $q​$ 中的 $S​$ 个元素，使这 $S​$ 个元素重新错排，设得到排列 $r​$，改变了位置 $a_1, a_2, …, a_S​$，那么有一定概率满足所有 $|p_{a_i} - q_{a_i}|​$ 构成的数的集合 $A​$ 与 $|p_{a_i} - r_{a_i}|​$ 构成的数的集合 $B​$ 完全没有交集，此时取 $S = \frac{\sqrt n}{2}​$ 可以使该概率比较大（证明咱也不会）</p><p>假定此时满足 $|A \cup B| = 2S​$，即满足两个集合无交，那么我们由 $A​$ 可以对每个 $q_{a_i}​$ 得到最多 $2 \times S​$ 个它可以匹配的位置，同样对 $B​$ 与 $r_{a_i}​$ 也是一样，这实际上就变成了一个二分图，为了方便，将其反过来记，即每次由 $A​$ 得到每个 $q_{a_i}​$ 不可能匹配到的位置，然后在二分图上将这些边删去，那么最终找到答案的情况等价于二分图匹配具有唯一性，这个用网络流和 $Tarjan​$ 维护一下就好了</p><p>进一步优化，随机几次之后可能一些位置已经确定了唯一匹配性，那么每次随机选 $S$ 个元素的时候优先选还未成功匹配的位置</p><p>再者，在 $n$ 比较小时可能很难随到答案，就可以在开头时随十个 $q$，然后每次随机使用其中一个 $q$，这样可以比较大的概率避免这样的情况</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"perm.h"</span></span></span><br><span class="line"><span class="comment">// #include "grader.cpp"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN], bel[MAXN], ord = <span class="number">0</span>, bcc = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = ord = bcc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) dfn[i] = low[i] = bel[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top = <span class="number">0</span>; <span class="keyword">bool</span> insta[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ ord;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = u, insta[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (! dfn[v]) &#123;</span><br><span class="line">Tarjan (v);</span><br><span class="line">low[u] = min (low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (insta[v]) low[u] = min (low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">bcc ++; <span class="keyword">int</span> tp;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tp = <span class="built_in">stack</span>[top --];</span><br><span class="line">bel[tp] = bcc, insta[tp] = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (tp != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="keyword">if</span> (! dfn[i]) Tarjan (i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">bool</span> con[<span class="number">1000</span>]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">namespace</span> net &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (u, v, cap), Insert (v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, S, T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123; <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que; <span class="keyword">int</span> depth[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[u] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (rest, cap));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">graph::N = <span class="number">2</span> * n, graph::init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[j].to, cap = Link[j].cap;</span><br><span class="line"><span class="keyword">if</span> (! cap) graph::Insert (i, match[i] = v);</span><br><span class="line"><span class="keyword">else</span> graph::Insert (v, i);</span><br><span class="line">&#125;</span><br><span class="line">graph::work ();</span><br><span class="line"><span class="keyword">bool</span> suc = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph::bel[i] == graph::bel[match[i]]) suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> con[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ext[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> N, S, B = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">trans</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret; ret.resize(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) ret[p[i] - <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ask</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123; <span class="keyword">return</span> query (trans (p)); &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[<span class="number">11</span>], r, rkc, rkd, rk;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qq[<span class="number">11</span>], qr, f1, f2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> cnt1[MAXN]= &#123;<span class="number">0</span>&#125;, cnt2[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">net::init (), net::n = N, net::N = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line">net::S = <span class="number">2</span> * N + <span class="number">1</span>, net::T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (ext[i][j]) net::addedge (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) net::addedge (net::S, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) net::addedge (i + N, net::T, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis1[MAXN], vis2[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rand () % B + <span class="number">1</span>; rkc.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) <span class="keyword">if</span> (! con[i + <span class="number">1</span>]) rkc.push_back(i);</span><br><span class="line">random_shuffle (rkc.begin(), rkc.end());</span><br><span class="line">rkd.clear(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) <span class="keyword">if</span> (con[i + <span class="number">1</span>]) rkd.push_back(i);</span><br><span class="line">random_shuffle (rkd.begin(), rkd.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) rkd.size(); i ++) rkc.push_back(rkd[i]);</span><br><span class="line">rk.clear(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) rk.push_back(rkc[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S; i ++) swap (rk[i], rk[rand () % i]);</span><br><span class="line">r.resize(N); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) r[i] = q[p][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) r[rkc[i]] = q[p][rk[i]]; qr = ask (r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cnt1[i] = cnt2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cnt1[qq[p][i]] ++, cnt2[qr[i]] ++;</span><br><span class="line">f1.clear(), f2.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (cnt1[i] &gt; cnt2[i]) f1.push_back(i), cnt1[i] --;</span><br><span class="line"><span class="keyword">while</span> (cnt1[i] &lt; cnt2[i]) f2.push_back(i), cnt1[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) f1.size() != S || (<span class="keyword">int</span>) f2.size() != S) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x1 = q[p][rkc[i]], x2 = r[rkc[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) vis1[i] = vis2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x1 - f1[j] &gt;= <span class="number">1</span>) vis1[x1 - f1[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x1 + f1[j] &lt;= N) vis1[x1 + f1[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x2 - f2[j] &gt;= <span class="number">1</span>) vis2[x2 - f2[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x2 + f2[j] &lt;= N) vis2[x2 + f2[j]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (! vis1[j] || ! vis2[j]) ext[rkc[i] + <span class="number">1</span>][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">build (); <span class="keyword">int</span> flow = net::maxflow ();</span><br><span class="line"><span class="keyword">if</span> (flow &lt; N) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (! net::check ()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[net::match[i] - N - <span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">guess</span> <span class="params">(<span class="keyword">int</span> pn)</span></span>&#123;</span><br><span class="line">N = pn;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret.push_back(i);</span><br><span class="line"><span class="keyword">while</span> (query (ret).back()) next_permutation (ret.begin(), ret.end());</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">srand (time (<span class="literal">NULL</span>));</span><br><span class="line">S = <span class="built_in">sqrt</span> (N) / <span class="number">2</span>; S = max (S, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) q[i].push_back(j);</span><br><span class="line">random_shuffle(q[i].begin(), q[i].end());</span><br><span class="line">qq[i] = ask (q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">ext[i][j] = <span class="literal">true</span>;</span><br><span class="line">ret.resize(N); <span class="keyword">while</span> (! work ());</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ grader.cpp perm.cpp -o perm -O2 -std=c++11</span></span><br></pre></td></tr></table></figure><h2 id="Problem-C：塔"><a href="#Problem-C：塔" class="headerlink" title="Problem C：塔"></a>Problem C：塔</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训 </tag>
            
            <tag> OEIS </tag>
            
            <tag> 交互题 </tag>
            
            <tag> 随机化 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十五）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>$\text{score：0 + 0 + 0 = 0            rk：32/39}$</p><h2 id="Problem-A：最短路"><a href="#Problem-A：最短路" class="headerlink" title="Problem A：最短路"></a>Problem A：最短路</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/uskNSrKd29XJQVq.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/FSp9RLq7WQkXEou.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>该路径一定是从 $1$ 走到 $n$ 后，在从 $n$ 返回 $1$ 时在外围走一遭，再回到 $1 \rightarrow n$ 的路径走一段，再出去向 $1$ 走一段。。</p><p>设往外围走时的起点为 $a$ 类点，回到 $1 \rightarrow n$ 路径的点为 $b$ 类点，容易知道 $a$ 和 $b$ 交错出现才可能最优，那么整个图大概就这么个样（起点和终点不作标记）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/1OtoEkzY6W78NwX.png" alt=""></p><p>令 $f_{i, j}$ 表示从 $1$ 走到 $i$，最后一个点为 $i$，为 $a$ 类点，倒数第二个点为 $j$，为 $b$ 类点</p><p>令 $g_{i, j}$ 表示从 $1$ 走到 $i$，最后一个点为 $i$，$i, j$  都为 $b$ 类点</p><p>实际上 $f$ 可以直接转移，不需要 $g$，但这样复杂度时 $O (n^4)$ 的，故 $g$ 相当于辅助函数</p><p>用类似 $Dijkstra$ 的形式转移，设 $i$ 到 $j$ 的最短路径为 $d_{i, j}$（即使路径上所有点的权值和最小，包括 $i, j$）</p><p>假设此时取出 $f_{x, y}$ 则有<br>$$<br>g_{k, y} = \min\{f_{x, y} + d_{x, k} - p_x\}<br>$$<br>即多出一个 $a$ 类点 $x$ 到 $b$ 类点 $k$ 的路径</p><p>假设此时取出 $g_{x, y}$，则有<br>$$<br>f_{k, x} = \min \{g_{x, y} + d_{x, k} + d_{k, y} - p_x - p_y - p_k\}<br>$$<br>直接用堆维护是 $O (n^3 \log n)$ 的，但观察一下发现在 $j$ 相同时，每次可以枚举取最小值，故最终复杂度 $O (n^3)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, d[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">2</span>][MAXN][MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val, x, y;</span><br><span class="line">node (<span class="keyword">int</span> val = <span class="number">0</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : val (val), x (x), y (y) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node maxf[MAXN], maxg[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getm</span> <span class="params">(node&amp; a, node b)</span> </span>&#123; <span class="keyword">if</span> (b.val &lt; a.val) a = b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workf</span> <span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">maxf[j] = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! visit[<span class="number">0</span>][i][j])</span><br><span class="line">getm (maxf[j], node (f[i][j], i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workg</span> <span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">maxg[j] = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! visit[<span class="number">1</span>][i][j])</span><br><span class="line">getm (maxg[j], node (g[i][j], i, j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (d, INF, <span class="keyword">sizeof</span> (d));</span><br><span class="line"><span class="built_in">memset</span> (f, INF, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="built_in">memset</span> (g, INF, <span class="keyword">sizeof</span> (g));</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123; a[i] = getnum (); d[i][i] = a[i]; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">d[u][v] = a[u] + a[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">d[i][j] = min (d[i][j], d[i][k] + d[k][j] - a[k]);</span><br><span class="line"><span class="keyword">if</span> (d[<span class="number">1</span>][N] &gt;= INF || d[N][<span class="number">1</span>] &gt;= INF) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>]; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) workf (i), workg (i);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">node mf, mg; mf = mg = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) getm (mf, maxf[i]), getm (mg, maxg[i]);</span><br><span class="line"><span class="keyword">int</span> type = mf.val &lt;= mg.val ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">getm (mf, mg);</span><br><span class="line"><span class="keyword">if</span> (mf.val &gt;= INF) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> x = mf.x, y = mf.y;</span><br><span class="line"><span class="keyword">if</span> (type) &#123;</span><br><span class="line">visit[<span class="number">1</span>][x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (k != y)</span><br><span class="line">f[k][x] = min (f[k][x], g[x][y] + d[x][k] + d[k][y] - a[x] - a[y] - a[k]);</span><br><span class="line">workf (x), workg (y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">visit[<span class="number">0</span>][x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line">g[k][y] = min (g[k][y], f[x][y] + d[x][k] - a[x]);</span><br><span class="line">workf (y), workg (y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N][N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训 </tag>
            
            <tag> 最短路DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>初来乍到，4h20min的题我打了2h，成功垫底，恭喜我自己</p><p>$\text{score：20 + 0 + 0 = 20   rk：26/27}$</p><h2 id="Problen-A"><a href="#Problen-A" class="headerlink" title="Problen A"></a>Problen A</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="http://xsy.gdgzez.com.cn/JudgeOnline/upload/attachment/image/20200701/20200701213322_88297.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看他们都会写。。这种比较复杂的容斥我几乎都没写过。。</p><h4 id="前置知识：高维前缀和"><a href="#前置知识：高维前缀和" class="headerlink" title="前置知识：高维前缀和"></a>前置知识：高维前缀和</h4><p>举个例子，对比如现在要求解 $\sum\limits_{s = 0}^{2^n - 1}\sum\limits_{j \in s} a_j$（此处 $\in$ 是二进制表示下的意义），直接枚举子集是 $O (3^n)$ 的，那么高维前缀和可以优化到 $O (n2^n)$</p><p>考虑低位前缀和，比如三位，我们是不是可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i - <span class="number">1</span>][j][k]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i][j - <span class="number">1</span>][k]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i][j][k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>就是对每一维分别求前缀和，那么高维前缀和也是这个思想，即 $f_{s \oplus (1 &lt;&lt; j)} \rightarrow f_s$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= limit; s ++)</span><br><span class="line">        <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">            f[s] += f[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))];</span><br></pre></td></tr></table></figure><h4 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h4><p>令 $|s|$ 表示 $s$ 的二进制表示下 $1$ 的个数</p><p>设 $g_s$ 表示构成最终状态 $s$ 的方案数，$f_s$ 表示状态 $s$ 二进制表示中的为 $0$ 位的卡片<strong>至少</strong>不存在于最终收藏的方案数，那么容斥一下有<br>$$<br>g_s = \sum\limits_{j \in s} f_j \times (-1)^{|s - j|}（根据多出来的 0 的个数进行容斥）<br>$$<br>那么现在考虑求 $f_s$</p><p>先考虑暴力计算，枚举 $s$，将每一轮满足相位置是零的组合的概率加起来为 $sum_i$，最后则有 $f_s = \prod sum_i$，这样显然会 $T$</p><p>对每一轮，可能满足的组合的组合共有 $2^k$ 种，现在考虑这 $2^k$ 种可能性分别都贡献到哪儿了</p><p>设对于当前取 $2^k$ 种状态中的一种所表示出的二进制状态为 $s$，该种组合的组合对应的卡片集合 $card_s$，概率和 $p_s$，那么很明显它可以贡献到的就是 $card_s$ 的超集，当然由于它子集也会贡献到那些超集，故还需容斥掉，设它使超集需要乘上数 $L_{card_s}$<br>$$<br>L_{card_s} = \prod\limits_{j \in s} p_j^{(- 1)^{|s - j|}}<br>$$<br>之后就可以通过计算子集给 $f_s$ 的贡献直接求出 $f_s$ 了</p><p>需要注意的是，当 $j$ 取空集的时候，$p_j = 0$，而 $p_j$ 又有可能被作为除数，故此时需要开一个数组计算到此为止究竟乘和除以了多少个零，若最终乘的次数多，则直接将 $f_s$ 赋零</p><p>最后一遍容斥求出 $g_s$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> KTRS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="keyword">int</span> mp[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXK], p[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> suma[KTRS]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sump[KTRS]= &#123;<span class="number">0</span>&#125;, undp[KTRS]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> zocnt[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL f[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL g[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; i ++) mp[i] = mp[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i ++) pcnt[i] = pcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i ++) f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> K = getnum (), d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line">a[j] = getnum (), p[j] = getnum ();</span><br><span class="line">d += p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> poe = power (<span class="number">1l</span>l * d, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) p[j] = <span class="number">1l</span>l * p[j] * poe % MOD;</span><br><span class="line"><span class="keyword">int</span> lik = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>;</span><br><span class="line">sump[<span class="number">0</span>] = undp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lik; j ++) &#123;</span><br><span class="line">suma[j] = suma[j ^ lowbit (j)] | a[mp[lowbit (j)]];</span><br><span class="line">sump[j] = (sump[j ^ lowbit (j)] + p[mp[lowbit (j)]]) % MOD;</span><br><span class="line">undp[j] = power (sump[j], MOD - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">sump[<span class="number">0</span>] = undp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= lik; k ++)</span><br><span class="line"><span class="keyword">if</span> (k &amp; l) &#123;</span><br><span class="line">sump[k] = sump[k] * undp[k ^ l] % MOD;</span><br><span class="line">undp[k] = undp[k] * sump[k ^ l] % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">zocnt[<span class="number">0</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lik; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pcnt[j] &amp; <span class="number">1</span>) zocnt[suma[j]] --;</span><br><span class="line"><span class="keyword">else</span> zocnt[suma[j]] ++;</span><br><span class="line">f[suma[j]] = f[suma[j]] * sump[j] % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++)</span><br><span class="line"><span class="keyword">if</span> (j &amp; l) &#123;</span><br><span class="line">f[j] = f[j] * f[j ^ l] % MOD;</span><br><span class="line">zocnt[j] += zocnt[j ^ l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (zocnt[i] &gt; <span class="number">0</span>) g[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> g[i] = f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++)</span><br><span class="line"><span class="keyword">if</span> (j &amp; l) g[j] = (g[j] - g[j ^ l] + MOD) % MOD; <span class="comment">// 注意这里使容斥，某个g[j]被减两次则变成加</span></span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++) ans ^= g[j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 个点 $m$ 条边的连通无向图，边上有边权，求该无向图的最小直径生成树，其具有最小的直径</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 500, ~ n - 1 \le m \le \frac{n(n - 1)}{2}, ~ 1 \le 边权 \le 10^9$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这玩意儿好像和求什么图的绝对中心是一样的，图的绝对中心就是指一个中心，到最远的点路径最短</p><p>那就通过图的绝对中心来求解这道题</p><p>假设改图的绝对中心为点 $p$，那么它可以是某条边的端点也可以在某条边上</p><p>首先有一个结论</p><blockquote><p>距离 $p$ 最远的点至少有两个点 $u, v$，并且它们到 $p$ 的距离相等</p></blockquote><p>这条结论很容易证明，若 $dis (u, p) \ne dis (v, p)$，那么将点 $p$ 往较远的那个端点稍微移动一下即可得到更优的答案此时假定 $p$ 在边 $(u, v)$ 上，$(u, v)$ 长 $L$，$p$ 距离点 $u$ 为 $x$，那么任意一点 $s$ 到 $p$ 的距离即为 $\min(dis (s, u) + x, dis (s, v) + L - x)$</p><p>可以发现，这个距离以函数形式表示出来是一条折线（上升部分斜率为 $1$，下降部分 $- 1$）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/13/Fn3jhbO9fVvUz2B.jpg" alt=""></p><p>（图源来自论文《Play with Trees Solutions》）</p><p>然后你就可以搞出 $n$ 条折线，其中横坐标对应每一种 $x$ 的取值，所以同一 $x$ 坐标对应同一个中心</p><p>而要求的是所有距离中的最大值，这对应实线部分</p><p>你又要保证最大的最小，故只需在实现部分取最小即为答案，通过图像可以看出，该最小值点一定为某两条折线的交点</p><p>那么就可以枚举所有点对 $(u, v)$，并按 $dis_{u, s}$ 进行排序，用扫描的做法求解了</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rnk[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">f[i][j] = f[j][i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">f[u][v] = f[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">f[i][j] = min (f[i][j], f[i][k] + f[k][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) rnk[i][j] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (f[i][rnk[i][j]] &gt; f[i][rnk[i][k]])</span><br><span class="line">swap (rnk[i][j], rnk[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">LL ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; u ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N; v ++) &#123;</span><br><span class="line">ans = min (ans, f[u][rnk[u][N]] &lt;&lt; <span class="number">1</span>); <span class="comment">// 中心取端点处</span></span><br><span class="line">ans = min (ans, f[v][rnk[v][N]] &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> k = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (f[v][rnk[u][i]] &gt; f[v][rnk[u][k]]) &#123; <span class="comment">// 判断两折线是否有交</span></span><br><span class="line">ans = min (ans, f[u][rnk[u][i]] + f[u][v] + f[v][rnk[u][k]]);</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 集训 </tag>
            
            <tag> 生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十四）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>成功由垫底转至中下水平。。</p><p>恭喜。。我？</p><p>$\text{score：55 + 0 + 0 = 55   rk：21/33}$</p><h2 id="Problem-A：猜想"><a href="#Problem-A：猜想" class="headerlink" title="Problem A：猜想"></a>Problem A：猜想</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/11/lzHy4UCcSLXmiVD.png" alt=""></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，记 $l$ 表示 $n$ 的长度，则 $1 \le l \le 2 \times 10^5$，保证 $n$ 的最高位为 $1$，且除此之外的 $l - 1$ 位使用 $\text{std::mt19937}$ 随机生成</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考场上敲了个 $55$ 分的暴力，本来想说看能不能枚举每一位然后直接算它的状态，然后不行</p><p>出题人提供的题解没看懂，就看了看其他 $A$ 掉的人的思路</p><p>首先考虑分块，使分出的块尽量大，取块大小 $L = 24$，对每一块分别处理</p><p>处理当前块时先不考虑右移删 $0$ 的情况，先只考虑乘三加一的情况，最后只要在答案上加上二进制位总数即可</p><p>设第 $i$ 块储存的数为 $a_i$</p><p>类似线段树处理乘法时的操作，记两个变量 $mul, add$ 记录总共乘了多少，总共进位多少，那么转移到 $a_j$ 时则有 $a_j = mul * a_j + add$，以此类推</p><p>细节就看代码吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">24</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;, bn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lowbit</span> <span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i ++) &#123;</span><br><span class="line">LL mul = <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a[i]) &#123;</span><br><span class="line">mul *= <span class="number">3</span>, add *= <span class="number">3</span>;</span><br><span class="line">a[i] = a[i] * <span class="number">3</span> + lowbit (a[i]); <span class="comment">// 此处由于没删0故加上的是lowbit</span></span><br><span class="line">add += a[i] &gt;&gt; L; a[i] &amp;= (<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>; <span class="comment">// 保持a[i]只有L位，同时计算进位add</span></span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= bn; j ++) &#123;</span><br><span class="line">a[j] = a[j] * mul + add;</span><br><span class="line">add = a[j] &gt;&gt; L; a[j] &amp;= (<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (add) &#123; a[++ bn] = add &amp; ((<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>); add &gt;&gt;= L; &#125;</span><br><span class="line">ans += L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a[bn] ^ <span class="number">1</span>) &#123;</span><br><span class="line">a[bn] = a[bn] &amp; <span class="number">1</span> ? a[bn] * <span class="number">3</span> + <span class="number">1</span> : a[bn] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">N = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span> &amp;&amp; str[<span class="number">1</span>] == <span class="string">'1'</span>) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">reverse (str + <span class="number">1</span>, str + N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! ((i - <span class="number">1</span>) % L)) bn ++;</span><br><span class="line">a[bn] |= (str[i] - <span class="string">'0'</span>) &lt;&lt; ((i - <span class="number">1</span>) % L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：覆盖"><a href="#Problem-B：覆盖" class="headerlink" title="Problem B：覆盖"></a>Problem B：覆盖</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/02/LuFUy4JASC3b1VZ.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/02/fe1ZOXTEyudg6m7.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>连神仙都说神仙的神仙题</p><p>设 $S_i$ 表示点 $i$ 连接的点的集合</p><p>从小问题开始思考，考虑点 $1, 2$，若有 $S_1 - \{2\} \neq S_2 - \{1\}$，那么交换节点 $1, 2$ 的标号得到一张新无向图，可以发现它们的最小点覆盖一定是相同的，那么它们的贡献和在 $\text{mod} ~~ 2$ 的情况下一定是 $0$，也就是说，对答案有贡献的无向图一定满足 $\forall u, v, S_u - \{v\} = S_v - \{u\}$</p><p>接下来考虑 $S_1 - \{2\} = S_2 - \{1\}$ 的情况，分类讨论</p><ul><li>若存在边 $(1, 2)$，则说明 $1, 2$ 中必须存在至少一个点加入覆盖点，否则边 $(1, 2)$ 就一定不会被覆盖到，不妨强制标号小的那个加入覆盖点，再删去所有与之相连的边，那么局面就变成了 $n’ = n - 1, k’ = k - 1$ 继续搞最小点覆盖</li><li>若不存在边 $(1, 2)$，那么可以选择 $S_1$ 中所有点加入覆盖点或 $1, 2$ 同时加入覆盖点，也就是说它们同时加入或不加入覆盖点，则它们可以合并成一个大点，并删去重复的边</li></ul><p>很容易发现，每次合并的两个点实际具有的节点数目一定是相同的</p><p>暴力计算则需要枚举 $S_1, S_2$ 等，但实际上在合并 $1, 2$ 后，$S_1$ 是不会发生变化的，也就是说枚举 $S_1$ 是在后面过程完成的，在不断合并、消去点的过程中，最终我们一定可以得到图，使之满足条件，所以就不需要所谓枚举 $S_1$ 这样的步骤了</p><p>为了方便计算，不妨假定每次合并，选择由具有相同节点数目，且该数目最小的两个点，并且这个数目一定是 $2$ 的幂次，设当前找到的这两个点具有 $2^t$ 个节点，可以发现任意具有 $2^d (d &lt; t)$ 个节点的点一定最多只有一个，且不存在具有 $2^{t + 2}$ 个节点的点，因为此时最多只会合并到 $2^{t + 1}$</p><p>那么设 $f_{n, k, t}$ 表示剩余节点数 $n$（即没加入覆盖点的剩余点的个数），还可以加入 $k$ 个覆盖点，$t$ 的意义如上所述</p><p>很明显在知道了 $n$ 之后我们就可以知道此时每种具有不同节点数的点的个数，此时有 $tot = n &gt;&gt; t$ 个由 $2^t$ 个节点组成的点，枚举在 $tot$ 中选择多少个进行留下、消失、合并的操作</p><p>设有 $r (r \in \{0, 1\})$ 个点留下，$m (0 \le m \le \frac{tot}2)$ <strong>对</strong>点合并，那么可以计算出有 $d = tot - 2 * m - r$ 个点消失，计算方案数，即要在 $m + d$ 个位置中选择 $d$ 个位置消失，即方案数为 $\dbinom{m + d}d$，但实际上这是错误的，因为</p><p>若 $r = 0$ 则必须强制要求最后一组点必须合并，假如一个都不剩且最后是消失的话，那就相当于在操作前最后是只有一个点的，而这唯一的最后一个点在不与其它点组合的情况下它独自消失是没有意义的，这种情况实际上应该是被 $r = 1$ 时计算到的，故若 $r = 0$ 则须强制令最后一个操作是合并，故方案数应为 $\dbinom{m + d - [rem = 0]}d$</p><p>记忆化一下即可，递归到最后 $n$ 不足以或恰只能提供 $2^t$ 个节点时，若该状态产生贡献则其必须满足 $n \neq k \cap lowbit(n) = k$，这是因为最后剩下若干个点，发现只有最小点覆盖为最小点的时候答案才是奇数，若此时最小点覆盖大于一，则覆盖点之间可以任意连边，则答案会是 $2$ 的幂次；若不是最小点，比这个点小的点可以选择连或不连这个点，则答案亦是 $2$ 的幂次</p><p>时间复杂度 $O (n^2\log^2n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (! k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((n &gt;&gt; t) &lt;= <span class="number">1</span>) <span class="keyword">return</span> n != k &amp;&amp; lowbit (n) == k;</span><br><span class="line"><span class="keyword">if</span> (~ f[n][k][t]) <span class="keyword">return</span> f[n][k][t];</span><br><span class="line">f[n][k][t] = <span class="number">0</span>; <span class="keyword">int</span> lim = n &gt;&gt; (t + <span class="number">1</span>), tot = n &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mer = <span class="number">0</span>; mer &lt;= lim; mer ++) <span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> rem = <span class="number">0</span>; rem &lt;= <span class="number">1</span>; rem ++) &#123; <span class="comment">// 留下</span></span><br><span class="line"><span class="keyword">int</span> des = tot - mer * <span class="number">2</span> - rem; <span class="comment">// 消失</span></span><br><span class="line"><span class="keyword">if</span> (des &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> c1 = mer + des - (! rem), c2 = des;</span><br><span class="line"><span class="keyword">if</span> ((c1 &amp; c2) == c2) f[n][k][t] ^= dp (n - (des &lt;&lt; t), k - (des &lt;&lt; t), t + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 对组合数 C (n, m) 若满足 (n &amp; m) == m 则说明 C (n, m) 是奇数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][k][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (f, - <span class="number">1</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = getnum (), k = getnum ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, dp (n, k, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 分块 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十六）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天是几场下来第一次完整搞出一道题</p><p>虽然跑的贼慢，方法不够优，比 $\text{std}$ 慢 $200ms$。。</p><p>$\text{score：0 + 100 + 0 = 100   rk：16/32}$</p><h2 id="Problem-A：Geometric-Progressions"><a href="#Problem-A：Geometric-Progressions" class="headerlink" title="Problem A：Geometric Progressions"></a>Problem A：Geometric Progressions</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>首项为 $a$ 且公比为 $b$ 的等比数列是一个形如 $a, ab, ab^2, ab^3, …$ 的数字序列</p><p>你被给定了 $n$ 个整数等比数列。你的任务是找出最小的整数 $x$，使得它是所有给定的序列的元素，或者声明这样的整数不存在</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 100, ~ 1 \le a, b \le 10^9$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://codeforces.com/problemset/problem/571/E" target="_blank" rel="noopener">CF571E</a></p><p>首先将所有 $a, b$ 分解质因数，得到大小为 $m$ 质因数集 $\{p_1, p_2, …, p_m\}$</p><p>设 $c_{i, j}$ 表示 $a_i$ 分解质因数后 $p_j$ 的幂次，$d_{i, j}$ 表示 $b_i$ 分解质因数后 $p_j$ 的幂次，那么答案即可被表示为 $\prod\limits_{i = 1}^m p_i^{c_{1, i} + k \times d_{1, i}}$，其中 $k \in N$</p><p>考虑每次将两对 $a, b$ 合并，设之前合并得到的 $a, b$ 分解质因数后的质因数幂次数组 $A, B$，其中 $A_i$ 表示第 $i$ 个质因数的幂次，再设准备与之合并的 $a, b$ 的质因数幂次数组 $C, D$</p><p>那么现在分为仅有一解、有无数解、无解三种情况</p><p>对 $A, B$ 单独考虑，设答案 $p_i$ 幂次 $t_i$，则有<br>$$<br>\left\{<br>    \begin{aligned}<br>        t_i &amp;= A_i + k \times B_i \\<br>        t_j &amp;= A_j + k \times B_j<br>    \end{aligned}<br>\right. \\<br>\Rightarrow<br>t_i = A_i + \frac{B_i}{B_j}(t_j - A_j)<br>$$<br>也就是说 $t_j$ 和 $t_i$ 的关系是一条斜率为 $\frac{B_i}{B_j}$ 的直线</p><p>同理对 $C, D$，有 $t_i = C_i + \frac{D_i}{D_j}(t_j - C_j)$</p><p>那么仅有一解的条件即为它们之间有交点，即 $\frac{B_i}{B_j} = \frac{D_i}{D_j}$，这种情况直接解出来就好了</p><p>那么考虑剩下的情况，$t_i = A_i + k_1 \times B_i = C_i + k_2 \times D_i$ 可以转化成 $k_2 \times D_i - k_1 \times B_i = A_i - C_i$，然后用 $ExGCD$ 求解，注意由于它们 $k_1, k_2$ 都相同，所以要满足每组方程是否满足比例关系，不满足则无解，其实我觉得上面那个 $\frac{B_i}{B_j} \ne \frac{D_i}{D_j}$ 则只有一解也应该可以用这个来理解，然后就相当于解一个二元一次方程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">900</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e04</span>;</span><br><span class="line"><span class="keyword">int</span> oa[MAXN], ob[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">GCD</span> <span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> ! b ? a : GCD (b, a % b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGCD</span> <span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line">exGCD (b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM]= &#123;<span class="number">0</span>&#125;, pn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separ</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (x % i)) &#123;</span><br><span class="line">prime[++ pn] = i;</span><br><span class="line"><span class="keyword">while</span> (! (x % i)) x /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) prime[++ pn] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pcnt[<span class="number">2</span>][MAXN][MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cencus</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> id, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (x % prime[i])) &#123;</span><br><span class="line"><span class="keyword">while</span> (! (x % prime[i])) &#123;</span><br><span class="line">x /= prime[i];</span><br><span class="line">pcnt[p][id][i] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a[MAXM], b[MAXM], c[MAXM], d[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL sb = <span class="number">0</span>, sd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) &#123; sb += b[i]; sd += d[i]; &#125;</span><br><span class="line"><span class="keyword">if</span> (! sb &amp;&amp; ! sd) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] != c[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! sb || ! sd) &#123;</span><br><span class="line"><span class="keyword">if</span> (! sd) &#123; swap (sb, sd); swap (a, c); swap (b, d); &#125;</span><br><span class="line">LL k = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (d[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[i] &gt; a[i] || (a[i] - c[i]) % d[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LL pk = (a[i] - c[i]) / d[i];</span><br><span class="line"><span class="keyword">if</span> (k != - <span class="number">1</span> &amp;&amp; pk != k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">k = pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (sb * d[i] != sd * b[i])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= pn) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= pn; j ++)</span><br><span class="line"><span class="keyword">if</span> (b[i] * d[j] != d[i] * b[j]) <span class="comment">// 只有一个解</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">LL ka = d[j] * (c[i] - a[i]) - d[i] * (c[j] - a[j]);</span><br><span class="line">LL kb = b[j] * (c[i] - a[i]) - b[i] * (c[j] - a[j]);</span><br><span class="line">LL down = d[j] * b[i] - d[i] * b[j];</span><br><span class="line"><span class="keyword">if</span> (down &lt; <span class="number">0</span>) ka = - ka, kb = - kb, down = - down;</span><br><span class="line"><span class="keyword">if</span> (ka &lt; <span class="number">0</span> || kb &lt; <span class="number">0</span> || ka % down || kb % down) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ka /= down, kb /= down;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= pn; k ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[k] + ka * b[k] != c[k] + kb * d[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">a[k] = a[k] + ka * b[k], b[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ExGCD合并</span></span><br><span class="line">LL rb = <span class="number">0</span>, rd = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (b[i]) &#123;</span><br><span class="line">LL g = GCD (b[i], d[i]);</span><br><span class="line">rb = b[i] / g, rd = d[i] / g;</span><br><span class="line"><span class="keyword">if</span> ((a[i] - c[i]) % g) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">r = (a[i] - c[i]) / g;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (r * (b[i] / rb) != a[i] - c[i]) <span class="comment">// 判断是否成比例</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>) swap (a, c), swap (b, d), swap (rb, rd), r = - r;</span><br><span class="line">LL ka, kb;</span><br><span class="line">exGCD (rb, rd, ka, kb);</span><br><span class="line">ka = (ka * (- r) % rd + rd) % rd;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line">a[i] += ka * b[i], b[i] *= rd;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) oa[i] = getnum (), ob[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) separ (oa[i]), separ (ob[i]);</span><br><span class="line">sort (prime + <span class="number">1</span>, prime + pn + <span class="number">1</span>);</span><br><span class="line">pn = unique (prime + <span class="number">1</span>, prime + pn + <span class="number">1</span>) - prime - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cencus (<span class="number">0</span>, i, oa[i]), cencus (<span class="number">1</span>, i, ob[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) a[i] = pcnt[<span class="number">0</span>][<span class="number">1</span>][i], b[i] = pcnt[<span class="number">1</span>][<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pn; j ++) c[j] = pcnt[<span class="number">0</span>][i][j], d[j] = pcnt[<span class="number">1</span>][i][j];</span><br><span class="line"><span class="keyword">if</span> (! merge ()) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) ans = ans * power (prime[i], a[i]) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：Bichrome-Spanning-Tree"><a href="#Problem-B：Bichrome-Spanning-Tree" class="headerlink" title="Problem B：Bichrome Spanning Tree"></a>Problem B：Bichrome Spanning Tree</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们有一个 $n$ 个点 $m$ 条边的带权无向图。图中的第 $i$ 条边连接了节点 $u_i, v_i,$，权重为 $w_i$。另外，你还被给定了一个整数 $X$。</p><p>请求出将每条边染成黑色或白色，且满足下面的条件的方案数模 $10^9 + 7$ 的值</p><ul><li>图中存在一棵同时包含染成白色的边和染成黑色的边的生成树。另外，在所有这种生成树中，权重最小的一棵的权重恰为 $X$</li></ul><p>这里，一棵生成树的权重定义为生成树中边的权重的和</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 1000, ~ 1 \le m \le 2000, ~ 1 \le w_i \le 10^9, ~ 1 \le X \le 10^{12}$</p><p>给出的数据保证图联通，不存在重边，不存在自环</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://atcoder.jp/contests/arc093/tasks/arc093_c" target="_blank" rel="noopener">ARC093C</a></p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>先讲讲我的方法吧</p><p>显然对一棵权重 $&lt; X$ 的树，它所有的边的颜色都应该相同，那么我们考虑对每条边判断它会不会有这种限制</p><p>此时直接用 $Kruskal$ 求出包含该边的最小生成树，若其权重 $&lt; X$，则该边的染色就会被限制，称一类边；若其权重 $&gt; X$，则它属于染色情况不论如何都不会对答案造成贡献的边，称二类边；若其权重 $= X$，则需要着重考虑，称三类边</p><p>这里考虑两棵在相同的图上但边集完全无交集的最小生成树，它们一定可以构成一个新的最小生成树，该最小生成树的边集与原两棵树的边集分别有交，这个也很好证明，因为最小生成树一定是最小瓶颈生成树，即最大边最小，那么它们之间一定可以互相替换，从而构成一棵新的 $MST$，至于对那些权重 $&lt; X$ 的树，也拥有类似该定理，证明类比一下就好了</p><p>自此我们就可以认为所有二类边的颜色一定是相同的</p><p>设某条三类边 $E$，三类边的总数为 $m$</p><p>现在只需枚举 $E$ 来进行组合计数，强制令 $E$ 染色与一类边不同，则剩余 $m - 1$ 条边则可随意染色，为避免算重，枚举 $m - 1$ 条边中与 $E$ 染色相同的个数 $j$，则 $E$ 在枚举到 $j$ 加上的贡献即为 $\frac{C (m - 1, j)}{j + 1}$，记得最后乘二，但对不存在一类边的情况要特判一下</p><p>那么最后再设三类边个数 $ext$，将之前统计得到的答案乘上 $2^{ext}$ 即可</p><p>时间复杂度 $O \big(nm \times \alpha(n)\big)$</p><h4 id="代码（方法一）"><a href="#代码（方法一）" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL pow2[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125;;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, sze = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ sze].to = v;</span><br><span class="line">Link[sze].w = w;</span><br><span class="line">Link[sze].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = sze;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXM]= &#123;<span class="number">0</span>&#125;, invfact[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL inv[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL X;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">Edge (<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u (u), v (v), w (w) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; p.w; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Edge edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find (fa[x]); &#125;</span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = edge[i].u, y = edge[i].v, w = edge[i].w;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">fa[fx] = fy; ret += w;</span><br><span class="line">Insert (x, y, w), Insert (y, x, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> white[MAXM]= &#123;<span class="number">0</span>&#125;, black[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> wn = <span class="number">0</span>, bn = <span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">cencus</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= bn; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> i = black[q];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123; fa[j] = j; Head[j] = <span class="number">0</span>; &#125;</span><br><span class="line">sze = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].u, v = edge[i].v, w = edge[i].w;</span><br><span class="line">fa[u] = v;</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">Kruskal ();</span><br><span class="line">LL add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bn - <span class="number">1</span> - (! wn); j ++)</span><br><span class="line">add = (add + C (bn - <span class="number">1</span>, j) * inv[j + <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">ret = (ret + add) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wn) ret = <span class="number">2l</span>l * ret % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>; <span class="keyword">int</span> ext = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1l</span>l * edge[i].w &gt; X) &#123; ext ++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123; fa[j] = j; Head[j] = <span class="number">0</span>; &#125;</span><br><span class="line">sze = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].u, v = edge[i].v, w = edge[i].w;</span><br><span class="line">fa[u] = v;</span><br><span class="line">LL x = w + Kruskal ();</span><br><span class="line"><span class="keyword">if</span> (x &lt; X) white[++ wn] = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == X) black[++ bn] = i;</span><br><span class="line"><span class="keyword">else</span> ext ++;</span><br><span class="line">&#125;</span><br><span class="line">ans = cencus ();</span><br><span class="line">ans = ans * pow2[ext] % MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (); <span class="built_in">cin</span> &gt;&gt; X;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span>) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max (N, M); i ++) pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2l</span>l % MOD;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">inv[<span class="number">1</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">edge[i] = Edge (u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">sort (edge + <span class="number">1</span>, edge + M + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>题解的方法，我觉着挺妙</p><p>先随便取一个 $MST$ 设为 $T$，设其权重和 $w(T)$，显然只需考虑 $w(T) \le X$</p><p>对 $w(T) = X$，可以先加上让其内部不全部染相同色，剩余边随意染色，即贡献 $(2^{n - 1} - 2) \cdot 2^{m - n + 1}$</p><p>接下来考虑 $T$ 染色全部相同的情况，不妨设 $T$ 中边均为黑边</p><blockquote><p>每次替换一个不在 $T$ 中的白边到 $T$，则最多替换一次</p></blockquote><p>证明反向思考一下就行了，每次替换权重一定不会减少，那么假定现在替换了两个白边，但全图的黑白边 $MST$ 仍不包括你第二次替换的边，因为第二次替换出来的黑边此时就满足条件了</p><p>对每次替换，若替换第 $i$ 条边，则会增大 $cost(i) = w_i - \max\{w_j | (u_j, v_j) 在T中(u_i, v_i)两点间路径上\}$（题解表述）的贡献，因此一定选最小边替换</p><p>求 $cost(i)$ 跳个倍增就好了</p><p>那么最后将所有 $i$ 的 $cost(i)$ 排个序，设排序后某条边排在位置 $p$，则其对答案贡献 $2^{n + m - 1 - p}$（只有后面的边才能任意染色）</p><p>时间复杂度 $O (m \log n)$</p><h2 id="Problem-C：Network"><a href="#Problem-C：Network" class="headerlink" title="Problem C：Network"></a>Problem C：Network</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/19/ZTh8wvO5FAqHKG4.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/19/DAaFX5Gpq2vzY8g.png" alt=""></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先计算在不反转用户的情况下，所有用户的 $MS(u)$</p><p>考虑点分治，现在递归到分治中心 $p$，设 $p$ 子树点 $x$ 到 $p$ 的边的最小值和最大值 $(mi_x, ma_x)$，假设现在有服务器 $i$，用户 $j$，都是 $p$ 的子树结点，计算 $MS(j)$，考虑有哪几种情况会贡献到 $MS(j)$，即是 $ma_i - mi_x$、$ma_i - mi_j$、$ma_j - mi_i$，同时 $(mi_i, ma_i), (mi_j, ma_j)$ 之间不存在任何关系，那么也就是说只需求得 $p$ 子树中满足 $ma_i - mi_i$ 最大，或 $ma_i$ 最大、或 $mi_i$ 最大，即可更新其它所有的用户（当然要与 $i$ 不同子树），又考虑到同子树不能互相更新，所以还得记录上面三者的次大值，这样就可以求出所有 $MS(u)$</p><p>接下来计算反转用户的情况，最小值最大，考虑二分答案</p><p>设此时二分答案 $mid$，继续考虑点分治（实际上只需要看点分树就好了），设分治中心 $p$，设在两个子树的用户 $i, j$，若使 $check$ 失败则需要找到一对 $i, j$，反转 $i$，使得 $Waste (j, i) &lt; mid$</p><p>将 $p$ 所有储存下来的 $(mi_x, ma_x)$ 按 $mi_x$ 排序，则对 $mi_j \le mi_x$，欲使其失败则需满足 $ma_i - mi_j &lt; mid$，即 $ma_x &lt; mi_j + mid$，对 $mi_j &gt; mi_x$，欲使其失败则需满足 $mi_i &gt; \max(ma_i, ma_j) - mid$，当然已经排除了所有满足 $ma_x - mi_x \ge mid$（对第一种情况）或 $MS(x) \ge mid$（对两种情况）的点，然后和前面相同可以线性处理</p><p>时间复杂度 $O (n \log n \log V)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> type[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rt, minval = INF, fa;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grvy</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">grvy (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">maxpart = max (maxpart, subsize[v]);</span><br><span class="line">&#125;</span><br><span class="line">maxpart = max (maxpart, n - subsize[root]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; minval) &#123; rt = root; fa = father; minval = maxpart; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, id, bel;</span><br><span class="line"><span class="comment">// min value, max value, original index, 子树从属</span></span><br><span class="line">node (<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>, <span class="keyword">int</span> bel = <span class="number">0</span>) : l (l), r (r), id (id), bel (bel) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l == p.l) <span class="keyword">return</span> r &lt; p.r;</span><br><span class="line"><span class="keyword">return</span> l &lt; p.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> minv[MAXN], maxv[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> bel)</span> </span>&#123;</span><br><span class="line">a[rt].push_back(node (minv[root], maxv[root], root, bel));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">minv[v] = min (minv[root], w);</span><br><span class="line">maxv[v] = max (maxv[root], w);</span><br><span class="line">DFS (v, root, bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MS[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">minv[rt] = INF, maxv[rt] = <span class="number">0</span>;</span><br><span class="line">a[rt].push_back(node (minv[rt], maxv[rt], rt, rt));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[rt]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">minv[v] = min (minv[rt], w);</span><br><span class="line">maxv[v] = max (maxv[rt], w);</span><br><span class="line">DFS (v, rt, v);</span><br><span class="line">&#125;</span><br><span class="line">sort (a[rt].begin(), a[rt].end());</span><br><span class="line">pair&lt;int, int&gt;  fir (- INF, 0), sec (- INF, 0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">int</span> ms = x.r - x.l;</span><br><span class="line"><span class="keyword">if</span> (ms &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (ms, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ms &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (ms, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second) &#123;</span><br><span class="line">MS[x.id] = max (MS[x.id], x.r - x.l);</span><br><span class="line">MS[x.id] = max (MS[x.id], now.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (- INF, <span class="number">0</span>), sec = make_pair (- INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.r &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.r &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second? sec : fir;</span><br><span class="line"><span class="keyword">int</span> r = max (x.r, now.first);</span><br><span class="line"><span class="keyword">if</span> (now.second) MS[x.id] = max (MS[x.id], r - x.l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (INF, <span class="number">0</span>), sec = make_pair (INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.l &lt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.l, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.l &lt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.l, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second? sec : fir;</span><br><span class="line"><span class="keyword">int</span> l = min (x.l, now.first);</span><br><span class="line"><span class="keyword">if</span> (now.second) MS[x.id] = max (MS[x.id], x.r - l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">minval = INF; grvy (n, x, <span class="number">0</span>);</span><br><span class="line">visit[rt] = <span class="literal">true</span>;</span><br><span class="line">work ();</span><br><span class="line">grvy (n, rt, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[rt]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">divide (subsize[v], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> fail[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">pair&lt;int, int&gt; fir (- INF, 0), sec (- INF, 0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[u].size(); i ++) &#123;</span><br><span class="line">node x = a[u][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second &amp;&amp; x.r &lt; now.first) fail[x.id] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (MS[x.id] &gt;= mid || x.r - x.l &gt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (x.l + mid &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.l + mid, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.l + mid &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.l + mid, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (INF, <span class="number">0</span>), sec = make_pair (INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a[u].size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">node x = a[u][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second &amp;&amp; x.l &gt; max (x.r, now.first) - mid) fail[x.id] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (MS[x.id] &gt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (x.r &lt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.r &lt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fail[i] = type[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) doit (i, mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! fail[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) type[i] = getnum ();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) sum += type[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= N - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == N) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! type[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d 0\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxi = <span class="number">0</span>, mini = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">maxi = max (maxi, w); mini = min (mini, w);</span><br><span class="line">&#125;</span><br><span class="line">divide (N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = maxi - mini, ans;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (mid)) &#123; ans = mid; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">check (ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! fail[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, i, ans);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
            <tag> 集训 </tag>
            
            <tag> ExGCD </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十八）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日依旧三道集训队原题，无部分分，连续三次</p><p>真该问候搬题人他母亲大人</p><p>$\text{score：NULL   rk：NULL}$</p><h2 id="Problem-A：Sasha-And-Circles"><a href="#Problem-A：Sasha-And-Circles" class="headerlink" title="Problem A：Sasha And Circles"></a>Problem A：Sasha And Circles</h2><h2 id="Problem-B：Choosing-Ads"><a href="#Problem-B：Choosing-Ads" class="headerlink" title="Problem B：Choosing Ads"></a>Problem B：Choosing Ads</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的序列和一个整数 $p$。</p><p>有 $m$ 个操作，操作要么是区间赋值，要么是询问区间内出现次数至少占 $p\%$ 的数。</p><p>输出询问的答案时，可以包含错的数，也可以重复输出，但对的数一定要在答案中，且输出的数的个数不超过 $\lfloor \frac{100}p \rfloor$</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n, m \le 1.5 \times 10^5, ~ 20 \le p \le 100$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑 $p = 51$ 的情况，很明显就是求区间众数</p><p>有一个经典区间众数套路，给数字 $i$ 一个数组 $c_i$，设当前众数 $p$，每次加一个数字 $t$，若该数字等于 $p$，则 $c_p ++$，反之则 $c_p –$，若删前 $c_p = 0$，则 $p = t$，同时 $c_p = 1$</p><p>这样子虽然没有计算每种数字的出现次数，但保留了相对数字个数大小的关系，毕竟若一个数的出现概率 $&gt; 50\%$，则它必定会留到最后</p><p>那么现在考虑 $20 \le p \le 50$，则考虑存每个出现次数至少占 $p\%$ 的数，则它们最多 $5$ 个，在线段树上维护，每次加入一个数，若它与其中一个数相等则对应的数的 $c$ 加一，反之所有数的 $c$ 减一，然后用该数替代最终应当被替代的数，合并复杂度最多 $5 \times 5 = 25$，复杂度正确</p><p>复杂度 $O (nk^2 \log n)$，其中 $k = \lfloor \frac{100}p \rfloor$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q, P, m;</span><br><span class="line"><span class="keyword">int</span> ori[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>], cnt[<span class="number">6</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line"><span class="built_in">memset</span> (cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> = (<span class="keyword">const</span> node&amp; p) &#123;</span><br><span class="line">n = p.n;</span><br><span class="line"><span class="built_in">memcpy</span> (a, p.a, <span class="keyword">sizeof</span> (a));</span><br><span class="line"><span class="built_in">memcpy</span> (cnt, p.cnt, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">node ret = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">bool</span> in = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] == ret.a[j]) &#123;</span><br><span class="line">ret.cnt[j] += cnt[i];</span><br><span class="line">in = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (in) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ret.n &lt; m) &#123;</span><br><span class="line">ret.a[++ ret.n] = a[i];</span><br><span class="line">ret.cnt[ret.n] = cnt[i];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> || ret.cnt[j] &lt; ret.cnt[k])</span><br><span class="line">k = j;</span><br><span class="line"><span class="keyword">if</span> (ret.cnt[k] &gt; cnt[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++) ret.cnt[j] -= cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tp = ret.cnt[k];</span><br><span class="line">ret.a[k] = a[i]; ret.cnt[k] = cnt[i] - ret.cnt[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (j != k)</span><br><span class="line">ret.cnt[j] -= tp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node T[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> lazy[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setup</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">T[root].a[T[root].n = <span class="number">1</span>] = x;</span><br><span class="line">T[root].cnt[<span class="number">1</span>] = right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">T[root].init ();</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">setup (root, left, right, ori[left]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid); build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">T[root] = T[lson] + T[rson];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! lazy[root]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">setup (lson, left, mid, lazy[root]);</span><br><span class="line">setup (rson, mid + <span class="number">1</span>, right, lazy[root]);</span><br><span class="line">lazy[lson] = lazy[rson] = lazy[root];</span><br><span class="line">lazy[root] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">setup (root, left, right, x);</span><br><span class="line">lazy[root] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown (root, left, right);</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R, x);</span><br><span class="line">T[root] = T[lson] + T[rson];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) <span class="keyword">return</span> T[root];</span><br><span class="line">pushdown (root, left, right);</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">node ret; ret.init ();</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) ret = ret + query (lson, left, mid, L, R);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) ret = ret + query (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), Q = getnum (), P = getnum (); m = <span class="number">100</span> / P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ori[i] = getnum ();</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= Q; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> type = getnum ();</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum (), id = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, r, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">node ans = query (<span class="number">1</span>, <span class="number">1</span>, N, l, r);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ans.n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans.n; i ++) <span class="built_in">printf</span> (<span class="string">" %d"</span>, ans.a[i]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：Distance-Sums"><a href="#Problem-C：Distance-Sums" class="headerlink" title="Problem C：Distance Sums"></a>Problem C：Distance Sums</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出 $n$ 个互不相同的数 $d_i$，表示树上的节点 $i$ 到其他所有点的距离和。</p><p>请判断是否存在这样一棵树，其中每条边的长度均为 $1$。若存在请输出一种方案，否则输出 <code>-1</code>。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^5, ~ 1 \le d_i \le 10^{12}$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题感觉是一直来做的比较水的。。</p><p>先给所有结点 $i$ 按 $d_i$ 排个序，将 $d$ 最小的看作根节点，那么显然子结点的 $d$ 比其祖先节点小</p><p>设结点 $u$ 子树大小 $s_u$，则考虑由 $u$ 走到其子结点 $v$ 时 $d$ 的增量，有 $\Delta d = n - 2s_v$</p><p>那么从排序后第 $n$ 个结点开始往上扫，每次将它与计算后与它相连的父结点连边，如若找不到父结点则无解</p><p>注意最后建完树要计算新建出的树的根节点的 $d$ 是否与输入所给相同</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">pair&lt;LL, <span class="keyword">int</span>&gt; d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;, fa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">1</span>; i --) &#123;</span><br><span class="line">subsize[d[i].second] ++;</span><br><span class="line"><span class="keyword">int</span> up = N - <span class="number">2</span> * subsize[d[i].second];</span><br><span class="line"><span class="keyword">if</span> (up &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="built_in">exit</span> (<span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">int</span> p = lower_bound (d + <span class="number">1</span>, d + N + <span class="number">1</span>, make_pair (d[i].first - up, <span class="number">0</span>)) - d;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= i || d[p].first != d[i].first - up) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="built_in">exit</span> (<span class="number">0</span>); &#125;</span><br><span class="line">fa[d[i].second] = d[p].second;</span><br><span class="line">subsize[d[p].second] += subsize[d[i].second];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line">LL dist[MAXN]= &#123;<span class="number">0</span>&#125;, total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">total += dist[root];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[root].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[root][i];</span><br><span class="line">dist[v] = dist[root] + <span class="number">1</span>;</span><br><span class="line">DFS (v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) d[i].first = getnum (), d[i].second = i;</span><br><span class="line">sort (d + <span class="number">1</span>, d + N + <span class="number">1</span>);</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) G[fa[d[i].second]].push_back(d[i].second);</span><br><span class="line">DFS (d[<span class="number">1</span>].second);</span><br><span class="line"><span class="keyword">if</span> (total != d[<span class="number">1</span>].first) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, fa[d[i].second], d[i].second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十五）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天有点人品，T1的50pts暴力怒压正解。。这数据。。不言而喻</p><p>$\text{score: 100 + 0 + 0 = 100   rk: 7/36}$</p><h2 id="Problem-A：时间管理带师"><a href="#Problem-A：时间管理带师" class="headerlink" title="Problem A：时间管理带师"></a>Problem A：时间管理带师</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>众所周知，罗老师是时间管理带师</p><p>因为罗老师是时间管理带师，所以他的时间是以东为单位的</p><p>具体来讲，罗老师一天有nn东的时间</p><p>现在有很多妹子想跟罗老师约会</p><p>奇特的，她们每天总会提出两段约会时间（可能相同，代表一种），并且每天提出的总是一样的。</p><p>她们提出的约会时间形式形如i,j,代表希望在[i东,(i+1)东)[i东,(i+1)东)或[j东,(j+1)东)[j东,(j+1)东)与罗老师进行约会。</p><p>当然，罗老师可以这两段时间都与这个妹子约会,只选择一段，或者伤心地抛弃。</p><p>那么，作为时间管理带师的罗老师，<strong>每天会选择尽可能多的妹子进行约会</strong></p><p>但你一定要注意,<strong>罗老师最近并不打算进行多人运动，所以他不会在1东的时间同时与两个或多个妹子约会</strong></p><p><strong>罗老师并不脸盲，与一个妹子约会2次并不能算成”2”次的贡献，只能是”1”</strong></p><p><strong>罗老师是时间管理带师，只要满足以上条件，他就可以安排好他的时间，不用担心别的</strong></p><p><strong>而且,每天可能会有新的妹子向罗老师提出约会邀请</strong></p><p><strong>但是时间久了，一些妹子认识到<del>罗老师是个渣男</del>罗老师太忙了，就不再给罗老师提出约会邀请</strong></p><p><strong>每天要么有妹子加入，要么有妹子退出，这两种情况有且仅会发生一种，并且退出的妹子一定是当前想要和罗老师约会的妹子中时间最久的。其实，这就对应了双端队列的push和pop。我们保证，罗老师每天的妹子数量非负</strong></p><p>现在，作为罗老师的贴身秘书，你每天要给罗老师规划好他的时间，每天告诉罗老师他今天最多可以约会多少个妹子</p><p>不过本题中，操作可以强制在线</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n, m \le 10^5, 0 \le type \le 1, 0 \le op, a, b \le 10^6$</p><p>其中 $a, b$ 表示妹子的约会时间为 $a, b$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这神奇的题目描述，真的时间管理带师</p><p>先考虑暴力，每次替换实际上就是一个类似匈牙利算法的东西，然后它只删队首的妹子，所以我们要尽可能让队首的妹子对答案无影响，所以每次队尾加入一个妹子的时候，如果判断出可以为她凑出一个额外的位置那就直接做，加入不行则替换掉其中最早入队的妹子（实际上这整个可以看成多棵内向基环树，即假如编号为 $i$ 的妹子占了一个位置，并且占的是约会时间 $a$，那么她就连一条 $a \rightarrow b$ 的有向边，并给这个边以入队顺序的编号，那么每一次类似匈牙利算法的过程即是这个图中的一条链，那么就取编号最小的边就行了），那么在删队首妹子的时候她就只有对答案无影响或者占了一个位置而使答案减一两种情况了</p><p>这个理论复杂度显然不能过，随便出个一条链的数据就卡掉了，但我还是稍微放一下它的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXA = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> A, M, type;</span><br><span class="line"><span class="keyword">int</span> ns = <span class="number">1</span>, ne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> posi[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> visit[MAXA]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> who[MAXA]= &#123;<span class="number">0</span>&#125;, use[MAXN]= &#123;<span class="number">0</span>&#125;, in[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">pair&lt;int, int&gt; findpos (int u) &#123; // pair&lt;int, int&gt; 分别表示找到的空座位与占位置的编号最小妹子</span><br><span class="line">    <span class="keyword">if</span> (visit[u]) <span class="keyword">return</span> make_pair (- <span class="number">1</span>, who[u]);</span><br><span class="line">    <span class="keyword">if</span> (! who[u]) <span class="keyword">return</span> make_pair (u, <span class="number">0</span>);</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = findpos (posi[who[u]][use[who[u]] ^ <span class="number">1</span>]);</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> make_pair (ret.first, min (ret.second, who[u]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == aim) &#123;</span><br><span class="line">        in[who[u]] = <span class="number">0</span>; who[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((suc = select (posi[who[u]][use[who[u]] ^ <span class="number">1</span>], aim))) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = who[u]; who[u] = <span class="number">0</span>;</span><br><span class="line">        use[p] ^= <span class="number">1</span>; in[p] = posi[p][use[p]];</span><br><span class="line">        who[in[p]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    use[p] = tp, in[p] = posi[p][tp];</span><br><span class="line">    who[in[p]] = p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A = getnum (), M = getnum (), type = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            op = getnum ();</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) a = getnum (), b = getnum ();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            op = (getnum () + ans) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) a = (getnum () + ans) % A + <span class="number">1</span>, b = (getnum () + ans) % A + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            posi[++ ne][<span class="number">0</span>] = a, posi[ne][<span class="number">1</span>] = b;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret1 = findpos (a), ret2;</span><br><span class="line">            <span class="keyword">if</span> (ret1.first == - <span class="number">1</span>) &#123;</span><br><span class="line">                ret2 = findpos (b);</span><br><span class="line">                <span class="keyword">if</span> (~ ret2.first) &#123;</span><br><span class="line">                    select (b, ret2.first); add (ne, <span class="number">1</span>);</span><br><span class="line">                    ans ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret1.second &lt; ret2.second) &#123;</span><br><span class="line">                    select (posi[ne][<span class="number">0</span>], in[ret1.second]);</span><br><span class="line">                    add (ne, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    select (posi[ne][<span class="number">1</span>], in[ret2.second]);</span><br><span class="line">                    add (ne, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; select (a, ret1.first); add (ne, <span class="number">0</span>), ans ++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[ns]) &#123;</span><br><span class="line">                ans --;</span><br><span class="line">                who[in[ns]] = <span class="number">0</span>; in[ns] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ns ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来就是正解，用 $\text{LCT}$ 来维护这个最小编号妹子</p><p>现在先考虑连边整出来的连通块，设该连通块有点 $x$ 个，边 $y$ 个，那么显然若 $x &gt; y$，则答案为 $x - 1$，若 $x \le y$，就代表有环，那么答案即为 $x$</p><p>现在考虑用 $\text{LCT}$ 来维护，首先把这个连通块里选择的节点抽成一棵树，并且边化点，那么剩下的边无法在 $\text{LCT}$ 中表示，但是只要存在其中一条就说明一定会构成环，所以我们只需统计每个点它会连多少这样的边即可</p><p>每次删 $\text{LCT}$ 中边的时候，删完边就给该边连接的两个点权值各加一，说明它们之间的边变成了使成环的边，那么就得更新答案；同理加边则把它们原来加上的权值减掉</p><p>感觉说不清楚具体还是看代码注释吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, type, n;</span><br><span class="line"><span class="keyword">int</span> posi[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// n: 边化点</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rev[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vimi[MAXN]= &#123;<span class="number">0</span>&#125;, fic[MAXN]= &#123;<span class="number">0</span>&#125;, vism[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 当前节点连的非树节点个数、当前节点虚子树vimi和、当前节点虚实子树vimi和</span></span><br><span class="line"><span class="keyword">int</span> mini[MAXN]= &#123;<span class="number">0</span>&#125;; <span class="comment">// 最早入队边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! p) <span class="keyword">return</span> ;</span><br><span class="line">swap (son[p][<span class="number">0</span>], son[p][<span class="number">1</span>]); rev[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">vism[p] = vimi[p] + fic[p] + vism[son[p][<span class="number">0</span>]] + vism[son[p][<span class="number">1</span>]];</span><br><span class="line">mini[p] = min (p &lt;= N ? INF : p, min (mini[son[p][<span class="number">0</span>]], mini[son[p][<span class="number">1</span>]]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! rev[p]) <span class="keyword">return</span> ;</span><br><span class="line">reverse (son[p][<span class="number">0</span>]), reverse (son[p][<span class="number">1</span>]);</span><br><span class="line">rev[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line"><span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (son[fa][s]) father[son[fa][s]] = fa;</span><br><span class="line"><span class="keyword">if</span> (! isroot (fa)) son[anc][sonbel (fa)] = p;</span><br><span class="line">father[p] = anc;</span><br><span class="line">son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">top = <span class="number">0</span>; <span class="built_in">stack</span>[++ top] = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tp = p; ! isroot (tp); tp = father[tp]) <span class="built_in">stack</span>[++ top] = father[tp];</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">0</span>) pushdown (<span class="built_in">stack</span>[top]), top --;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line"><span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tp = <span class="number">0</span>; p; tp = p, p = father[p]) &#123;</span><br><span class="line">splay (p);</span><br><span class="line">fic[p] += vism[son[p][<span class="number">1</span>]] - vism[tp];</span><br><span class="line">son[p][<span class="number">1</span>] = tp; pushup (p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; access (p), splay (p); reverse (p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">access (p), splay (p);</span><br><span class="line"><span class="keyword">while</span> (son[p][<span class="number">0</span>]) &#123; pushdown (p); p = son[p][<span class="number">0</span>]; &#125;</span><br><span class="line">splay (p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">value</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> vism[p] &gt; <span class="number">0</span>; &#125; <span class="comment">// 判断是否成环，若成环则答案需要再点个数上加一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hideit</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> delta)</span> </span>&#123; <span class="comment">// 将树上边变为使成环边</span></span><br><span class="line">makeroot (p); ans -= value (p);</span><br><span class="line">vimi[p] += delta, pushup (p); ans += value (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> in[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot (x), makeroot (y);</span><br><span class="line">ans -= value (x) + value (y); <span class="comment">// 删去原来两个分开的连通块的贡献再加上新合成连通块贡献</span></span><br><span class="line">ans ++; father[x] = father[y] = id;</span><br><span class="line">fic[id] += vism[x] + vism[y], pushup (id);</span><br><span class="line">ans += value (id); in[id] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot (x), access (y), splay (id);</span><br><span class="line">ans --, ans -= value (id);</span><br><span class="line">father[x] = father[y] = <span class="number">0</span>; ans += value (x) + value (y);</span><br><span class="line">in[id] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PUSH</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y) &#123; hideit (x, <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">makeroot (x);</span><br><span class="line"><span class="keyword">if</span> (findroot (y) == x) &#123;</span><br><span class="line">access (y), splay (y); <span class="keyword">int</span> p = mini[y];</span><br><span class="line">cut (p, posi[p][<span class="number">0</span>], posi[p][<span class="number">1</span>]);</span><br><span class="line">hideit (posi[p][<span class="number">0</span>], <span class="number">1</span>), hideit (posi[p][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">link (id, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">POP</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! in[id]) &#123;</span><br><span class="line">hideit (x, - <span class="number">1</span>), hideit (y, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">cut (id, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">n = N = getnum (), M = getnum (), type = getnum ();</span><br><span class="line"><span class="keyword">int</span> st = N + <span class="number">1</span>; mini[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> op, a, b;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">op = getnum ();</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) a = getnum (), b = getnum ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">op = (getnum () + ans) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) a = (getnum () + ans) % N + <span class="number">1</span>, b = (getnum () + ans) % N + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">posi[++ n][<span class="number">0</span>] = a, posi[n][<span class="number">1</span>] = b; <span class="comment">// ++ n表示边化点</span></span><br><span class="line">PUSH (n, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; POP (st, posi[st][<span class="number">0</span>], posi[st][<span class="number">1</span>]); st ++; &#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：大猫熊和他的k边形"><a href="#Problem-B：大猫熊和他的k边形" class="headerlink" title="Problem B：大猫熊和他的k边形"></a>Problem B：大猫熊和他的k边形</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>菜鸡zjr今天被一道幼儿园几何题打爆了，一分都拿不到。</p><p>于是他向你求助QwQ:</p><p>给定 $n,k$，求出 $i(k \le i \le n)$ 边形的所有三角剖分中, $k$ 边形的总数的和对 $1e9 + 7$ 取模的结果。</p><p>$k$ 边形指的是 $n$ 个点中的 $k$ 个点，他们在这个剖分中构成一个封闭图形。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $100\%$ 的数据，$3 \le k \le n \le 5 \times 10^6$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>官方题解看不懂。。看别人的题解。。</p><p>首先这个问题可以看成求所有 $n - 2$ 个节点的二叉树中大小为 $k - 2$ 的连通块的数量之和</p><p>那么现在直接令 $n, k$ 减二</p><p>单独考虑每个连通块的贡献，首先它有 $Cat_k$ 种形态，该树有 $k + 1$ 种接子树的方案（数一下就知道了，不包括该树根节点往其父亲连），那么第一部分（接儿子）方案数即为<br>$$<br>\sum\limits_{i = 0}^{n - k} Cat_k[x^i]C^{k + 1}<br>$$<br>其中 $i$ 表示接儿子子树的总大小，$C$ 表示卡特兰数列的生成函数</p><p>那么现在考虑接父亲，容易知道方案数为<br>$$<br>\sum\limits_{j = 0}^{n - k - i} Cat_j(j + 1)<br>$$<br>其中 $j$ 表示接的树的大小，$j + 1$ 也是一样表示对接的树来讲有 $j + 1$ 种接儿子的方案</p><p>现在时间复杂度的症结在于 $[x^n]C^m$ 的计算，考虑它的几何意义</p><p>它相当于 $i$ 个折线图拼起来，现在考虑如何将这些折线图分段，就是将每一段折线图的结尾 $-1$，那么总共会减 $m - 1$ 次（最后一段是不需要减的），也就是说“第一次出现 $0$ 到第一次出现 $- 1$ 的位置”对应第一段折线，“第一次出现 $- 1$ 到第一次出现 $- 2$ 的位置”对应第二段折线。。。</p><p>那么现在就是给 $n$ 个 $+ 1$，$n + m - 1$ 个 $- 1$，计算其由 $(0, 0)$ 到 $(2n + m - 1, - m + 1)$，并且保证前缀和 $\ge - m + 1$ 的方案数，故显然有<br>$$<br>[x^n]C^m = \dbinom{2n + m - 1}{n} - \dbinom{2n + m - 1}{n - 1}<br>$$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我的 $\text{code}$ 跑的贼慢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e07</span>;</span><br><span class="line"> </span><br><span class="line">LL inv[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">LL cat[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD; &#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (C (<span class="number">2</span> * n + m - <span class="number">1</span>, n) - C (<span class="number">2</span> * n + m - <span class="number">1</span>, n - <span class="number">1</span>) + MOD) % MOD; &#125;</span><br><span class="line"><span class="comment">// [x^n]C^m</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    n -= <span class="number">2</span>, k -= <span class="number">2</span>;</span><br><span class="line">    fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    fact[<span class="number">1</span>] = invfact[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">        invfact[i] = invfact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cat[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cat[i] = cat[i - <span class="number">1</span>] * (<span class="number">4</span> * i  - <span class="number">2</span>) % MOD * inv[i + <span class="number">1</span>] % MOD;</span><br><span class="line">        g[i] = (g[i - <span class="number">1</span>] + cat[i] * (i + <span class="number">1</span>) % MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)</span><br><span class="line">        ans = (ans + cat[k] * calc (i, k + <span class="number">1</span>) % MOD * g[n - i - k] % MOD) % MOD;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：SUMMER-WC"><a href="#Problem-C：SUMMER-WC" class="headerlink" title="Problem C：SUMMER WC"></a>Problem C：SUMMER WC</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>OIer是个可爱的群体，他们有很多的禁忌词汇，对此他们会有坏感度，我们表示成 $- x$ 的形式，$x$ 为正整数，越大，表示他们越讨厌，比如:</p><p>$\text{ccf}$ $-250250$ $\text{summerwc}$ $-2600$ $\text{unitedshengxuan}$ $-700$</p><p>但他们也会对一些东西有好感度，类似的，我们列出例子:</p><p>$\text{frog}$ $+1000000$（其实远远不止，但本题的权值上限 $1e6$）$\text{apiadu}$ $+3681$ $\text{txdy}$ $+3669$</p><p>类似的，我们还有很多例子</p><p>一个字符串的好感度就是里面出现过的词汇的感觉的和，一个词汇出现多次算多次</p><p>例如 $\text{frogfrog}$ 的好感度就是 $2e6$</p><p>特别的，我们考虑空串，其好感度为 $0$</p><p>现在我么给出一个大的串，同时给出所有词汇(好感度可以为负，表示有多讨厌),我们需要求出里面最大好感度子串，可以为空</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p>设 $n$ 个词汇的长度和为 $L$，$L_{max}$ 为其中的最大长度</p><p>对 $100\%$ 的数据，$1 \le n, m, L, L_{max} \le 10^6, ~ 1 \le x \le 10^6$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>完全不会。。我字符串实在太菜了。。</p><p>好像这是 $\text{GDOI2019}$ 的 $D2T3$ 的原题</p><p>主要思路就先建出一个$\text{AC}$自动机然后在上面$dp$</p><p>建出自动机后那些结尾节点都会有一个权值 $val$，那么对文本串 $[l, r]$ 的子串就是在自动机上走然后把路径上所有 $val$ 加起来即可得到它的好感度和</p><p>此时不妨设计状态 $f_{i, j}$ 表示文本串匹配到 $i$ 时，$\text{AC}$自动机上走到节点 $j$ 时的最大值，而造成这个最大值的子串即是 $1…i$ 的其中一个后缀子串</p><p>假设文本串子串 $[1, i]$ 在自动机上走到节点 $node_i$，那么现在考虑有可能被 $1…i$ 的后缀子串遍历到的 $j$，则 $j$ 一定在 $fail$ 树上是 $node_i$ 的祖先，故总状态有 $mL_{max}$ 个，此时复杂度为 $O (mL_{max})$</p><p>现在对上述 $dp$ 进行优化</p><p>在往$\text{AC}$自动机里插入的时候，建立父子关系（即$\text{trie}$树上的父子关系），用 $fa_i$ 表示</p><p>每经过自动机上某一条边，转移一定是相同的，故简化一下，令 $f_i$ 表示自动机上走到 $i$ 的答案（此时与文本串无关，因为节点 $i$ 已经确定了唯一一个后缀），考虑 $f_i$ 都从哪里转移，令字符串 $S_i$ 表示节点 $i$ 表示后缀</p><ul><li>直接等于 $f_{fail_i}$</li><li>由 $fa_i$ 及其后缀再加上 $val_{fail_i}$ 转移（即不取 $S_i$ 的第一个字符，那么 $val_i$ 也不能加上了）</li><li>直接取整个 $S_i$</li></ul><p>故此时再设两个状态 $g_i, h_i$，其中 $g_i$ 表示第三种情况，$h_i$ 表示第二种情况，那么 $f_i$ 的转移就表示为<br>$$<br>f_i = \max (f_{fail_i}, \max (g_i, h_i))<br>$$<br>至于为什么还要设 $h_i$，因为假如直接从 $f_{fail_i}$ 转移的话可能 $S_i$ 的某些有贡献后缀就无法被遍历到了，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e</span><br><span class="line">de</span><br><span class="line">bd</span><br><span class="line">abde</span><br></pre></td></tr></table></figure><p>那么在计算 $f(abde)$ 的时候，若只取其 $fail$ 树上父亲，则只会访问到 $\text{de}$，那么 $\text{bd}$ 后面拼上一个 $e$ 的情况就遍历不到了</p><p>其中对 $h_i$ 的转移只要考虑 $S_i$ 与 $S_{fail_i}$ 的差值部分就好了，故总转移复杂度是 $O (m + L)$ 的</p><p>注意记得将文本串插入到自动机中，不然显然无法统计答案</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tr[MAXN][<span class="number">26</span>]= &#123;<span class="number">0</span>&#125;, fail[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; <span class="keyword">int</span> n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (! tr[p][c]) &#123; tr[p][c] = ++ m; father[m] = p; &#125;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">&#125;</span><br><span class="line">value[p] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;, h[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">que.push(tr[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">value[u] += value[fail[u]];</span><br><span class="line">g[u] = g[father[u]] + value[u];</span><br><span class="line"><span class="keyword">if</span> (! fail[u]) h[u] = h[father[u]];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">h[u] = - INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = father[u]; j != father[fail[u]]; j = fail[j])</span><br><span class="line">h[u] = max (h[u], h[j] + value[fail[u]]);</span><br><span class="line">&#125;</span><br><span class="line">f[u] = max (f[fail[u]], max (g[u], h[u]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u][i]) &#123;</span><br><span class="line">fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">que.push(tr[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>, n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">ans = max (ans, f[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">insert (getnum ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>); insert (<span class="number">0</span>);</span><br><span class="line">build ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 卡特兰数 </tag>
            
            <tag> 集训 </tag>
            
            <tag> AC自动机 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十二）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日继续垫底系列</p><p>T1题意理解错误暴力写挂</p><p>T2怒敲 $n \le 4$ 求根公式然后发现答案还得排序。。</p><p>$\text{score：0 + 10 + 0 = 10   rk：27/27}$</p><h2 id="Problem-A：游戏"><a href="#Problem-A：游戏" class="headerlink" title="Problem A：游戏"></a>Problem A：游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh是一名Herthstone大师。现在他遇到了一个很严峻的问题：</p><p>场上总共有 $n+m$ 个随从，其中ysgh控制着 $n$ 个，对手控制着 $m$ 个。每个随从有自己的血量。</p><p>如果ysgh在这一回合成功解掉了对手的所有随从，则ysgh获胜。否则下一回合对手直接骑脸，ysgh就会输掉。</p><p>ysgh现在手里仅有一场牌，属性如下：</p><p>进行 $d$ 次，每一次等概率随机一个在场上的未死亡随从（包括自己和对手的）并且对其造成一点伤害。若不存在未死亡随从，则不进行此次攻击。一个随从未死亡当且仅当其血量严格大于 $0$。每一次攻击后，所有血量小于等于 $0$ 的随从立即死亡。</p><p>ysgh想要知道，他有多大概率可以取胜，也就是多大的概率使得在使用这张牌后，对手的随从全部死亡。</p><p><strong>特别提醒：由于描述与实际游戏规则有出入，一切以实际题面描述为准。</strong></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，满足 $1 \le n, m \le 6, ~ 1 \le d \le 400$</p><p>保证所有随从血量均为 $1 \sim 12$ 之间的正整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我没玩过炉石还真是对不起哦。。原来假如这一个技能结束全场都没了的话是算我方胜利而不是平手。。</p><p>将 $n + m$ 个随从一起考虑，设第 $i$ 个随从血量 $a_i$</p><p>很容易可以想到设 $f_{i, state}$ 表示前 $i$ 轮，死亡状态为为 $state$ 的概率</p><p>显然一个随从死亡后会分一段，就是你接下来要乘的概率分母要减一</p><p>多加一个死亡随从很好转移，但是当时我就卡在如何计算该随从的血量分配在前面几段需要乘上的概率</p><p>实际上很简单，只要在转移该轮攻击后无新人死亡的时候“预支”一下这个概率就好了，$\text{dp}$ 式子如下，其中，令 $|state|$ 表示 $state$ 二进制表示 $1$ 的个数，$s (state)$ 表示 $state$ 表示出的死亡随从的总血量<br>$$<br>\begin{aligned}<br>攻击后无新人死亡：&amp;f_{i, state} \times \frac1{n + m - |state|} \rightarrow f_{i + 1, state} \\<br>攻击后存在新随从k(k \not\in state)死亡：&amp;f_{i, state} \times \frac{\dbinom{i - s (state)}{a_k - 1}}{n + m - |state|} \rightarrow f_{i, state | (1 &lt;&lt; (k - 1))}<br>\end{aligned}<br>$$<br>“预支”过后在死亡随从转移时就只要直接在前面预留下的位置中选几个就好了</p><p>当然现在还需要将剩下的未死亡的随从的血量分配（即他们可能被攻击但未死亡），一个多重背包就好了</p><p>时间复杂度 $O (2^{n + m}144^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">12</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXD = <span class="number">144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, M, D;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL inv[MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXD]= &#123;<span class="number">0</span>&#125;, ifact[MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * ifact[m] % MOD * ifact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXD][MAX]= &#123;<span class="number">0</span>&#125;, g[MAXN][MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt ++; state ^= lowbit (state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), D = getnum (); T = N + M;</span><br><span class="line">fact[<span class="number">0</span>] = ifact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">fact[<span class="number">1</span>] = ifact[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max (T, D); i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">ifact[i] = ifact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + M; i ++) &#123; a[i] = getnum (); tot += a[i]; &#125;</span><br><span class="line">D = min (D, tot);</span><br><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; T) - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++) &#123;</span><br><span class="line"><span class="keyword">int</span> s = calc (state), sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j ++)</span><br><span class="line"><span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">sum += a[j];</span><br><span class="line"><span class="keyword">if</span> (i &lt; sum) <span class="keyword">continue</span>;</span><br><span class="line">f[i + <span class="number">1</span>][state] = (f[i + <span class="number">1</span>][state] + f[i][state] * inv[T - s] % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= T; k ++)</span><br><span class="line"><span class="keyword">if</span> (! (state &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)))) &#123;</span><br><span class="line">LL mul = C (i - sum, a[k] - <span class="number">1</span>) % MOD * inv[T - s] % MOD;</span><br><span class="line">f[i + <span class="number">1</span>][state | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] = (f[i + <span class="number">1</span>][state | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] + f[i][state] * mul % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stan = <span class="number">0</span>;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = N + <span class="number">1</span>; j &lt;= T; j ++) stan |= (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++)</span><br><span class="line"><span class="keyword">if</span> ((state &amp; stan) == stan) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) sum += a[j];</span><br><span class="line"><span class="keyword">else</span> b[++ m] = a[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> V = D - sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= V; k ++) &#123;</span><br><span class="line">g[j][k] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= min (k, b[j] - <span class="number">1</span>); l ++)</span><br><span class="line">g[j][k] = (g[j][k] + g[j - <span class="number">1</span>][k - l] * C (V - (k - l), l) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + f[D][state] * g[m][V] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：方程"><a href="#Problem-B：方程" class="headerlink" title="Problem B：方程"></a>Problem B：方程</h2><h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h3><p>求解一元 $n$ 次方程 $f(x) = \sum a_ix^i = 0$ 的所有实数根</p><p>有 $T$ 组数据</p><p><strong>注意输出的实数根要按从大到小排序</strong></p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 6$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>（百度长的跟什么一样的求根公式的卑微的我）</p><p>对 $f(x)$，考虑其导数 $f’(x)$，对于 $f’(x)$ 的相邻两实数根 $x_1, x_2$ 显然有 $f(x)$ 在 $(x_1, x_2)$ 单调</p><p>那么求出 $f’(x)$ 实数根后在上述单调区间二分答案即可</p><p>递归处理</p><p>时间复杂度 $O (Tn^3)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> Ld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Ld eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="keyword">const</span> Ld INF = <span class="number">1e20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span> <span class="params">(Ld p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Ld zero[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">Ld <span class="title">value</span> <span class="params">(<span class="keyword">int</span> n, Ld val)</span> </span>&#123;</span><br><span class="line">Ld x = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++, x = x * val)</span><br><span class="line">ret += t[n][i] * x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> n, Ld L, Ld R, Ld&amp; ze)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d1 = dcmp (value (n, L));</span><br><span class="line"><span class="keyword">int</span> d2 = dcmp (value (n, R));</span><br><span class="line"><span class="keyword">if</span> (d1 * d2 &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (d1 * d2 == <span class="number">0</span>) &#123; ze = d1 == <span class="number">0</span> ? L : R; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (d1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld left = L, right = R;</span><br><span class="line"><span class="keyword">while</span> (dcmp (right - left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld mid = (left + right) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (value (n, mid)) &lt;= <span class="number">0</span>) left = mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line">ze = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Ld left = L, right = R;</span><br><span class="line"><span class="keyword">while</span> (dcmp (right - left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld mid = (left + right) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (value (n, mid)) &gt;= <span class="number">0</span>) left = mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line">ze = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">Ld a = t[n][<span class="number">1</span>], b = t[n][<span class="number">0</span>];</span><br><span class="line">zero[n][++ cnt[n]] = - b / a;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">Ld a = t[n][<span class="number">2</span>], b = t[n][<span class="number">1</span>], c = t[n][<span class="number">0</span>];</span><br><span class="line">Ld delta = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp (delta) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>) delta = <span class="number">0</span>;</span><br><span class="line">Ld x1, x2;</span><br><span class="line"><span class="keyword">if</span> (dcmp (a) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">x1 = (- b - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">x2 = (- b + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = (- b + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">x2 = (- b - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>) zero[n][++ cnt[n]] = x1;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">zero[n][++ cnt[n]] = x1;</span><br><span class="line">zero[n][++ cnt[n]] = x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">work (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (! cnt[n - <span class="number">1</span>]) &#123;</span><br><span class="line">Ld posi;</span><br><span class="line"><span class="keyword">if</span> (find (n, - INF, INF, posi))</span><br><span class="line">zero[n][++ cnt[n]] = posi;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">zero[n - <span class="number">1</span>][<span class="number">0</span>] = - INF, zero[n - <span class="number">1</span>][cnt[n - <span class="number">1</span>] + <span class="number">1</span>] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt[n - <span class="number">1</span>]; i ++) &#123;</span><br><span class="line">Ld posi;</span><br><span class="line"><span class="keyword">if</span> (find (n, zero[n - <span class="number">1</span>][i], zero[n - <span class="number">1</span>][i + <span class="number">1</span>], posi))</span><br><span class="line">zero[n][++ cnt[n]] = posi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">t[i][j] = t[i + <span class="number">1</span>][j + <span class="number">1</span>] * (j + <span class="number">1</span>);</span><br><span class="line">work (n);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, cnt[n]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[n]; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.8Lf\n"</span>, zero[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> (t));</span><br><span class="line"><span class="built_in">memset</span> (cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line"><span class="built_in">memset</span> (zero, <span class="number">0</span>, <span class="keyword">sizeof</span> (zero));</span><br><span class="line"><span class="keyword">int</span> n = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) t[n][i] = getnum ();</span><br><span class="line">solve (n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：旅游"><a href="#Problem-C：旅游" class="headerlink" title="Problem C：旅游"></a>Problem C：旅游</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh是最优化大师</p><p>ysgh想去旅游，他所在的城市共有 $n$ 个景点，景点之间有 $m$ 条双向道路连接。保证 $n$ 个景点可以通过 $m$ 条道路互相到达。道路长度均为 $1$。</p><p>ysgh可以通过乘坐出租车完成旅行。具体的，第 $i$ 个景点的出租车最多可以将其载到距离 $i$ 不超过 $f_i$ 的地方。在第 $T$ 天，搭乘从第 $i$ 个景点出发的出租车需要花费 $c_i \times T + w_i$ 元。</p><p>ysgh的钱已经在小卖部中挥霍一空，因此他想要选择 $1$ 至 $T_{max}$ 中的一天，从景点 $1$ 出发，搭乘出租车到达景点$x$，同时花费尽量地小。</p><p>由于他没有定下来在那个城市游玩，因此他想要对所有的 $x \in [1, n]$ 求出答案。</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/06/52phqVItFKWuRNg.png" alt=""></p><p>保证对所有 $1 \le T \le T_{max}, c_i \times T + w_i &gt; 0$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>设 $v_i = c_i \times T + w_i$</p><p>考虑暴力，对每个点向它能到达的所有点连一个边权为 $v_i$ 的边，且容易发现，答案一定在 $T$ 取 $1$ 或 $T_{max}$ 中选，然后从 $1$ 开始跑最短路</p><p>由于每个点向外出边边权相同，所以考虑用数据结构优化建图过程</p><p>从 $m = n - 1$ 的情况开始说明，首先贪心思想，每个点只会被更新一次，每次使用堆中 $d$（已知最短路）最小的点来更新其它点</p><p>设 $dist(u, v)$ 表示 $u, v$ 的最短距离（此时即树上距离）建立点分树，假设现在最短路跑到从 $u$ 开始更新其它节点，那么枚举 $u$ 在点分树上的每个祖先，那么其每个祖先 $fa$ 包含的节点中，满足 $dist (u, fa) + dist (fa, v) \le f_u$ 的所有节点 $v$ 是 $u$ 应当去更新的，不难发现，这样的 $v$ 一定是按它到 $fa$ 的距离被顺序更新的，所以可以记录每个点 $p$ 在点分树上按到 $p$ 距离递增排列的子节点，并记录一个指针，即已经更新到哪个子节点，以后在点分树上枚举到 $p$ 只需从指针记录位置开始枚举即可，这样子每个节点被访问到 $log n$ 次，故总时间复杂度 $O (n \log n)$</p><p>对于 $m \ge n$ 的情况，用与上面类似的算法，由于它最多多出 $50$ 条边，不妨就以 $m = n + 50$ 来论</p><p>在图中随意抽出一棵生成树，那么那些不在生成树中的边 $(u, v)$ 我们将 $u$ 记作冗余节点，即这样的边为冗余边，很显然这样的节点最多 $50$ 个</p><p>那么从点 $u$ 到点 $v$ 的最短距离就有两种情况</p><ul><li>全部走树上路径</li><li>交替走树上路径与冗余路径，那么它一定至少经过一个冗余节点 $x$，满足 $dist (u, x) + dist (x, v) \le f_u$</li></ul><p>对第一种情况，在生成树中运行上面所述 $m = n - 1$ 同样的算法即可，问题在于第二种情况</p><p>实际上两种情况本质上是一样的，对每个冗余节点 $p$，将所有 $n$ 个节点按到 $p$ 的距离递增排序存在数组中，那么最短路运行到 $u$ 时同样也只要用指针在数组里走就好了，步骤和 $m = n - 1$ 的情况也是一样的</p><p>这样每个节点最多被访问 $50 + \log n$ 次，总时间复杂度 $O \left(n (50 + \log n)\right)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> LL LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span>  <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, E = <span class="number">0</span>, Tm;</span><br><span class="line"><span class="keyword">int</span> b[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], c[MAXN], w[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pt[MAXN], ex[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> poi[MAXN]= &#123;<span class="number">0</span>&#125;, pex[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ances[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ances[x] == x ? x : ances[x] = find (ances[x]); &#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ances[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = edge[i].first, y = edge[i].second;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123; b[++ E] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">ances[fx] = fy; Insert (x, y), Insert (y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN], g, mini;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acsize</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>; <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">acsize (v, root, n);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">maxpart = max (maxpart, subsize[v]);</span><br><span class="line">&#125;</span><br><span class="line">maxpart = max (maxpart, n - subsize[root]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) g = root, mini = maxpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lev[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> depth[<span class="number">25</span>][MAXN], d[MAXN], m = <span class="number">0</span>, mdep = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">d[++ m] = root; mdep = max (mdep, depth[l][root]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">depth[l][v] = depth[l][root] + <span class="number">1</span>;</span><br><span class="line">DFS (v, root, l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXN]= &#123;<span class="number">0</span>&#125;, topo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">mini = INF, acsize (u, <span class="number">0</span>, n);</span><br><span class="line">father[g] = fa; visit[g] = <span class="literal">true</span>;</span><br><span class="line">mdep = m = <span class="number">0</span>, lev[g] = l, depth[l][g] = <span class="number">0</span>; DFS (g, <span class="number">0</span>, l);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mdep; i ++) buck[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) buck[depth[l][d[i]]] ++, topo[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mdep; i ++) buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) topo[buck[depth[l][d[i]]] --] = d[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) pt[g].push_back(topo[i]);</span><br><span class="line">acsize (g, <span class="number">0</span>, n); <span class="keyword">int</span> fg = g;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fg]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">divide (v, subsize[v], l + <span class="number">1</span>, fg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> deep[<span class="number">51</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkit</span> <span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">que.push(S), deep[id][S] = <span class="number">0</span>, vis[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[u].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">deep[id][v] = deep[id][u] + <span class="number">1</span>;</span><br><span class="line">que.push(v); vis[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) buck[i] = topo[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) buck[deep[id][i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) topo[buck[deep[id][i]] --] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ex[id].push_back(topo[i]);</span><br><span class="line">&#125;</span><br><span class="line">LL value[MAXN], ans[MAXN]= &#123;<span class="number">0</span>&#125;, dist[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id; LL d;</span><br><span class="line">node (<span class="keyword">int</span> id = <span class="number">0</span>, LL d = <span class="number">0</span>) : id (id), d (d) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; p.d; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;node&gt; heap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span> <span class="params">(<span class="keyword">int</span> u, LL d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = u; p; p = father[p]) &#123;</span><br><span class="line"><span class="keyword">int</span> l = lev[p];</span><br><span class="line"><span class="keyword">for</span> ( ; poi[p] &lt; (<span class="keyword">int</span>) pt[p].size(); poi[p] ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = pt[p][poi[p]];</span><br><span class="line"><span class="keyword">if</span> (depth[l][u] + depth[l][v] &gt; f[u]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[v] &lt; LINF) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[u] + value[v];</span><br><span class="line">heap.push(node (v, dist[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; pex[i] &lt; (<span class="keyword">int</span>) ex[i].size(); pex[i] ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = ex[i][pex[i]];</span><br><span class="line"><span class="keyword">if</span> (deep[i][u] + deep[i][v] &gt; f[u]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[v] &lt; LINF) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[u] + value[v];</span><br><span class="line">heap.push(node (v, dist[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) value[i] = <span class="number">1l</span>l * c[i] * T + w[i];</span><br><span class="line"><span class="built_in">memset</span> (poi, <span class="number">0</span>, <span class="keyword">sizeof</span> (poi)); <span class="built_in">memset</span> (pex, <span class="number">0</span>, <span class="keyword">sizeof</span> (pex));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) heap.pop();</span><br><span class="line"><span class="built_in">memset</span> (dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (dist));</span><br><span class="line">dist[<span class="number">1</span>] = value[<span class="number">1</span>], heap.push(node (<span class="number">1</span>, dist[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) &#123;</span><br><span class="line">node top = heap.top(); heap.pop();</span><br><span class="line"><span class="keyword">int</span> u = top.id; LL d = top.d;</span><br><span class="line">trans (u, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ans[i] = min (ans[i], dist[i] - value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Tm = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) f[i] = getnum (), c[i] = getnum (), w[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">edge[i] = make_pair (u, v);</span><br><span class="line">&#125;</span><br><span class="line">build ();</span><br><span class="line">sort (b + <span class="number">1</span>, b + E + <span class="number">1</span>);</span><br><span class="line">E = unique (b + <span class="number">1</span>, b + E + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">divide (<span class="number">1</span>, N, <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; i ++) linkit (b[i], i);</span><br><span class="line"><span class="built_in">memset</span> (ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (ans));</span><br><span class="line">solve (<span class="number">1</span>), solve (Tm);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) write (ans[i]), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 概率DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十九）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>再次垫底$\text{.jpg}$</p><p>$\text{score：20 + 0 + 10 = 30   rk：27/29}$</p><h2 id="Problem-A：sign"><a href="#Problem-A：sign" class="headerlink" title="Problem A：sign"></a>Problem A：sign</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/v9ViJtBL6OAnzYG.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题贼水，但我没想出来。。</p><p>我大概以为这不是数学所以没想到代入，或者是我忘记该点值表示可以 $O (\log A)$</p><p>反正全村就我没到及格线</p><p>题解懒得写了，就搬出题人给的吧</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/Pu2fmObx8V4RDnZ.png" alt=""></p><p>事实上，这个做法不能通过。</p><p>考虑上面做法复杂度瓶颈是快速幂。一个简单的$\text{trick}$是对于一个固定的 $son_u = k$，令 $M = \lceil \sqrt{A} \rceil$，预处理出 $k^0, k^1, k^2, …, k^{M - 1}$ 以及 $(k^M)^0, (k^M)^1, …, (k^M)^{M - 1}$。这样单次求某个点值就可以用 $O (1)$ 次算术运算求得。</p><p>时间复杂度为 $O ((n + \sqrt{A})\sqrt{n})$。</p><p>以上是出题人提供题解</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e04</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">LL ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL inv;</span><br><span class="line">LL f1[MAXN]= &#123;<span class="number">0</span>&#125;, f2[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = p / M, rest = p - base * M;</span><br><span class="line"><span class="keyword">return</span> f2[base] * f1[rest] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">LL r;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) r = a[root] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = (<span class="number">1</span> - calc (a[root] + <span class="number">1</span>) + MOD) % MOD * inv % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">r = r * work (v, t) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t == son[root]) ans[root] = r;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa = getnum ();</span><br><span class="line">Insert (fa, i); son[fa] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) b[++ m] = son[i];</span><br><span class="line">sort (b + <span class="number">1</span>, b + m + <span class="number">1</span>);</span><br><span class="line">m = unique (b + <span class="number">1</span>, b + m + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">inv = power (<span class="number">1</span> - b[i] + MOD, MOD - <span class="number">2</span>);</span><br><span class="line">f1[<span class="number">0</span>] = <span class="number">1</span>, f2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) f1[j] = f1[j - <span class="number">1</span>] * b[i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) f2[j] = f2[j - <span class="number">1</span>] * f1[M] % MOD;</span><br><span class="line">work (<span class="number">1</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：match"><a href="#Problem-B：match" class="headerlink" title="Problem B：match"></a>Problem B：match</h2><h2 id="Problem-C：tree"><a href="#Problem-C：tree" class="headerlink" title="Problem C：tree"></a>Problem C：tree</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/rxE7RpM2lkOtGWi.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题最基本的思路我一开始想了一下，然后马上扔了。。</p><p>首先考虑每个点它能够作为被 $LCA$ 的情况</p><p>考虑重链剖分，启发式合并，设点 $u$ 重子树 $A$，另一子树 $B$，则对 $i \in B, j \in A$，满足 $LCA (i, j) = u$，此时选择 $i, j$，$u$ 可以贡献给区间 $[l, r]$ 满足 $l \in [1, i], r \in [j, n]$（假定 $i &lt; j)$，也就是说，极限情况即是取 $i$ 在 $A$ 中的前驱 $pre$ 与后继 $nxt$，则最大 $u$ 可贡献区间即为 $[1, pre] \cup [i, n]$ 与 $[1, i] \cup [nxt, n]$</p><p>此时不妨把区间 $l, r$ 视为二维平面上的点 $(l, r)$，那么上面所说的 $i$ 导致的 $u$ 的最大可贡献区间在平面上则投影为矩形 $(1, i), (1, n), (pre, i), (pre, n)$ 与矩形 $(1, nxt), (1, n), (i, nxt), (i, n)$（取矩形的四个角）</p><p>考虑把所有  $depth$ 一致的点所贡献的矩形涂上相同的颜色，求每种颜色的矩形各自的并，那么最终询问点 $(l, r)$ 被多少种颜色的面积所覆盖则是答案</p><p>求矩形的并也很简单，因为这些矩形都是严格贴着平面左上角（即 $(1, n)$）的</p><p>然后扫描线一波就做完了</p><p>不过不要忘了题面所说的 $i, j$ 可以相同，所以对每个 $i, i \in [1, n]$，还得加上 $(1, i), (1, n), (i, i), (i, n)$ 的矩形</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[MAXN]= &#123;<span class="number">0</span>&#125;, subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> d[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL dist[MAXN]= &#123;<span class="number">0</span>&#125;, mpp[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line">mpp[++ m] = dist[root];</span><br><span class="line">son[root] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span> || subsize[v] &gt; subsize[son[root]])</span><br><span class="line">son[root] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; mat[MAXN]; <span class="comment">// &lt;纵坐标, 横坐标&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st[MAXN];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it, it2;</span><br><span class="line"><span class="keyword">int</span> ext[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (it = st[y].begin(); it != st[y].end(); it ++) &#123;</span><br><span class="line"><span class="keyword">int</span> i = * it;</span><br><span class="line">it2 = st[x].lower_bound(i);</span><br><span class="line"><span class="keyword">int</span> pre = i, nxt = i;</span><br><span class="line"><span class="keyword">if</span> (it2 != st[x].begin()) &#123; it2 --; pre = * it2; &#125;</span><br><span class="line">it2 = st[x].upper_bound(i);</span><br><span class="line"><span class="keyword">if</span> (it2 != st[x].end()) nxt = * it2;</span><br><span class="line"><span class="keyword">if</span> (nxt != i) mat[id].push_back(make_pair (nxt, i));</span><br><span class="line"><span class="keyword">if</span> (pre != i) mat[id].push_back(make_pair (i, pre));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (it = st[y].begin(); it != st[y].end(); it ++) st[x].insert(* it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span>) &#123;</span><br><span class="line">st[root].insert(root); ext[root] = root;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">make (son[root], root);</span><br><span class="line">ext[root] = ext[son[root]];</span><br><span class="line">st[ext[root]].insert(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || v == son[root]) <span class="keyword">continue</span>;</span><br><span class="line">make (v, root);</span><br><span class="line">merge (ext[root], ext[v], d[root]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, type, id;</span><br><span class="line"><span class="comment">// type: - 1, + 1, 2(dot)</span></span><br><span class="line">node (<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> type = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>) : x (x), y (y), type (type), id (id) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x == p.x) <span class="keyword">return</span> type &lt; p.type;</span><br><span class="line"><span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node a[MAXM &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mesh</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">sort (mat[id].begin(), mat[id].end());</span><br><span class="line"><span class="keyword">int</span> lx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) mat[id].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = mat[id][i].first, x = mat[id][i].second;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= lx) &#123;</span><br><span class="line">a[++ n] = node (lx, y, <span class="number">1</span>, id);</span><br><span class="line">a[++ n] = node (x + <span class="number">1</span>, y, - <span class="number">1</span>, id);</span><br><span class="line">lx = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> answer[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= N) &#123;</span><br><span class="line">subsum[x] += delta;</span><br><span class="line">x += lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret += subsum[x];</span><br><span class="line">x -= lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">sort (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = a[i].y, type = a[i].type, id = a[i].id;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">2</span>) answer[id] = query (y);</span><br><span class="line"><span class="keyword">else</span> add (y, type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">sort (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>);</span><br><span class="line">m = unique (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>) - mpp - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) d[i] = lower_bound (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>, dist[i]) - mpp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) mat[d[i]].push_back(make_pair (i, i));</span><br><span class="line">make (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) mesh (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">a[++ n] = node (l, r, <span class="number">2</span>, q);</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十七）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日又是三道集训队作业原题。。又没部分分。。</p><p>反正我都不会必定爆零就没交了。。</p><p>$\text{score：NULL   rk：NULL}$</p><h2 id="Problem-A：Birthday"><a href="#Problem-A：Birthday" class="headerlink" title="Problem A：Birthday"></a>Problem A：Birthday</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 $n$ 个仅包含 <code>a,b</code> 的字符串。</p><p>你需要去掉尽可能少的字符串，使得剩下的字符串中不存在某一个串是另一个串的子串。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 750, ~ \sum\limits_{i = 1}^n |s_i \le 10^7$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://codeforces.com/problemset/problem/590/E?f0a28=2" target="_blank" rel="noopener">CF590E</a></p><p>由于 $n$ 很小，很显然可以对每一对字符串判断一个是不是另一个的子串，如果是就连个单向边，最终形成一个 $DAG$ 然后在上面搞</p><p>那么对于建图，先建个$\text{AC}$自动机，在 $trie$ 的结尾存一下编号，然后把每个串扔上去匹配，每次匹配与走到节点 $fail$ 树上的所有编号（即它的子串）连边</p><p>当然直接连边肯定会 $T$，实际上你只要往在 $fail$ 树往上找到的第一个编号以及本身节点的编号（如果存在的话）连边，然后传递闭包就好了，这样复杂度就正确了</p><p>那么接下来的任务就是在 $DAG$ 上求出最长反链并构造方案</p><p>那这就是 <a href="https://colythme.github.io/2020/07/15/[CTSC2008]祭祀（DAG最长反链及其方案构造）/">[CTSC2008]祭祀</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">750</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">2</span> * MAXN + MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFDS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125;;</span><br><span class="line">LFDS iLink[MAXN * MAXN];</span><br><span class="line"><span class="keyword">int</span> iHead[MAXM]= &#123;<span class="number">0</span>&#125;, isize = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">iLink[++ isize].to = v;</span><br><span class="line">iLink[isize].next = iHead[u];</span><br><span class="line"></span><br><span class="line">iHead[u] = isize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXM];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sve[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[MAXM][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>, n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">sve[ind].push_back(c);</span><br><span class="line"><span class="keyword">if</span> (! tr[p][c]) tr[p][c] = ++ m;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">&#125;</span><br><span class="line">Insert (p, ind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fail[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> lastp[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">que.push(tr[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">lastp[u] = iHead[fail[u]] ? fail[u] : lastp[fail[u]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u][i]) &#123;</span><br><span class="line">fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">que.push(tr[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) sve[ind].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = sve[ind][i];</span><br><span class="line">p = tr[p][c];</span><br><span class="line"><span class="keyword">int</span> tp = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = iHead[tp]; k; k = iLink[k].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = iLink[k].to;</span><br><span class="line"><span class="keyword">if</span> (v == ind) <span class="keyword">continue</span>;</span><br><span class="line">g[v][ind] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">tp = lastp[tp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXL &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, size = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (x, y, cap); Insert (y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T, _N;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[p]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[p] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (cap, rest));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAXFLOW</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> tagl[MAXN]= &#123;<span class="literal">false</span>&#125;, tagr[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">tagr[u - N] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][u - N] &amp;&amp; ! tagl[i]) &#123;</span><br><span class="line">tagl[i] = <span class="literal">true</span>;</span><br><span class="line">DFS (match[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">insert (i);</span><br><span class="line">&#125;</span><br><span class="line">build ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) work (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][k])</span><br><span class="line">g[i] |= g[k];</span><br><span class="line">S = <span class="number">2</span> * N + <span class="number">1</span>, _N = T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = N - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! Link[<span class="number">4</span> * i - <span class="number">2</span>].cap)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next)</span><br><span class="line"><span class="keyword">if</span> (! Link[j].cap) &#123;</span><br><span class="line">match[i] = Link[j].to;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (Link[<span class="number">4</span> * i].cap)</span><br><span class="line">DFS (i + N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! tagl[i] &amp;&amp; tagr[i])</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d "</span>, i);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：A-Sequence-of-Permutations"><a href="#Problem-B：A-Sequence-of-Permutations" class="headerlink" title="Problem B：A Sequence of Permutations"></a>Problem B：A Sequence of Permutations</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个长为 $n$ 的排列 $p, q$，设 $f(p, q)$ 为使第 $p_i$ 个数为 $q_i$ 的排列</p><p>已知 $a_1 = p, a_2 = q, a_{n + 2} = f(a_n, a_{n + 1})$，求 $a_k$</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n \le 10^5, ~ k \le 10^9$</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>定义两个排列 $p, q$ 的乘法为，设 $r = pq$，则有<br>$$<br>r_i = p_{q_i}<br>$$<br>该乘法满足结合律，但不满足交换律</p><p>该乘法的单位元为 $e$ 满足 $e_i = i$，那么排列 $p$ 的逆元 $p^{- 1}$ 即可定义为 $p^{- 1}$ 满足 $p^{- 1}_{p_i} = i$</p><p>对逆元，有 $(pq)^{- 1} = q^{- 1}p^{- 1}$，同理对多个排列相乘的逆元，将它们反过来再分别求逆，最后按顺序相乘即可</p><p>下面给出该逆元公式的简单证明：</p><ul><li>设 $A = (pq)^{- 1}$，则有 $A_{p_{q_i}} = i$</li><li>设 $B = q^{-  1}p^{- 1}$，则有 $B_i = q^{- 1}<em>{p^{- 1}_i}$，令 $i = p_i$，有 $B</em>{p_i} = q^{- 1}<em>i$，再令 $i = q_i$，最后有 $B</em>{p_{q_i}} = i$</li><li>即 $A_{p_{q_i}} = B_{p_{q_i}}$，故等式成立</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$$<br>\begin{aligned}<br>&amp;f(p, q)_{p_i} = q_i \\<br>\Rightarrow &amp;f(p, q) * p = q \\<br>\Rightarrow &amp;f(p, q) = qp^{- 1}<br>\end{aligned}<br>$$</p><p>然后打表找规律<br>$$<br>\begin{aligned}<br>a_1 &amp;= p \\<br>a_2 &amp;= q \\<br>a_3 &amp;= qp^{- 1} \\<br>a_4 &amp;= qp^{- 1}q^{- 1} \\<br>a_5 &amp;= qp^{- 1}q^{- 1}pq^{- 1} \\<br>a_6 &amp;= qp^{- 1}q^{- 1}p^2q^{- 1} \\<br>a_7 &amp;= qp^{- 1}q^{- 1}pqpq^{- 1} \\<br>a_8 &amp;= qp^{- 1}q^{- 1}pqp^{- 1}qpq^{- 1} \\<br>\cdots<br>\end{aligned}<br>$$<br>令 $t = qp^{- 1}q^{- 1}p$，则 $a_7 = tpt^{- 1}, a_8 = tqt^{- 1}$，那么可以得到 $a_{6k + 1} = t^kpt^{- k}, a_{6k + 2} = t^kqt^{- k}$，对 $t$ 做个快速幂，然后剩下的几项暴力一下就好了</p><p>时间复杂度 $O (n \log \frac{k}{6})$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> P[MAXN], Q[MAXN];</span><br><span class="line"><span class="keyword">int</span> IP[MAXN], IQ[MAXN];</span><br><span class="line"><span class="keyword">int</span> T[MAXN], IT[MAXN];</span><br><span class="line"><span class="keyword">int</span> Tk[MAXN], ITk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(<span class="keyword">int</span>* ret, <span class="keyword">int</span>* p, <span class="keyword">int</span>* q)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = p[q[i]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span>* I, <span class="keyword">int</span>* p)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) I[p[i]] = i; &#125;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], ret[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = i;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) &#123; mul (A, ret, x); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = A[i]; &#125;</span><br><span class="line">mul (A, x, x); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) x[i] = A[i];</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) x[i] = ret[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, a[i]);</span><br><span class="line">&#125; <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) n = <span class="number">6</span>;</span><br><span class="line">mul (a[<span class="number">1</span>], P, ITk), mul (A, Tk, a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[<span class="number">1</span>][i] = A[i];</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123; print (a[<span class="number">1</span>]); <span class="keyword">return</span> ; &#125;</span><br><span class="line">mul (a[<span class="number">2</span>], Q, ITk), mul (A, Tk, a[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[<span class="number">2</span>][i] = A[i];</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) &#123; print (a[<span class="number">2</span>]); <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) a[i + <span class="number">2</span>][a[i][j]] = a[i + <span class="number">1</span>][j];</span><br><span class="line">print (a[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) P[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) Q[i] = getnum ();</span><br><span class="line">inv (IP, P), inv (IQ, Q);</span><br><span class="line">mul (T, IQ, P), mul (A, IP, T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) T[i] = A[i];</span><br><span class="line">mul (A, Q, T); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) T[i] = A[i];</span><br><span class="line">inv (IT, T); <span class="keyword">int</span> k = K / <span class="number">6</span>; <span class="keyword">if</span> (! (K % <span class="number">6</span>)) k --;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) Tk[i] = T[i]; power (Tk, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ITk[i] = IT[i]; power (ITk, k);</span><br><span class="line"><span class="keyword">int</span> r = K % <span class="number">6</span>; solve (r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：Synchronized-Subsequence"><a href="#Problem-C：Synchronized-Subsequence" class="headerlink" title="Problem C：Synchronized Subsequence"></a>Problem C：Synchronized Subsequence</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 $2n$ 的仅由字符 $\mathtt{a}, \mathtt{b}$ 构成的字符串，且 $\mathtt{a}$ 的个数恰好等于 $\mathtt{b}$ 的个数，都出现了 $n$ 次</p><p>你需要保留一些字符，剩下的字符删掉。对于一个 $i$，你可以保留从左往右数的第 $i$ 个 $\mathtt{a}$ 和第 $i$ 个 $\mathtt{b}$</p><p>注意，对于这两个字符，只能同时保留或同时删掉，不能只保留其中一个</p><p>请你求出能得到的字典序最大的串</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 3000$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>其实好像可以直接贪心来着，但我觉得 贪心 + $dp$ 的方法更值得记录</p><p>现在考虑若强制要求第 $i$ 对 $a, b$ 存在有什么样的局面，设第 $i$ 对 $a, b$ 在字符串中的位置 $apos_i. bpos_i$</p><ul><li>若 $apos_i &lt; bpos_i$，那么在把该对 $a, b$ 之间的 $a$ 全部删掉之前都不是更优的，故它们之间的 $a$ 应全部删去，最终留下 $ab$</li><li>若 $apos_i &gt; bpos_i$，显然它们之间的 $b$ 都必须全部存在</li></ul><p>那么现在记 $f_i$ 表示强制选第 $i$ 对 $a,b$，对 $i…n$ 对 $a, b$ 组合成的最大串，记 $g_i$ 表示 $\max (f_i, f_i + 1, …, f_n)$</p><p>注意 $f, g$ 都是 $\text{string}$ 类型</p><p>转移就看代码把</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> apos[MAXN]= &#123;<span class="number">0</span>&#125;, bpos[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> an = <span class="number">0</span>, bn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="comment">// f[i]: 强制选第i对a、b，对i...n对a、b的最大串</span></span><br><span class="line"><span class="comment">// g[i]: max (f[i], f[i + 1], ..., f[n])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%s"</span>, &amp; N, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N &lt;&lt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'a'</span>) apos[++ an] = i;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'b'</span>) bpos[++ bn] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">if</span> (apos[i] &lt; bpos[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= N &amp;&amp; apos[j] &lt; bpos[i]) j ++;</span><br><span class="line">f[i] = <span class="string">"ab"</span> + g[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= N &amp;&amp; bpos[j] &lt; apos[i]) j ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - i; k ++) f[i] += <span class="string">'b'</span>;</span><br><span class="line">f[i] += <span class="string">'a'</span> + (i + <span class="number">1</span> == j ? g[i + <span class="number">1</span>] : f[i + <span class="number">1</span>]).substr(j - i - <span class="number">1</span>, <span class="built_in">string</span>::npos); <span class="comment">// j-i-1表示i...j-1都已经放完，取g[i+1]或f[i+1]的j...n段</span></span><br><span class="line">&#125;</span><br><span class="line">g[i] = max (f[i], g[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 集训 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十一）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>好了，又是爆零的一天，恭喜我自己</p><p>$\text{score：0 + 0 + 0 = 0   rk：27/27}$</p><h2 id="Problem-A：小卖部"><a href="#Problem-A：小卖部" class="headerlink" title="Problem A：小卖部"></a>Problem A：小卖部</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh 是一名数数大师。</p><p>现在小卖部有 $n$ 种商品，第 $i$ 种有 $a_i$ 个，价格为 $b_i$。</p><p>ysgh 总共去了 $Q$ 天小卖部，第 $i$ 天他只会购买编号在 $l_i \sim r_i$ 的商品。他的卡里有 $c_i$ 元，因此他只能购买价值和不超过 $c_i$ 元的物品。</p><p>ysgh 想要知道有多少种购买物品的方案。由于答案很大，你只需要输出答案对 $1000000007$ 取模后的结果。两种方案被认为是不同的当且仅当存在一种物品，其购买数量不同。</p><p>当然，ysgh玩了个小花招，你需要通过上一个询问的答案来推导下一个询问的参数。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，满足 $1 \le n \le 10000, ~ 1 \le Q \le 50000, ~ 1 \le a_i, b_i, c_i \le 1000, 1 \le l’_i, r’_i \le n$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令 $C = 1000$</p><p>首先看得出来可以用生成函数搞，显然答案为 $F_i(x) = \prod\limits_{i = 1}^n \left(\sum\limits_{k = 0}^{a_i}x^{k \times b_i}\right)$</p><p>对 $F(x)$ 求个前缀和 $SF_n (x)$，并设 $SF_n(x)$ 逆元为 $I_n(x)$，答案就是 $SF_r(x)I_{l - 1}(x)$ 的前 $c$ 项系数和</p><p>然后我就开始 $FFT$、多项式求逆什么的乱搞，时间爆炸，然后爆零（虽然我连每次询问的 $l, r$ 都算错了）</p><p>好吧实际上上面那玩意儿继续化，可以变成 $F_i(x) = \frac{1 - x^{(a_i + 1)b_i}}{1 - x^{b_i}}$</p><p>接下来的步骤我觉着很有意思</p><p>首先把分子分母分开，就变成 $F_i(x) = (1 + x^{b_i} + x^{2b_i} + …)(1 - x^{(a_i + 1)b_i})$</p><p>假设现在要处理 $SF_i(x) = SF_{i - 1}(x)F_i(x)$，那么设 $SF_i(X), SF_{i - 1}(x)$ 的第 $k$ 项分别为 $g_k, f_k$，则有 $g_k = f_k + f_{k - b_i} + f_{k - 2b_i} + …$（乘 $F(x)$ 前半部分），然后 $g_k = g_k - g_{k - (a_i + 1)b_i}$（乘 $F(x)$ 后半部分），记得第二部分要倒推</p><p>接下来只需处理逆元，先直接 $O (C^2)$ 求出 $I_{n}(x)$，然后 $I_i(x) = I_{i + 1}(x)F_{i + 1}(x)$ 处理即可</p><p>还有一部处理，假设得到的最终多项式 $A(x) = SF_r(x)I_{l - 1}(x)$，然后要求 $\sum\limits_{i = 0}^cA(x)[x^i]$，这样还是需要一次多项式乘法，时间还是不行</p><p>此时可以令 $B(x) = \frac{A(x)}{1 - x} = A(x)(1 + x + x^2 + …)$，那么 $\sum\limits_{i = 0}^cA(x)[x^i] = B(x)[x^c]$，就可以 $O (C)$ 处理</p><p>说实话我觉得这些处理是真挺厉害的（但我觉得只是因为我太菜了）</p><p>时间复杂度 $O \left((n + Q)C\right)$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXC = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = <span class="number">1l</span>l * cnt * x % MOD;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span>* B, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= C; i ++) A[i] = (B[i] + (i &gt;= b[p] ? A[i - b[p]] : <span class="number">0</span>)) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = C; i &gt;= (a[p] + <span class="number">1</span>) * b[p]; i --)</span><br><span class="line">A[i] = (A[i] - A[i - (a[p] + <span class="number">1</span>) * b[p]] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span>* inv)</span> </span>&#123;</span><br><span class="line">inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">inv[i] = (inv[i] - <span class="number">1l</span>l * inv[j] * A[i - j] % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN][MAXC]= &#123;<span class="number">0</span>&#125;, inv[MAXN][MAXC]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen ("A.in", "r", stdin);</span></span><br><span class="line"><span class="comment">// freopen ("A.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">N = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum (), b[i] = getnum ();</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, inv[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) mul (sum[i], sum[i - <span class="number">1</span>], i);</span><br><span class="line">inverse (sum[N], inv[N]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) mul (inv[i], inv[i + <span class="number">1</span>], i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line">inv[i][j] = (inv[i][j] + inv[i][j - <span class="number">1</span>]) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= Q; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum (), V = getnum ();</span><br><span class="line">l = (l + ans) % N + <span class="number">1</span>, r = (r + ans) % N + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) swap (l, r);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i ++) ans = (ans + <span class="number">1l</span>l * sum[r][i] * inv[l - <span class="number">1</span>][V - i] % MOD) % MOD;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Problem-B：博弈"><a href="#Problem-B：博弈" class="headerlink" title="Problem B：博弈"></a>Problem B：博弈</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh 有一棵 $n$ 个节点的树，树上在 $1$ 有一颗棋子。</p><p>ysgh 和 ysgs 利用这个棋子开始 van 游戏。具体的，ysgh 和 ysgs 轮流移动这个棋子，ysgh 先手。每次移动时，需要满足本次移动的树上距离严格大于上一次移动的树上距离（第一次移动需要满足树上距离不为 $0$），无法移动着输。他们称此游戏为 ogsc。ysgh 和 ysgs 都会做出游戏的最优决策。</p><p>ysgh 和 ysgs van 了很多游戏，渐渐觉得无聊了。</p><p>现在他们打算 van 以下游戏：</p><p>给定一颗 $n$ 个节点的树。ysgs 会选出一个包含节点 $1$ 的联通子树进行 ogsc 游戏。在两人均作最优决策的情况下，有多少个 ysgs 必胜的游戏。由于答案很大，只需要算对 $998244353$ 取膜的结果。</p><p>ysgs 花了 $0.5s$ 报出了答案，但是 ysgh 不知道是不是对的，于是他们找到了在一旁吃瓜的你。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 2e05, ~ T \le 10$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>后手必胜的条件：$1$ 位于树直径的中点上</p></blockquote><p>此时若先手到达一个距离 $1$ 为 $d$ 的点上，那么后手总是可以合法地到达与先手不在同一棵 $1$ 的子树，并且<strong>距离 $1$ 也为 $d$</strong> 的点，那么先手最终一定会被迫到达直径的一个端点，之后后手走到另一个直径的端点，那么先手就无法移动了</p><p>而若 $1$ 不在树直径的中点上，那么先手可以移动到树直径中点，而使得后手必输</p><p>现在问题转化为有多少棵连通子树满足 $1$ 位于树直径中点上</p><p>设 $f_{u, j}$ 表示以点 $u$ 为根，有多少个连通子树 $T’$ 满足 $\forall p \in T’, ~ dist (u, p) \le j$，其中 $dist (u, v)$ 表示点 $u, v$ 的树上距离</p><p>假设我们求出所有以 $1$ 为根的连通子树个数为 $tot$，那么此时只需枚举 $1$ 的每个儿子 $u$，以及 $u$ 的连通子树离 $u$ 的最大距离 $j$，强制令 $u$ 的连通子树为深度最深的，以其余 $1$ 的儿子为根的连通子树最大深度都小于它，那么这样的方案一定是不合法的，因为直径中点不可能是 $1$，统计方案数</p><p>令 $S_u$ 表示 $u$ 的儿子集合，$l_u$ 表示点 $u$ 在子树中可以到达的最远距离，公式化地，有<br>$$<br>ans = tot - \sum\limits_{u \in S_1}\sum\limits_{j = 0}^{l_u} (f_{u, j} - f_{u, j - 1}) \prod\limits_{v \in S_1 \cap u \neq v} f_{v, \min(l_v, j - 1)}<br>$$<br>那么现在问题转化为求解 $f_{u, j}$</p><p>考虑暴力，显然有<br>$$<br>\begin{aligned}<br>&amp;f_{u, 0} = 2 \\<br>&amp;f_{u, j} = 1 + \prod\limits_{v \in S_u} f_{v, j - 1}<br>\end{aligned}<br>$$<br>复杂度的症结在于 $j$ 的大小是由 $l_1$ 决定的，但实际上我们观察 $f_{v, j - 1}$ 对 $f_{u, j}$ 的贡献，只有满足 $j \le l_v$ 的才有可能被贡献到，因为 $\forall j \in (l_v, l_1], f_{v, j} = f_{v, l_v}$，看到这公式可以想到什么？长链剖分！</p><p>需要额外处理的是 $f_{v, l_v}$ 对 $f_{u, j}, j \in (l_v + 1, l_u]$，不妨用一个数组 $g$ 来储存它，即 $g_u = f_{u, l_u}$，而显然我们又不能枚举 $l_u$，这一部分的答案一开始是由重儿子继承过来的，但它们都乘上相同的 $g_v$，那么不妨用类似标记永久化的方法来记录这个 $g_v$，标记 $\forall j \in [0, l_u] f_{u, j} = f_{u, j} \times g_v$，很显然对 $j \in [0, l_v + 1]$ 还需要把 $g_v$ 除掉，因为它们不需要这个贡献</p><p>然而转移公式里还有一个 $+ 1$，那么用 $mul_u, add_u$ 分别表示标记永久化的乘和加，还需要记录一个 $imul_u$ 来记录需要除掉的 $g_v$，用 $dp_{u, j}$ 来表示没有乘上过标记的数值，它可以和 $f$ 互相转化<br>$$<br>\begin{aligned}<br>&amp;f_{u, j} = dp_{u, j} \times mul_u + add_u \\<br>&amp;dp_{u, j} = \frac{f_{u, j} - add_u}{mul_u}<br>\end{aligned}<br>$$<br>不妨用函数来表示这么一个变换，$f(u, j) = dp_{u, j} \times mul_u + add_u$ 以及 $df (u, r) = \frac{r - add_u}{mul_u}$，那么 $dp_{u, j}$ 在转移的时候就需要一直保持没累计过标记的数值，即 $dp_{u, j} = df (u, f(u, j) \times f(v, j - 1))$</p><p>但是注意，可能会存在某时刻 $f (v, l_u) \equiv 0 \pmod{998244353}$，也就是 $\forall j \in (l_v, l_u], f (u, j) = 0$，用 $lim_u$ 来记录这种 $l_v + 1$，$z_u$ 来记录在当前情况下，$0$ 所对应的未累计标记过的数值，即 $df (u, 0)$，那么对 $j &lt; lim_u$ 则照常，对 $j \ge lim_u$ 则有 $f(u, j) = z_u \times mul_u + add_u$，其实就是直接赋值 $z_u \rightarrow dp_{u, j}$</p><p>时间复杂度 $O (T \times n)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = <span class="number">1l</span>l * cnt * x % MOD;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = power (<span class="number">2</span>, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">len[root] = <span class="number">0</span>, son[root] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span> || len[v] &gt; len[son[root]])</span><br><span class="line">son[root] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (~ son[root]) len[root] = len[son[root]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[MAXN &lt;&lt; <span class="number">1</span>], *dp[MAXN], *id;</span><br><span class="line"><span class="keyword">int</span> mul[MAXN], imul[MAXN], add[MAXN], g[MAXN], ig[MAXN];</span><br><span class="line"><span class="keyword">int</span> lim[MAXN], zero[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">k = min (k, len[n]);</span><br><span class="line"><span class="keyword">if</span> (lim[n] &lt;= k) <span class="keyword">return</span> (<span class="number">1l</span>l * zero[n] * mul[n] % MOD + add[n]) % MOD;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1l</span>l * dp[n][k] * mul[n] % MOD + add[n]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">df</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * r - add[n] + MOD) % MOD * imul[n] % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (son[u] == - <span class="number">1</span>) &#123;</span><br><span class="line">mul[u] = imul[u] = <span class="number">1</span>;</span><br><span class="line">add[u] = g[u] = <span class="number">2</span>;</span><br><span class="line">lim[u] = N + <span class="number">1</span>, ig[u] = inv2;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">dp[son[u]] = dp[u] + <span class="number">1</span>;</span><br><span class="line">DP (son[u], u);</span><br><span class="line">mul[u] = mul[son[u]], imul[u] = imul[son[u]], add[u] = add[son[u]];</span><br><span class="line">lim[u] = lim[son[u]], zero[u] = zero[son[u]];</span><br><span class="line">dp[u][<span class="number">0</span>] = df (u, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == fa || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">dp[v] = id, id += len[v] + <span class="number">1</span>, DP (v, u);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[v] + <span class="number">1</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (lim[u] == j) dp[u][j] = zero[u], lim[u] ++;</span><br><span class="line">dp[u][j] = df (u, <span class="number">1l</span>l * f (u, j) * f (v, j - <span class="number">1</span>) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! g[v]) &#123; lim[u] = len[v] + <span class="number">2</span>, zero[u] = df (u, <span class="number">0</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">mul[u] = <span class="number">1l</span>l * mul[u] * g[v] % MOD;</span><br><span class="line">imul[u] = <span class="number">1l</span>l * imul[u] * ig[v] % MOD;</span><br><span class="line">add[u] = <span class="number">1l</span>l * add[u] * g[v] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v] + <span class="number">1</span>; j ++)</span><br><span class="line">dp[u][j] = df (u, <span class="number">1l</span>l * f (u, j) * ig[v] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">add[u] = (<span class="number">1l</span>l * add[u] + <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="keyword">if</span> (son[fa] != u) &#123; g[u] = f (u, len[u]); ig[u] = power (g[u], MOD - <span class="number">2</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> gr[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stati</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">gr[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">stati (v, u);</span><br><span class="line">gr[u] = <span class="number">1l</span>l * gr[u] * (gr[v] + <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> subpro[MAXN], subflo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span> (tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> (tmp));</span><br><span class="line">id = tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">mul[i] = imul[i] = add[i] = lim[i] = zero[i] = g[i] = ig[i] = <span class="number">0</span>;</span><br><span class="line">subpro[i] = subflo[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); dp[<span class="number">1</span>] = id, id += len[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[<span class="number">1</span>]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">dp[v] = id, id += len[v] + <span class="number">1</span>; DP (v, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v]; j ++)</span><br><span class="line">subpro[j] = <span class="number">1l</span>l * subpro[j] * f (v, j) % MOD;</span><br><span class="line"><span class="keyword">if</span> (len[v] + <span class="number">1</span> &lt;= len[<span class="number">1</span>]) subflo[len[v] + <span class="number">1</span>] = <span class="number">1l</span>l * subflo[len[v] + <span class="number">1</span>] * f (v, len[v]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len[<span class="number">1</span>]; i ++) subflo[i] = <span class="number">1l</span>l * subflo[i - <span class="number">1</span>] * subflo[i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len[<span class="number">1</span>]; i ++) subpro[i] = <span class="number">1l</span>l * subpro[i] * subflo[i] % MOD;</span><br><span class="line">stati (<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> ans = gr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[<span class="number">1</span>]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v]; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> del = (<span class="number">1l</span>l * f (v, j) - (j &gt; <span class="number">0</span> ? f (v, j - <span class="number">1</span>) : <span class="number">1</span>) + MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) del = <span class="number">1l</span>l * del * subpro[j - <span class="number">1</span>] % MOD * power (f (v, j - <span class="number">1</span>), MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">ans = (<span class="number">1l</span>l * ans - del + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum (); init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Problem-C：网络流"><a href="#Problem-C：网络流" class="headerlink" title="Problem C：网络流"></a>Problem C：网络流</h3>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 树上DP </tag>
            
            <tag> 集训 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>晚了几天写，暴力场</p><p>$\text{score：40 + 40 + 45 = 125   rk：17/30}$</p><h2 id="Problem-A：Tree"><a href="#Problem-A：Tree" class="headerlink" title="Problem A：Tree"></a>Problem A：Tree</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/At2B5jTuCRhF9Yv.png" alt=""></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^8, ~ 1000 \le k \le 10^8$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很容易发现，满足条件等价于要求树中没有任意一条从根出发的路径经过超过 $k - 1$ 个左儿子</p><p>然后就是一个很妙的转换，将树按如下规则变为括号序列：</p><p>子树 $u$ 括号序 = ‘(‘ + ‘$u$ 左子树括号序’ + ‘)’ + ‘$u$ 右子树括号序</p><p>给个题解的图例</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/UzbMDAGx3FZ7nJX.jpg" alt=""></p><p>实际上可以不用考虑叶节点，那么现在将 $n$ 变为 $n - 1$，$k$ 变为 $k - 2$</p><p>那么现在的任务就变为在坐标系中将左括号看作往右上角走，右括号看作往右下角走，从 $(0, 0)$ 最终走到 $(2n, 0)$ 的方案数，并需要满足过程中纵坐标始终在 $[0, k]$ 中的方案数（注意此时 $n, k$ 已变化）</p><p>这就是类似卡特兰数，但是有两条限制，即不能碰到 $y = - 1$ 也不能碰到 $y = k + 1$</p><p>又从 $(x1, y1)$ 走到 $(x_2, y_2)$ 无限制的方案数为 $f(x_1, y_1, x_2, y_2) = \dbinom{|x_1 - x_2|}{\frac{|x_1 - x_2| + |y_1 - y_2|}{2}}$</p><p>考虑容斥，首先有总方案数 $f(0, 0, 2n, 0)$，再取对称一次、两次、三次。。求方案数</p><p>对称一次即对称到 $(0, -2), (0, 2k + 2)$，减去其到 $(2n, 0)$ 的方案数</p><p>对称两次分类讨论，先经过 $y = - 1$ 再经过 $y = k + 1$ 或先经过 $y = k + 1$ 再经过 $y = - 1$，对第一种情况，对称两次后到 $(0, 2k + 4)$，对第二种，到 $(0, - 2k - 4)$，再加上它们到 $(2n, 0)$ 的方案数</p><p>但是会发现这样会多加上对称三次的答案，所以还需减去对称三次中讨论的答案</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/7TaRXmWoSwKB61p.png" alt=""></p><p>举个例子，考虑上图这样一个运动轨迹，那么它一共会被这些所计算到：先下再上、先上再下、下上下、上下上、下上下上</p><p>实际上有应该作贡献的只有最后一个“下上下上”而已，所以是要容斥的</p><p>可以知道没两次对称就可以使纵坐标绝对值增加 $2k + 4$，当纵坐标绝对值超过 $2n$ 时，显然贡献为 $0$，此时就可以停止，那么计算总次数大约为 $\frac{4n}{k}$</p><p>时间复杂度 $O (\frac{n}k \log_p n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = MOD + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lucas</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MOD &amp;&amp; m &lt;= MOD) <span class="keyword">return</span> C (n, m);</span><br><span class="line"><span class="keyword">return</span> C (n % MOD, m % MOD) * lucas (n / MOD, m / MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sym</span> <span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p ? - y - <span class="number">2</span> : - y + <span class="number">2</span> * k + <span class="number">2</span>; &#125; <span class="comment">// y = - 1 &amp; y = k + 1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">path</span> <span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> lucas (<span class="number">2</span> * n, n + y / <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">n = N - <span class="number">1</span>, k = K - <span class="number">2</span>;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MOD; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[MOD - <span class="number">1</span>] = power (fact[MOD - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MOD - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i --) invfact[i] = invfact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">2</span> * k + <span class="number">2</span>, down = - <span class="number">2</span>, p = <span class="number">1</span>;</span><br><span class="line">LL ans = lucas (<span class="number">2</span> * n, n);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span> (up) &gt; <span class="number">2</span> * n &amp;&amp; <span class="built_in">abs</span> (down) &gt; <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> t = p == <span class="number">1</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">ans = (ans + t * path (up) % MOD + MOD) % MOD;</span><br><span class="line">ans = (ans + t * path (down) % MOD + MOD) % MOD;</span><br><span class="line">up = sym (up, p), down = sym (down, p ^ <span class="number">1</span>);</span><br><span class="line">p ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：文本编辑器"><a href="#Problem-B：文本编辑器" class="headerlink" title="Problem B：文本编辑器"></a>Problem B：文本编辑器</h2><h2 id="Problem-C：第k深-kth"><a href="#Problem-C：第k深-kth" class="headerlink" title="Problem C：第k深(kth)"></a>Problem C：第k深(kth)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个 $n$ 个点的有根树，$1$ 为根，带边权，有 $m$ 次操作</p><ul><li>操作 $1$：求 $x$ 的子树中第 $k$ 小的深度的值，如果子树中没有 $k$ 个点则输出 $- 1$</li><li>操作 $2$：将 $x$ 与 $x$ 父亲的边权加上 $k$</li></ul><p>保证每次操作 $2$ 的 $k$ 以及原树的边权小于等于一个数 $len$<br>如果操作 $2$ 中 $x$ 为 $1$，那么视为将 $x$ 的基础深度加上了 $k$</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n, m \le 10^5, ~ 1 \le len \le 10, ~ k \in N^+$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://www.luogu.com.cn/problem/P3712" target="_blank" rel="noopener">少女与战车</a></p><p>$\text{lxl}$ 分块题。。</p><p>首先搞出每个点的 $DFS$ 序，那么每次修改就是区间加</p><p>现在考虑如何分块，据说这种分块方式可能叫双关键字分块？</p><p>对每一块，保证</p><ul><li>每一块最大（小）值 $max(min)$，块左右端点 $l, r$，满足，$max - min \le 2\sqrt{10m}$ 且 $r - l + 1 \le \sqrt n$</li></ul><p>那么这样就可以保证块的分割点个数不超过 $\frac{10m}{\sqrt{10m}} + \frac{n}{\sqrt n}$</p><p>查询二分，然后在每个块内存块每个元素比块中最小值大多少，并记录它们的个数，那么每次 $check$ 的时候就可以 $O (1)$ 查询块内比 $mid$ 小的点的个数</p><p>然后每修改 $1000$ 重新分块，修改 $1000$ 次后块内最大最小值差不会新增超过 $20000$，这也是数组能存下的极限</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXB = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN]= &#123;<span class="number">0</span>&#125;, ord = <span class="number">0</span>;</span><br><span class="line">LL d[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, LL dist)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line">dfn[root] = ++ ord; d[ord] = dist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line">DFS (v, dist + w);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="keyword">int</span> bel[MAXN]= &#123;<span class="number">0</span>&#125;, bl[MAXB]= &#123;<span class="number">0</span>&#125;, br[MAXB]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">LL mini[MAXB]= &#123;<span class="number">0</span>&#125;, maxi[MAXB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXB][MAXV]= &#123;<span class="number">0</span>&#125;, lazy[MAXB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">mini[i] = LINF, maxi[i] = - LINF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bl[i]; j &lt;= br[i]; j ++) &#123;</span><br><span class="line">d[j] += lazy[i];</span><br><span class="line">mini[i] = min (mini[i], d[j]);</span><br><span class="line">maxi[i] = max (maxi[i], d[j]);</span><br><span class="line">&#125;</span><br><span class="line">lazy[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxi[i] - mini[i]; j ++) subsum[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bl[i]; j &lt;= br[i]; j ++) subsum[i][d[j] - mini[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxi[i] - mini[i]; j ++) subsum[i][j] += subsum[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! lazy[p]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[p]; i &lt;= br[p]; i ++) d[i] += lazy[p];</span><br><span class="line">lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) pushdown (i);</span><br><span class="line">LL mi = LINF, ma = - LINF; m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">mi = min (mi, d[i]), ma = max (ma, d[i]);</span><br><span class="line"><span class="keyword">if</span> (ma - mi &gt; V || i - br[m - <span class="number">1</span>] &gt; lim) &#123;</span><br><span class="line">bl[m] = br[m - <span class="number">1</span>] + <span class="number">1</span>, br[m] = i - <span class="number">1</span>;</span><br><span class="line">mi = ma = d[i]; m ++;</span><br><span class="line">&#125;</span><br><span class="line">bel[i] = m;</span><br><span class="line">&#125;</span><br><span class="line">bl[m] = br[m - <span class="number">1</span>] + <span class="number">1</span>, br[m] = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) maintain (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bel[l] + <span class="number">1</span> &gt;= bel[r]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) d[i] += x;</span><br><span class="line">maintain (bel[l]); maintain (bel[r]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= br[bel[l]]; i ++) d[i] += x;</span><br><span class="line">maintain (bel[l]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l] + <span class="number">1</span>; i &lt;= bel[r] - <span class="number">1</span>; i ++) &#123; lazy[i] += x; mini[i] += x, maxi[i] += x; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[bel[r]]; i &lt;= r; i ++) d[i] += x;</span><br><span class="line">maintain (bel[r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, LL mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bel[l] + <span class="number">1</span> &gt;= bel[r]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= br[bel[l]]; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l] + <span class="number">1</span>; i &lt;= bel[r] - <span class="number">1</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (mid - mini[i] &gt;= <span class="number">0</span>)</span><br><span class="line">cnt += subsum[i][min (maxi[i] - mini[i], mid - mini[i])];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[bel[r]]; i &lt;= r; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">pushdown (bel[l]); pushdown (bel[r]);</span><br><span class="line">LL left = LINF, right = - LINF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l]; i &lt;= bel[r]; i ++) &#123;</span><br><span class="line">left = min (left, mini[i]);</span><br><span class="line">right = max (right, maxi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> left;</span><br><span class="line">LL ans = left;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">LL mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (l, r, k, mid)) &#123; ans = mid; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), len = getnum ();</span><br><span class="line">lim = <span class="built_in">sqrt</span> (N); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa = getnum (), w = getnum ();</span><br><span class="line">Insert (fa, i, w);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> modi = <span class="number">0</span>;</span><br><span class="line">build ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), x = getnum (), k = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[x] &lt; k) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, query (dfn[x], dfn[x] + subsize[x] - <span class="number">1</span>, k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">modi ++;</span><br><span class="line"><span class="keyword">if</span> (! (modi % <span class="number">1000</span>)) build ();</span><br><span class="line">modify (dfn[x], dfn[x] + subsize[x] - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十二）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>中下</p><p>$\text{score：24 + 40 + 0 = 64   rk：23/34}$</p><h2 id="Problem-A：Mythological-V"><a href="#Problem-A：Mythological-V" class="headerlink" title="Problem A：Mythological V"></a>Problem A：Mythological V</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小S打算送给小M一棵 $n$ 个点的圣诞树，点从 $1$ 到 $n$ 标号，他打算给树上挂上 $m$ 个礼物，每个礼物在树上的某个点上，礼物可以重叠。</p><p> 小M给了小S $q$ 个限制，其中第 $i$ 个形如“第 $a_i$ 个礼物和第 $b_i$ 个礼物在树上的最短路径经过了点 $c_i$”。</p><p> 小S想要构造出符合小M条件的挂礼物方案。可怜的小S当然不会啦，所以他向你求助。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n, m \le 250, ~ q \le 5 \times 10^4$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>好久没写过 $2-SAT$ 了</p><p>虽然我的暴力虽然 $\text{WA}$ 了但竟然没有 $\text{T}$？说不定改对了能过呢</p><p>考虑两个礼物 $a, b$ 放置位置经过 $c$ 代表着什么，说明 $a, b$ 放置的位置在以 $c$ 为根的树上位于不同的 $c$ 儿子的子树上</p><p>那么现在以 $1$ 为根，设 $g_{i, j, 0}$ 表示第 $j$ 个礼物不在 $i$ 点的子树上，而 $g_{i, j, 1}$ 表示在</p><p>对每个题目所给限制，连边有 $g_{c, a, 0} \rightarrow g_{c, b, 1}$（表示 $a$ 在 $c$ 祖先不包括 $c$ 的子树中，那么 $b$ 一定在 $c$ 子树中）、$g_{i, a, 1} \rightarrow g_{i, b, 0}$、$g_{i, b, 1} \rightarrow g_{i, a, 0}$（其中 $i$ 表示 $c$ 的儿子结点）</p><p>当然还有最基本的限制，对某个节点 $u$ 以及某个礼物 $i$，$g_{1, i, 0} \rightarrow g_{1, i, 1}$（强制要求 $i$ 在 $1$ 的子树中）、$g_{u, i, 1} \rightarrow g_{fa_u, i, 1}$、$g_{u, i, 0} \rightarrow g_{son_u, i, 0}$、$g_{u, i, 1} \rightarrow g_{v, i, 0}$（其中 $u, v$ 的两个子树无交集）</p><p>时间复杂度 $O (N + M) = O (n^2m + qn^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = MAXN * MAXN * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">3e07</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXL];</span><br><span class="line"><span class="keyword">int</span> Head[MAXK]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;, depth[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">father[root] = fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[root].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[root][i];</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isanc</span> <span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> x == y ? <span class="literal">true</span> : isanc (y, father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[MAXK]= &#123;<span class="number">0</span>&#125;, low[MAXK]= &#123;<span class="number">0</span>&#125;, ord = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXK]= &#123;<span class="number">0</span>&#125;, top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> insta[MAXK]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> bel[MAXK]= &#123;<span class="number">0</span>&#125;, co = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ ord;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = u; insta[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (! dfn[v]) &#123;</span><br><span class="line">Tarjan (v);</span><br><span class="line">low[u] = min (low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (insta[v]) low[u] = min (low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">co ++; <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">x = <span class="built_in">stack</span>[top --];</span><br><span class="line">insta[x] = <span class="literal">false</span>, bel[x] = co;</span><br><span class="line">&#125; <span class="keyword">while</span> (x != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">G[u].push_back(v); G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">depth[<span class="number">1</span>] = <span class="number">1</span>, DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">g[i][j][<span class="number">1</span>] = ++ m, g[i][j][<span class="number">0</span>] = ++ m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = getnum (), b = getnum (), u = getnum ();</span><br><span class="line"><span class="keyword">if</span> (father[u]) &#123; Insert (g[u][a][<span class="number">0</span>], g[u][b][<span class="number">1</span>]); Insert (g[u][b][<span class="number">0</span>], g[u][a][<span class="number">1</span>]); &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) G[u].size(); j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][j];</span><br><span class="line"><span class="keyword">if</span> (v != father[u]) &#123;</span><br><span class="line">Insert (g[v][a][<span class="number">1</span>], g[v][b][<span class="number">0</span>]);</span><br><span class="line">Insert (g[v][b][<span class="number">1</span>], g[v][a][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (father[i]) Insert (g[i][j][<span class="number">1</span>], g[father[i]][j][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="keyword">int</span>) G[i].size(); k ++)</span><br><span class="line"><span class="keyword">if</span> (G[i][k] != father[i])</span><br><span class="line">Insert (g[i][j][<span class="number">0</span>], g[G[i][k]][j][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) Insert (g[<span class="number">1</span>][i][<span class="number">0</span>], g[<span class="number">1</span>][i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (! isanc (i, j) &amp;&amp; ! isanc (j, i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= M; k ++)</span><br><span class="line">Insert (g[i][k][<span class="number">1</span>], g[j][k][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line"><span class="keyword">if</span> (! dfn[i])</span><br><span class="line">Tarjan (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (bel[g[i][j][<span class="number">1</span>]] &lt; bel[g[i][j][<span class="number">0</span>]])</span><br><span class="line">ans[j] = depth[ans[j]] &lt; depth[i] ? i : ans[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">&#125; <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：Mythological-IV"><a href="#Problem-B：Mythological-IV" class="headerlink" title="Problem B：Mythological IV"></a>Problem B：Mythological IV</h2><h2 id="Problem-C：Mythological-VII"><a href="#Problem-C：Mythological-VII" class="headerlink" title="Problem C：Mythological VII"></a>Problem C：Mythological VII</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>数轴上有一行 $n$ 个点，每个点有权值。小M和小S在上面玩游戏。</p><p>小M和小S一开始都在第 $k$ 号点上，小M只能向左移动，小S只能向右移动。</p><p>令 $p_x$ 表示当前时刻小M的位置，$p_y$ 表示当前时刻小S的位置，要求任意时刻都满足 $(p_x, p_y]$ 这个区间的所有数和都 $\le 0$。</p><p>现在，小M想要知道 $p_x, p_y$ 能否同时等于 $1, n$。可怜的小M当然不会啦，所以她向你求助。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^5, ~ T \le 20, ~ a_i \in [- 10^{13}, 10^{13}]$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题目是要满足前缀和 $sum_l \ge sum_r$</p><p>与 <a href="https://colythme.github.io/2020/07/26/「JOISC%202017%20Day%201」烟花棒/">「JOISC 2017 Day 1」烟花棒</a> 贪心部分是相同的</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e09</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, K;</span><br><span class="line">LL a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] &lt; a[N]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> l = K, r = K, ll = K, lr = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[ll])</span><br><span class="line">ll = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[lr])</span><br><span class="line">lr = i;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &gt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl - <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &lt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr + <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">1</span>, r = N;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &lt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl + <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &gt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr - <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">solve () ? <span class="built_in">puts</span> (<span class="string">"Yes"</span>) : <span class="built_in">puts</span> (<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十三）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>没交</p><p>$\text{score：NULL            rk：NULL}$</p><h2 id="Problem-A：区间第k小"><a href="#Problem-A：区间第k小" class="headerlink" title="Problem A：区间第k小"></a>Problem A：区间第k小</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/znS2C4hFuYj79VT.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/c8je9HNIn4CoEyW.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑离线，整体二分，二分答案 $mid$，处理所有 $\le mid$ 的数，那么此时问题就转化为在区间出现次数不超过 $w$ 的数有多少个</p><p>不妨关注每个数对询问区间 $[L, R]$ 的贡献，对某个数 $a$，若它是从左往右后 $w$ 个出现为 $a$ 的数，则它的贡献为 $1$，若为倒数第 $w + 1$ 个则贡献为 $- w$，剩下的贡献都为 $0$，那么我们就可以开一个队列，首先总大小（即不删去超过 $w$ 的）算出来，此时计算需要删去的，队列大小未到 $w$ 时没有需要删的，若大于 $w$ 时每次就让队首点贡献减去 $w + 1$，当然之前多减的还要加回来</p><p>那么现在就可以考虑从离线转成在线，在整体二分的过程中每一层（即每一次二分的 $[l, r]$）都会建一些可持久化线段树，而它又最多会修改 $O (n \log n)$ 次，开 $O (n \log^2 n)$ 个节点，所以把每一层的可持久化线段树都存下来，在线二分时即可直接查找，总时间复杂度 $O (n \log^2 n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXL * MAXL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, W, Q, type;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[MAXM]= &#123;<span class="number">0</span>&#125;, rson[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXM]= &#123;<span class="number">0</span>&#125;, nd = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span>&amp; p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">lson[p = ++ nd] = lson[pre], rson[p] = rson[pre];</span><br><span class="line">subsum[p] = subsum[pre] + x;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson[pre], lson[p], left, mid, posi, x);</span><br><span class="line"><span class="keyword">else</span> modify (rson[pre], rson[p], mid + <span class="number">1</span>, right, posi, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123; <span class="comment">// &gt;= posi的和</span></span><br><span class="line"><span class="keyword">if</span> (right &lt; posi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= left) <span class="keyword">return</span> subsum[p];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> subsum[rson[p]] + query (lson[p], left, mid, posi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query (rson[p], mid + <span class="number">1</span>, right, posi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rt[MAXN &lt;&lt; <span class="number">2</span>], posi[MAXL + <span class="number">10</span>], use[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que[MAXN];</span><br><span class="line"><span class="keyword">int</span> ldel[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>, n = posi[d].size();</span><br><span class="line">use[p].resize(n); posi[d + <span class="number">1</span>].clear(), posi[d + <span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d][i];</span><br><span class="line"><span class="keyword">if</span> (a[t] &lt;= mid) &#123;</span><br><span class="line">posi[d + <span class="number">1</span>].push_back(t);</span><br><span class="line">use[p][i] = use[p][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">ldel[a[t]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> use[p][i] = use[p][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lim = posi[d + <span class="number">1</span>].size();</span><br><span class="line">rt[p].resize(lim);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d + <span class="number">1</span>][i], x = a[t];</span><br><span class="line">que[x].push(i);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) que[x].size() &gt; W) &#123;</span><br><span class="line">modify (rt[p][i - <span class="number">1</span>], rt[p][i], <span class="number">1</span>, lim - <span class="number">1</span>, que[x].front(), - W - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ldel[x]) modify (rt[p][i], rt[p][i], <span class="number">1</span>, lim - <span class="number">1</span>, ldel[x], W);</span><br><span class="line">ldel[x] = que[x].front(); que[x].pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> rt[p][i] = rt[p][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d + <span class="number">1</span>][i], x = a[t];</span><br><span class="line"><span class="keyword">while</span> (! que[x].empty()) que[x].pop();</span><br><span class="line">&#125;</span><br><span class="line">build (left, mid, lp, d + <span class="number">1</span>);</span><br><span class="line">posi[d + <span class="number">1</span>].clear(), posi[d + <span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d][i];</span><br><span class="line"><span class="keyword">if</span> (a[t] &gt; mid) posi[d + <span class="number">1</span>].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">build (mid + <span class="number">1</span>, right, rp, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = use[p][L], r = use[p][R], n = rt[p].size();</span><br><span class="line"><span class="keyword">int</span> sum = r - l + query (rt[p][r], <span class="number">1</span>, n - <span class="number">1</span>, l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= k) <span class="keyword">return</span> solve (lp, left, mid, l, r, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> solve (rp, mid + <span class="number">1</span>, right, L - l, R - r, k - sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), W = getnum (), Q = getnum (), type = getnum ();</span><br><span class="line">posi[<span class="number">1</span>].resize(N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123; a[i] = getnum (); posi[<span class="number">1</span>][i] = i; &#125;</span><br><span class="line">build (<span class="number">0</span>, N, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> xxo = type * ans;</span><br><span class="line"><span class="keyword">int</span> l = getnum () ^ xxo, r = getnum () ^ xxo, k = getnum () ^ xxo;</span><br><span class="line">ans = solve (<span class="number">1</span>, <span class="number">0</span>, N, l - <span class="number">1</span>, r, k);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：求和"><a href="#Problem-B：求和" class="headerlink" title="Problem B：求和"></a>Problem B：求和</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/eBd1iKnvg7Gf92A.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/YW1rji2cIUylMm5.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先对式子进行变换<br>$$<br>\begin{aligned}<br>ans &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n\sum\limits_{d = 1}^k f_d(gcd(i, j)) \\<br>&amp;= \sum\limits_{x = 1}^n\sum\limits_{d = 1}^k f_d(x)\sum\limits_{i = 1}^{\lfloor\frac{n}{x}\rfloor}\sum\limits_{j = 1}^{\lfloor\frac{n}{x}\rfloor}[(i, j) = 1] \\<br>&amp;= \sum\limits_{x = 1}^n\sum\limits_{d = 1}^k f_d(x)\left((2\sum\limits_{i = 1}^{\lfloor\frac{n}{x}\rfloor}\varphi(i)) - 1\right)<br>\end{aligned}<br>$$<br>那么这时对 $n$ 整除分块到，$\sum\limits_{i = 1}^n \varphi(i)$ 就可以直接杜教筛求出，设此时分块到 $[l, r]$，现在考虑求解 $\sum\limits_{x = l}^r\sum\limits_{d = 1}^k f_d(x)$，当然前缀和是肯定的</p><p>令 $F_d(x) = \sum\limits_{i = 1}^n f_d(i)$，设质因数分解 $n = \prod\limits_i p_i^{c_i}$，令 $\lambda(x) = \prod\limits_i (- 1)^{c_i}$，$F_d(x)$ 则可以通过容斥求出<br>$$<br>\begin{aligned}<br>F_d(x) &amp;= \sum\limits_{i = 1}^x \mu(i)\sum\limits_{j = 1}^{\lfloor\frac{x}{i^{d + 1}}\rfloor}\lambda(i^{d + 1}j) \\<br>&amp;= \sum\limits_{i = 1}^x \lambda^{d + 1}(i)\mu(i)\sum\limits_{j = 1}^{\lfloor\frac{x}{i^{d + 1}}\rfloor}\lambda(j)<br>\end{aligned}<br>$$<br>第一步实际上就是类似求 $n$ 以内无平方因子数的方法，$i = 1$ 时为总方案，后面容斥删去不合法</p><p>而第二步是因为 $\lambda(x)$ 是一个完全积性函数</p><p>现在问题转化为求 $\sum\limits_{i = 1}^n \lambda(i)$，可以发现一个性质，$\sum\limits_{d |n} \lambda(i) = [n为完全平方数]$</p><p>下面给出证明</p><ul><li>设 $n = \prod\limits_i p_i^{c_i}$，考虑两个数 $p_1^2x, p_1^3x$，满足 $p_1^2x, p_1^3x | n$，若 $p_1^2x$ 的贡献为 $1$，那么 $p_1^3x$ 的贡献则一定为 $- 1$，那么以此类推，也就是 $0, 1$ 次、$2, 3$ 次、$4, 5$ 次…分别两两配对，若 $c_i$ 为奇数，则最后贡献总和一定为 $0$，若为偶数，最后则一定为 $1$</li></ul><p>这样的话就是 $\sqrt n = \lambda * 1$，就可以杜教筛了</p><p>那么对 $F_d(x)$，类似杜教筛预处理 $x$ 比较小的（注意用原式，即 $F_d(x) = \sum\limits_{i = 1}^n f_d(i)$ 来预处理），然后大的就直接暴力枚举，最多 $O (\sqrt n)$，那么这样总时间复杂度是 $O (n^{\frac23})$ 的</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e06</span> + <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N; <span class="keyword">int</span> K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN / <span class="number">10</span>], pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint phi[MAXN]= &#123;<span class="number">0</span>&#125;, sphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint lamda[MAXN]= &#123;<span class="number">0</span>&#125;, suml[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint sumf[MAXN]= &#123;<span class="number">0</span>&#125;; <span class="comment">// sumf(x): Σ(d=1~k)f[d](x)</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e06</span> + <span class="number">5e05</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = lamda[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">sumf[<span class="number">1</span>] = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! visit[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">phi[i] = i - <span class="number">1</span>, lamda[i] = - <span class="number">1</span>;</span><br><span class="line">a[i] = b[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">lamda[i * prime[j]] = - lamda[i];</span><br><span class="line">a[i * prime[j]] = a[i] + <span class="number">1</span>;</span><br><span class="line">b[i * prime[j]] = max (a[i * prime[j]], b[i]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">lamda[i * prime[j]] = - lamda[i];</span><br><span class="line">a[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">b[i * prime[j]] = b[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">suml[i] = suml[i - <span class="number">1</span>] + lamda[i];</span><br><span class="line">sphi[i] = sphi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">sumf[i] = sumf[i - <span class="number">1</span>]  + lamda[i] * max (<span class="number">0</span>, K - max (b[i], <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vp[MAXM]= &#123;<span class="literal">false</span>&#125;, vl[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint sp[MAXM], sl[MAXM];</span><br><span class="line"><span class="function">uint <span class="title">phi_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (vp[N / n]) <span class="keyword">return</span> sp[N / n];</span><br><span class="line">uint ret = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ret -= <span class="number">1u</span> * (r - l + <span class="number">1</span>) * phi_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vp[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sp[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint <span class="title">lamda_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> suml[n];</span><br><span class="line"><span class="keyword">if</span> (vl[N / n]) <span class="keyword">return</span> sl[N / n];</span><br><span class="line">uint ret = <span class="built_in">sqrt</span> (n);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ret -= <span class="number">1u</span> * (r - l + <span class="number">1</span>) * lamda_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vl[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sl[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL mpow[MAXL][<span class="number">42</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lim = <span class="built_in">sqrt</span> (N) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i ++) &#123;</span><br><span class="line">mpow[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K + <span class="number">1</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mpow[i][j - <span class="number">1</span>] &gt; N) <span class="keyword">break</span>;</span><br><span class="line">mpow[i][j] = mpow[i][j - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vf[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint sf[MAXM];</span><br><span class="line"><span class="function">uint <span class="title">work</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumf[n];</span><br><span class="line"><span class="keyword">if</span> (vf[N / n]) <span class="keyword">return</span> sf[N / n];</span><br><span class="line">uint ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= K; d += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; mpow[i][d + <span class="number">1</span>] &amp;&amp; mpow[i][d + <span class="number">1</span>] &lt;= n; i ++)</span><br><span class="line">ret += mu[i] * lamda_sieve (n / mpow[i][d + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt;= K; d += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; mpow[i][d + <span class="number">1</span>] &amp;&amp; mpow[i][d + <span class="number">1</span>] &lt;= n; i ++)</span><br><span class="line">ret += lamda[i] * mu[i] * lamda_sieve (n / mpow[i][d + <span class="number">1</span>]);</span><br><span class="line">vf[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sf[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">init (); sieve ();</span><br><span class="line">uint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = N / (N / l);</span><br><span class="line">ans += (<span class="number">2u</span> * phi_sieve (N / l) - <span class="number">1</span>) * (work (r) - work (l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C-树"><a href="#Problem-C-树" class="headerlink" title="Problem C: 树"></a>Problem C: 树</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 整体二分 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树求树的直径</title>
      <link href="/2020/08/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2020/08/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>线段树求直径可以求任意子树（包括连子树都不算的分散节点集合）的直径，适用范围广。</p><p>线段树的每个节点所对应的区间$[L, R]$，指代了$Dfn$在$[L, R]$内节点，其中线段树上每个节点存储了$diam$（当前区间直径）及$lp,  rp$（当前直径对应的左右端点），每次$Merge$操作分为全左区间、全右区间和横跨两个区间作讨论，对于第三种情况，选择两侧原直径端点求$Dist$取最值即可，正确性显然，查询直接通过$Dfn$查询即可。</p><p>当然可能有一些区间内的点不连通，先当作它们连通即可。</p><p>对于删除某些子树，相当于把整棵树分为$n$部分，查询每个部分，全部$Merge$起来即可。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/T55282" target="_blank" rel="noopener">Snow的追寻</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line">  <span class="number">6</span> </span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"> <span class="number">13</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"> <span class="number">16</span>     <span class="keyword">int</span> to;</span><br><span class="line"> <span class="number">17</span> </span><br><span class="line"> <span class="number">18</span>     <span class="keyword">int</span> next;</span><br><span class="line"> <span class="number">19</span> &#125; ;</span><br><span class="line"> <span class="number">20</span> </span><br><span class="line"> <span class="number">21</span> LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> <span class="number">22</span> <span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="number">23</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> <span class="number">24</span> </span><br><span class="line"> <span class="number">25</span> <span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"> <span class="number">26</span>     Link[++ size].to = v;</span><br><span class="line"> <span class="number">27</span>     Link[size].next = Head[u];</span><br><span class="line"> <span class="number">28</span> </span><br><span class="line"> <span class="number">29</span>     Head[u] = size;</span><br><span class="line"> <span class="number">30</span> &#125;</span><br><span class="line"> <span class="number">31</span> </span><br><span class="line"> <span class="number">32</span> <span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"> <span class="number">33</span> </span><br><span class="line"> <span class="number">34</span> <span class="keyword">int</span> Deep[MAXN];</span><br><span class="line"> <span class="number">35</span> <span class="keyword">int</span> Size[MAXN];</span><br><span class="line"> <span class="number">36</span> <span class="keyword">int</span> Val[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> <span class="number">37</span> <span class="keyword">int</span> Dfn[MAXN], DDfn[MAXN];</span><br><span class="line"> <span class="number">38</span> <span class="keyword">int</span> Rank[MAXN];</span><br><span class="line"> <span class="number">39</span> <span class="keyword">int</span> dfsord = <span class="number">0</span>, dod2 = <span class="number">0</span>;</span><br><span class="line"> <span class="number">40</span> </span><br><span class="line"> <span class="number">41</span> <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"> <span class="number">42</span>     Size[root] = <span class="number">1</span>;</span><br><span class="line"> <span class="number">43</span>     Dfn[root] = ++ dfsord;</span><br><span class="line"> <span class="number">44</span>     Rank[dfsord] = root;</span><br><span class="line"> <span class="number">45</span>     DDfn[root] = ++ dod2;</span><br><span class="line"> <span class="number">46</span>     Val[dod2] = Deep[root];</span><br><span class="line"> <span class="number">47</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"> <span class="number">48</span>         <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"> <span class="number">49</span>         <span class="keyword">if</span> (v == father)</span><br><span class="line"> <span class="number">50</span>             <span class="keyword">continue</span>;</span><br><span class="line"> <span class="number">51</span> </span><br><span class="line"> <span class="number">52</span>         Deep[v] = Deep[root] + <span class="number">1</span>;</span><br><span class="line"> <span class="number">53</span>         DFS (v, root);</span><br><span class="line"> <span class="number">54</span>         Size[root] += Size[v];</span><br><span class="line"> <span class="number">55</span>         Val[++ dod2] = Deep[root];</span><br><span class="line"> <span class="number">56</span>     &#125;</span><br><span class="line"> <span class="number">57</span> &#125;</span><br><span class="line"> <span class="number">58</span> </span><br><span class="line"> <span class="number">59</span> <span class="keyword">int</span> ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">30</span>];</span><br><span class="line"> <span class="number">60</span> </span><br><span class="line"> <span class="number">61</span> <span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">62</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dod2; i ++)</span><br><span class="line"> <span class="number">63</span>         ST[i][<span class="number">0</span>] = Val[i];</span><br><span class="line"> <span class="number">64</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line"> <span class="number">65</span>         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dod2; i ++)</span><br><span class="line"> <span class="number">66</span>             <span class="keyword">if</span> (i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) &lt;= dod2)</span><br><span class="line"> <span class="number">67</span>                 ST[i][j] = min (ST[i][j - <span class="number">1</span>], ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"> <span class="number">68</span> &#125;</span><br><span class="line"> <span class="number">69</span> </span><br><span class="line"> <span class="number">70</span> <span class="function"><span class="keyword">int</span> <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"> <span class="number">71</span>     <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line"> <span class="number">72</span>     <span class="keyword">return</span> min (ST[L][k], ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line"> <span class="number">73</span> &#125;</span><br><span class="line"> <span class="number">74</span> </span><br><span class="line"> <span class="number">75</span> <span class="function"><span class="keyword">int</span> <span class="title">Dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="number">76</span>     <span class="keyword">if</span> (DDfn[x] &gt; DDfn[y])</span><br><span class="line"> <span class="number">77</span>         swap (x, y);</span><br><span class="line"> <span class="number">78</span> </span><br><span class="line"> <span class="number">79</span>     <span class="keyword">int</span> deeplca = Query (DDfn[x], DDfn[y]);</span><br><span class="line"> <span class="number">80</span>     <span class="keyword">return</span> Deep[x] + Deep[y] - <span class="number">2</span> * deeplca;</span><br><span class="line"> <span class="number">81</span> &#125;</span><br><span class="line"> <span class="number">82</span> </span><br><span class="line"> <span class="number">83</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"> <span class="number">84</span>     <span class="keyword">int</span> diam;</span><br><span class="line"> <span class="number">85</span>     <span class="keyword">int</span> lp, rp;</span><br><span class="line"> <span class="number">86</span> </span><br><span class="line"> <span class="number">87</span>     Node () &#123;</span><br><span class="line"> <span class="number">88</span>         diam = <span class="number">0</span>;</span><br><span class="line"> <span class="number">89</span>         lp = rp = <span class="number">0</span>;</span><br><span class="line"> <span class="number">90</span>     &#125;</span><br><span class="line"> <span class="number">91</span> </span><br><span class="line"> <span class="number">92</span>     Node (<span class="keyword">int</span> fdiam, <span class="keyword">int</span> flp, <span class="keyword">int</span> frp) :</span><br><span class="line"> <span class="number">93</span>         diam (fdiam), lp (flp), rp (frp) &#123;&#125;</span><br><span class="line"> <span class="number">94</span> &#125; ;</span><br><span class="line"> <span class="number">95</span> </span><br><span class="line"> <span class="number">96</span> Node Tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"> <span class="number">97</span> </span><br><span class="line"> <span class="number">98</span> </span><br><span class="line"> <span class="number">99</span> <span class="function">Node <span class="title">Merge</span> <span class="params">(Node s1, Node s2)</span> </span>&#123;</span><br><span class="line"><span class="number">100</span>     <span class="keyword">if</span> (s1.diam == - <span class="number">1</span>)</span><br><span class="line"><span class="number">101</span>         <span class="keyword">return</span> s2;</span><br><span class="line"><span class="number">102</span>     Node news = s1.diam &gt;= s2.diam ? s1 : s2; <span class="comment">// 以下讨论</span></span><br><span class="line"><span class="number">103</span>     <span class="keyword">if</span> (Dist (s1.lp, s2.lp) &gt; news.diam)</span><br><span class="line"><span class="number">104</span>         news = Node (Dist (s1.lp, s2.lp), s1.lp, s2.lp);</span><br><span class="line"><span class="number">105</span>     <span class="keyword">if</span> (Dist (s1.lp, s2.rp) &gt; news.diam)</span><br><span class="line"><span class="number">106</span>         news = Node (Dist (s1.lp, s2.rp), s1.lp, s2.rp);</span><br><span class="line"><span class="number">107</span>     <span class="keyword">if</span> (Dist (s1.rp, s2.lp) &gt; news.diam)</span><br><span class="line"><span class="number">108</span>         news = Node (Dist (s1.rp, s2.lp), s1.rp, s2.lp);</span><br><span class="line"><span class="number">109</span>     <span class="keyword">if</span> (Dist (s1.rp, s2.rp) &gt; news.diam)</span><br><span class="line"><span class="number">110</span>         news = Node (Dist (s1.rp, s2.rp), s1.rp, s2.rp);</span><br><span class="line"><span class="number">111</span> </span><br><span class="line"><span class="number">112</span>     <span class="keyword">return</span> news;</span><br><span class="line"><span class="number">113</span> &#125;</span><br><span class="line"><span class="number">114</span> </span><br><span class="line"><span class="number">115</span> <span class="function"><span class="keyword">void</span> <span class="title">Build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="number">116</span>     Tree[root] = Node ();</span><br><span class="line"><span class="number">117</span> </span><br><span class="line"><span class="number">118</span>     <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="number">119</span>         Tree[root].diam = <span class="number">0</span>;</span><br><span class="line"><span class="number">120</span>         Tree[root].lp = Tree[root].rp = Rank[left];</span><br><span class="line"><span class="number">121</span>         <span class="keyword">return</span> ;</span><br><span class="line"><span class="number">122</span>     &#125;</span><br><span class="line"><span class="number">123</span> </span><br><span class="line"><span class="number">124</span>     <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">125</span>     Build (lson, left, mid);</span><br><span class="line"><span class="number">126</span>     Build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="number">127</span> </span><br><span class="line"><span class="number">128</span>     Tree[root] = Merge (Tree[lson], Tree[rson]);</span><br><span class="line"><span class="number">129</span> &#125;</span><br><span class="line"><span class="number">130</span> </span><br><span class="line"><span class="number">131</span> <span class="function">Node <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="number">132</span>     <span class="keyword">if</span> (L == left &amp;&amp; R == right)</span><br><span class="line"><span class="number">133</span>         <span class="keyword">return</span> Tree[root];</span><br><span class="line"><span class="number">134</span> </span><br><span class="line"><span class="number">135</span>     <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">136</span>     <span class="keyword">if</span> (R &lt;= mid)</span><br><span class="line"><span class="number">137</span>         <span class="keyword">return</span> Query (lson, left, mid, L, R);</span><br><span class="line"><span class="number">138</span>     <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid)</span><br><span class="line"><span class="number">139</span>         <span class="keyword">return</span> Query (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="number">140</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">141</span>         <span class="keyword">return</span> Merge (Query (lson, left, mid, L, mid), Query (rson, mid + <span class="number">1</span>, right, mid + <span class="number">1</span>, R));</span><br><span class="line"><span class="number">142</span> &#125;</span><br><span class="line"><span class="number">143</span> </span><br><span class="line"><span class="number">144</span> <span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="number">145</span> </span><br><span class="line"><span class="number">146</span> <span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">147</span>     <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="number">148</span>     <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="number">149</span> </span><br><span class="line"><span class="number">150</span>     <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line"><span class="number">151</span>         ch = getchar ();</span><br><span class="line"><span class="number">152</span>     <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line"><span class="number">153</span>         num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="number">154</span> </span><br><span class="line"><span class="number">155</span>     <span class="keyword">return</span> num;</span><br><span class="line"><span class="number">156</span> &#125;</span><br><span class="line"><span class="number">157</span> </span><br><span class="line"><span class="number">158</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">159</span>     <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line"><span class="number">160</span> </span><br><span class="line"><span class="number">161</span>     N = getnum (), Q = getnum ();</span><br><span class="line"><span class="number">162</span> </span><br><span class="line"><span class="number">163</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="number">164</span>         <span class="keyword">int</span> u, v;</span><br><span class="line"><span class="number">165</span>         u = getnum (), v = getnum ();</span><br><span class="line"><span class="number">166</span>         Insert (u, v), Insert (v, u);</span><br><span class="line"><span class="number">167</span>     &#125;</span><br><span class="line"><span class="number">168</span> </span><br><span class="line"><span class="number">169</span>     DFS (Root, <span class="number">0</span>);</span><br><span class="line"><span class="number">170</span>     RMQ ();</span><br><span class="line"><span class="number">171</span> </span><br><span class="line"><span class="number">172</span>     Build (Root, <span class="number">1</span>, dfsord);</span><br><span class="line"><span class="number">173</span>     <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line"><span class="number">174</span>         <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="number">175</span>         x = getnum (), y = getnum ();</span><br><span class="line"><span class="number">176</span> </span><br><span class="line"><span class="number">177</span>         Node res = Node (- <span class="number">1</span>, - <span class="number">1</span>, - <span class="number">1</span>);</span><br><span class="line"><span class="number">178</span>         <span class="keyword">if</span> (Dfn[x] &gt; Dfn[y])</span><br><span class="line"><span class="number">179</span>             swap (x, y);</span><br><span class="line"><span class="number">180</span>         <span class="keyword">int</span> sx = Dfn[x], ex = sx + Size[x] - <span class="number">1</span>;</span><br><span class="line"><span class="number">181</span>         <span class="keyword">int</span> sy = Dfn[y], ey = sy + Size[y] - <span class="number">1</span>;</span><br><span class="line"><span class="number">182</span>         <span class="keyword">if</span> (sx &gt; <span class="number">1</span>) <span class="comment">// 第一部分</span></span><br><span class="line"><span class="number">183</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, <span class="number">1</span>, sx - <span class="number">1</span>));</span><br><span class="line"><span class="number">184</span>         <span class="keyword">if</span> (ex + <span class="number">1</span> &lt; sy) <span class="comment">// 第二部分</span></span><br><span class="line"><span class="number">185</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, ex + <span class="number">1</span>, sy - <span class="number">1</span>));</span><br><span class="line"><span class="number">186</span>         <span class="keyword">int</span> fen = max (ex, ey);</span><br><span class="line"><span class="number">187</span>         <span class="keyword">if</span> (fen &lt; dfsord) <span class="comment">// 第三部分</span></span><br><span class="line"><span class="number">188</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, fen + <span class="number">1</span>, dfsord));</span><br><span class="line"><span class="number">189</span>         <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, res.diam == - <span class="number">1</span> ? <span class="number">0</span> : res.diam);</span><br><span class="line"><span class="number">190</span>     &#125;</span><br><span class="line"><span class="number">191</span> </span><br><span class="line"><span class="number">192</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">193</span> &#125;</span><br><span class="line"><span class="number">194</span> </span><br><span class="line"><span class="number">195</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">196 5 2</span></span><br><span class="line"><span class="comment">197 1 3</span></span><br><span class="line"><span class="comment">198 3 2</span></span><br><span class="line"><span class="comment">199 3 4</span></span><br><span class="line"><span class="comment">200 2 5</span></span><br><span class="line"><span class="comment">201 2 4</span></span><br><span class="line"><span class="comment">202 5 4</span></span><br><span class="line"><span class="comment">203 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竞赛图染色</title>
      <link href="/2020/08/04/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E6%9F%93%E8%89%B2/"/>
      <url>/2020/08/04/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>给定一个 $n$ 个点的竞赛图，给该图的每条边染色，颜色数量不能超过 $m$ 个，一个染色合法当且仅当不存在长度为 $2$ 的路径，即对有向图中任意路径 $i \rightarrow j \rightarrow k$ 均有边 $i \rightarrow j$ 和边 $j \rightarrow k$ 颜色不同</p></blockquote><blockquote><p>$2 \le n \le 3000, ~ 2 \le m \le 26$</p></blockquote><p>设该竞赛图点集 $V$</p><p>考虑染每一种颜色意味着什么，相当于选择一个点集 $S \subseteq V$，将所有边 $(u, v)$ 满足 $u \in S \cap v \in \complement_VS$ 染上该颜色，也就是说我们要找到至多 $m$ 个这样的集合来覆盖所有的边</p><p>这样可以给出一个 $m = 2\log n$ 的染色方案，对所有点分治，每次一分为二，给 $S, \complement_V S$ 之间的边按两种方向染上不同的颜色，这样总共需要颜色是 $2\log n$ 的</p><p>但实际上可以用二进制来表示这种是否在每个 $S$ 中的关系，对每个 $S_i$，若当前点 $u$ 得到的二进制位为 $1$，则代表 $u \in S_i$，否则 $u \in \complement_VS_i$，即代表 $i$ 不存在颜色为 $i$ 的外向边，那么点 $i$ 的选择方案可以看作 $\{1, 2, …, m\}$ 的一个子集，设为 $A_i$，我们则要选出 $n$ 个集合满足 $\forall i, j$，有 $\exists x, y, ~ x \in A_i, y \in A_j$ 满足 $x \notin A_j, y \notin A_i$</p><p>那么一个比较好的构造方法就是取所有大小恰为 $\lfloor\frac{m}2\rfloor$ 的集合，又 $\dbinom{14}{7} = 3432 \ge 3000$，故实际上 $m \le 14$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3432</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sve[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= lim; state ++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = __builtin_popcount (state);</span><br><span class="line"><span class="keyword">if</span> (cnt == (M &gt;&gt; <span class="number">1</span>)) sve[++ m] = state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">if</span> (M &gt; <span class="number">14</span>) M = <span class="number">14</span>;</span><br><span class="line">work ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, in + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M; k ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[j] == <span class="string">'1'</span> &amp;&amp; ((sve[i] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((sve[j] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span> (k + <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (in[j] == <span class="string">'0'</span> &amp;&amp; ((sve[i] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((sve[j] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span> (k + <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成函数与组合计数初步</title>
      <link href="/2020/08/04/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/"/>
      <url>/2020/08/04/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>该文为（金策《生成函数的运算与组合计数问题》）学习笔记</p><h3 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h3><p>级数：一个有穷或无穷序列 $a_0, a_1, a_2, …$ 的形式和「即 $\sum\limits_{i = 0} a_i$」被称为级数，序列中的项称作级数的通项</p><p>敛散性：极限是无穷即为发散「如 $f(x) = x$」；极限不为无穷即为收敛「如 $f(x) = \frac{1}{x}$」</p><p>那么幂级数即为形如 $\sum\limits_{n = 0}^{\infty} a_n(x - c)^n$ 或者化简为 $\sum\limits_{n = 0}^{\infty} a_nx^n$ 的形式</p><h3 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h3><p>形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} a_nx^n<br>$$<br>形式与幂级数很像，但这里 $x$ 作为一个符号而不用具体数值带进去算，也不研究敛散性什么的</p><p>形式幂级数的加减乘法与多项式的有着类似的定义</p><p>实际运算时一般在 $\bmod{x^n}$ 的意义下进行，即仅取次数不超过 $n - 1$ 的项</p><h3 id="笛卡儿积「直积」"><a href="#笛卡儿积「直积」" class="headerlink" title="笛卡儿积「直积」"></a>笛卡儿积「直积」</h3><p>有集合 $A, B$，则 $A, B$ 的笛卡儿积记作 $A \times B$，是所有可能组成的有序对的集合，且分别为 $A, B$ 的成员，即 $A \times B = \{(a, b) | a \in A \land b \in B\}$</p><ul><li><p>笛卡儿积一般不满足交换律与结合律</p></li><li><p>笛卡儿积对集合的并和交满足分配律<br>$$<br>A \times (B \cup C) = (A \times B) \cup (A \times C) \\<br>A \times (B \cap C) = (A \times B) \cap (A \times C) \\<br>(A \times B) \cap (C \times D) = (A \cap C) \times (B \cap D)<br>$$</p></li></ul><h2 id="生成函数与组合计数"><a href="#生成函数与组合计数" class="headerlink" title="生成函数与组合计数"></a>生成函数与组合计数</h2><h3 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h3><p>在组合计数问题中，一般定义了一类组合对象，该对象可能是满足某一性质的树、图等的集合，且一类组合对象 $A$ 其中的对象 $a \in A$ 有大小 $size(a)$，那么通常的计数任务即为求出 $A_n = (size (a) = n)$ 的数值</p><p>组合对象分为有标号与无标号，就比如结点有标号的无向图个数与结点无标号的无向图个数</p><p><strong>这一部分非常重要，对于题目必须先明确组合对象，才可以通过 OGF 或 EGF 的公式来进行求解</strong></p><h3 id="普通生成函数「OGF」"><a href="#普通生成函数「OGF」" class="headerlink" title="普通生成函数「OGF」"></a>普通生成函数「OGF」</h3><p>数列 $A_0, A_1, A_2, …$ 的 OGF 定义为形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} A_nx^n<br>$$</p><p>其中，$A$ 是一类无标号对象，$A_n$ 表示满足 $size(a) = n$ 的对象 $a \in A$ 的数量</p><p>或者可以这么理解，对于集合 $A = \{A_0, A_1, A_2, …\}$，其中 $A_i$ 的出现集合为 $M_i$，那么 $A$ 的 OGF 即为 $\prod\limits_{n = 0}^{\infty} \left(\sum\limits_{m \in M_n} x^m\right)$</p><p>考虑集合 $A, B$ 的笛卡儿积 $D = A \times B$，并有 $size(d) = size(a) + size(b)$，那么显然<br>$$<br>D_k = \sum\limits_{i + j = k} A_iB_j<br>$$<br>则有<br>$$<br>D(x) = A(x)B(x)<br>$$</p><h4 id="生成函数-frac-1-1-x-n"><a href="#生成函数-frac-1-1-x-n" class="headerlink" title="生成函数 $\frac{1}{(1 - x)^n}$"></a>生成函数 $\frac{1}{(1 - x)^n}$</h4><p>这是一个比较常见的生成函数，接下来证明它的原数列为<br>$$<br>\sum\limits_{k = 0}^{\infty} \dbinom{k + n - 1}{n - 1} x^k<br>$$<br>有两种方法</p><h5 id="证明方法一"><a href="#证明方法一" class="headerlink" title="证明方法一"></a>证明方法一</h5><p>首先显然<br>$$<br>\frac{1}{(1 - x)^n} = \prod_{i = 1}^n\left(\sum\limits_{k = 0}^{\infty} x^k\right)<br>$$<br>那么使用隔板法就可以直接证明了</p><h5 id="证明方法二"><a href="#证明方法二" class="headerlink" title="证明方法二"></a>证明方法二</h5><ul><li>结论：若数列 $a_0, a_1, a_2, …$ 的 OGF 是 $A(x)$，令 $s_n = \sum\limits_{i = 0}^n a_i$，则 $s_0, s_1, s_2, …$ 的 OGF $B(x)$ 为 $\frac{A(x)}{1 - x}$</li><li>证明：显然 $B(x) = \sum\limits_{n = 0}^{\infty} x^nA(x)$，得证</li></ul><p>那么对于 $\frac{1}{(1 - x)^n}$ 的系数来讲，假如按照括号顺序合并，那么第 $n$ 项的系数就是第 $n - 1$ 项的系数加上上一版的第 $n$ 项系数，又初始系数全部为 $1$，所以这就是杨辉三角的递推关系，得证</p><h3 id="指数生成函数「EGF」"><a href="#指数生成函数「EGF」" class="headerlink" title="指数生成函数「EGF」"></a>指数生成函数「EGF」</h3><p>数列 $A_0, A_1, A_2, …$ 的 EGF 定义为形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} A_n\frac{x^n}{n!}<br>$$<br>其中，$A$ 是一类有标号对象，$A_n$ 的意义同 OGF</p><p>OGF 表示的是序列，而 EGF 表示的是集合，而集合不同于序列的就是其没有顺序关系，故需除以 $n!$</p><p>换个层面理解，对于多重集 $A = \{\infty \times A_0, \infty \times A_1, \infty \times A_2, …\}$</p><p>首先多重集的排列数为 $\frac{n!}{n_0!n_1!n_2!…}$</p><p>又其中 $A_i$ 的出现集合为 $M_i$，那么 $A$ 的 EGF 即为 $\prod\limits_{n = 0}^{\infty} \left(\sum\limits_{m \in M_n} \frac{x^m}{m!}\right)$</p><p>这个式子和上面那个定义式是一样的</p><p>同样地，考虑有标号对象的拼接，从 $A, B$ 中各选 $n, m$ 件，因为是有标号的，所以需要令其保持顺序，故选择方法共有<br>$$<br>\dbinom{n + m}{n}<br>$$<br>种，那么<br>$$<br>\begin{aligned}<br>D_k &amp;= \sum\limits_{i + j = k} a_ib_j\frac{k!}{i!j!} \\<br>\frac{D_k}{k!} &amp;= \sum\limits_{i + j = k} \frac{a_i}{i!}\frac{b_j}{j!}<br>\end{aligned}<br>$$<br>说明<br>$$<br>\begin{aligned}<br>D(x) &amp;= \sum\limits_{k = 0}^{\infty}\left(\sum\limits_{i = 0}^{\infty} \dbinom{k}{i} a_ib_{k - i}\right)\frac{x^k}{k!} \\<br>&amp;= \sum\limits_{k = 0}^{\infty}\sum\limits_{i = 0}^{\infty} \frac{a_i}{i!}\frac{b_{k - i}}{(k - i)!} \\<br>&amp;= A(x)B(x)<br>\end{aligned}<br>$$</p><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>该部分见 <a href="https://colythme.github.io/2020/07/01/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/">多项式求逆</a></p><h3 id="生成函数相关应用"><a href="#生成函数相关应用" class="headerlink" title="生成函数相关应用"></a>生成函数相关应用</h3><h4 id="OGF-求-Fibonacci-数列通项"><a href="#OGF-求-Fibonacci-数列通项" class="headerlink" title="OGF 求 $Fibonacci$ 数列通项"></a>OGF 求 $Fibonacci$ 数列通项</h4><p>定义 $Fibonacci$ 数列的 OGF<br>$$<br>F(x) = \sum\limits_{n = 1}^{\infty} fibo_n x^n<br>$$<br>因为 $Fibonacci$ 数列与其右移一位的 $Fibonacci$ 数列的差是其右移两位，得<br>$$<br>\begin{aligned}<br>F(x) - xF(x) &amp;= x + x^2 \times F(x) \\<br>F(x) &amp;= \frac{x}{1 - x - x^2} \\<br>&amp;= \frac{x}{(1 - \frac{1 - \sqrt5}{2}x)(1 - \frac{1 + \sqrt5}{2}x)}<br>\end{aligned}<br>$$<br>现在要将该式裂项，假定 $F(x) = \frac{x}{(x - x_1)(x - x_2)}$，则裂项结果为 $\frac{t_1}{x - x_1} + \frac{t_2}{x - x_2}$，通项，得<br>$$<br>F(x) = \frac{t_1x - t_1x_2 + t_2x - t_2x_1}{(1 - x_1)(1 - x_2)}<br>$$<br>现在求解 $t_ 1, t_2$，有方程组<br>$$<br>\begin{cases}<br>t_1 + t_2 = 1 \\<br>t_1x_1 + t_2x_2 = 0<br>\end{cases}<br>$$<br>解出 $t_1, t_2$ 即可裂项，得<br>$$<br>F(x) = -\frac{1}{\sqrt5}\frac{1}{1 - \frac{1 - \sqrt5}{2}x} + \frac{1}{\sqrt5}\frac{1}{1 - \frac{1 + \sqrt5}{2}x}<br>$$<br>注意式子 $\frac{1}{1 - \frac{1 - \sqrt5}{2}x}$ ，这和式子 $\sum\limits_{n = 0}^{\infty} x^n = \frac{1}{1 - x}$，是一样的，可以直接还原为数列，故<br>$$<br>fibo_n = - \frac{1}{\sqrt5}\left(\frac{1 - \sqrt5}{2}\right)^n + \frac{1}{\sqrt5}\left(\frac{1 + \sqrt5}{2}\right)^n<br>$$</p><h4 id="生成函数求伯努利数"><a href="#生成函数求伯努利数" class="headerlink" title="生成函数求伯努利数"></a>生成函数求伯努利数</h4><h5 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h5><p>伯努利数分为两类：</p><p>$B_n^-$ 表示第一类伯努利数，$B_n^+$ 表示第二类伯努利数，它们的差别在于第一项，分别为 $B_1^- = - \frac{1}{2}, B_1^+ = + \frac{1}{2}$</p><p>并且对于所有大于 $1$ 的奇数 $n$，其伯努利数 $B_n = 0$</p><p>现在定义等幂和<br>$$<br>S_m(n) = \sum\limits_{k = 1}^n k^m<br>$$<br>该式成为伯努利多项式，变量为 $n$，次数为 $m$，又<br>$$<br>S_m(n) = \frac{1}{m + 1}\sum\limits_{k = 0}^n \dbinom{m + 1}{k} B_k^+ n^{m + 1 - k}<br>$$<br>这就是伯努利数与伯努利多项式的关系</p><p>伯努利数可以通过递推式计算<br>$$<br>\sum\limits_{j = 0}^m \dbinom{m + 1}{j} B_j = 0  (B_0 = 1)<br>$$<br>它还可以通过 EGF 表达「证明占坑」<br>$$<br>\frac{x}{e^x - 1} = \sum\limits_{n = 0}^{\infty} B_n\frac{x^n}{n!}<br>$$</p><h5 id="乘法逆元求伯努利数"><a href="#乘法逆元求伯努利数" class="headerlink" title="乘法逆元求伯努利数"></a>乘法逆元求伯努利数</h5><p>$$<br>\begin{aligned}<br>\sum\limits_{n = 0}^{\infty} B_n\frac{x^n}{n!} &amp;= \frac{x}{e^x - 1} \\<br>&amp;= \frac{x}{\sum\limits_{n = 1}^{\infty} \frac{x^n}{n!}} \\<br>&amp;= \frac{1}{\left(\sum\limits_{n = 0}^{\infty} \frac{x^n}{(n + 1)!}\right)}<br>\end{aligned}<br>$$</p><p>那么求一次乘法逆元即可</p><h4 id="生成函数优化-DP"><a href="#生成函数优化-DP" class="headerlink" title="生成函数优化 $DP$"></a>生成函数优化 $DP$</h4><p>先给出一道来自论文的例题</p><blockquote><p>字符集大小为 $m$。给定一个长度为 $k$ 的字符串 $s$，求出所有长为 $n$ 的串中，不包含子串 $s$ 的有多少个。$(n, m, k \le 10^5)$</p></blockquote><p>直接 $DP$ 很好想，令 $f_i$ 表示前 $i$ 个位置填字符，并且第一次满足 $substr[i - k + 1, i] = s$<br>$$<br>f_i = m^{i - k} - \sum\limits_{j = 1}^{i - k} f_jm^{i - j - k} - \sum\limits_{j \in Next} f_{i - j}<br>$$<br>注意，此处的 $Next$ 集合定义为 $\{j \ge 0 | s[1, k - j] = s[j + 1, k]\}$，不然下面不好进行优化</p><p>接下来对 $DP$ 进行优化</p><p>考虑生成函数 $f(x) = \sum\limits_{n = 0}^{\infty} f_nx^n, N(x) = \sum\limits_{j \in Next} x^j$，根据上面的 $DP$ 方程，可以得到<br>$$<br>f(x) = \frac{x^k}{1 - mx} + \frac{x^k}{1 - mx}f(x) + f(x)(N(x) - 1)<br>$$<br>其中，第一项直接等比数列求和即可得到，至于 $2, 3$ 项，会发现这实际上就是两个生成函数相乘每一项的系数变化，并且注意此时 $N(x)$ 需减 $1$，防止计算到 $f_i$，故得该表示</p><p>化简，得<br>$$<br>f(x) = \frac{x^k}{x^k + (1 - mx)N(x)}<br>$$</p><p>那么最终答案为 $g_n = m^n - \sum\limits_{j = 1}^n f_jm^{n - j}$，其 OGF $g(x)$ 为<br>$$<br>\begin{aligned}<br>g(x) &amp;= \frac{1}{1 - mx} - \frac{1}{1 - mx}f(x) \\<br>&amp;= \frac{N(x)}{x^k + (1 - mx)N(x)}<br>\end{aligned}<br>$$<br>然后把下面那东西乘出来化简一下就又可以得到一个新的多项式，然后就可直接解了</p><p>复杂度 $O (n \log n)$</p><h3 id="对数与指数运算"><a href="#对数与指数运算" class="headerlink" title="对数与指数运算"></a>对数与指数运算</h3><h4 id="形式幂级数的复合运算"><a href="#形式幂级数的复合运算" class="headerlink" title="形式幂级数的复合运算"></a>形式幂级数的复合运算</h4><p>设 $A(x) = \sum\limits_{i = 0}^{\infty} a_ix^i, B(x) = \sum\limits_{i = 1}^{\infty} b_ix^i$，那么它们的复合为<br>$$<br>C(x) = A(B(x)) = \sum\limits_{i = 0}^{\infty} a_i(B(x))^i<br>$$<br>显然最终 $C(x)$ 可以归纳成 $C(x) = \sum\limits_{i = 0}^{\infty} c_ix^i$ 的形式</p><p>注意因为 $B(x)$ 是没有常数项的，所以 $B(x)^i$ 是从 $x^i$ 起步的，故 $B(x)$ 与 $A(x)$ 的复合可以定义「猜测是这样，真正原因占坑」</p><h4 id="形式导数"><a href="#形式导数" class="headerlink" title="形式导数"></a>形式导数</h4><p>对于 $A(x) = \sum\limits_{n = 0} ^{\infty} a_nx^n$，定义其形式导数<br>$$<br>A’(x) = \sum\limits_{n = 1}^{\infty} na_nx^{n - 1}<br>$$<br>经过验证可知<br>$$<br>\begin{matrix}<br>&amp;(cA(x))’ = cA’(x) \\<br>&amp;(A(x) \pm B(x))’ = A’(x) \pm B’(x) \\<br>&amp;(A(x)B(x))’ = A’(x)B(x) + A(x)B’(x) \\<br>&amp;\left(\frac{1}{A(x)}\right) = - \frac{A’(x)}{A(x)^2} \\<br>&amp;(A(B(x))’ = A’(B(x))B’(x)<br>\end{matrix}<br>$$<br>这些基本求导法则对形式导数仍然成立</p><h4 id="可微函数"><a href="#可微函数" class="headerlink" title="可微函数"></a>可微函数</h4><p>可微函数指那些在其定义域中所有点都存在导数的函数，因此，可微函数的图像不存在任何间断点、尖点或是有垂直切线的点</p><h4 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h4><p>对于一个在实数或复数 $a$ 邻域上，以实数或复数作为变量，并且是无穷且可微的函数，其泰勒级数定义为以下形式的幂级数<br>$$<br>\sum\limits_{n = 0}^{\infty} \frac{f^{(n)}(a)}{n!}(x - a)^n<br>$$<br>如果 $a = 0$，那么该级数亦称作麦克劳林级数</p><p>实际上该式也就是泰勒展开的式子，证明：<a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/7681487?fr=aladdin" target="_blank" rel="noopener">泰勒展开证明</a></p><h5 id="常用函数的麦克劳林序列"><a href="#常用函数的麦克劳林序列" class="headerlink" title="常用函数的麦克劳林序列"></a>常用函数的麦克劳林序列</h5><p>$$<br>\begin{matrix}<br>\frac{1} {1 - x} = \sum\limits_{n = 0}^{\infty} x^n ~ ~ ~ ~ \forall x \in (- 1, 1) \\\<br>e^x = \sum\limits_{n = 0}^{\infty} \frac{x^n} {n!}  ~ ~ ~ ~ \forall x \\\<br>\ln (1 + x) = \sum\limits_{n = 1}^{\infty} \frac{(- 1)^{n + 1} } {n}x^n ~ ~ ~ ~ \forall x \in (- 1, 1) \\\<br>\ln (1 - x) = - \sum\limits_{n = 1}^{\infty} \frac{x^i} {i}<br>\end{matrix}<br>$$</p><h4 id="对数函数的计算"><a href="#对数函数的计算" class="headerlink" title="对数函数的计算"></a>对数函数的计算</h4><p>给定 $A(x) = 1 + \sum\limits_{n = 1}^{\infty} a_nx^n$ 「此处 $+ 1$ 是为了保证多项式求逆有解」<br>$$<br>\begin{aligned}<br>B(x) &amp;= ln (A(x)) \\\<br>B’(x) &amp;= \frac{A(x)}{A’(x)} \\\<br>B(x) &amp;= \int \frac{A(x)}{A’(x)} \mathrm{d}x<br>\end{aligned}<br>$$<br>时间复杂度 $O (n \log n)$</p><h4 id="指数函数的计算"><a href="#指数函数的计算" class="headerlink" title="指数函数的计算"></a>指数函数的计算</h4><p>给定 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，令<br>$$<br>B(x) = e^{A(x)}<br>$$<br>那么经过归纳之后可以表示为 $B(x) = \sum\limits_{i = 0}^{\infty} b_ix^i$</p><p>那么接下来的事情就是要计算系数 $b_i$</p><p>显然 $b_0 = 1$，那么扩展，得<br>$$<br>b_i = \frac{1}{i}\sum\limits_{k = 1}^i a_kb_{i - k}<br>$$<br>接下来证明这个结论</p><h5 id="证明方法一-1"><a href="#证明方法一-1" class="headerlink" title="证明方法一"></a>证明方法一</h5><p>先从简单的开始看起<br>$$<br>\begin{aligned}<br>&amp;b_1 = \frac{a_1}{1!} \\\<br>&amp;b_2 = \frac{a_2}{1!} + \frac{a_1 \times a_1}{2!} \\\<br>&amp;b_3 = \frac{a_3}{1!} + \frac{a_1 \times a_2 + a_2 \times a_1}{2!} + \frac{a_1 \times a_1 \times a_1}{3!}<br>\end{aligned}<br>$$<br>对于 $b_4$ 先只列举一个：<br>$$<br>b_4 = … + \frac{a_1 \times a_1 \times a_2 + a_1 \times a_2 \times a_1 + a_2 \times a_1 \times a_1}{3!} + …<br>$$<br>可以发现，相当于现在处理的问题是，令 $n = \sum\limits_{i = 1}^{total} m_ip_i$，那么可以得到一个集合 $\{m_1 \times p_1, m_2 \times p_2, …\}$，那么要如何通过集合 $\{\{m_1 \times p_1, …, (m_i - 1) \times p_i, …, m_{total} \times p_{total}\}(i = 1, 2, …, total)\}$ 转移到该集合</p><p>由于最终得到的 $a_{p_1}a_{p_2}a_{p_3}…$ 无关紧要，故只考虑其系数</p><p>先考虑最终需要的值<br>$$<br>\begin{aligned}<br>final &amp;= \frac{\frac{m!}{m_1!m_2!m_3!…}}{m!} \\\<br>&amp;= \frac{1}{m_1!m_2!m_3!…}<br>\end{aligned}<br>$$<br>对于每个 $i$，容易知道它的贡献为 $\frac{1}{m_1!…(m_i - 1)!…m_{total}!}$</p><p>现在只有 $n$ 关于 $m_i, p_i$，的公式，考虑将每个 $i$ 的贡献乘上 $p_i$，求和，则有<br>$$<br>\frac{\sum\limits_i m_ip_i}{m_1!m_2!m_3!…} = \frac{n}{m_1!m_2!m_3!…}<br>$$<br>上下同除一个 $n$ 即可得解</p><p>好像这个证明有点麻烦，那么还有一个</p><h5 id="证明方法二-1"><a href="#证明方法二-1" class="headerlink" title="证明方法二"></a>证明方法二</h5><p>两边求导，得<br>$$<br>B’(x) = A’(x)B(x)<br>$$<br>那么展开一下就得到该式了</p><p>那么有了这个结论之后求 $b_i$ 直接分治 $FFT$ 解决即可</p><p>时间复杂度 $O (n \log^2 n)$</p><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>给定 $g(x)$，求解 $f(x)$<br>$$<br>g(f(x)) = 0<br>$$<br>假设已经处理出 $f(x)$ 的前 $n$ 项 $f_0(x)$，则有<br>$$<br>\begin{aligned}<br>f(x) &amp;\equiv f_0(x) &amp;\pmod{x^n} \\\<br>f(x) - f_0(x) &amp;\equiv 0 &amp;\pmod{x^n} \\\<br>(f(x) - f_0(x))^2 &amp;\equiv 0 &amp;\pmod{x^{2n}}<br>\end{aligned}<br>$$<br>那么将 $g(f(x))$ 泰勒展开，得<br>$$<br>\begin{aligned}<br>0 &amp;= g(f(x)) \\\<br>&amp;= \sum\limits_{n = 0}^{\infty} \frac{g^{(n)}(f_0(x))}{n!}(f(x) - f_0(x))^n \\\<br>&amp;\equiv g(f_0(x)) + g’(f_0(x))(f(x) - f_0(x)) \pmod{x^{2n}} \\\<br>f(x) &amp;\equiv f_0(x) - \frac{g(f_0(x))}{g’(f_0(x))} \pmod{x^{2n}}<br>\end{aligned}<br>$$<br>那么就可以 $O (n \log n)$ 求解 $f(x)$ 了</p><h5 id="牛顿迭代法计算指数函数"><a href="#牛顿迭代法计算指数函数" class="headerlink" title="牛顿迭代法计算指数函数"></a>牛顿迭代法计算指数函数</h5><p>给定 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，求解 $e^{A(x)}$</p><p>令 $g(x) = \ln (x) - A(x)$，则有<br>$$<br>\begin{aligned}<br>f(x) &amp;= f_0(x) - \frac{\ln (f_0(x)) - A(x)}{\frac{1}{f_0(x)}} \\<br>&amp;= f_0(x)\left(1 - \ln (f_0(x)) + A(x)\right)<br>\end{aligned}<br>$$</p><h4 id="牛顿迭代法计算-k-次幂"><a href="#牛顿迭代法计算-k-次幂" class="headerlink" title="牛顿迭代法计算 $k$ 次幂"></a>牛顿迭代法计算 $k$ 次幂</h4><p>给定多项式 $A(x) = \sum\limits_{i = 0}^n a_ix^i$ 及正整数 $k$，求解 $A(x)^k$</p><p>直接快速幂复杂度 $O (n \log^2 n)$，复杂度较高</p><p>接下来讨论：</p><p>若 $A(x)$ 常数项为 $1$，则<br>$$<br>A(x)^k = e^{k \ln A(x)}<br>$$<br>若 $A(x)$ 常数项不为 $1$，则进行转化</p><p>设 $A(x)$ 得最低次项为 $a_tx^t$，转化为常数项为 $1$，即<br>$$<br>A(x)^k = a_t^kx^{kt}\left(\frac{A(x)}{a_tx^t}\right)^k<br>$$<br>同样牛顿迭代法即可</p><p>时间复杂度 $O (n \log n)$</p><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><h4 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h4><p>有一类组合对象 $A$，$A$ 的元素可以组成序列「最简单的例子就是由 $\{n_1 \times l_1, n_2 \times l_2, …\}$ 这样的长度集合拼成长度为 $k (k = 1, 2, …)$ 的方案数所构成的序列」，则这些序列定义了新的一类组合对象 $B$，即<br>$$<br>B(x) = \sum\limits_{k = 0}^{\infty} A(x)^k = \frac{1}{1 - A(x)}<br>$$<br>该结论对有无标号都成立</p><h4 id="集合计数"><a href="#集合计数" class="headerlink" title="集合计数"></a>集合计数</h4><h5 id="有标号的集合计数"><a href="#有标号的集合计数" class="headerlink" title="有标号的集合计数"></a>有标号的集合计数</h5><p>集合与序列的区别在于元素没有顺序，故需去除重复的，则<br>$$<br>B(x) = \sum\limits_{n = 0}^{\infty} \frac{A(x)^n}{n!} = e^{A(x)}<br>$$</p><h6 id="有标号的连通图计数"><a href="#有标号的连通图计数" class="headerlink" title="有标号的连通图计数"></a>有标号的连通图计数</h6><p>设 $G$ 是所有简单连通图，则其 EGF 为<br>$$<br>G(x) = \sum\limits_{n = 0}^{\infty} 2^{\frac{n(n - 1)}{2}}\frac{x^n}{n!}<br>$$<br>可以将所有简单连通图看作连通分量「其集合为 $C(x)$」的集合，故<br>$$<br>\begin{aligned}<br>G(x) &amp;= e^{C(x)} \\<br>C(x) &amp;= \ln G(x)<br>\end{aligned}<br>$$<br>时间复杂度 $O (n \log n)$</p><h5 id="无标号的集合计数"><a href="#无标号的集合计数" class="headerlink" title="无标号的集合计数"></a>无标号的集合计数</h5><h6 id="完全背包计数"><a href="#完全背包计数" class="headerlink" title="完全背包计数"></a>完全背包计数</h6><blockquote><p>体积为 $i$ 的有 $a_i$ 种不同的物品，每种物品有无限个，那么最终装满体积为 $V$ 的背包的方案数</p></blockquote><p>显然答案为<br>$$<br>\begin{aligned}<br>Ans &amp;= \prod_{i = 1}^n\left(\sum\limits_{j = 0}x^{ij}\right)^{a_i} \\<br>&amp;= \prod_{i = 1}^n\left(\frac{1}{1 - x^i}\right)^{a_i} \\<br>\end{aligned}<br>$$</p><p>接下来用对数函数化乘为加<br>$$<br>\begin{aligned}<br>Ans &amp;= \exp (\sum\limits_{i = 1}^n \ln \left(\left(\frac{1}{1 - x^i}\right)^{a_i}\right)) \\<br>&amp;= \exp (- \sum\limits_{i = 1}^n a_i\ln(1 - x^i)) \\<br>&amp;= \exp (\sum\limits_{i = 1}^na_i\left(\sum\limits_{n = 1}^{\infty} \frac{x^{in}}{n}\right)) \\<br>\end{aligned}<br>$$<br>接下来令 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，换为枚举 $n$，得<br>$$<br>Ans = \exp (\sum\limits_{n = 1}^{\infty} \frac{1}{n}A(x^n))<br>$$<br>那么时间复杂度的计算就是调和级数，总时间复杂度 $O (n \log n)$</p><h4 id="环的计数"><a href="#环的计数" class="headerlink" title="环的计数"></a>环的计数</h4><h5 id="有标号的环的计数"><a href="#有标号的环的计数" class="headerlink" title="有标号的环的计数"></a>有标号的环的计数</h5><h6 id="圆排列问题"><a href="#圆排列问题" class="headerlink" title="圆排列问题"></a>圆排列问题</h6><blockquote><p>从 $n$ 个元素中不重复地取出 $m$ 个元素在一个圆周上，并且每个排列经过旋转后不会与其它任意一个排列相同，叫做这 $n$ 个元素的圆排列</p></blockquote><p>显然 $n$ 个元素取 $m$ 个作圆排列的方案数为<br>$$<br>total = \frac{A_n^m}{m}<br>$$<br>那么，对于一类组合对象 $A$，其圆排列的生成函数为<br>$$<br>\sum\limits_{k = 1}^{\infty} \frac{A(x)^k}{k} = - \ln (1 - A(x))<br>$$</p><h6 id="有标号的无向连通图中的基环树个数计数"><a href="#有标号的无向连通图中的基环树个数计数" class="headerlink" title="有标号的无向连通图中的基环树个数计数"></a>有标号的无向连通图中的基环树个数计数</h6><p>考虑将基环树拆分为若干棵树的拼凑</p><p>注意此时需考虑的是有根树，即先将节点看作组合对象，根据 $Cayley$ 定理，$n$ 个节点的完全图有 $n^{n - 1}$ 棵有根树，则有根树的 EGF $T(x)$ 为<br>$$<br>T(x) = \sum\limits_{n = 1}^{\infty} n^{n - 1}\frac{x^n}{n!}<br>$$<br>那么此时将有根树看作组合对象，则将它们组成环，即基环树的 EGF $G(x)$ 为<br>$$<br>\begin{aligned}<br>G(x) &amp;= \frac{1}{2}\sum\limits_{n = 3}^{\infty} \frac{T(x)^k}{k} \\<br>&amp;= - \frac{1}{2}\ln (1 - T(x)) - \sum\limits_{k = 1}^2 \frac{T(x)^k}{k}<br>\end{aligned}<br>$$</p><h5 id="无标号的环的计数"><a href="#无标号的环的计数" class="headerlink" title="无标号的环的计数"></a>无标号的环的计数</h5><p>「由于需要群论知识，故留坑」</p><p>「以下留坑」</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狄利克雷卷积与莫比乌斯反演</title>
      <link href="/2020/08/04/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2020/08/04/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><h3 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h3><p>　　　　指定义域为正整数的函数<br>　　　　定义其加法为逐项相加，即$(f + g)(n) = f(n) + g(n)$<br>　　　　定义其数乘为逐项相乘，即$(xf)(n) = x × f(n)$</p><h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>　　　　单位元是集合中一种特别的元素，当单位元与其它元素相结合时，不会改变其它元素的值</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>　　　　逆元是指可以取消另一给定元素运算的元素，即将其变回单位元</p><h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><p>　　　　$[A]$表示条件$A$是否为真<br>　　　　此处的符号”$*$”表示狄利克雷卷积</p><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>　　令$t(n) = f(n) * g(n)$，则　　</p><p>$$<br>t(n) = \sum\limits_{i | n} f(i)g(\frac{n}{i})<br>$$</p><p>　　那么狄利克雷卷积显然有下面几个性质：</p><h3 id="满足乘法交换律、结合律、分配律"><a href="#满足乘法交换律、结合律、分配律" class="headerlink" title="满足乘法交换律、结合律、分配律"></a>满足乘法交换律、结合律、分配律</h3><ul><li>对于单位元$\epsilon(n) = [n = 1]$，满足$\epsilon(n)*f(n) = f(n)$<br>　　　　- 对于每一个$f(1) \ne 1$的数论函数$f(n)$，皆存在其逆元$f^{- 1}(n)$，满足$f(n) * f^{- 1}(n) = \epsilon(n)$，那么对于这个结论，可以令$f^{- 1}(n) = \frac{1}{f(1)}\left(\epsilon(n) - \sum\limits_{i | n, i \ne 1} f(i)f^{- 1}(\frac{n}{i})\right)$，再代回原式，满足条件</li></ul><h3 id="狄利克雷卷积与积性函数"><a href="#狄利克雷卷积与积性函数" class="headerlink" title="狄利克雷卷积与积性函数"></a>狄利克雷卷积与积性函数</h3><h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>　　　　积性函数满足当$(n, m) = 1$，有$f(nm) = f(n)f(m)$</p><h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ul><li><p>若$(n, m) = 1,  d | nm$，则必定存在$a | n,  b | m$且满足$ab = d$，证明显然</p></li><li><p>若$(n, m) = 1,  a | n,  b | m$，则有$(a, b) = 1$，证明显然</p></li></ul><p>​       这样的话，就有性质：两个积性函数的狄利克雷卷积仍是积性函数，证明：<br>　　若$(n, m) = 1$，则有<br>$$<br>\begin{aligned}<br>t(nm) &amp;= \sum\limits_{i | nm} f(i)g(\frac{nm}{i}) \\<br>&amp;= \sum\limits_{a | n, b | m} f(ab)g(\frac{nm}{ab}) \\<br>&amp;= \sum\limits_{a | n, b | m} f(a)f(b)g(\frac{n}{a})g(\frac{m}{b}) \\<br>&amp;= t(n) * t(m)<br>\end{aligned}<br>$$</p><p>　　另外一个性质，就是两个积性函数的逆元仍是积性函数，是用数学归纳法证明：<br>　　　　令$(n, m) = 1$，当$nm = 1$时，结论显然成立<br>　　　　当$nm &gt; 1$且$n_1m_1 &lt; nm$时$n_1m_1$结论成立，再假设$nm$时结论成立，则有（注意，积性函数中一定满足$f(1) = 1$）<br>$$<br>\begin{aligned} f^{- 1}(nm) &amp;= - \sum\limits_{i | nm, i \ne 1} f(i)f^{- 1}(\frac{nm}{i}) \\ &amp;= - \sum\limits_{a | n, b | m, ab \ne 1} f(a)f(b)f^{- 1}(\frac{n}{a})f^{- 1}(\frac{m}{b}) \\ &amp;= f(1)f(1)f^{- 1}(n)f^{- 1}(m) - \sum\limits_{a | n, b | m, ab \ne 1} f(a)f(b)f^{- 1}(\frac{n}{a})f^{- 1}(\frac{m}{b}) \\ &amp;= f^{- 1}(n)f^{- 1}(m) - \epsilon(n)\epsilon(m) \\ &amp;= f^{- 1}(n)f^{- 1}(m) \end{aligned}<br>$$<br>　　注：积性函数$f(1) = 1$</p><h3 id="狄利克雷卷积与莫比乌斯反演"><a href="#狄利克雷卷积与莫比乌斯反演" class="headerlink" title="狄利克雷卷积与莫比乌斯反演"></a>狄利克雷卷积与莫比乌斯反演</h3><p>　　令$\mu$表示$1$在狄利克雷卷积意义下的逆元，令$g = f * 1$，则有$f = f * 1 * \mu = g * \mu$，再令$g(n) = \sum\limits_{d | n} f(d)$，则有</p><p>$$<br>f(n) = g(n) * \mu(n) = \sum\limits_{d | n} g(d)\mu(\frac{n}{d})<br>$$<br>　　这就是莫比乌斯反演的式子了<br>　　那么对于函数$\mu(n)$，由于$1$是积性函数，则$\mu$也是积性函数，又易知（代回原式就好了）<br>$$<br>\mu(p^k) = \left\{\begin{aligned} 1     k = 0 \\ - 1     k = 1 \\ 0     k &gt; 1 \end{aligned}\right.<br>$$<br>　　那么由积性函数，可得<br>　　- 若$n = p_1p_2…p_k$且$p_1 \ne p_2 \ne … \ne p_k$，则有</p><p>$$<br>\mu(n) = (- 1)^k<br>$$</p><p>　　- 若$p_k^r | n (r &gt; 1)$，则有</p><p>$$<br>\mu(n) = 0<br>$$</p><p>　　那么积性筛即可</p><h4 id="另附"><a href="#另附" class="headerlink" title="另附"></a>另附</h4><p>　　莫比乌斯反演的另一种形式，有</p><p>$$<br>g(n) = \sum\limits_{n | d}f(d)<br>$$<br>　　则有</p><p>$$<br>f(n) = \sum\limits_{n | d} \mu(\frac{d}{n})g(d)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3768 - 简单的数学题</title>
      <link href="/2020/08/04/%E6%B4%9B%E8%B0%B7%203768%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/2020/08/04/%E6%B4%9B%E8%B0%B7%203768%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据<a href="https://www.cnblogs.com/Colythme/p/10275893.html" target="_blank" rel="noopener">Crash的数字表格</a>，很容易可以将式子化简为<br>$$<br>\begin{aligned} Ans &amp;= \sum\limits_{i = 1}^n \sum\limits_{j = 1} ij(i, j) \\ &amp;= \sum\limits_{d = 1}^n d^3 \sum\limits_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(k) k^2 \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{kd}\right\rfloor} i \right)^2 \end{aligned}<br>$$<br>感觉 $d, k$ 放在一起式子无法继续化简，主要是有 $kd$ 存在，故令 $T = kd$ ，则有<br>$$<br>Ans = \sum\limits_{T = 1}^n \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} i \right)^2 T^2 \sum\limits_{d | T} d \mu(\frac{T}{d})<br>$$<br>那么考虑整除分块，现在需要处理的是后半部分</p><p>通过观察（看题解）可以发现， $\sum\limits_{d | T} d \mu(\frac{T}{d})$ 可以看成 $\mu * id$ ，故可替换成 $\phi(T)$ ，则有<br>$$<br>Ans = \sum\limits_{T = 1}^n \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} i \right)^2 T^2 \phi(T)<br>$$<br>现在考虑将 $T^2 \phi(T)$ 部分用杜教筛解决<br>$$<br>h(n) = \sum\limits_{d | n} d^2 \phi(d) g(\frac{n}{d})<br>$$<br>为了消除 $d^2$ ，令 $g(\frac{n}{d}) = n^2$ ，则有<br>$$<br>h(n) = n^3<br>$$<br>故得<br>$$<br>S(n) = \sum\limits_{i = 1}^n i^3 - \sum\limits_{d = 2}^n d^2 S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>又（通过看题解）有一个知识点<br>$$<br>\sum\limits_{i = 1}^n i^3 = \left( \sum\limits_{i = 1}^n i \right)<br>$$<br>那么就可以直接杜教筛了</p><p>至于复杂度，将最外围的整除分块与杜教筛看为一体，故复杂度为 $O (n^{\frac{2}{3}})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL MOD, N;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL inv2, inv6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line">LL phi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">6e06</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">phi[i] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * <span class="number">1l</span>l * prime[j] % MOD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * prime[j]] = phi[i] * <span class="number">1l</span>l * (prime[j] - <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++)</span><br><span class="line">sumphi[i] = (sumphi[i - <span class="number">1</span>] + <span class="number">1l</span>l * i % MOD * <span class="number">1l</span>l * i % MOD * phi[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;LL, LL&gt; maphi;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">sqr</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * x % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">eqm</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n + <span class="number">1</span>) % MOD * (n % MOD) % MOD * (<span class="number">2</span> * n % MOD + <span class="number">1</span>) % MOD * inv6 % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">oseqm</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n % MOD * ((n + <span class="number">1</span>) % MOD) % MOD * inv2 % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">phi_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX)</span><br><span class="line"><span class="keyword">return</span> sumphi[n];</span><br><span class="line"><span class="keyword">if</span> (maphi[n])</span><br><span class="line"><span class="keyword">return</span> maphi[n];</span><br><span class="line">LL total = sqr (oseqm (n));</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total = (total - (eqm (r) - eqm (l - <span class="number">1</span>) + MOD) % MOD * phi_sieve (n / l) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maphi[n] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = N / (N / l);</span><br><span class="line">ans = (ans + sqr (oseqm (N / l)) * ((phi_sieve (r) - phi_sieve (l - <span class="number">1</span>) + MOD) % MOD) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>, &amp; MOD, &amp; N);</span><br><span class="line">inv2 = power (<span class="number">2l</span>l, MOD - <span class="number">2</span>), inv6 = power (<span class="number">6l</span>l, MOD - <span class="number">2</span>);</span><br><span class="line">MAX = (<span class="keyword">int</span>) min (<span class="number">1l</span>l * MAX, N), linear_sieve ();</span><br><span class="line">LL ans = Solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">998244353 2000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1000000007 9786510294</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3676 - 小清新数据结构题</title>
      <link href="/2020/08/04/%E6%B4%9B%E8%B0%B7%203676%20-%20%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98/"/>
      <url>/2020/08/04/%E6%B4%9B%E8%B0%B7%203676%20-%20%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>说实话这题写树剖 $LCT$ 什么的真的思想又不难又好实现的样子，但是我还是选择自虐选择了动态点分治</p><p>那就两种做法都稍微提一下：</p><h3 id="树链剖分-LCT"><a href="#树链剖分-LCT" class="headerlink" title="树链剖分 / $LCT$"></a>树链剖分 / $LCT$</h3><p>很容易可以发现一个换根操作只会对当前根在原树（根为 $1$ ）上的祖先一条链造成影响，也就是将它们的子树变成除当前链方向其它与之相连的点集，那么用树剖跳，用线段树维护一下原树上从上面来的和从下面来的，再将所有涉及的节点合并，并且删去算重复的和不该算的即可（虽然我没实现但是这个思路应该是对的</p><h3 id="动态点分治"><a href="#动态点分治" class="headerlink" title="动态点分治"></a>动态点分治</h3><p>首先有两篇博客：<a href="https://www.luogu.org/blog/user4134/solution-p3676" target="_blank" rel="noopener">zzq</a>、<a href="http://www.cnblogs.com/zhoushuyu/p/8309410.html" target="_blank" rel="noopener">租酥雨</a></p><p>因为我们要算 $\sum\limits_{i = 1}^n s_i^2$ ，可以先想一下 $\sum\limits_{i = 1}^n s_i$ 怎么算，因为每个点的贡献只会被祖先计算到，那么易知 $\sum\limits_{i = 1}^n s_i = \sum\limits_{i = 1}^n value_i * (depth_i + 1)$ ，这个直接用动态点分治维护三个变量 $sumo_i, sumt_i, sumfa_i$ （sumo -&gt; $p$ 子节点权值之和,  $sumt$ -&gt; 子节点权值与距离的乘积到 $p$ 之和,  $sumfa$ -&gt; 子节点权值与距离的乘积到 $fa$ （点分树上）之和）即可得到</p><p>接下来有个很重要的结论（反正我是肯定想不到</p><p>​    - 不论根如何换， $\sum\limits_{i = 1}^n s_i (sum - s_i)$ 一定是一个定值（说实话一开始一直想着如何化简 $\sum\limits_{i = 1}^n s_i$ ，所以是真的没有想到可以通过构造定值的方法来解出 $\sum\limits_{i = 1}^n s_i^2$ ）</p><p>先来意会一下这个结论：就是每一条边连接的两个点在他们的子树中各自选两个点让它们权值相乘，求总权值</p><p>那么就比较容易知道证明了：每条边的边权为所有对应路径经过这条边的两个点的权值和，求总边权，即求的是 $\sum\limits_{i = 1}^n \sum\limits_{j = 1}^n value_i * value_j * dist (i, j)$ ，所以有 $\sum\limits_{i = 1}^n s_i (sum - s_i) = \sum\limits_{i = 1}^n \sum\limits_{j = 1}^n value_i * value_j * dist (i, j)$</p><p>因为该式是个定值，所以求出 $\sum\limits_{i = 1}^n s_i$ 后直接解出 $Ans$ 就完成了查询操作</p><p>对于修改操作，若修改完后与原权值的差值为 $\Delta value$ ，那么 $\Delta total = \Delta value \sum\limits_{j = 1}^n value_j * dist (p, j)$ （ $p$ 为修改点）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> value[MAXN];</span><br><span class="line"></span><br><span class="line">LL Deep[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Dfn[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, belong[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dfsord = <span class="number">0</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line">LL subtree[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL s1 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    Dfn[root] = ++ dfsord;</span><br><span class="line">    val[dfsord] = Deep[root], belong[dfsord] = root;</span><br><span class="line">    sum += value[root];</span><br><span class="line">    subtree[root] = value[root];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Deep[v] = Deep[root] + <span class="number">1</span>;</span><br><span class="line">        DFS (v, root);</span><br><span class="line">        val[++ dfsord] = Deep[root], belong[dfsord] = root;</span><br><span class="line">        subtree[root] += subtree[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfsord; i ++)</span><br><span class="line">        ST[i][<span class="number">0</span>] = make_pair (val[i], belong[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= dfsord; i ++)</span><br><span class="line">            ST[i][j] = ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first ? ST[i][j - <span class="number">1</span>] : ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = Dfn[x], R = Dfn[y];</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        swap (L, R);</span><br><span class="line">    <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ST[L][k].first &lt; ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first ? ST[L][k].second : ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA (x, y);</span><br><span class="line">    <span class="keyword">return</span> Deep[x] + Deep[y] - (Deep[lca] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> minv = INF, grvy;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grvy_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    Size[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Grvy_Acqu (v, root);</span><br><span class="line">        Size[root] += Size[v];</span><br><span class="line">        maxpart = max (maxpart, Size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxpart = max (maxpart, total - Size[root]);</span><br><span class="line">    <span class="keyword">if</span> (maxpart &lt; minv)</span><br><span class="line">        minv = maxpart, grvy = root;</span><br><span class="line">&#125;</span><br><span class="line">LL sumo[MAXN]= &#123;<span class="number">0</span>&#125;, sumt[MAXN]= &#123;<span class="number">0</span>&#125;, sumfa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// sumo -&gt; p子节点权值之和, sumt -&gt; 子节点权值与距离的乘积到p之和, sumfa -&gt; 子节点权值与距离的乘积到fa(点分树上)之和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sums_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sumo[grvy] += value[root], sumt[grvy] += value[root] * dist (root, grvy);</span><br><span class="line">    <span class="keyword">if</span> (father[grvy])</span><br><span class="line">        sumfa[grvy] += value[root] * dist (root, father[grvy]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i =    Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sums_Acqu (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">point_DAC</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    minv = INF, grvy = p, total = Size[p];</span><br><span class="line">    Grvy_Acqu (p, <span class="number">0</span>);</span><br><span class="line">    Vis[grvy] = <span class="literal">true</span>, father[grvy] = pre;</span><br><span class="line">    sums_Acqu (grvy, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fgrvy = grvy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fgrvy]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        point_DAC (v, fgrvy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    LL tsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = op; p; p = father[p]) &#123;</span><br><span class="line">        tsum += sumt[p];</span><br><span class="line">        <span class="keyword">if</span> (p != op)</span><br><span class="line">            tsum += sumo[p] * dist (p, op);</span><br><span class="line">        <span class="keyword">if</span> (father[p])</span><br><span class="line">            tsum -= sumo[p] * dist (father[p], op) + sumfa[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = op; p; p = father[p]) &#123;</span><br><span class="line">        sumo[p] -= value[op] - delta;</span><br><span class="line">        sumt[p] -= value[op] * dist (p, op) - delta * dist (p, op);</span><br><span class="line">        <span class="keyword">if</span> (father[p])</span><br><span class="line">            sumfa[p] -= value[op] * dist (father[p], op) - delta * dist (father[p], op);</span><br><span class="line">    &#125;</span><br><span class="line">    sum -= value[op] - delta;</span><br><span class="line">    LL s = Query (op);</span><br><span class="line">    s1 += (delta - value[op]) * s;</span><br><span class="line">    value[op] = delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            isneg = <span class="number">1</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), Q = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">        Insert (u, v), Insert (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        value[i] = getnum ();</span><br><span class="line">    DFS (<span class="number">1</span>, <span class="number">0</span>), RMQ ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        s1 += subtree[i] * (sum - subtree[i]);</span><br><span class="line">    Size[<span class="number">1</span>] = N, point_DAC (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*cout &lt;&lt; "Next----------------------" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= N; i ++)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; sumo[i] &lt;&lt; ' ' &lt;&lt; sumt[i] &lt;&lt; ' ' &lt;&lt; sumfa[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "End-----------------------" &lt;&lt; endl;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum (), delta = getnum ();</span><br><span class="line">            Modify (p, delta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum ();</span><br><span class="line">            LL ans = (Query (p) + sum) * sum - s1;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">4 3 2 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">4 3 2 1</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根号算法相关</title>
      <link href="/2020/08/04/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/08/04/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><p>首先有一道题</p><h3 id="王室联邦"><a href="#王室联邦" class="headerlink" title="王室联邦"></a>王室联邦</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一棵树，将树分为大小范围为 $[B, 3B]$ 的连通块集，求方案</p><h4 id="树上分块方法之一"><a href="#树上分块方法之一" class="headerlink" title="树上分块方法之一"></a>树上分块方法之一</h4><p>类似贪心，用栈维护还没有在连通块中的子节点，对于递归到的当前的点 $p$ ，扫描它的子树，能拼凑就拼凑</p><p>但是注意最后可能还会有一些点（一定包括根）剩下，那么将这些点并到最后一个连通块即可</p><p>显然每个连通块都满足大小为 $[B, 3B]$</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bot = top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS (v, root);</span><br><span class="line">        <span class="keyword">if</span> (top - bot &gt;= B) &#123;</span><br><span class="line">            capt[++ bind] = root;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; bot)</span><br><span class="line">                belong[Stack[top --]] = bind;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack[++ top] = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树上莫队-1"><a href="#树上莫队-1" class="headerlink" title="树上莫队"></a>树上莫队</h3><p>首先用王室联邦的方法将树分块</p><p>用一个数组 $state_p$ 来维护 $p$ 点是否在当前询问的路径上，那么每次访问就将 $state_p$ 翻转，顺便修改 $ans$ ，相当于原序列上莫队的 $add, del$ 操作</p><p>那么，每次需要修改那些点呢？</p><p>假设当前处理到 $(px, py)$ ，现在需要处理 $(x, y)$ ，那么只需修改 $px$ 到 $x$ 以及 $py$ 到 $y$ 的路径上的点即可</p><p>接下来证明该操作的正确性：</p><p>令 $T (x, y)$ 表示 $x$ 到 $y$ 路径上的点集， $xor$ 操作类似位运算的异或，即有相同点则删去，无则加入</p><p>则有 $T (x, y) = T (x, root) xor T (y, root)$ （注意，这里的 $T (x, y)$ 是不包括 $lca$ 的，故 <strong>$lca$ 需单独处理</strong>）</p><p>接下来是证明<br>$$<br>\begin{aligned} &amp;T (px, py)  xor  T (x, y) \\ &amp;= [T (px, root)  xor  T (py, root)]  xor  [T (x, root)  xor  T (y, root)] \\ &amp;=  [T (px, root)  xor  T (x, root)]  xor  [T (py, root)  xor  T (y, root)] \\ &amp;= T (px, x)  xor  T (py, y) \end{aligned}<br>$$<br>那么其它的修改什么的就和序列上莫队一样了</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P4074" target="_blank" rel="noopener">[WC2013]糖果公园</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line">LL V[MAXN], W[MAXN];</span><br><span class="line"><span class="keyword">int</span> pcol[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> belong[MAXN];</span><br><span class="line"><span class="keyword">int</span> lind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_bel</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bot = top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS_bel (v, root);</span><br><span class="line">        <span class="keyword">if</span> (top - bot &gt;= limit) &#123;</span><br><span class="line">            lind ++;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; bot)</span><br><span class="line">                belong[Stack[top --]] = lind;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack[++ top] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> deep[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN];</span><br><span class="line"><span class="keyword">int</span> value[MAXN &lt;&lt; <span class="number">1</span>], ranking[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfsord = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_LCA</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    father[root] = fa;</span><br><span class="line">    dfn[root] = ++ dfsord;</span><br><span class="line">    value[dfsord] = deep[root], ranking[dfsord] = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        deep[v] = deep[root] + <span class="number">1</span>;</span><br><span class="line">        DFS_LCA (v, root);</span><br><span class="line">        value[++ dfsord] = deep[root], ranking[dfsord] = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfsord; i ++)</span><br><span class="line">        ST[i][<span class="number">0</span>] = make_pair (value[i], ranking[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= dfsord; i ++)</span><br><span class="line">            ST[i][j] = ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first ? ST[i][j - <span class="number">1</span>] : ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = dfn[x], R = dfn[y];</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        swap (L, R);</span><br><span class="line">    <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ST[L][k].first &lt; ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first ? ST[L][k].second : ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuerySt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    QuerySt (<span class="keyword">int</span> find = <span class="number">0</span>, <span class="keyword">int</span> ftime = <span class="number">0</span>, <span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>) :</span><br><span class="line">        index (find), time (ftime), x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> QuerySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (belong[x] != belong[p.x])</span><br><span class="line">            <span class="keyword">return</span> belong[x] &lt; belong[p.x];</span><br><span class="line">        <span class="keyword">if</span> (belong[y] != belong[p.y])</span><br><span class="line">            <span class="keyword">return</span> belong[y] &lt; belong[p.y];</span><br><span class="line">        <span class="keyword">return</span> time &lt; p.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">QuerySt Query[MAXQ];</span><br><span class="line"><span class="keyword">int</span> qind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> modposi[MAXQ], modtime[MAXQ];</span><br><span class="line"><span class="keyword">int</span> modpre[MAXQ], modval[MAXQ];</span><br><span class="line"><span class="keyword">int</span> mind = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> state[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> donet[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state[p])</span><br><span class="line">        ans -= V[pcol[p]] * W[donet[pcol[p]]], donet[pcol[p]] --;</span><br><span class="line">    state[p] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (state[p])</span><br><span class="line">        donet[pcol[p]] ++, ans += V[pcol[p]] * W[donet[pcol[p]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA (u, v);</span><br><span class="line">    <span class="keyword">while</span> (u != lca)</span><br><span class="line">        reverse (u), u = father[u];</span><br><span class="line">    <span class="keyword">while</span> (v != lca)</span><br><span class="line">        reverse (v), v = father[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extime</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> exist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state[modposi[p]]) &#123;</span><br><span class="line">        exist = <span class="literal">true</span>;</span><br><span class="line">        reverse (modposi[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        modpre[p] = pcol[modposi[p]];</span><br><span class="line">        pcol[modposi[p]] = modval[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pcol[modposi[p]] = modpre[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exist)</span><br><span class="line">        reverse (modposi[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timemod</span> <span class="params">(<span class="keyword">int</span> ptime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; mind &amp;&amp; modtime[cur + <span class="number">1</span>] &lt;= ptime)</span><br><span class="line">        extime (++ cur, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; modtime[cur] &gt; ptime)</span><br><span class="line">        extime (cur --, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL answer[MAXQ]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moqueue</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> px = <span class="number">1</span>, py = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qind; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = Query[i].index, time = Query[i].time;</span><br><span class="line">        <span class="keyword">int</span> x = Query[i].x, y = Query[i].y;</span><br><span class="line">        timemod (time);</span><br><span class="line">        move (px, x), px = x;</span><br><span class="line">        move (py, y), py = y;</span><br><span class="line">        <span class="keyword">int</span> lca = LCA (px, py);</span><br><span class="line">        reverse (lca);</span><br><span class="line">        answer[ind] = ans;</span><br><span class="line">        reverse (lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line">    limit = (<span class="keyword">int</span>) <span class="built_in">ceil</span> (<span class="built_in">pow</span> ((<span class="keyword">double</span>) N, <span class="number">2.0</span> / <span class="number">3.0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">        V[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        W[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">        Insert (u, v), Insert (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        pcol[i] = getnum ();</span><br><span class="line">    DFS_bel (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">        belong[Stack[top --]] = lind;</span><br><span class="line">    DFS_LCA (<span class="number">1</span>, <span class="number">0</span>), RMQ ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum (), col = getnum ();</span><br><span class="line">            modposi[++ mind] = p, modtime[mind] = i, modval[mind] = col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getnum (), y = getnum ();</span><br><span class="line">            qind ++, Query[qind] = (QuerySt (qind, i, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort (Query + <span class="number">1</span>, Query + qind + <span class="number">1</span>);</span><br><span class="line">    Moqueue ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qind; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 3 5</span></span><br><span class="line"><span class="comment">1 9 2</span></span><br><span class="line"><span class="comment">7 6 5 1</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1 2 3 2</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">0 2 1</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="二次离线莫队"><a href="#二次离线莫队" class="headerlink" title="二次离线莫队"></a>二次离线莫队</h2><p>考虑某个莫队的复杂度是 $O (n\sqrt{n}T)$，其中 $x$ 是某种复杂度，即莫队在移动端点时的更新不是 $O (1)$ 而是 $O (x)$ 的，即可用二次离线莫队优化掉 $O (T)$</p><p>考虑右端点的一次由 $R_{i - 1}$ 到 $R_i (R_i &gt; R_{i - 1})$ 的一次移动，对于 $x \in (R_{i - 1}, R_i]$，令其对区间 $[l, r]$ 的贡献为 $c (x, [l, r])$，那么也就是说 $x$ 每次移动我们需要知道 $c (x, [l, x - 1])$，差分，得<br>$$<br>c (x, [l, x - 1]) = c (x, [1, x - 1]) - c (x, [1, l - 1])<br>$$<br>对于 $c (x, [1, x - 1])$，显然可以直接前缀和维护；对于 $c (x, [1, l - 1])$，由于在一次移动中永远都是给 $[1, l - 1]$ 做贡献，那么可以只在 $l - 1$ 的位置打个标记说有哪些 $x$ 需要了解它在该区间的贡献，再计算一下就好了</p><p>也就是说第一次离线处理出 $c (x, [1, x - 1])$ 并且给每个端点打上标记说明仍需计算的区间，第二次离线则处理第一次离线分离出的区间</p><p>故总时间复杂度 $O (nT + n\sqrt{n})$，空间复杂度 $O (n)$</p><hr><p>以 「第十四分块(前体)」 为例</p><p>题目描述：查询 $l \le i &lt; j \le r$，且 $a_i \bigoplus a_j$ 的二进制表示下存在 $k$ 个 $1$ 的二元组 $(i, j)$ 个数</p><p>令二进制下有 $k$ 个 $1$ 的数的集合为 $A$（最多有 $3432$ 个），数字 $x$ 出现的次数为 $ap (x)$，那么加入一个数 $y$ 时所增加的贡献即为<br>$$<br>\Delta c(x, [l, r]) = \sum\limits_{x \in A} ap (x \bigoplus y)<br>$$<br>二次离线莫队即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXU = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">0</span>, bel[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits;</span><br><span class="line">LL buck[MAXU]= &#123;<span class="number">0</span>&#125;, preans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">querySt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, ind;</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line">querySt () &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> querySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bel[l] == bel[p.l] ? r &lt; p.r : l &lt; p.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">querySt query[MAXM];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span><span class="keyword">int</span> l, r, delt;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; subs[MAXN];</span><br><span class="line"></span><br><span class="line">LL answer[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), K = getnum ();</span><br><span class="line">limit = <span class="built_in">sqrt</span> (N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">bel[i] = (i - <span class="number">1</span>) / limit + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">query[i].l = getnum (), query[i].r = getnum ();</span><br><span class="line">query[i].ind = i, query[i].ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16384</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (__builtin_popcount (i) == K)</span><br><span class="line">bits.push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">preans[i] = buck[a[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) bits.size(); j ++)</span><br><span class="line">buck[a[i] ^ bits[j]] ++;</span><br><span class="line">&#125;</span><br><span class="line">sort (query + <span class="number">1</span>, query + M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pl = <span class="number">1</span>, pr = <span class="number">0</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = query[i].l, r = query[i].r;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l) subs[pr].push_back((T) &#123;pl, l - <span class="number">1</span>, - i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pl &lt; l) query[i].ans += preans[pl], pl ++;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l) subs[pr].push_back((T) &#123;l, pl - <span class="number">1</span>, i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pl &gt; l) query[i].ans -= preans[pl - <span class="number">1</span>], pl --;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r) subs[pl - <span class="number">1</span>].push_back((T) &#123;pr + <span class="number">1</span>, r, - i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pr &lt; r) query[i].ans += preans[pr + <span class="number">1</span>], pr ++;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r) subs[pl - <span class="number">1</span>].push_back((T) &#123;r + <span class="number">1</span>, pr, i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pr &gt; r) query[i].ans -= preans[pr], pr --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span> (buck, <span class="number">0</span>, <span class="keyword">sizeof</span> (buck));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) bits.size(); j ++)</span><br><span class="line">buck[a[i] ^ bits[j]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) subs[i].size(); j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = subs[i][j].l, r = subs[i][j].r, ind = subs[i][j].delt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k ++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = buck[a[k]];</span><br><span class="line"><span class="keyword">if</span> (k &lt;= i &amp;&amp; ! K) tmp --;</span><br><span class="line"><span class="keyword">if</span> (ind &gt; <span class="number">0</span>) query[ind].ans += tmp;</span><br><span class="line"><span class="keyword">else</span> query[- ind].ans -= tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i ++) query[i].ans += query[i - <span class="number">1</span>].ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) answer[query[i].ind] = query[i].ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">write (answer[i]), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5 2</span></span><br><span class="line"><span class="comment">3 4 8 0 2</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归纳 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教筛</title>
      <link href="/2020/08/04/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
      <url>/2020/08/04/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置相关"><a href="#前置相关" class="headerlink" title="前置相关"></a>前置相关</h2><ul><li><p>类型积性函数（注：以下皆为完全积性函数，即无需满足 $x \perp y$ 即有 $f(x) · f(y) = f(xy)$</p><p>$\epsilon (n) = [n = 1]$</p><p>$id (n) = n$</p></li><li><p><a href="https://www.cnblogs.com/Colythme/p/9972264.html" target="_blank" rel="noopener">狄利克雷卷积与莫比乌斯函数</a></p></li><li><p>狄利克雷卷积与欧拉函数</p><p>此处若以 $id $ 作单位元，则 $1$ 为 $\phi$ 的逆，即 $\phi * 1 = id$</p><p>证明：由 $\sum\limits_{d | n} \phi (d) = n$ ，再带回原式可证</p></li><li><p>莫比乌斯函数与欧拉函数的转化<br>$$<br>\begin{aligned} \phi * 1 &amp;= id \ \phi * 1 * \mu &amp;= id * \mu \ \phi * \epsilon &amp;= id * \mu \ \phi &amp;= \sum\limits_{d | n} \mu(d) \frac{n}{d} \ \frac{\phi}{n} &amp;= \sum\limits_{d | n} \frac{\mu(d)}{d} \end{aligned}<br>$$</p></li></ul><h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><ul><li><p>杜教筛用于求解积性函数前缀和一类问题</p></li><li><p>下面求解积性函数 $f$ 的前缀和</p></li><li><p>设积性函数 $f, g, h$ ，且 $h = f * g$ ，则有</p></li></ul><p>$$<br>\begin{aligned} \sum\limits_{i = 1}^n h(n) &amp;= \sum\limits_{i = 1}^n \sum\limits_{d | n} g(d)f(\frac{n}{d}) \\ &amp;= \sum\limits_{d = 1}^n g(d) \sum\limits_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} f(i) \end{aligned}<br>$$</p><ul><li>令 $S(n) = \sum\limits_{i = 1}^n f(i)$</li><li>将 $d = 1$ 时的提出，再移项，得</li></ul><p>$$<br>S(n) = \sum\limits_{i = 1}^n h(i) - \sum\limits_{d = 2}^n g(d)S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$</p><ul><li>那么预处理 $h, g$ 的前缀和（一般预处理 $n^{\frac{2}{3}}$ 个？），再递归整除分块即可处理，不过一般 $h, g$ 需要自己配</li><li>但实际上并不需要用 $\text{unordered_map}$ 来记忆化，设题目给定 $N$，当前递归到 $n$，则 $n$ 的答案可以被 $N / n$ 记录，也就是用 $visit(\lfloor\frac{N}n\rfloor)$ 来判断是否已被搜过，下面给出别人的简单证明为什么不会判重</li><li><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/sG79MC6wLoOvu8k.png" alt=""></li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><h3 id="求-sum-limits-i-1-n-mu-i-sum-limits-i-1-n-phi-i"><a href="#求-sum-limits-i-1-n-mu-i-sum-limits-i-1-n-phi-i" class="headerlink" title="求$\sum\limits_{i = 1}^n \mu(i), \sum\limits_{i = 1}^n \phi(i)$"></a>求$\sum\limits_{i = 1}^n \mu(i), \sum\limits_{i = 1}^n \phi(i)$</h3><p>由 $\mu * 1 = \epsilon$ ，可令 $g = 1, h = \epsilon$ ，那么得到<br>$$<br>S(n) = 1 - \sum\limits_{d = 2}^n S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>求 $\sum \phi$ 同理</p><h3 id="求-sum-limits-i-1-n-i-phi-i-（需要用配的）"><a href="#求-sum-limits-i-1-n-i-phi-i-（需要用配的）" class="headerlink" title="求$\sum\limits_{i = 1}^n i \phi(i) （需要用配的）$"></a>求$\sum\limits_{i = 1}^n i \phi(i) （需要用配的）$</h3><p>$$<br>h(n) = \sum\limits_{d | n} d \phi(d) g(\frac{n}{d})<br>$$</p><p>希望将 $d$ 消去，故配 $g = id$ ，得 $h(n) = n^2$<br>$$<br>S(n) = \sum\limits_{i = 1}^n i - \sum\limits_{d = 2}^n d S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>即可解</p><h2 id="代码（求解-sum-mu-sum-phi-）"><a href="#代码（求解-sum-mu-sum-phi-）" class="headerlink" title="代码（求解$\sum \mu, \sum \phi$ ）"></a>代码（求解$\sum \mu, \sum \phi$ ）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN / <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL phi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sumu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e06</span> + <span class="number">5e05</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">sumu[i] = sumu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">sumphi[i] = sumphi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> mapmu[MAXM];</span><br><span class="line">LL maphi[MAXM];</span><br><span class="line"><span class="keyword">bool</span> vmu[MAXM]= &#123;<span class="literal">false</span>&#125;, vphi[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumu[n];</span><br><span class="line"><span class="keyword">if</span> (vmu[N / n]) <span class="keyword">return</span> mapmu[N / n];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= (r - l + <span class="number">1</span>) * mu_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vmu[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> mapmu[N / n] = total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">phi_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumphi[n];</span><br><span class="line"><span class="keyword">if</span> (vphi[N / n]) <span class="keyword">return</span> maphi[N / n];</span><br><span class="line">LL total = n * <span class="number">1l</span>l * (n + <span class="number">1</span>) / <span class="number">2l</span>l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= <span class="number">1l</span>l * (r - l + <span class="number">1</span>) * phi_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vphi[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> maphi[N / n] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">linear_sieve ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (vmu, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vmu));</span><br><span class="line"><span class="built_in">memset</span> (vphi, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vphi));</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line">LL ans1 = phi_sieve (N);</span><br><span class="line"><span class="keyword">int</span> ans2 = mu_sieve (N);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld %d\n"</span>, ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速沃尔什变换「FWT」</title>
      <link href="/2020/08/04/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%E3%80%8CFWT%E3%80%8D/"/>
      <url>/2020/08/04/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%E3%80%8CFWT%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p>$$<br>C_i = \sum\limits_{i \oplus j} A_iB_j<br>$$</p><h2 id="离散沃尔什变换「DWT」"><a href="#离散沃尔什变换「DWT」" class="headerlink" title="离散沃尔什变换「DWT」"></a>离散沃尔什变换「DWT」</h2><p>设 $DWT_i (A) = \sum\limits_{j = 0}^n A_jf(i, j)$ （第一次知道原来离散变换是这么设的）</p><p>又由于<br>$$<br>\begin{aligned}<br>DWT_i(A)DWT_i(B) &amp;= DWT_i(C) \\<br>\sum\limits_{j = 0}^{n - 1} \sum\limits_{k = 0}^{n - 1} A_jB_kf(i, j)f(i, k) &amp;= \sum\limits_{j = 0}^{n - 1} \sum\limits_{k = 0}^{n - 1} A_jB_kf(i, j \oplus k)<br>\end{aligned}<br>$$<br>故 $f(i, j)f(i, k) = f(i, j \oplus k)​$</p><p>于是就有一些结论</p><ul><li>$and:  f(i, j) = [(i  and   j) = i]$ </li><li>$or:  f(i, j) = [(i  and  j) = j]$</li><li>$xor:  f(i, j) = (- 1)^{cnt (i  and  j)}$ （$cnt (x)$ 是 $x$ 的二进制位数）</li></ul><p>至于证明自己意会一下就好了</p><p>又由于 $f(i, j)$ 满足二进制拆分，即<br>$$<br>f(i, j) = \prod\limits_{bit = 0}^{cntbit - 1} f(i_{bit}, j_{bit})<br>$$<br>那么将其左右拆分，推一下式子，得（注意下面的 $i_{bit}$ 表示的是<strong>从高到低</strong>的第 $bit​$ 位）<br>$$<br>\begin{aligned}<br>DWT_i(A) &amp;= \sum\limits_{j = 0}^n A_jf(i, j) \\<br>&amp;= \sum\limits_{j = 0}^{\frac{n}{2} - 1} A_jf(i, j) + \sum\limits_{j = \frac{n}{2}}^{n - 1} A_jf(i, j)<br>\end{aligned}<br>$$<br>然后将它们的最高位提出来，得<br>$$<br>\begin{aligned}<br>DWT_i(A) = f(i_0, 0)\sum\limits_{j = 0}^{\frac{n}{2} - 1} A_j\prod_{bit = 1}^{cntbit - 1}  f(i_{bit}, j_{bit}) + f(i_0, 1)\sum\limits_{j = \frac{n}{2}}^{n - 1}A_j\prod_{bit = 1}^{cntbit - 1} f(i_{bit}, j_{bit})<br>\end{aligned}<br>$$<br>整理一下，得 $(i \in [0, \frac{n}{2} - 1])$<br>$$<br>\begin{aligned}<br>DWT_i(A) &amp;= f(0, 0)DWT_{\frac{n}{2}}(A_{left}) + f(0, 1)DWT_{\frac{n}{2}}(A_{right}) \\<br>DWT_{i + \frac{n}{2}}(A) &amp;= f(1, 0))DWT_{\frac{n}{2}}(A_{left}) + f(1, 1)DWT_{\frac{n}{2}}(A_{right})<br>\end{aligned}<br>$$<br>至于 $iDWT$，就是解个二元一次方程的问题</p><p>接下来只要把 $FFT$ 的部分程序改一下就好了</p><p>下面记录一些常见公式<br>$$<br>and:  a[i + j] += a[i + j + k]  (DWT) \\<br>and:  a[i + j] -= a[i + j + k]  (iDWT) \\<br> \\<br>or:  a[i + j + k] += a[i + j]  (DWT) \\<br>or:  a[i + j + k] -= a[i + j]  (iDWT) \\<br> \\<br>xor:  a[i + j] = a[i + j] + a[i + j + k],  a[i + j + k] = a[i + j] - a[i + j + k]  (DWT) \\<br>xor:  a[i + j] = \frac{a[i + j] + a[i + j + k]}{2},  a[i + j + k] = \frac{a[i + j] - a[i + j + k]}{2}  (iDWT)<br>$$</p><h2 id="代码「-and-or-xor-」"><a href="#代码「-and-or-xor-」" class="headerlink" title="代码「$and,  or,  xor$」"></a>代码「$and,  or,  xor$」</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常系数线性递推</title>
      <link href="/2020/08/04/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
      <url>/2020/08/04/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多项式除法-取模"><a href="#多项式除法-取模" class="headerlink" title="多项式除法|取模"></a>多项式除法|取模</h3><p>该部分见 <a href="https://colythme.github.io/2020/07/22/多项式操作/">多项式操作</a></p><h3 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h3><p>（这部分我也不怎么理解，就大概记个结论）</p><p>对 $n$ 阶矩阵 $A$ 的特征向量 $\vec{v}$ 与，有特征值 $\lambda$ 满足<br>$$<br>A\vec v = \lambda\vec v<br>$$<br>移项则有 $(\lambda I - A)\vec v = 0$，其中 $I$ 为单位矩阵</p><p>那么有解的充要条件是 $det(\lambda I - A) = 0$</p><p>令 $f(\lambda) = det(\lambda I - A)$，即此时可将 $det (\lambda I - A)$ 看作一个 $n$ 阶多项式，则称 $f(\lambda)$ 为矩阵 $A$ 的特征多项式，对矩阵 $A$，其任意特征值 $\lambda_0$ 都满足 $f(\lambda_0) = 0$</p><h3 id="text-Hamiton-Cayley-定理"><a href="#text-Hamiton-Cayley-定理" class="headerlink" title="$\text{Hamiton-Cayley}$定理"></a>$\text{Hamiton-Cayley}$定理</h3><p>对矩阵 $A$ 及其特征多项式 $f(x)$，满足 $f(A) = O$，其中 $O$ 为零矩阵</p><p>证明留坑</p><h2 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h2><p>求一个满足 $k$ 阶齐次线性递推数列 $h_i$ 的第 $n$ 项，即<br>$$<br>h_n = \sum\limits_{i = 1}^k f_i \times h_{n - i}<br>$$<br>它有三个特点</p><ul><li>常系数：递推系数与下标无关</li><li>齐次：递推式不存在常数项，就类似 $y = ax + b$ 中 $b = 0$</li><li>线性：都为一次项</li></ul><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>加速矩阵 $A$ $\times$ 初始矩阵 $H$：<br>$$<br>\begin{pmatrix}<br>f_1 &amp; f_2 &amp; f_3 &amp; \cdots &amp; f_n \\<br>1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \cdots &amp; \vdots \\<br>0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1<br>\end{pmatrix}<br>\times<br>\begin{pmatrix}<br>h_k \\<br>\vdots \\<br>h_3 \\<br>h_2 \\<br>h_1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>h_{k + 1} \\<br>\vdots \\<br>h_4 \\<br>h_3 \\<br>h_2<br>\end{pmatrix}<br>$$<br>那么快速幂 $A^nH$ 即可，复杂度 $O (k^3 \log n)$</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>考虑 $A\vec v = \lambda\vec v$，也就是说现在存在<br>$$<br>\begin{pmatrix}<br>h_{k + 1} \\<br>\vdots \\<br>h_4 \\<br>h_3 \\<br>h_2<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\lambda h_k \\<br>\vdots \\<br>\lambda h_3 \\<br>\lambda h_2 \\<br>\lambda h_1<br>\end{pmatrix}<br>$$<br>推广一下，$h_n = \lambda^{n - 1} h_1$，则<br>$$<br>\begin{aligned}<br>h_{k + 1} &amp;= f_1h_{k -1} + f_2h_{k - 2} + … + f_kh_1 \\<br>\lambda^kh_1 &amp;= f_1\lambda^{k - 1}h_1 + f_2\lambda^{k - 2}h_2 + … + f_kh_1 \\<br>\lambda^k &amp;= f_1\lambda^{k - 1} + f_2\lambda^{k - 2} + … + f_k<br>\end{aligned}<br>$$<br>将 $\lambda$ 替换为 $x$，则有 $F(x) = x^k - f_1x^{k - 1} - f_2x^{k - 2} - … - f_k$</p><p>此时 $F(x)$ 就是矩阵 $A$ 的特征多项式，有 $F(A) = 0$</p><p>考虑等式<br>$$<br>x^n = F(x)Q(x) + R(x)<br>$$<br>以 $A$ 代入，则有<br>$$<br>A^n = R(A)<br>$$<br>别忘了现在要求的是 $A^n\vec v$，那么两边同乘 $\vec v$，有 $A^n\vec v = R(A)\vec v$</p><p>$R(x)$ 可以通过由 $A(x) = x^n$ 对 $F(x)$ 取模求得，注意此时不能直接取模，因为 $n$ 可以非常大（比如 $n = 1e9）$，无法存下多项式 $x^n$，需要通过快速幂求解</p><p>设 $R(x) = \sum\limits_{i = 0}^{k - 1} c_ix^i$，则<br>$$<br>A^n\vec v = \sum\limits_{i = 0}^{k - 1}c_iA^i\vec v<br>$$<br>而 $A^i\vec v$ 实际上就是<br>$$<br>\begin{pmatrix}<br>h_{k + i} \\<br>\vdots \\<br>h_{i + 3} \\<br>h_{i + 2} \\<br>h_{i + 1}<br>\end{pmatrix}<br>$$<br>$A$ 的次数最多 $k - 1$，也就是说最多只会取到前 $2k - 1$ 个 $h_i$，我们最后要取得是 $A^n\vec v$ 的第一位，每次乘上一个 $A$ 则令 $h$ 数组向下移一位，那么最终答案即为 $ans = \sum\limits_{i = 0}^{k - 1} c_ih_i$</p><p>时间复杂度 $O (k \log k \log n)$</p><p>其实每次在求多项式取模的时候都是对 $F(x)$ 取模，所以可以提前对 $F(x)$ 预处理，求出其逆，那么可以少很多常数（虽然我的常数还是贼大就是了。。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">32000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;, limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL A[MAXN], B[MAXN], O[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(LL* X, LL* Y, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm, <span class="keyword">int</span> rst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= fn + fm; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn; i ++) A[i] = X[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fm; i ++) B[i] = Y[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = A[i] * B[i] % MOD;</span><br><span class="line">NTT (A, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rst; i ++) X[i] = A[i] * invn % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = rst + <span class="number">1</span>; i &lt;= fn + fm; i ++) X[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123; a[<span class="number">0</span>] = power (O[<span class="number">0</span>], MOD - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= deg &lt;&lt; <span class="number">1</span>; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) A[i] = O[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++) B[i] = a[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) a[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL R[MAXN], INVG[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prep</span> <span class="params">(LL* G, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) O[i] = G[i];</span><br><span class="line">reverse (O, O + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= m; i ++) O[i] = <span class="number">0</span>;</span><br><span class="line">inverse (n - m + <span class="number">1</span>, INVG);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyMod</span> <span class="params">(LL* F, LL* G, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123; <span class="comment">// F mod G = R</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) R[i] = F[i];</span><br><span class="line">reverse (R, R + n + <span class="number">1</span>); mul (R, INVG, n, n - m + <span class="number">1</span>, n);</span><br><span class="line">reverse (R, R + n - m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i ++) R[i] = <span class="number">0</span>;</span><br><span class="line">mul (R, G, n - m, m, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) R[i] = (F[i] - R[i] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123; F[i] = i &lt; m ? R[i] : <span class="number">0</span>; R[i] = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, L;</span><br><span class="line">LL F[MAXK]= &#123;<span class="number">0</span>&#125;, h[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL X[MAXN]= &#123;<span class="number">0</span>&#125;, ANS[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPow</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// X ^ p (mod F)</span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) &#123; mul (ANS, X, K - <span class="number">1</span>, K - <span class="number">1</span>, L); PolyMod (ANS, F, L, K); &#125;</span><br><span class="line">mul (X, X, K - <span class="number">1</span>, K - <span class="number">1</span>, L); PolyMod (X, F, L, K);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum (); L = (K - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++) F[K - i] = (MOD - getnum () % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) h[i] = getnum () % MOD;</span><br><span class="line">F[K] = X[<span class="number">1</span>] = ANS[<span class="number">0</span>] = <span class="number">1</span>; prep (F, L, K);</span><br><span class="line">PolyPow (N);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) ans = (ans + ANS[i] * h[i] % MOD + MOD) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常系数非齐次线性递推"><a href="#常系数非齐次线性递推" class="headerlink" title="常系数非齐次线性递推"></a>常系数非齐次线性递推</h2><p>求一个满足 $k$ 阶齐次线性递推数列 $h_i$ 的第 $n$ 项，即<br>$$<br>h_n = P(n) + \sum\limits_{i = 1}^k f_i \times h_{n - i}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷4233 - 射命丸文的笔记</title>
      <link href="/2020/08/04/%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/04/%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>显然答案是总哈密顿回路数除以值得记录的竞赛图数</p><p>那么先求解总哈密顿回路数，考虑每个哈密顿回路会在几个值得记录的竞赛图中，则有<br>$$<br>Hamitons = (n - 1)!2^{C_n^2 - n}<br>$$<br>即总共有 $(n - 1)!$ 种哈密顿回路，然后剩下的边随便选</p><p>于是现在考虑值得记录的竞赛图数</p><p>首先如果一个竞赛图要有哈密顿回路，那么它至少要有一个包含所有节点的环，即该图是强连通的，并且显然非强连通竞赛图它一定不存在哈密顿回路，所以有结论</p><blockquote><p>有且仅有强连通竞赛图存在哈密顿回路</p></blockquote><p>那么问题转化为求解强连通竞赛图</p><p>发现正面难以求解，就考虑反面求解</p><p>设 $f_n$ 表示 $n$ 个节点的强连通竞赛图数，$g_n$ 表示 $n$ 个节点的竞赛图数（即 $2^{C_n^2}$），可得 $DP$ 方程<br>$$<br>f_n = g_n - \sum\limits_{j = 1}^{n - 1} f_jg_{n - j}\dbinom{n}{j}<br>$$<br>其中求解非强连通竞赛图部分是每次将拓扑序最小的强连通分量提取出来计数，那么剩下的点随意连接（注意，此时取的是<strong>拓扑序最小的强联通分量</strong>，故该强联通分量与其它连通分量的连边方向是固定的）</p><p>现在考虑优化<br>$$<br>\frac{f_n}{n!} = \frac{g_n}{n!} - \sum\limits_{j = 1}^{n - 1} \frac{f_j}{j!}\frac{g_{n - j}}{(n - j)!}<br>$$</p><p>令指数型生成函数 $F(x) = \sum\limits_n^{\infty} \frac{f_n}{n!}, G(x) = \sum\limits_n^{\infty} \frac{g_n}{n!}$，易知<br>$$<br>\begin{aligned}<br>F(x) &amp;= G(x) - F(x)G(x) \\<br>F(x) &amp;= \frac{G(x)}{1 + G(x)}<br>\end{aligned}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span> <span class="params">(LL* a, <span class="keyword">int</span> limit, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL omega = power (inv == <span class="number">1</span> ? g : invg, <span class="number">1l</span>l * (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL a1[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, a2[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* A, LL* B, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> limit, lim;</span><br><span class="line"><span class="keyword">for</span> (limit = <span class="number">1</span>, lim = <span class="number">0</span>; limit &lt; n + m; limit &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">a1[i] = A[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">a2[i] = B[i];</span><br><span class="line">DFT (a1, limit, <span class="number">1</span>), DFT (a2, limit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a1[i] * a2[i] % MOD;</span><br><span class="line">DFT (a1, limit, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (limit, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">A[i] = a1[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL temp[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* A, LL* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">temp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">temp[i] = A[i];</span><br><span class="line">NTT (temp, B, deg, deg), NTT (temp, B, deg, deg);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">B[i] = (<span class="number">2l</span>l * B[i] % MOD - temp[i] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL F[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL G[MAXN]= &#123;<span class="number">0</span>&#125;, invG[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL answer[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">F[i] = G[i] = power (<span class="number">2l</span>l, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * power (fact[i], MOD - <span class="number">2</span>);</span><br><span class="line">G[<span class="number">0</span>] ++;</span><br><span class="line">inverse (N, G, invG);</span><br><span class="line">NTT (F, invG, N, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">answer[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">answer[i] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">answer[i] = fact[i - <span class="number">1</span>] * power (<span class="number">2l</span>l, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) / <span class="number">2l</span>l - i) % MOD * power (F[i] * fact[i] % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导数与积分</title>
      <link href="/2020/08/04/%E5%AF%BC%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/"/>
      <url>/2020/08/04/%E5%AF%BC%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><h3 id="平均变化率"><a href="#平均变化率" class="headerlink" title="平均变化率"></a>平均变化率</h3><p>函数 $y = f(x)$ 从 $x_1$ 到 $x_2$ 的平均变化率为 $\frac{f(x_2) - f(x_1)}{x_2 - x_1}$，简记作 $\frac{\Delta y}{\Delta x}$</p><h3 id="瞬时变化率与导数"><a href="#瞬时变化率与导数" class="headerlink" title="瞬时变化率与导数"></a>瞬时变化率与导数</h3><p>函数 $y = f(x)$ 在 $x = x_0$ 处的瞬时变化率是函数 $f(x)$ 从 $x_0$ 到 $x_0 + \Delta x$ 的平均变化率在 $\Delta x \to 0$ 时的极限，记作 $\lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x)}{\Delta x} = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}$</p><p>一般地，我们称上文的瞬时变化率为函数 $y = f(x)$ 在 $x = x_0$ 处的导数，记作 $f’(x_0)$ 或 $\frac{\mathrm{d} y}{\mathrm{d} x} \bigg|_{x = x_0}$</p><p>实际上，导数描述的即为任何事物的瞬时变化率</p><p>Example：</p><p>求 $y = f(x) = x^2 - 7x + 5$ 在 $x = 2$ 的导数，则有<br>$$<br>\begin{aligned} \frac{\Delta y}{\Delta x} &amp;= \frac{f(2 + \Delta x) - f(2)}{\Delta x} \\ &amp;= \Delta x - 3  \end{aligned}<br>$$<br>所以<br>$$<br>f’(2) = \lim\limits_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim\limits_{\Delta x \to 0} (\Delta x - 3) = - 3<br>$$</p><h3 id="常见的基本初等函数的导数公式"><a href="#常见的基本初等函数的导数公式" class="headerlink" title="常见的基本初等函数的导数公式"></a>常见的基本初等函数的导数公式</h3><table><thead><tr><th align="center">$f(x)$</th><th align="center">$f’(x)$</th><th align="center">$f(x)$</th><th align="center">$f’(x)$</th></tr></thead><tbody><tr><td align="center">$c$</td><td align="center">$0$</td><td align="center">$x^a$</td><td align="center">$ax^{a - 1}$</td></tr><tr><td align="center">$\sin x$</td><td align="center">$\cos x$</td><td align="center">$\cos x$</td><td align="center">$- \sin x$</td></tr><tr><td align="center">$a^x$</td><td align="center">$a^x \ln a$</td><td align="center">$e^x$</td><td align="center">$e^x$</td></tr><tr><td align="center">$\log_a x$</td><td align="center">$\frac{1}{x \ln a}$</td><td align="center">$\ln x$</td><td align="center">$\frac{1}{x}$</td></tr><tr><td align="center">$\tan x$</td><td align="center">$\sec^2 x = \frac{1}{\cos^2 x}$</td><td align="center">$\cot x$</td><td align="center">$- \csc^2 x = - \frac{1}{\sin^2 x}$</td></tr></tbody></table><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p>$$<br>[f(x) \pm g(x)]’ = f’(x) \pm g’(x) \\<br>[cf(x)]’ = cf’(x) \\<br>[f(x) \cdot g(x)]’ = f’(x)g(x) + f(x)g’(x) \\<br>[\frac{f(x)}{g(x)}]’ = \frac{f’(x)g(x) - f(x)g’(x)}{[g(x)]^2}<br>$$</p><p>复合函数 $y = f(g(x))​$ 的导数和函数 $y = f(u), u = g(x)​$ 的导数间的关系为 $y_x’ = y_u’ \cdot u_x’​$，即 $y​$ 对 $x​$ 的导数，等于 $y​$ 对 $u​$ 的导数与 $u​$ 对 $x​$ 的导数的乘积</p><p>Example：</p><p>对 $y = cos^2 \left(2x + \frac{\pi}{3}\right)$ 求导<br>$$<br>这个复合函数是 f(x) = x^2 套 f(x) = \cos x 套 f(x) = 2x + \frac{\pi}{3} \\<br>容易得到 y’ = -4\sin (2x + \frac{\pi}{3})\cos (2x + \frac{\pi}{3}) \\<br>则有 y’ = -2\sin (4x + \frac{2\pi}{3})<br>$$</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>如果有函数自变量个数大于一，如<br>$$<br>f(x, y) = x^2 + xy + y^2<br>$$<br>那么可以固定一个平面，如 $x$ 平面，那么 $f(x, y)$ 可以看作是关于 $y$ 的参数函数 $f_x(y)$，也就是说每个 $x$ 定义了一个一元函数 $f_x(y)$</p><p>比如现在令 $x = a$，则有<br>$$<br>f_a(y) = a^2 + ay + y^2<br>$$<br>对其求导，则有<br>$$<br>f’_a(y) = a + 2y<br>$$<br>那么对于所有 $x$ 的取值，定义<br>$$<br>\frac{\partial f}{\partial y}(x, y) = x + 2y<br>$$<br>这就是 $f$ 关于 $y$ 的偏导数</p><p>那么对于多元函数 $f(x_1, x_2, …, x_n)$ 在点 $(a_1, a_2, …, a_n)$ 关于 $x_k$ 的偏导数定义为<br>$$<br>\frac{\partial f}{\partial x_k}(a_1, …, a_n) = \lim\limits_{\Delta x_k \to -} \frac{f(a_1, …, a_k + \Delta x_k, …, a_n) - f(a_1, …, a_n)}{\Delta x_k}<br>$$<br>这就做到了偏导数通过一元函数进行计算</p><p>这说明<br>$$<br>\frac{\partial f}{\partial x_k}(a_1, …, a_n) = \frac{\mathrm{d} f(a_1, …, a_{k - 1}, a_{k + 1}, …, a_n)}{\mathrm{d} x_k}(a_1, …, a_n)<br>$$</p><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><h4 id="二阶导数"><a href="#二阶导数" class="headerlink" title="二阶导数"></a>二阶导数</h4><p>如何函数的导数 $f’(x)$ 在 $x$ 处可导，则称 $[f’(x)]’$ 为 $x$ 的二阶导数</p><h4 id="高阶导数-1"><a href="#高阶导数-1" class="headerlink" title="高阶导数"></a>高阶导数</h4><p>那么高阶导数的定义即为二阶导数的扩展</p><p>$n$ 阶导数记作 $f^{(n)}(x), y^{(n)}, \frac{\mathrm{d}^ny}{\mathrm{d}x^n}$ 或 $\frac{\mathrm{d}^nf(x)}{\mathrm{d}x^n}$</p><h4 id="高阶导数求导法则"><a href="#高阶导数求导法则" class="headerlink" title="高阶导数求导法则"></a>高阶导数求导法则</h4><p>$$<br>\frac{\mathrm{d}^n}{\mathrm{d}^nx^n}(cu) = c\frac{\mathrm{d}}{\mathrm{d}x^n}u \\<br>\frac{\mathrm{d}^n}{\mathrm{d}x^n}(u \pm v) = \frac{\mathrm{d}^n}{\mathrm{d}x^n}u \pm \frac{\mathrm{d}^n}{\mathrm{d}x^n}v \\<br>\frac{\mathrm{d}^n}{\mathrm{d}x^n}(u \times v) = \sum\limits_{k = 0}^n \dbinom{n}{k}\frac{\mathrm{d}^{d - k}}{\mathrm{d}x^{d - k}}u\frac{\mathrm{d^k}}{\mathrm{d}x^k}v 「莱布尼兹公式」<br>$$</p><h4 id="常用高阶导数公式"><a href="#常用高阶导数公式" class="headerlink" title="常用高阶导数公式"></a>常用高阶导数公式</h4><p>$$<br>(x^{\alpha})^{(n)} = x^{\alpha - n} \prod\limits_{k = 0}^{n - 1}(\alpha - k) \\<br>(\frac{1}{x})^{(n)} = (- 1)^n\frac{n!}{x^{n + 1}} \\<br>(\ln x)^{(n)} = (- 1)^{n - 1}\frac{(n - 1)!}{x^n} \\<br>(e^x)^{(n)} = e^x \\<br>(a^x){(n)} = a^x \cdot \ln^n a (a &gt; 0) \\<br>(\sin (kx + b))^{(n)} = k^n\sin (kx + b + \frac{n\pi}{2}) \\<br>(\cos (kx + b))^{(n)} = k^n\cos (kx + b + \frac{n\pi}{2})<br>$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><p>函数 $f(x)$ 在区间 $[a, b]$ 上连续，用分点 $a = x_0 &lt; x_1 &lt; … &lt; x_{i - 1} &lt; x_i &lt; … &lt; x_n = b$，在每个小区间 $[x_{i - 1}, x_i]$ 上人去一点 $\xi (i = 1, 2, …, n)$，作和式 $S_n = \sum\limits_{i = 1}^n f(\xi_i)\Delta x = \sum\limits_{i = 1}^n \frac{b - a}{n} f(\xi_i)$，当 $n \to \infty$ 时，和式无限接近的常数被称作函数 $f(x)$ 在区间 $[a, b]$ 上的定积分，记作 $\int_a^b f(x) \mathrm{d} x = \lim\limits_{n \to \infty} \sum\limits_{i = 1}^n \frac{b - a}{n} f(\xi_i)$ ，$a, b$ 分别称作积分下限与积分上限，区间 $[a, b]$ 称作积分区间，$f(x)$ 称作被积函数，$x$ 称作积分变量，$f(x)\, \mathrm{d} x$ 称作积式</p><p>其几何意义表示由直线 $x = a, x = b, y = 0​$ 及曲线 $y = f(x)​$ 所围成的曲边梯形面积</p><p>当 $x \in [a, b]​$ 时，若 $f(x) &lt; 0​$，则直线 $x = a, x = b, x​$ 轴和曲线 $f(x)​$ 围成的图形的面积应为 $- \int_a^b f(x) \mathrm{d} x​$</p><h4 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h4><p>$$<br>\int_a^b kf(x) \mathrm{d} x = k\int_a^b f(x) \mathrm{d} \\<br>\int_a^b[f_1(x) \pm f_2(x)] \mathrm{d} x = \int_a^b f_1(x) \mathrm{d} x \pm \int_a^b f_2(x) \mathrm{d} x \\<br>\int_a^b f(x) \mathrm{d} = \int_a^c f(x) \mathrm{d} x + \int_c^b f(x) \mathrm{d} x (其中 a &lt; c &lt; b)<br>$$</p><h3 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h3><p>一般地，如果 $f(x)$ 是区间 $[a, b]$ 上的连续函数，并且 $F’(x) = f(x)$，那么<br>$$<br>\int_a^b f(x) \mathrm{d} x = F(x) \big|_a^b = F(b) - F(a)<br>$$</p><h3 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h3><p>不定积分实际上就是 $f(x)$ 的原函数 $F(x)$，$F(x)$ 也被称作 $f(x)$ 的不定积分</p><p>函数族 $f = \{F(x) + C | C \in \mathbb{R}\}​$ 称为函数 $f = k​$ 的原函数族，也就是 $f = k(x)​$ 的所有可能的原函数的集合，其中 $f = C​$ 称作积分常数，是 $f = k(x)​$ 经过垂直平移得到的一组常数「因为不管怎么样对于每个 $x​$ 它们的导数是相同的」</p><h3 id="常见不定积分公式表"><a href="#常见不定积分公式表" class="headerlink" title="常见不定积分公式表"></a>常见不定积分公式表</h3><table><thead><tr><th align="center">$\int_a^b c \mathrm{d}x = cx \mid_a^b$</th></tr></thead><tbody><tr><td align="center">$\int_a^b x^n \mathrm{d}x = \frac{1}{n + 1}x^{n + 1} \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \frac{1}{x} \mathrm{d}x = \ln x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \sin x \mathrm{d}x = - \cos x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \cos x \mathrm{d}x = \sin x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b e^x \mathrm{d}x = e^x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b a^x \mathrm{d}x = \frac{a^x}{\ln a} \mid_a^b$ $(a &gt; 0$ 且 $a \neq 1)$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串类题记录</title>
      <link href="/2020/08/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><h3 id="在文本串中寻找子串"><a href="#在文本串中寻找子串" class="headerlink" title="在文本串中寻找子串"></a>在文本串中寻找子串</h3><p>在文本串 $T$ 中寻找模式串 $S$，那么 $S$ 一定是 $T$ 的某个后缀的前缀，后缀排序后，在 $SA$ 中二分 $S$ 的位置，每次 $check$ 比较时间 $O (|S|)$，总时间复杂度 $O (|S| \log |T|)$</p><h3 id="比较两个子串的大小关系"><a href="#比较两个子串的大小关系" class="headerlink" title="比较两个子串的大小关系"></a>比较两个子串的大小关系</h3><p>比较 $S$ 的子串 $A = S[l_1…r_1], B = S[l_2…r_2]$ 的大小关系</p><p>若 $lcp (l_1, l_2) \ge \min (|A|, |B|)$，则 $A &lt; B \Longleftrightarrow |A| &lt; |B|$，反之 $A &lt; B \Longleftrightarrow rk_{l_1} &lt; rk_{l_2}$</p><h3 id="本质不同子串数目"><a href="#本质不同子串数目" class="headerlink" title="本质不同子串数目"></a>本质不同子串数目</h3><p>设字符串 $S$ 长度为 $n$</p><p>$ans = \frac{n(n + 1)}2 - \sum\limits_{i = 2}^n height[i]$</p><h3 id="从字符串首或尾取字符构成最小字典序的字符串"><a href="#从字符串首或尾取字符构成最小字典序的字符串" class="headerlink" title="从字符串首或尾取字符构成最小字典序的字符串"></a>从字符串首或尾取字符构成最小字典序的字符串</h3><p><a href="https://www.luogu.com.cn/problem/P2870" target="_blank" rel="noopener">[USACO07DEC]Best Cow Line G</a></p><p>最基本贪心，若两端字符不同，优先取大的，那么问题就在于两端相同</p><p>设 $pre_i, suf_i$ 分别表示字符串 $i$ 开始的前、后缀，那么每次只要比较 $pre_i$ 和 $suf_i$ 的大小就可以决定，但是这样是 $O (n^2)$ 的</p><p>考虑将反串隔一个特殊字符插在原串后，跑一边后缀数组，假设此时原串剩余 $[l, r]$ 没处理，那么只要比较 $SA[2n - l + 2]$ 和 $SA[r]$ 即可（串以 $1$ 为起始位置）</p><h3 id="判断字符串中是否存在某子串不重叠地出现了两次"><a href="#判断字符串中是否存在某子串不重叠地出现了两次" class="headerlink" title="判断字符串中是否存在某子串不重叠地出现了两次"></a>判断字符串中是否存在某子串不重叠地出现了两次</h3><p>二分子串长度 $L$，则 $height$ 数组能被分为若干满足段内 $height$ 数组大小都 $\ge L$ 的段，再利用 $RMQ$ 求出段内最大与最小的 $SA$ 值，判断其插值与 $L$ 的关系</p><h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = last, p = ++ m;</span><br><span class="line">last = p;</span><br><span class="line">len[p] = len[fa] + <span class="number">1</span>, subsize[p] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; ! tr[fa][c])</span><br><span class="line">tr[fa][c] = p, fa = father[fa];</span><br><span class="line"><span class="keyword">if</span> (! fa) &#123; father[p] = <span class="number">1</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; father[p] = x; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">len[np] = len[fa] + <span class="number">1</span>, father[np] = father[x];</span><br><span class="line">father[x] = father[p] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质不同子串个数"><a href="#本质不同子串个数" class="headerlink" title="本质不同子串个数"></a>本质不同子串个数</h3><p>建立后缀自动机，在 $parent$ 树上对所有状态 $u$，统计 $\sum\limits_u len(u) - fa(len(u))$ 即可</p><h3 id="所有不同子串的总长度"><a href="#所有不同子串的总长度" class="headerlink" title="所有不同子串的总长度"></a>所有不同子串的总长度</h3><p>建立后缀自动机，在 $parent$ 树上一个点 $u$ 代表的所有后缀的贡献为 $\frac{(1 + len(u))len(u)}2$，然后再减去 $fa(u)$ 相应的贡献即是其净贡献</p><h3 id="字典序第-k-大子串"><a href="#字典序第-k-大子串" class="headerlink" title="字典序第 $k$ 大子串"></a>字典序第 $k$ 大子串</h3><p><a href="https://www.luogu.com.cn/problem/P3975" target="_blank" rel="noopener">[TJOI2015]弦论</a></p><p>其中 $T$ 为 $0$ 则表示不同位置的相同子串算作一个，$T$ 为 $1$ 则表示不同位置的相同子串算作多个</p><p>咱按着路径来走，那么此时走到的每个状态对应唯一一个后缀，设 $sum_i$ 表示节点 $i$ 能够到达的所有子串个数，初始化 $sum_i$，若 $T = 0$ 则 $sum_i = 1$，若 $T = 1$ 则 $sum_i = size(i)$，然后再求个和，即 $sum_i += \sum\limits_c sum_{trans(i, c)}$</p><p>然后按位判断走一下就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">T == <span class="number">0</span> ? Size[i] = Sum[i] = <span class="number">1</span> : Sum[i] = Size[i];</span><br><span class="line">Size[<span class="number">1</span>] = Sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line"><span class="keyword">if</span> (Tree[Topo[i]][j])</span><br><span class="line">Sum[Topo[i]] += Sum[Tree[Topo[i]][j]];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= Size[x]) <span class="keyword">return</span> ;</span><br><span class="line">k -= Size[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = Tree[x][i];</span><br><span class="line"><span class="keyword">if</span> (! t) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; Sum[t]) &#123; k -= Sum[t]; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="built_in">putchar</span> (i + <span class="string">'a'</span>), print (t, k);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小循环移位"><a href="#最小循环移位" class="headerlink" title="最小循环移位"></a>最小循环移位</h3><blockquote><p>给定一个字符串 $S$，求其字典序最小的循环移位</p></blockquote><p>不难发现 $S + S$ 一定包含 $S$ 的最小循环移位，那么构造出 $S + S$ 的后缀自动机，然后贪心访问最小的字符即可</p><h3 id="模式串第一次出现的位置"><a href="#模式串第一次出现的位置" class="headerlink" title="模式串第一次出现的位置"></a>模式串第一次出现的位置</h3><blockquote><p>给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）</p></blockquote><p>设 $firstpos(i)$ 表示状态 $i$ 代表后缀第一次出现的位置</p><p>在 $parent$ 树上考虑，显然底层节点的 $endpos$ 一定是唯一的，那么它们的 $firstpos$ 也可直接确定，那么对一个不在底层的状态 $i$，有 $firstpos(i) = \min\limits_{j \cap fa(j) = i}\{firstpos(j)\}$</p><p>实际上上述过程可以在构造时做完（以下操作前提为 $T$ 位置编号从 $1$ 开始）</p><p>在新加入一个点 $p$ 时，有 $firstpos(p) = len(p)$</p><p>在将节点 $q$ 复制到 $np$ 时，有 $firstpos(np) = \min(firstpos(q), firstpos(p)) = firstpos(q)$</p><p>令 $t$ 表示 $P$ 在 $T$ 中走到的状态，那么答案便为 $firstpos(t) - |P| + 1$</p><h3 id="最短的没有出现过的字符串"><a href="#最短的没有出现过的字符串" class="headerlink" title="最短的没有出现过的字符串"></a>最短的没有出现过的字符串</h3><blockquote><p>给定一个字符串 $S$ 和一个特定的字符集 $M$，我们要找一个长度最短的由 $M$ 中字符构成的没有在 $S$ 中出现过的字符串</p></blockquote><p>在后缀自动机上动态规划，令 $f_u$ 表示已经处理了一段子串，当前在状态 $u$，为找到不连续转移还需要添加的最少字符数量，转移也比较简单<br>$$<br>f_u = 1 + \min\limits_{c \in M \cap trans(u, c) \in SAM} f_{trans(u, c)}<br>$$<br>那么最终答案为 $f_0$，输出字符串则逆推回去即可</p><h3 id="两个字符串的最长公共子串"><a href="#两个字符串的最长公共子串" class="headerlink" title="两个字符串的最长公共子串"></a>两个字符串的最长公共子串</h3><blockquote><p>给定字符串 $S$ 和 $T$，求它们的最长公共子串</p></blockquote><p>对 $S$ 构造后缀自动机</p><p>对 $T$ 的每个前缀，设当前前缀 $[1, i]$，求出该前缀的在 $S$ 上的最长后缀长度 $l_i$，那么答案即为 $\max\limits_i \{l_i\}$</p><p>将每个前缀放在后缀自动机上跑，设当前前缀 $i$ 最终走到状态 $u$，那么现在扩展到前缀 $i + 1$，多出字符 $T_{i + 1} = c$，有两种情况</p><ul><li>如果存在 $trans(u, c)$，那么 $u = trans(u, c), l_{i + 1} = l_i + 1$</li><li>如若不然，则在后缀自动机找到前缀 $i$ 第一个点 $p$，使其满足 $trans (p, c)$ 存在，就是 $p$ 在 $parent$ 上是 $u$ 的祖先，同时 $l_{i + 1} = len(p)$，如果最终找不到，那就返回源点，同时 $l_{i + 1} = 0$</li></ul><p>$l_n$ 最多为 $|T|$，而每位又最多被删一次，故最终时间复杂度 $O (|S| + |T|)$</p><h3 id="多个字符串间的最长公共子串"><a href="#多个字符串间的最长公共子串" class="headerlink" title="多个字符串间的最长公共子串"></a>多个字符串间的最长公共子串</h3><blockquote><p>给定 $k$ 个字符串 $S$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$</p></blockquote><p><a href="https://www.spoj.com/problems/LCS2/" target="_blank" rel="noopener">Longest Common Substring II</a></p><p>这和求两个的实际上是差不多的</p><p>先对第一个字符串建一个后缀自动机，剩下的串在上面匹配</p><p>对于每个节点 $i$，设 $mx_i$ 表示当前匹配串走到状态 $i$ 可匹配的最长长度，$pl_i$ 表示走到状态 $i$ 的所有串在该处留下的最长匹配长度的最小值</p><p>当然 $mx_i$ 要先对它的子树的所有 $mx$ 取一个最大值，这样方便统计答案</p><p>那么最后答案便是 $\max\limits_i \{pl_i\}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (~ <span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>)) &#123;</span><br><span class="line">n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; ! tr[p][c])</span><br><span class="line">p = father[p], l = len[p];</span><br><span class="line"><span class="keyword">if</span> (! p) p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l ++, p = tr[p][c];</span><br><span class="line">mx[p] = max (mx[p], l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> x = topo[i];</span><br><span class="line">pl[x] = min (pl[x], mx[x]);</span><br><span class="line">mx[father[x]] = max (mx[father[x]], min (len[father[x]], mx[x]));</span><br><span class="line">mx[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) ans = max (ans, pl[i]);</span><br></pre></td></tr></table></figure><p>对另外一种方法，就是把每个字符串隔一个不同的特殊字符拼在一起，然后把拼好的字符串拿去建后缀自动机的方法，本质上是一样的</p><h3 id="求两个字符串本质不同的的子串总数"><a href="#求两个字符串本质不同的的子串总数" class="headerlink" title="求两个字符串本质不同的的子串总数"></a>求两个字符串本质不同的的子串总数</h3><blockquote><p>给定字符串 $S$ 和 $T$，并给定 $l, r$，求 $T$ 中不在 $S[l…r]$ 内出现的子串个数</p></blockquote><p><a href="https://www.luogu.com.cn/problem/P4770" target="_blank" rel="noopener">[NOI2018]你的名字</a></p><p>先考虑 $l = 1, r = |T|$ 的情况：</p><p>因为任意子串为字符串前缀的某些后缀，那么令 $lim[i]$ 表示 $T[1…i]$ 在 $S$ 上所能匹配的最大长度，$posi[i]$ 表示$T$的后缀自动机上的点 $i$ 的 $endpos$ 集合中最靠前的位置，那么答案即为<br>$$<br>ans = \sum\limits_i \max (0, len(i) - min (len(fa(i)), lim[posi[i]]))<br>$$<br>其中 $i$ 枚举 $T$ 后缀自动机中的所有点</p><p>接下来考虑 $l, r$ 任意的情况：</p><p>原来能否在 $S$ 的后缀自动机上往下走的判断依据只有当前节点是否存在 $c$ 边，那么有了 $l, r$ 的限制，就多需要判断向下的这个节点的 $endpos$ 是否有存在于 $[l + len, r]$（$len$ 表示已匹配长度）区间的位置，$endpos$ 集合用动态开点线段树维护一下就好了</p><p><a href="https://colythme.github.io/2020/07/01/[NOI2018]你的名字/">代码</a></p><h3 id="求所有长度为-k-的子串的最大出现次数"><a href="#求所有长度为-k-的子串的最大出现次数" class="headerlink" title="求所有长度为 $k$ 的子串的最大出现次数"></a>求所有长度为 $k$ 的子串的最大出现次数</h3><blockquote><p>给定字符串 $S$，求 $S$ 中长度为 $k = 1…n$ 的子串的最大出现次数（对每个 $k$ 单独考虑）</p></blockquote><p>考虑对某个 $k$，显然对它有贡献的只可能是 $minlen(i) \le k \le maxlen(i)$ 的所有状态 $i$</p><p>直接算的话得建棵线段树，实际上对某个子串，它的贡献一定是它自己直接给出贡献或是将它作为后缀的子串给出的，所以每次只需在 $maxlen(i)$ 处标记一下，然后再 $parent$ 树上对子树所有的贡献取 $max$ 就好了</p><h3 id="广义后缀自动机"><a href="#广义后缀自动机" class="headerlink" title="广义后缀自动机"></a>广义后缀自动机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> last, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = last;</span><br><span class="line"><span class="keyword">if</span> (tr[fa][c]) &#123; <span class="comment">// 与单串后缀自动机不同处</span></span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; subsize[x][id] = <span class="number">1</span>; <span class="keyword">return</span> x; &#125; <span class="comment">// 特判一</span></span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">father[np] = father[x], len[np] = len[fa] + <span class="number">1</span>;</span><br><span class="line">father[x] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line">subsize[np][id] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> np; <span class="comment">// 特判二</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = ++ m;</span><br><span class="line">len[p] = len[fa] + <span class="number">1</span>, subsize[p][id] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; ! tr[fa][c])</span><br><span class="line">tr[fa][c] = p, fa = father[fa];</span><br><span class="line"><span class="keyword">if</span> (! fa) &#123; father[p] = <span class="number">1</span>; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; father[p] = x; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">father[np] = father[x], len[np] = len[fa] + <span class="number">1</span>;</span><br><span class="line">father[p] = father[x] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line">last = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) last = append (str[j] - <span class="string">'a'</span>, last, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 $size$ 要对每个串分开存</p><h3 id="线段树合并维护广义后缀自动机-size"><a href="#线段树合并维护广义后缀自动机-size" class="headerlink" title="线段树合并维护广义后缀自动机 $size$"></a>线段树合并维护广义后缀自动机 $size$</h3><p><a href="http://codeforces.com/problemset/problem/666/E" target="_blank" rel="noopener">Forensic Examination</a></p><blockquote><p>给你一个串 $S$ 以及 $m$ 个字符串数组 $T_1, T_2, …, T_m$，$q$ 次询问，每次问 $S$ 的子串 $S[p_l…p_r]$ 在 $T_l, …, T_r$ 中的哪个串里的出现次数最多，并输出出现次数。如有多解输出最靠前的那一个</p></blockquote><p>对所有串建立广义后缀自动机，开一棵区间为 $[1, m]$ 的线段树，将每个状态的 $size$ 存下来（类似 $\text{modify} (rt[p], 1, m, id)$，其中 $id$ 表示当前插入的是 $m$ 个字符串中的哪个，注意 $S$ 插入后缀自动机时就不用修改线段树了），并进行线段树合并</p><p>那么每次只要在 $parent$ 树上倍增跳到包含区间 $S[p_l…p_r]$ 的点，就可以直接统计其对应线段树 $[l, r]$ 区间的最大值（即它子树的答案）</p><h3 id="Parent-树上两点间距离"><a href="#Parent-树上两点间距离" class="headerlink" title="$Parent$ 树上两点间距离"></a>$Parent$ 树上两点间距离</h3><p><a href="https://www.luogu.com.cn/problem/P4248" target="_blank" rel="noopener">[AHOI2013]差异</a></p><blockquote><p>给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀，求 $\sum\limits_{1 \le i &lt; j \le n} len(T_i) + len(T_j) - 2 \times LCP(T_i, T_j)$</p></blockquote><p>将串反过来，后缀的最长公共前缀就变成了前缀的最长公共后缀</p><p>以 $len(i) - len(fa(i))$ 作为状态 $i$ 在 $parent$ 树上到父亲的边权，那么原式就可以看作 $parent$ 树上两个前缀对应的点 $u, v$ 之间的路径长度</p><p>由于只有前缀状态的 $size$ 才可能被初始化为 $1$，那么对点 $i$ 到其父亲的边，其贡献即为 $w_i \times size(i) \times (n - size(i))$，对所有边求和即可</p>]]></content>
      
      
      <categories>
          
          <category> 归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 归纳 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求逆</title>
      <link href="/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/"/>
      <url>/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先定义多项式的度数 $degA$ 为多项式 $A(x)$ 的最高次数</p><p>那么多项式 $A(x)$ 的逆即为存在多项式 $B(x)$ 使得条件满足：<br>$$<br>A(x)B(x) \equiv 1 \pmod{x^n}<br>$$</p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><h3 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 $FFT$"></a>分治 $FFT$</h3><p>对 $A(x) = \sum\limits_{k = 0}^{n - 1} a_kx^k, B(x) = \sum\limits_{k = 0}^{n - 1} b_kx^k$</p><p>从常数项考虑，有 $b_0 = \frac1{a_0}$，则由 $\sum\limits_{k = 0}^n b_ka_{n - k} = 0$ 可得<br>$$<br>b_k = \sum\limits_{i = 0}^{k - 1} b_i\left(- \frac{a_{k - i}}{a_0}\right)<br>$$</p><h3 id="倍增迭代"><a href="#倍增迭代" class="headerlink" title="倍增迭代"></a>倍增迭代</h3><p>假设存在多项式 $A(x)$ ，以及其逆 $B(x)$ 满足条件 ，那么必定有$A(x)B(x) \equiv 1 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (1)$ ，因为 $x^n$ 是 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 的倍数</p><p>并且存在 $A(x)B’(x) \equiv 1 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (2)$</p><p>$(1) - (2)$ ，得<br>$$<br>\begin{aligned} B(x) - B’(x) &amp;\equiv 0 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (3) \\ B(x)^2 - 2B(x)B’(x) + B’(x)^2 &amp;\equiv 0 \pmod{x^n} \end{aligned}<br>$$<br>上一步解释一下，是两边平方</p><p>至于为什么模数也需要平方，是因为 $(3)$ 式满足左边的多项式在其模意义下为 $0$ ，且式子恒成立，故其除了第 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 项其余系数皆为 $0$ ，那么现在考虑 $0 \le x \le n - 1$ ，又因为 $a_i = \sum\limits_{j = 1}^i a_j b_{i - j}$ ，所以必定存在 $i$ 或者 $i - j$ 小于 $x^{\left\lceil\frac{n}{2}\right\rceil}$ ，故 $a_i = 0$ ，所以平方无妨</p><p>同乘 $A(x)$ ，移项，得<br>$$<br>B(x) \equiv 2B’(x) - A(x)B’(x)^2 \pmod{x^n}<br>$$<br>在递归过程中最后会递归到 $n = 1$ ，那么此时 $A(x)B’’(x) \equiv c \pmod{x}$ ，取 $c^{- 1}$ 就好了</p><p>那么再用 $FFT$ 优化就可以做到 $O (n \log n)$ 求解</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL f[MAXN], invf[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL A[MAXN]= &#123;<span class="number">0</span>&#125;, B[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL omega = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + k + mid] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* ps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">ps[<span class="number">0</span>] = power (f[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">Inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ps);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt; (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">A[i] = f[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++)</span><br><span class="line">B[i] = ps[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">ps[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">f[i] = getnum ();</span><br><span class="line">Inverse (N, invf);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, invf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 6 3 4 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">2 3 3 3 1233 211 23 3 3 322</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式操作</title>
      <link href="/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><p>该部分见 <a href="https://colythme.github.io/2020/07/01/多项式求逆/">多项式求逆</a></p><h2 id="多项式除法-取模"><a href="#多项式除法-取模" class="headerlink" title="多项式除法|取模"></a>多项式除法|取模</h2><p>有 $F(x) = G(x)Q(x) + R(x)$，给定 $F(x)$ 与 $G(x)$，求解 $Q(x), R(x)$，其中 $F(x), G(x)$ 最高次数分别为 $n, m$</p><p>显然地，$Q(x), R(x)$ 的最高次数必定不超过 $n - m, m - 1$，考虑式子变形<br>$$<br>\begin{aligned}<br>&amp;F(x) = G(x)Q(x) + R(x) \\<br>\Rightarrow &amp;F(\frac1x) = G(\frac1x)Q(\frac1x) + R(\frac1x) \\<br>\Rightarrow &amp;x^nF(\frac1x) = x^mG(\frac1x)x^{n - m}Q(\frac1x) + x^{n - m + 1}x^{m - 1}R(\frac1x) \\<br>\end{aligned}<br>$$<br>令 $A_R(x)$ 表示 $A(x)$ 系数翻转后得到的多项式，即 $A(x)$ 系数 $(a_0, a_1, …, a_n)$，$A_R(x)$ 系数 $(a_n, a_{n - 1}, …, a_1)$，有<br>$$<br>\begin{aligned}<br>\Rightarrow &amp;x^nF(\frac1x) = x^mG(\frac1x)x^{n - m}Q(\frac1x) + x^{n - m + 1}x^{m - 1}R(\frac1x) \\<br>\Rightarrow &amp;F_R(x) = G_R(x)Q_R(x) + x^{n - m + 1}R_R(x) \\<br>\Rightarrow &amp;F_R(x) \equiv G_R(x)Q_R(x) \pmod{x^{n - m + 1}} \\<br>\Rightarrow &amp;Q_R(x) \equiv \frac{F_R(x)}{G_R(x)}<br>\end{aligned}<br>$$<br>那么这样就可以求出 $Q(x)$，之后则有 $R(x) = F(x) - G(x)Q(x)$</p><p>时间复杂度 $O (n \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;, limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL A[MAXN], B[MAXN], f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(LL* X, LL* Y, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= fn + fm; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn; i ++) A[i] = X[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fm; i ++) B[i] = Y[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = A[i] * B[i] % MOD;</span><br><span class="line">NTT (A, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn + fm; i ++) X[i] = A[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123; a[<span class="number">0</span>] = power (f[<span class="number">0</span>], MOD - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) A[i] = f[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++) B[i] = a[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) a[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL F[MAXN], G[MAXN], INVG[MAXN];</span><br><span class="line">LL RF[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) RF[i] = F[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++) f[i] = G[i] = getnum ();</span><br><span class="line">reverse (RF, RF + N + <span class="number">1</span>); reverse (f, f + M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - M + <span class="number">2</span>; i &lt;= M; i ++) f[i] = <span class="number">0</span>;</span><br><span class="line">inverse (N - M + <span class="number">1</span>, INVG); mul (RF, INVG, N, N - M + <span class="number">1</span>);</span><br><span class="line">reverse (RF, RF + N - M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - M + <span class="number">1</span>; i &lt;= N; i ++) RF[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, RF[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">mul (RF, G, N - M, M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) RF[i] = (F[i] - RF[i] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, RF[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JOISC2017Day1」烟花棒</title>
      <link href="/2020/08/04/%E3%80%8CJOISC%202017%20Day%201%E3%80%8D%E7%83%9F%E8%8A%B1%E6%A3%92/"/>
      <url>/2020/08/04/%E3%80%8CJOISC%202017%20Day%201%E3%80%8D%E7%83%9F%E8%8A%B1%E6%A3%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $N$ 人站在一条数轴上。他们人手一个烟花，每人手中的烟花都恰好能燃烧 $T$ 秒。每个烟花只能被点燃一次。<br>$1$ 号站在原点，$i$ 号 $(1 \le i \le N)$ 到 $1$ 号的距离为 $X_i$。保证 $X_1 = 0$，$X_1, X_2, …, X_N$ <strong>单调</strong>递增（可能有人位置重叠）<br>开始时，$K$ 号的烟花刚开始燃烧，其他人的烟花均未点燃。他们的点火工具坏了，只能用燃着的烟花将未点燃的烟花点燃。当两人位置重叠且其中一人手中的烟花燃着时，另一人手中的烟花就可以被点燃。忽略点火所需时间。<br>求至少需要以多快的速度跑，才能点燃所有人的烟花（此时可能有些人的烟花已经熄灭了）。<strong>速度必须是一个非负整数</strong></p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对 $100\%$ 的数据，$1 \le K, N \le 10^5, ~ 1 \le T \le 10^9, ~ 0 \le X_i \le 10^9, ~ X_1 = 0$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很显然所有人一定会不断向拿烟花的人靠近</p><p>可以发现，一个拿烟花棒的人和另一个人相遇时，让另一个人跟着拿烟花的人走直至烟花在灭掉的瞬间将烟花传递的情况和在相遇时传递时一样的（注意相对位置，仔细想一下就可以证明）</p><p>也就是说，整个过程可以看作只有一个拿烟花的人，进一步推理可以发现，拿烟花的人和另一个人相遇等价于他的烟花燃烧时间加上 $T$（在最优情况下）</p><p>又两人相向而行时相对速度为 $2v$，那么对于一个区间 $[L, R]$，它满足条件的必要条件即是<br>$$<br>2vT(R - L) \ge x_R - x_L<br>$$<br>而我们从 $K$ 开始不断向两边扩展，使得每次扩展都满足条件，那么扩展到 $[L, R]$ 时，该条件便成为充要条件</p><p>对上式进行变换，有<br>$$<br>x_L - 2vTL \ge x_R - 2vTR<br>$$<br>不妨令 $a_i = x_i - 2vTi$，那么该条件便转化为 $a_L \ge a_R$</p><p>进行二分答案</p><p>在 $check$ 时进行贪心，贪心扩展当前所到区间 $[l, r]$，对 $l$，不断找到一个 $k$，使得 $a_k \ge a_l \cap k &lt; l \cap a_k \ge a_r$，对 $r$ 同理，最终会扩展到一个极大区间 $[ll, lr]$</p><p>若 $ll = 1 \cap lr = N$，那么就可以返回 $true$，如若不然，则观察当前情况</p><p>现在局面是 $l, r$ 不能继续往左右扩展，也就是 $l$ 往左不存在 $a_k \ge a_l$ 或 $a_k \ge a_r$，$r$ 往右不存在 $a_k \le a_r$ 或 $a_k \le a_l$，对不存在 $a_{k_1} \ge a_r \cup a_{k_2} \le a_l$ 的局面，显然就直接返回 $false$，那么对另一种局面，考虑 $l$ 往左，说明一段一段的最大值是递减的，但是不妨将其反过来，那不就和上面 $K$ 往两边扩展的情况一样了吗，$r$ 往右同理，那么现在要做的就是重新令 $l = 1, r = N$，然后向内缩，看能否缩到 $[ll, lr]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e09</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, T;</span><br><span class="line"><span class="keyword">int</span> X[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = X[i] - <span class="number">2l</span>l * v * T * i;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] &lt; a[N]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> l = K, r = K, ll = K, lr = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[ll])</span><br><span class="line">ll = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[lr])</span><br><span class="line">lr = i;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &gt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl - <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &lt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr + <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">1</span>, r = N;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &lt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl + <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &gt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr - <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum (), T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) X[i] = getnum ();</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = INF, ans;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (mid)) &#123; ans = mid; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「省选模拟赛」矩阵（matrix）</title>
      <link href="/2020/08/04/%5B%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B%5D%E7%9F%A9%E9%98%B5%EF%BC%88matrix%EF%BC%89/"/>
      <url>/2020/08/04/%5B%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B%5D%E7%9F%A9%E9%98%B5%EF%BC%88matrix%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $n*m$ 的 $01$ 矩阵，矩阵中 $k$ 个格子的数已经确定，你需要求出有多少种方案使得矩阵每行每列的异或和均为 $1$。对 $998244353$ 取模。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.org/upload/pic/53120.png" alt=""></p><hr><h3 id="Subtask-1"><a href="#Subtask-1" class="headerlink" title="Subtask 1"></a>Subtask 1</h3><p>暴力自不必说</p><h3 id="Subtask-2"><a href="#Subtask-2" class="headerlink" title="Subtask 2"></a>Subtask 2</h3><p>对于 $k = 0$ 的数据，如何做？</p><p>那么我们只要空出一列（或一行或是一行一列），让其它的格子随便填，因为不管怎么样，最后空出的这一列（行）总是可以将整行（列）的异或和变为 $1$</p><p>同理 $k &lt;= m$ 的数据找出一个全空的列就好了</p><h3 id="Subtask-3"><a href="#Subtask-3" class="headerlink" title="Subtask 3"></a>Subtask 3</h3><p>仿照 $Subtask  2$ 的思路，还是找出一个被限制的格子最少的列，令该列被限制的格子数为 $p$，考虑到 $k \le 10m$，故 $p \le 10$，那么对于其它列，只要关注这 $p$ 行以及它们本身列的异或和就好了</p><p>考虑使用 $DP$，设 $f_{i, j, k, state}$ 表示前 $i$ 列前 $j$ 行，目前该列的异或和为 $k$，那 $p$ 行的异或情况状压后为 $state$</p><p>复杂度 $O (nm2^{\frac{k}{m}})$</p><h3 id="Subtask-4"><a href="#Subtask-4" class="headerlink" title="Subtask 4"></a>Subtask 4</h3><p>因为状态数太多，考虑能够直接计算的状态数就直接消去</p><p>对于除了那 $p$ 行以外还存在不被限制的格子的列，可以空出一个格子，然后其它格子随便填，然后将这些列删去</p><p>在删去上述列之前，还要计算它们对于行的贡献</p><p>假设在 $p$ 行的其中一行，在上述列中该行总共有 $k$ 个空格，那么同理还是只要留出一个空格其它随便填，故答案要算上 $2^{k - 1}$</p><p>那么对于未删去的列只需考虑那 $p$ 行就可以了（因为其它行一定是被限制的），然后仿照 $Subtask  3$ 做 $DP$ 即可</p><p>复杂度 $O (\frac{k^2}{nm}2^{\frac{k}{m}})$</p><p>感觉整题就是将空一行算异或的思想完全贯彻的说</p><p>至于代码，感觉理论上那些存在空格的行 $DP$ 之后不管取其异或为 $0$ 或 $1$ 都是可以的（可惜因为写到心态爆炸然后就放弃了代码的说</p><p>（至于考场上连 $Subtask  2$ 都没想出来，只是瞎打了 $k = 0$ 的规律而且还有可能错的我感觉我好菜啊</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「清华集训2016」你的生命已如风中残烛（卡特兰数的另一种组合意义）</title>
      <link href="/2020/08/04/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%5D%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%EF%BC%88%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%EF%BC%89/"/>
      <url>/2020/08/04/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%5D%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%EF%BC%88%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将题意转化一下</p><p>有 $m = \sum\limits_{i = 1}^n w_i$ 个数，前 $n$ 个中第 $i$ 个为 $w_i − 1$ ，剩下的 $m − n$ 个数都是 $− 1$</p><p>求对这 $m$ 个数 $m!$ 种重排的方案中，有多少种满足重排后的序列任意前缀和不为负</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="卡特兰数的另一种组合意义"><a href="#卡特兰数的另一种组合意义" class="headerlink" title="卡特兰数的另一种组合意义"></a>卡特兰数的另一种组合意义</h3><p>首先有一个引理</p><ul><li>给定 $n$ 个 $1$ 和 $n$ 个 $- 1$，它们组成一个长度为 $2n$ 的序列 $a$，则必定存在一个 $i$ 使得序列 $a_{i + 1…2n} + a_{1…i}$ 满足任意前缀都不小于零</li><li>证明也很简单，找到一个使得前缀和最小的位置 $i$，设 $s_{i,j}$ 表示 $a$ 上 $a_i$ 到 $a_j$ 的和，那么显然 $s_{i + 1, 2n} \ge 0$，对 $\forall k \in [1, i]$，$s_{i + 1, 2n} + s_{1, k} \ge 0$</li></ul><p>那么接下来求解 $n$ 个 $1$ 和 $n$ 个 $- 1$ 组成的合法序列（即任意前缀和不小于零）的方案数，也就是卡特兰数</p><p>$1$ 的编号为 $1 \sim n$，$- 1$ 的编号为 $n + 1 \sim 2n$</p><p>现在先假定所有 $1$ 和 $- 1$ 都是有标号的，那么最后乘上一个 $\frac1{n!n!}$ 就好了</p><p>由于直接看 $2n$ 的环可以断的地方较多无法处理，故考虑在后面接上一个编号为 $2n + 1$ 的 $- 1$，那么现在问题就变成给定一个 $2n + 1$ 长度的环，断开其中一处 $- 1$，得到的序列前 $2n$ 项任意前缀和非负，前 $2n + 1$ 项前缀和为 $- 1$</p><p>那么和上面同样取一个使前缀和最小的位置 $i$（若有多个则取最小的那一个），可以证明 $i$ 使唯一的</p><p>就那取第二个为例，设取第二个使前缀和最小的位置为 $j$，那么有 $s_{j + 1, 2n + 1} + s_{1, j} = - 1$，即 $s_{j + 1, 2n + 1} + s_{1, i} = - 1$，这样子就已经不满足条件了</p><p>证明了唯一性，也就是说断开方式是唯一的</p><p>由于此时 $- 1$ 使有标号的，总共有 $n + 1$ 个 $- 1$，也就是说所有 $2n + 1$ 个元素组成的环中平均每 $n + 1$ 个环就存在一个满足条件的，那么就可以得到卡特兰数的通项<br>$$<br>Cat_n = \frac{\frac{(2n + 1)!}{2n + 1}}{(n + 1)(n!)^2} = \frac{\dbinom{2n}{n}}{n + 1}<br>$$</p><h3 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h3><p>同样的，这 $m$ 个数组成的序列同样也满足存在一个位置 $i$ 使得 $s_{i + 1, m} + s_{1, i}$ 不小于零</p><p>故也在该序列后面加入一个编号为 $m + 1$ 的 $- 1$，连成环后断环方式唯一</p><p>那么答案即为 $\frac{m!}{m - n + 1}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">n = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) m += getnum ();</span><br><span class="line">LL fact = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++) fact = fact * i % MOD;</span><br><span class="line">cout &lt;&lt; fact * power (m - n + 1, MOD - 2) % MOD &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 卡特兰数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「国家集训队」middle</title>
      <link href="/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5Dmiddle/"/>
      <url>/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5Dmiddle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一道其实很简单然而我还是瞄了题解的题</p><p>首先考虑二分答案</p><p>显然将小于 $mid$ 的赋为 $-1$，将大于等于 $mid$ 赋为 $1$</p><p>那么显然 $total =  $ $[q_1, q_2]$ 最长后缀 $+$ 中间必选 $+$ $[q_3, q_4]$ 最长前缀</p><p>然后若 $total \ge 0$ 则 $check (mid)$ 返回 $true$</p><p>很好然后我就不会处理了</p><p>于是题解就说将每个 $mid$ 建一棵线段树，然后用主席树就不会 $MLE$（好吧原来本来是想建序列上的主席树的说当然并不可行</p><p>那么每次 $check$ 就在 $mid$ 号版本上的树查询即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = MAXN * MAXLOG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], mapp[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">valueSt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> subsum;</span><br><span class="line">    <span class="keyword">int</span> lmax, rmax;</span><br><span class="line"></span><br><span class="line">    valueSt () &#123;</span><br><span class="line">        subsum = <span class="number">0</span>;</span><br><span class="line">        lmax = rmax = - INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> ctree[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> lson[MAXT]= &#123;<span class="number">0</span>&#125;, rson[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">valueSt value[MAXT];</span><br><span class="line"><span class="keyword">int</span> nodes = <span class="number">0</span>;</span><br><span class="line"><span class="function">valueSt <span class="title">maintain</span> <span class="params">(valueSt A, valueSt B)</span> </span>&#123;</span><br><span class="line">    valueSt res;</span><br><span class="line">    res.subsum = A.subsum + B.subsum;</span><br><span class="line">    res.lmax = max (A.lmax, A.subsum + B.lmax);</span><br><span class="line">    res.rmax = max (B.rmax, A.rmax + B.subsum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    root = ++ nodes;</span><br><span class="line">    value[root] = valueSt ();</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        value[root].subsum = value[root].lmax = value[root].rmax = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build (lson[root], left, mid);</span><br><span class="line">    build (rson[root], mid + <span class="number">1</span>, right);</span><br><span class="line">    value[root] = maintain (value[lson[root]], value[rson[root]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line">    root = ++ nodes;</span><br><span class="line">    lson[root] = lson[pre], rson[root] = rson[pre];</span><br><span class="line">    value[root] = value[pre];</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        value[root].subsum = value[root].lmax = value[root].rmax = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (posi &lt;= mid) update (lson[pre], lson[root], left, mid, posi);</span><br><span class="line">    <span class="keyword">else</span> update (rson[pre], rson[root], mid + <span class="number">1</span>, right, posi);</span><br><span class="line">    value[root] = maintain (value[lson[root]], value[rson[root]]);</span><br><span class="line">&#125;</span><br><span class="line">valueSt tans;</span><br><span class="line"><span class="comment">// 以下注意（以rmax为例）</span></span><br><span class="line"><span class="comment">// 由于query_sum是由左至右走，并且maintain中是取B的rmax或者将A与B合并</span></span><br><span class="line"><span class="comment">// 那么在query_sum中value[root]不可能作为B</span></span><br><span class="line"><span class="comment">// 故最终获得的tans.rmax的起始点一定为q[2]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sum</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">        tans = maintain (tans, value[root]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) query_sum (lson[root], left, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) query_sum (rson[root], mid + <span class="number">1</span>, right, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[<span class="number">2</span>] + <span class="number">1</span> &lt;= q[<span class="number">3</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">        tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">2</span>] + <span class="number">1</span>, q[<span class="number">3</span>] - <span class="number">1</span>);</span><br><span class="line">        total += tans.subsum;</span><br><span class="line">    &#125;</span><br><span class="line">    tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">1</span>], q[<span class="number">2</span>]);</span><br><span class="line">    total += tans.rmax;</span><br><span class="line">    tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">3</span>], q[<span class="number">4</span>]);</span><br><span class="line">    total += tans.lmax;</span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        a[i] = getnum (), mapp[i] = i;</span><br><span class="line">    sort (mapp + <span class="number">1</span>, mapp + N + <span class="number">1</span>, comp);</span><br><span class="line">    build (ctree[<span class="number">1</span>], <span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        ctree[i] = ctree[i - <span class="number">1</span>];</span><br><span class="line">        update (ctree[i - <span class="number">1</span>], ctree[i], <span class="number">1</span>, N, mapp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Q = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i ++)</span><br><span class="line">            q[i] = (getnum () + ans) % N + <span class="number">1</span>;</span><br><span class="line">        sort (q + <span class="number">1</span>, q + <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = N;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            check (mid) ? (ans = a[mapp[mid]], left = mid + <span class="number">1</span>) : right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">170337785</span></span><br><span class="line"><span class="comment">271451044</span></span><br><span class="line"><span class="comment">22430280</span></span><br><span class="line"><span class="comment">969056313</span></span><br><span class="line"><span class="comment">206452321</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 1 0 2</span></span><br><span class="line"><span class="comment">2 3 1 4</span></span><br><span class="line"><span class="comment">3 1 4 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「国家集训队」Crash的数字表格</title>
      <link href="/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5DCrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
      <url>/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5DCrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求 $\sum\limits_{i = 1}^N \sum\limits_{j = 1}^M lcm (i, j)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>易知，原式<br>$$<br>\sum\limits_{i = 1}^N \sum\limits_{j = 1}^M \frac{ij}{\gcd (i, j)}<br>$$<br>枚举 $\gcd (i, j)$ ，且将 $d$ 提出来得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij[(i, j) = 1]<br>$$<br>将公式 $\sum\limits_{k | n} \mu(k) = [n = 1]$ 代入，得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij \sum\limits_{k | (i, j)} \mu(k)<br>$$<br>套路枚举 $k$ ，得</p><p>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} \mu(k) \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij [k | (i, j)]<br>$$<br>那么 $ij$ 存在贡献时其必定是 $k$ 的倍数，故<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} \mu(k) \sum\limits_{ki = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{kj = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} k^2 ij<br>$$<br>将 $k$ 提出，得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} k^2 \mu(k) ( \sum\limits_{i = 1}^{\left\lfloor\frac{N}{kd}\right\rfloor} i) (\sum\limits_{j = 1}^{\left\lfloor\frac{M}{kd}\right\rfloor} j)<br>$$<br>那么就可以预处理 $\sum\limits_{k = 1}^n k^2 \mu(k)$ ，后面的用整除分块就好了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 20101009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e07</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_Acqu</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j]))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++)</span><br><span class="line">sum[i] = (sum[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * <span class="number">1l</span>l * i % MOD * mu[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">LL fn = (LL) n;</span><br><span class="line"><span class="keyword">return</span> (fn * (fn + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> limit = min (N, M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= limit; d ++) &#123;</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minlim = min (N / d, M / d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= minlim; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min ((N / d) / ((N / d) / l), (M / d) / ((M / d) / l));</span><br><span class="line">total = (total + (sum[r] - sum[l - <span class="number">1</span>] + MOD) % MOD * calc (N / d / l) % MOD * calc (M / d / l) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + (LL) (d) * total % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">prime_Acqu ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; M);</span><br><span class="line">LL ans = Solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「四校联考」密码</title>
      <link href="/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%AF%86%E7%A0%81/"/>
      <url>/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 行 $m$ 列的 $01$ 矩阵，求满足 $\big(\sum_{\forall i \in A, j \in B} value_{i, j}\big) \equiv 0 \pmod{2}$ 的二元组的数量</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑 $n = 1$，令 $1$ 的个数为 $t$，可以发现答案<br>$$<br>\sum\limits_{k = 0}^{\lfloor\frac{m}{2}\rfloor} \dbinom{t}{2k} \times 2^{m - t} - 1 = 2^{m - 1} - 1<br>$$<br>至于证明，可以考虑已经选好的数列 $\{a_1, a_2, …, a_n\}$，那么现在考虑加入第 $n +1$ 个，显然加入 $0, 1$ 都是多了两种选择</p><p>那么现在考虑将行合并成一列</p><p>但是问题是如果需要枚举选的行还是需要 $2^n$ 的复杂度，然后我考场上就想到这就凉了</p><p>那么显然每次选好了行，再选列的时候这若干个列会贯穿所有行，那就可以将每行看作一个数，并且将它们合并（异或）起来，这样就变成做 $n = 1$ 的情况了</p><p>接下来只要考虑有几种情况会使得其异或和为 $1$ （或不为 $1$）就行了</p><p>将它们求线性基，因为表示基的行向量不可能组成 $0$，故异或和为 $0$ 的情况就是 $2^{\text{所有的零向量个数}}$</p><p>令所有零向量个数为 $k$，那么答案即为 $(2^k - 1)(2^m - 1) + (2^n - 2^k)(2^{m - 1} - 1)$</p><p>然后高斯消元再用 $bitset$ 维护一下就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; bit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Guass</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">for</span> (row = <span class="number">1</span>, col = <span class="number">1</span>; row &lt;= N &amp;&amp; col &lt;= M; row ++, col ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (bit[i][col])</span><br><span class="line">swap (bit[row], bit[i]);</span><br><span class="line"><span class="keyword">if</span> (! bit[row][col]) &#123;</span><br><span class="line">row --;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (bit[i][col])</span><br><span class="line">bit[i] ^= bit[row];</span><br><span class="line">&#125;</span><br><span class="line">row --;</span><br><span class="line"><span class="keyword">return</span> N - row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">freopen (<span class="string">"password.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen (<span class="string">"password.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> p = getnum ();</span><br><span class="line">bit[i][j] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> zero = Guass ();</span><br><span class="line">LL ans = ((power (<span class="number">2l</span>l, zero) - <span class="number">1</span> + MOD) % MOD * ((power (<span class="number">2l</span>l, M) - <span class="number">1</span> + MOD) % MOD) % MOD +</span><br><span class="line"> (power (<span class="number">2l</span>l, N) - power (<span class="number">2l</span>l, zero) + MOD) % MOD * ((power (<span class="number">2l</span>l, M - <span class="number">1</span>) - <span class="number">1</span> + MOD) % MOD) % MOD) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">0 1 0</span></span><br><span class="line"><span class="comment">1 0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「四校联考」大水题 「简单prufer序列」</title>
      <link href="/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%A4%A7%E6%B0%B4%E9%A2%98%20%E3%80%8C%E7%AE%80%E5%8D%95prufer%E5%BA%8F%E5%88%97%E3%80%8D/"/>
      <url>/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%A4%A7%E6%B0%B4%E9%A2%98%20%E3%80%8C%E7%AE%80%E5%8D%95prufer%E5%BA%8F%E5%88%97%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="prufer序列"><a href="#prufer序列" class="headerlink" title="prufer序列"></a>prufer序列</h2><p>prufer序列是一种无根树的序列表示方法，<strong>一个节点个数为 $n$ 的无根树对应着唯一一种长度为 $n - 2$ 的prufer序列</strong></p><h3 id="无根树化prufer序列"><a href="#无根树化prufer序列" class="headerlink" title="无根树化prufer序列"></a>无根树化prufer序列</h3><p>每次取编号最小的叶子节点，将其指向的“父亲”（就是它唯一指向的）节点加入prufer序列中，最终剩余两个连接的节点结束</p><h3 id="prufer序列化无根树"><a href="#prufer序列化无根树" class="headerlink" title="prufer序列化无根树"></a>prufer序列化无根树</h3><p>对于prufer序列 $A= \{a_1, a_2, a_3, …\}$，每次取最前面的元素 $a_s$，在总点集中找到最小的没有在 $A$ 中的节点 $t$，将 $a_s,  t$ 连边并删去 $a_s$，可以使用 $set$ 等维护</p><h3 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h3><ul><li>$n$ 个点的有标号完全图无根树计数：$n^{n - 2}$</li><li>$n$ 个点，每个点的度数为 $\{d_1, d_2, d_3, …\}$ 的有标号无根树计数：$\frac{(n - 2)!}{d_1!d_2!d_3!…}$（实际上就是一个多重集的排列数）</li><li>$n$ 个点的prufer序列中第 $i$ 个点恰好出现 $d_i - 1$ 次</li><li>$n$ 个点度数为 $\{d_1, d_2, …, d_k\}$，剩余 $k + 1 \thicksim n$ 未知度数的节点的有标号无根树计数：设剩余的位置 $d_l = (n - 2) - \sum\limits_{i = 1}^k (d_i- 1) $，先将它们看作一个整体再局部求解得到 $ans = \frac{(n - 2)!}{d_1!d_2!…d_k!d_l!}(n - k)^{d_l}$</li><li>$n$ 个点的有标号有根树计数：$n^{n - 1}$</li><li>$n$ 个点的无标号有根树计数：待续</li><li>$n$ 个点的无标号无根树计数：待续</li></ul><h2 id="本题题解"><a href="#本题题解" class="headerlink" title="本题题解"></a>本题题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 $n$ 个有标号点，第 $i$ 个点的度数上限为 $A_i$</p><p>现在对于每个 $s (1 \le s \le n)$，问从这 $n$ 个点中选出一些点组成大小为 $s$ 的有标号无根树的方案数</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $100\%$ 的数据，$n \le 100$</p><p>考虑直接将无根树转化为prufer序列，由唯一性在序列上直接 $dp$<br>令 $f_{i, j, k}$ 表示前 $i$ 个点选 $j$ 个组成长度为 $k$ 的prufer序列的方案数</p><p>显然<br>$$<br>\begin{aligned}<br>f_{i + 1, j, k} &amp;+= f_{i, j, k} \\<br>f_{i + 1, j + 1, k + l(l \in [0, A_{i + 1} - 1])} &amp;+= f_{i, j, k} \times \dbinom{k + l}{l}<br>\end{aligned}<br>$$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1004535809</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL C[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL f[MAXN][MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> limit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">freopen (<span class="string">"tree.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen (<span class="string">"tree.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">limit[i] = getnum ();</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= N; k ++) &#123; <span class="comment">// 注意需眼神到N</span></span><br><span class="line">f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k &amp;&amp; l &lt; limit[i]; l ++) <span class="comment">// 注意因为可以作叶子所以l需要从0开始枚举</span></span><br><span class="line">f[i][j][k] = (f[i][j][k] + f[i - <span class="number">1</span>][j - <span class="number">1</span>][k - l] * C[k][l] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">write (N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>), write (f[N][i][i - <span class="number">2</span>]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 5 2 4 4 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">6 15 50 160 392 509</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> prufer序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「北京省选集训2019」生成树计数「Matrix-Tree」</title>
      <link href="/2020/08/04/%5B%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%E3%80%8CMatrix-Tree%E3%80%8D/"/>
      <url>/2020/08/04/%5B%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%E3%80%8CMatrix-Tree%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Matrix-Tree定理"><a href="#Matrix-Tree定理" class="headerlink" title="Matrix-Tree定理"></a>Matrix-Tree定理</h3><p>对于无向图 $G$，定义其度数矩阵 $D$<br>$$<br>\left[<br>\begin{matrix}<br>deg_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; deg_2 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; 0 &amp; deg_3 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; deg_n<br>\end{matrix}<br>\right]<br>$$<br>定义其邻接矩阵 $C$<br>$$<br>\left[<br>\begin{matrix}<br>0 &amp; a_{1,2} &amp; a_{1,3} &amp; \cdots &amp; a_{1,n} \\<br>a_{2,1} &amp; 0 &amp; a_{2,3} &amp; \cdots &amp; a_{2,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; a_{n,4} &amp; 0<br>\end{matrix}<br>\right]<br>$$<br>其中 $a_{i, j} \in \{0, ~1\}$</p><p>定于其的基尔霍夫矩阵 $L(G) = D - C$，则有 $L(G)$ 的任意代数余子式即为无向图 $G$ 的生成树个数</p><p>至于求代数余子式则任意删去第 $i$ 行 $i$ 列高斯消元得其斜上三角矩阵最后即有 $ans = \sum\limits_i a_{i,i}$</p><p>至于证明就留坑吧</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ul><li>带权图生成树：定义一棵生成树的权值为边权之积，求解所有生成树的权值之和。      将 $D$ 中的 $deg_i$ 改为连接其的点的权值和，再令 $C$ 中 $a_{i, j} = w_{i, j}$ （$w_{i, j}$ 为边权），最后Matrix-Tree定理即可</li><li>有向图的生成树形图计数：我们将度数矩阵改为入度，邻接矩阵改为有向边的邻接矩阵，以 $p$ 为根的树形图个数是去掉 $p$ 行 $p$ 列后做行列式得的答案</li></ul><h3 id="多项式求逆-O-n-2"><a href="#多项式求逆-O-n-2" class="headerlink" title="多项式求逆 $O (n^2)$"></a>多项式求逆 $O (n^2)$</h3><p>于是我先会 $O (n \log n)$ 再会 $O (n^2)$ 我也很绝望啊</p><p>令 $C(x) = A(x)B(x) \pmod p$，首先有 $C_0 = A_0B_0 = 1 \pmod p$ （此处表示在 $\mod p$ 意义下，然后以 $C_1$ 为例，则有 $C_1 = A_0B_1 + A_1B_0 = 0 \pmod p$，可解得 $B_1 = - \frac{A_1B_0}{A_0}$，其它同理</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对于 $(w_1 + w_2 + w_3 + \wedge ~+ w_n)^k = \sum\prod\limits_{i = 1}^n w_{\forall}$</p><p>那么可以联想到有标号的整数拆分，那么即可将每条边的边权设为原边权的 EGF，即 $value = \sum\limits_{n \ge 0} w^n\frac{x^n}{n!}$ （$w$ 为原边权），接下来Matrix-Tree即可</p><p>最后得到一个多项式 $G(x)$，答案即为 $ans = G_k \cdot fact_k$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL invf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, k;</span><br><span class="line"></span><br><span class="line">LL <span class="built_in">map</span>[MAXN][MAXN][MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL res[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXK]= &#123;<span class="number">0</span>&#125;, tmp[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span> <span class="params">(LL* a, LL* b, LL* ret)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (temp, <span class="number">0</span>, <span class="keyword">sizeof</span> (temp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">temp[i] = (temp[i] + a[j] * b[i - j] % MOD) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span> (ret, temp, <span class="keyword">sizeof</span> (temp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span> <span class="params">(LL* a, LL* ret)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i ++)</span><br><span class="line">temp[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">temp[<span class="number">0</span>] = power (a[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">tmp[i] = a[i] * temp[<span class="number">0</span>] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">temp[i] = (temp[i] - tmp[j] * temp[i - j] % MOD + MOD) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span> (ret, temp, <span class="keyword">sizeof</span> (temp));</span><br><span class="line">&#125;</span><br><span class="line">LL ret[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">multiply (<span class="built_in">map</span>[i][i], res, res);</span><br><span class="line">inv (<span class="built_in">map</span>[i][i], ret);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j ++)</span><br><span class="line">multiply (<span class="built_in">map</span>[i][j], ret, <span class="built_in">map</span>[i][j]);</span><br><span class="line"><span class="built_in">memset</span> (<span class="built_in">map</span>[i][i], <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="built_in">map</span>[i][i]));</span><br><span class="line"><span class="built_in">map</span>[i][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = N - <span class="number">1</span>; t &gt;= i; t --) &#123;</span><br><span class="line">multiply (<span class="built_in">map</span>[i][t], <span class="built_in">map</span>[j][i], ret);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l ++) &#123;</span><br><span class="line"><span class="built_in">map</span>[j][t][l] = (<span class="built_in">map</span>[j][t][l] - ret[l] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), k = getnum ();</span><br><span class="line">invf[<span class="number">0</span>] = invf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i ++)</span><br><span class="line">invf[i] = (- MOD / i + MOD) % MOD * invf[MOD % i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">invf[i] = invf[i] * invf[i - <span class="number">1</span>] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123;</span><br><span class="line">LL delta = getnum ();</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">LL <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l ++) &#123;</span><br><span class="line">LL value = <span class="built_in">pow</span> * invf[l] % MOD;</span><br><span class="line"><span class="built_in">map</span>[i][j][l] = <span class="built_in">map</span>[j][i][l] = (- value + MOD) % MOD;</span><br><span class="line"><span class="built_in">map</span>[i][i][l] = (<span class="built_in">map</span>[i][i][l] + value) % MOD;</span><br><span class="line"><span class="built_in">map</span>[j][j][l] = (<span class="built_in">map</span>[j][j][l] + value) % MOD;</span><br><span class="line"><span class="built_in">pow</span> = <span class="built_in">pow</span> * delta % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Gauss ();</span><br><span class="line">LL ans = res[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">ans = ans * i % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">1 1 0 0</span></span><br><span class="line"><span class="comment">1 1 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵树定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 5280 - [ZJOI2019]线段树</title>
      <link href="/2020/08/04/%5BZJOI2019%5D%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/08/04/%5BZJOI2019%5D%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看题解里有人说这题实在太水</p><p>但我连第一步对点分类都不会（虽然分类完后的确不会很难）</p><p>我依旧是太菜</p><p>好了进入正题</p><p>线段树上打 $\text{tag}$，因为它一直复制来复制去，不可能在没棵线段树上都进行修改，就考虑点的共同性质，相同性质的点可以一起修改，那么此时相当于只进行一次 $\text{modify}$ 就行了</p><p>可以将点分成五类：</p><ul><li>一类点：半覆盖（就是修改时会经过但是不打标记）</li><li>二类点：全覆盖，打标记（区间被修改区间完全覆盖，会被访问到，被打标记）</li><li>三类点：全覆盖，不打标记（区间被修改区间完全覆盖，但不会被访问到，就是打标记全覆盖节点的子节点，不被打标记）</li><li>四类点：访问不到，会被下传标记</li><li>五类点：访问不到，不会被下传标记</li></ul><p>那么此时方案数转概率，令 $f_u$ 表示节点 $u$ 有被打标记的概率，即 $u$ 有被打标记的线段树占比，那么最终被打标记的节点 $u$ 个数即为 $f_u \times 2^n$（其中 $n$ 表示被修改次数）</p><p>但是会发现写四类点的时候还需要知道它祖先有没有被打标记，所以还需要设一个 $g_u$ 表示节点 $u$ 及其祖先被打标记的概率，开始转移</p><p>对一类点，复制后一半保持原样，一半必定无标记（因为是经过点肯定会被下传），其祖先同理<br>$$<br>f_u = \frac12(f_u + 0), g_u = \frac12(g_u + 0)<br>$$<br>对二类点，复制后一半保持原样，一半必定会被打标记<br>$$<br>f_u = \frac12(f_u + 1), g_u = \frac12(g_u + 1)<br>$$<br>对三类点，复制后一半保持原样，一半必定不会被下传标记，但其祖先必定会被标记<br>$$<br>f_u = f_u, g_u = \frac12(g_u + 1)<br>$$<br>对四类点，复制后一半保持原样，一半可能会被下传标记（必定会经过其父节点，否则它不可能成为四类点，同时是否会被下传标记取决于它祖先是否有标记，即 $g_u$）<br>$$<br>f_u = \frac12(f_u + g_u), g_u = g_u<br>$$<br>对五类点，复制后一半保持原样，一半也不会被影响<br>$$<br>f_u = f_u, g_u = g_u<br>$$<br>故五类点可不做处理</p><p>但是三类点的数目很多，是 $O (n)$ 级别，故对三类点的修改还需要打懒标记</p><p>再开一个 $sumf_u$ 维护其子树答案</p><p>最终答案即为 $sumf_1 \times 2^n$</p><p>时间复杂度 $O (m\log n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL inv2 = <span class="number">499122177</span>;</span><br><span class="line"></span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumf[MAXN]= &#123;<span class="number">0</span>&#125;, lazy[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">lazy[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid);</span><br><span class="line">build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; sumf[root] = (f[root] + sumf[lson] + sumf[rson]) % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushG</span> <span class="params">(<span class="keyword">int</span> root, LL value)</span> </span>&#123;</span><br><span class="line">g[root] = (g[root] * value % MOD + <span class="number">1l</span>l - value + MOD) % MOD;</span><br><span class="line">lazy[root] = lazy[root] * value % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushF</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; f[root] = (f[root] + g[root]) % MOD * inv2 % MOD; maintain (root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy[root] == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">pushG (lson, lazy[root]); pushG (rson, lazy[root]);</span><br><span class="line">lazy[root] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">f[root] = (f[root] + <span class="number">1</span>) % MOD * inv2 % MOD; <span class="comment">// 二类点</span></span><br><span class="line">g[root] = (g[root] + <span class="number">1</span>) % MOD * inv2 % MOD;</span><br><span class="line">pushG (lson, inv2); pushG (rson, inv2); <span class="comment">// 三类点</span></span><br><span class="line">maintain (root);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown (root); <span class="comment">// 三类点pushdown</span></span><br><span class="line">f[root] = f[root] * inv2 % MOD; <span class="comment">// 一类点</span></span><br><span class="line">g[root] = g[root] * inv2 % MOD;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R);</span><br><span class="line"><span class="keyword">else</span> pushF (lson); <span class="comment">// 四类点</span></span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="keyword">else</span> pushF (rson); <span class="comment">// 四类点</span></span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line">LL down = <span class="number">1</span>;</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> type = getnum ();</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">2</span>) &#123; write (sumf[<span class="number">1</span>] * down % MOD); <span class="built_in">puts</span> (<span class="string">""</span>); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">down = down * <span class="number">2l</span>l % MOD;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ZJOI2016」大森林</title>
      <link href="/2020/08/04/%5BZJOI2016%5D%E5%A4%A7%E6%A3%AE%E6%9E%97/"/>
      <url>/2020/08/04/%5BZJOI2016%5D%E5%A4%A7%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>（貌似整个代码不能用 $makeroot$ ？是因为是有根树？）</p><p>因为是区间操作，所以可以考虑在区间内与区间外的差异</p><p>对于操作 $1$ ，可以看作一个生成节点包含了到下一个 $1$ 操作之间长出的节点，那么对于一个操作 $l, r$ ，相当于是在 $l$ 处将当前生成节点及其包含的节点整个移植到它更改后的位置，到 $r + 1$ 时再移植回去，所以可以考虑将一个 $1$ 操作分解为两个操作（一个移植，一个移植回去），故可以将所有操作按端点、时间排序（以及同位置修改操作必定在查询操作前，因为可以先把树建完再查询对结果没有影响），扫描一遍即可</p><p>同时，为了方便移植，将每个生成节点看作新建的一个虚点</p><p>对于操作 $0$ ，直接在虚点下 $link$ 即可，因为就算已经建了一些对于当前操作不存在的虚点，也不会对答案造成影响</p><p>对于操作 $2$ ，无法正面在 $LCT$ 上算出两点的距离，故可考虑差分，得到 $Ans = Sum_x + Sum_y - 2 * Sum_{lca}$ ，其中实点贡献为 $1$ ，虚点贡献为 $0$</p><p>对于求 $LCA$ ，先 $access (y)$ ，再在 $access (x)$ 的时候得到的最后一个跳虚边的点即是它们的 $LCA$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuerySt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, time;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    QuerySt () &#123;&#125;</span><br><span class="line">    QuerySt (<span class="keyword">int</span> fpos, <span class="keyword">int</span> ftime, <span class="keyword">int</span> fx, <span class="keyword">int</span> fy) :</span><br><span class="line">        pos (fpos), time (ftime), x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> QuerySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos == p.pos ? time &lt; p.time : pos &lt; p.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">QuerySt Query[MAXN];</span><br><span class="line"><span class="keyword">int</span> que = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Sum[MAXN]= &#123;<span class="number">0</span>&#125;, value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Sum[p] = Sum[son[p][<span class="number">0</span>]] + Sum[son[p][<span class="number">1</span>]] + value[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line">    <span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">    son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[fa][s])</span><br><span class="line">        father[son[fa][s]] = fa;</span><br><span class="line">    <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">        son[anc][sonbel (fa)] = p;</span><br><span class="line">    father[p] = anc;</span><br><span class="line">    son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">    pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line">        <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">            sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; p; tp = p, p = father[p])</span><br><span class="line">        splay (p), son[p][<span class="number">1</span>] = tp, pushup (p);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 注意此时没有makeroot所以需要注意是将y连到x下</span></span><br><span class="line">    splay (y);</span><br><span class="line">    father[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Access (x), splay (x);</span><br><span class="line">    father[son[x][<span class="number">0</span>]] = <span class="number">0</span>, son[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup (x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sort (Query + <span class="number">1</span>, Query + que + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> time = Query[i].time;</span><br><span class="line">        <span class="keyword">int</span> x = Query[i].x, y = Query[i].y;</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Access (x), splay (x), ans[time] += Sum[x];</span><br><span class="line">            <span class="keyword">int</span> lca = Access (y);</span><br><span class="line">            splay (y), ans[time] += Sum[y];</span><br><span class="line">            Access (lca), splay (lca), ans[time] -= (Sum[lca] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cut (x), link (y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ind[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> liml[MAXN], limr[MAXN];</span><br><span class="line"><span class="keyword">int</span> nodes = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">int</span> lastr = <span class="number">1</span>, real = <span class="number">1</span>;</span><br><span class="line">    ind[<span class="number">1</span>] = Sum[<span class="number">1</span>] = value[<span class="number">1</span>] = <span class="number">1</span>, liml[<span class="number">1</span>] = <span class="number">1</span>, limr[<span class="number">1</span>] = N;</span><br><span class="line">    link (<span class="number">1</span>, nodes = lastr = <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">            link (lastr, ind[++ real] = ++ nodes);</span><br><span class="line">            value[nodes] = Sum[nodes] = <span class="number">1</span>;</span><br><span class="line">            liml[real] = l, limr[real] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = getnum (), r = getnum (), x = getnum ();</span><br><span class="line">            l = max (l, liml[x]), r = min (r, limr[x]);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            link (lastr, ++ nodes);</span><br><span class="line">            Query[++ que] = QuerySt (l, i - M, nodes, ind[x]); <span class="comment">// 由nodes离开link向index[x]</span></span><br><span class="line">            Query[++ que] = QuerySt (r + <span class="number">1</span>, i - M, nodes, lastr);</span><br><span class="line">            lastr = nodes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getnum (), u = getnum (), v = getnum ();</span><br><span class="line">            Query[++ que] = QuerySt (x, ++ totq, ind[u], ind[v]); <span class="comment">// 由index[u]到index[v]的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Solve ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totq; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">0 1 5</span></span><br><span class="line"><span class="comment">1 2 4 2</span></span><br><span class="line"><span class="comment">0 1 4</span></span><br><span class="line"><span class="comment">2 1 1 3</span></span><br><span class="line"><span class="comment">2 2 1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ynoi2013」D1T1</title>
      <link href="/2020/08/04/%5BYnoi2013%5DD1T1/"/>
      <url>/2020/08/04/%5BYnoi2013%5DD1T1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$\text{opt} = 1$ 时，代表把一个区间  $l, r$ 内的所有数都 $\text{xor}$ 上 $v$。</p><p>$\text{opt} = 2$ 时， 查询一个区间 $[l, r]$ 内选任意个数（包括 $0$ 个）数 $\text{xor}$ 起来，这个值与 $v$ 的最大 $\text{xor}$ 和是多少。</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>几乎没写过差分，看完这题之后顿时感觉到了差分的强大</p><p>首先显然第二个操作需要维护线性基，然后 $O (\log{n})$ 求解</p><p>然后因为有 $1$ 操作，所以若是直接维护区间线性基，在计算答案时不知道 $1$ 操作中的 $v$ 在当前答案中被异或上了奇数还是偶数次，故无法求解</p><p>但是在单点修改的情景下就不会有上述问题，故现在的问题是如何将区间问题转化为单点问题</p><p>于是就需要差分，让每个 $b_{i + 1} = a_{i + 1} ~ \text{xor} ~ a_i$，那么此时 $v$ 的贡献就只作用于 $b_l$ 与 $b_{r + 1}$，可直接单点修改，然后在线段树上同时维护区间线性基，查询时只需查询 $1…l$ 的前缀和（即 $b_l$），再将之与 $l + 1…r$ 的区间线性基合并即可求解答案</p><p>复杂度 $O (n \log^2{n})$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">baseSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> subsum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (b, <span class="number">0</span>, <span class="keyword">sizeof</span> (b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (! b[j]) &#123;</span><br><span class="line">b[j] = x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> x ^= b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">baseSt base[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function">baseSt <span class="title">merge</span> <span class="params">(baseSt A, baseSt B)</span> </span>&#123;</span><br><span class="line">baseSt ret; ret.init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --) &#123;</span><br><span class="line"><span class="keyword">if</span> (A.b[j]) ret.b[j] = A.b[j];</span><br><span class="line"><span class="keyword">else</span> ret.b[j] = B.b[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (A.b[j] &amp;&amp; B.b[j])</span><br><span class="line">ret.append (B.b[j]);</span><br><span class="line">ret.subsum = A.subsum ^ B.subsum;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">base[root].init ();</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">base[root].subsum = a[left];</span><br><span class="line">base[root].append (base[root].subsum);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid);</span><br><span class="line">build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">base[root] = merge (base[lson], base[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">base[root].init ();</span><br><span class="line">base[root].subsum ^= delta, base[root].append (base[root].subsum);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson, left, mid, posi, delta);</span><br><span class="line"><span class="keyword">else</span> modify (rson, mid + <span class="number">1</span>, right, posi, delta);</span><br><span class="line">base[root] = merge (base[lson], base[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">baseSt <span class="title">query_base</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line"><span class="keyword">return</span> base[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">baseSt ret; ret.init ();</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) ret = merge (ret, query_base (lson, left, mid, L, R));</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) ret = merge (ret, query_base (rson, mid + <span class="number">1</span>, right, L, R));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_value</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span> base[root].subsum;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> query_value (lson, left, mid, posi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query_value (rson, mid + <span class="number">1</span>, right, posi) ^ base[lson].subsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> x, baseSt A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">ret = max (ret, ret ^ A.b[j]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">a[i + <span class="number">1</span>] ^= a[i];</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), l = getnum (), r = getnum (), x = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, x);</span><br><span class="line"><span class="keyword">if</span> (r &lt; N) modify (<span class="number">1</span>, <span class="number">1</span>, N, r + <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> delta = query_value (<span class="number">1</span>, <span class="number">1</span>, N, l);</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, max (x ^ delta, x));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">baseSt bas = query_base (<span class="number">1</span>, <span class="number">1</span>, N, l + <span class="number">1</span>, r);</span><br><span class="line">bas.append (delta);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, solve (x, bas));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 14 51 4</span></span><br><span class="line"><span class="comment">2 1 3 0</span></span><br><span class="line"><span class="comment">1 2 3 3</span></span><br><span class="line"><span class="comment">2 1 4 10</span></span><br><span class="line"><span class="comment">1 1 4 514</span></span><br><span class="line"><span class="comment">2 3 4 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ynoi2012」D2T1</title>
      <link href="/2020/08/04/%5BYnoi2012%5DD2T1/"/>
      <url>/2020/08/04/%5BYnoi2012%5DD2T1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先有一个性质</p><blockquote><p>对于 $n \ge 11$，操作 $1$ 必定有解</p></blockquote><p>一个来自 $\text{Okami}$ 的严谨证明：</p><p>考虑互不相同的数 $x, y, z, …$，则有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">x y x+y</span><br><span class="line">x y z x+y x+z y+z x+y+z</span><br></pre></td></tr></table></figure><p>也就是对于 $n$ 个互不相同的数它们显然可以拼出 $2^n - 1$，那么根据抽屉原理，则有 $2^n - 1 \ge 1000$ 时必定有解，则命题成立</p><p>那么剩下的就直接 $\text{bitset}$ 优化背包就好了（注意可以直接背包因为若集合 $X$ 和 $Y$ 同时选了一个数，那么它们同时去除该数也是相等的），至于操作 $2$ 的影响则直接树状数组统计每个数要立方几次，由于 $\bmod V$，那么直接倍增处理即可</p><p>单词询问复杂度 $O (\frac{(r - l + 1)^2V}{32})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, V;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> powv[MAXV][<span class="number">25</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i ++) powv[i][<span class="number">0</span>] = i * i * i % V;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i ++)</span><br><span class="line">powv[i][j] = powv[powv[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">x = powv[x][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (- x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= N) &#123;</span><br><span class="line">subsum[x] += delta;</span><br><span class="line">x += lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt += subsum[x];</span><br><span class="line">x -= lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;12 * MAXV&gt; f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), V = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), l = getnum (), r = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= <span class="number">12</span>) <span class="built_in">puts</span> (<span class="string">"Yuno"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f.reset(); <span class="keyword">bool</span> suc = <span class="literal">false</span>; f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = calc (a[i], query (i));</span><br><span class="line"><span class="keyword">if</span> ((f &amp; (f &lt;&lt; x)).any()) &#123;</span><br><span class="line">suc = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = f | (f &lt;&lt; x);</span><br><span class="line">&#125;</span><br><span class="line">suc ? <span class="built_in">puts</span> (<span class="string">"Yuno"</span>) : <span class="built_in">puts</span> (<span class="string">"Yuki"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> add (l, <span class="number">1</span>), add (r + <span class="number">1</span>, - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20 20 152</span></span><br><span class="line"><span class="comment">3 26 133 54 79 81 72 109 66 91 82 100 35 23 104 17 51 114 12 58</span></span><br><span class="line"><span class="comment">2 1 17</span></span><br><span class="line"><span class="comment">2 6 12</span></span><br><span class="line"><span class="comment">1 1 12</span></span><br><span class="line"><span class="comment">2 3 5</span></span><br><span class="line"><span class="comment">2 11 11</span></span><br><span class="line"><span class="comment">2 7 19</span></span><br><span class="line"><span class="comment">2 6 15</span></span><br><span class="line"><span class="comment">1 5 12</span></span><br><span class="line"><span class="comment">1 1 9</span></span><br><span class="line"><span class="comment">1 10 19</span></span><br><span class="line"><span class="comment">2 3 19</span></span><br><span class="line"><span class="comment">2 6 20</span></span><br><span class="line"><span class="comment">2 1 13</span></span><br><span class="line"><span class="comment">2 1 15</span></span><br><span class="line"><span class="comment">2 1 9</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">2 1 7</span></span><br><span class="line"><span class="comment">2 7 19</span></span><br><span class="line"><span class="comment">2 6 19</span></span><br><span class="line"><span class="comment">2 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「WC2018」通道</title>
      <link href="/2020/08/04/%5BWC2018%5D%E9%80%9A%E9%81%93/"/>
      <url>/2020/08/04/%5BWC2018%5D%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这题真的是写到心态爆炸。。</p><p>一道边分治 + 虚树</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="边分治"><a href="#边分治" class="headerlink" title="边分治"></a>边分治</h3><p>顾名思义，就是选择一条边，类似点分治对所有经过该边的路径进行处理，但与点分治不同的是，边分治可能会被菊花图卡到 $O (n^2)$，故此时需要重构树，将之变为度数不超过三的二叉树</p><h4 id="树重构"><a href="#树重构" class="headerlink" title="树重构"></a>树重构</h4><p>通过建立新的虚点进行重构，但要满足加入的虚点不影响最后答案计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (! nf) &#123;</span><br><span class="line">Insert (root, v, w), Insert (v, root, w);</span><br><span class="line">nf = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = ++ m; <span class="comment">// 虚点</span></span><br><span class="line">Insert (nf, k, <span class="number">0</span>), Insert (k, nf, <span class="number">0</span>);</span><br><span class="line">Insert (k, v, w), Insert (v, k, w);</span><br><span class="line">nf = k;</span><br><span class="line">&#125;</span><br><span class="line">rebuild (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求中心边"><a href="#求中心边" class="headerlink" title="求中心边"></a>求中心边</h4><p>于点分治的求重心略有不同，但本质是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cet, mini; <span class="comment">// 重心边</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAXM &lt;&lt; <span class="number">3</span>]= &#123;<span class="literal">false</span>&#125;; <span class="comment">// 边是否已经被经过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">findc (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">int</span> maxpart = max (subsize[v], n - subsize[v]); <span class="comment">// 注意此处</span></span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) &#123; mini = maxpart; cet = i; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>现在开始边分治，分治到某一边 $E$，将相应点分为两个连通块 $A, B$</p><p>考虑原式，其中 $d_T(x)$ 表示在树 $T$ 中 $x$ 距根节点（或分治中心）的长度，对两点 $i \in A, j \in B$<br>$$<br>ans = \max \{d_{T_1}(i) + d_{T_1}(j) + dist_{T_2}(i, j) + dist_{T_3}(i, j)\}<br>$$<br>此时对 $A \cup B$ 建立虚树，在虚树上跑 $\text{DFS}$，设此时访问到虚树上点 $p$，则式子可变为<br>$$<br>\begin{aligned}<br>ans &amp;= \max \{d_{T_1}(i) + d_{T_1}(j) + d_{T_2}(i) + d_{T_2}(j) - 2 \times d_{T_2}(p) + dist_{T_3}(i, j)\} \\<br>&amp;= \max \{(d_{T_1} + d_{T_2})(i) + (d_{T_1} + d_{T_2})(j)- 2 \times d_{T_2}(p) + dist_{T_3}(i, j)\}<br>\end{aligned}<br>$$<br>这就相当于给 $T_3$ 的点 $i, j$ 分别赋上权值 $value_i = d_{T_1}(i) + d_{T_2}(i), value_j = d_{T_1}(j) + d_{T_2}(j)$，然后求 $T_3$ 上点 $i \in A, j \in B$ 的 $i, j$ 间边权和在加上 $i, j$ 点权的最大值即可求得答案，就是给 $T_3$ 上的点黑白染色，求白点到黑点的端点点权即边权和的最大值</p><p>那么此时发现边权 $w_i$ 都是正整数，说明它们满足直径合并的定理，即新直径必定由原来两条直径的端点产生，这样就可以直接求了，在 $T_2$ 上 $\text{dp}$ 时顺便合并 $T_3$ 的答案</p><p>这么直接做时 $O (n \log^2 n)$ 的，常数一大那就玩球</p><p>其实优化到 $O (n \log n)$ 也是很显然的，写个 $\text{RMQ}$ 的 $\text{LCA}$，并且在建虚树时不用 $\text{sort}$ 而是基数排序就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>357行（包含少量注释）。。都不知多久没有打代码打的这么带感过了。。</p><p>$\text{debug}$ 真的就够受了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T3</span></span><br><span class="line">LL val[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree3</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], ord, cnt;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], value[MAXN &lt;&lt; <span class="number">1</span>], bel[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">LL d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">dfn[root] = ++ ord;</span><br><span class="line">value[ord] = depth[root], bel[ord] = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">d[v] = d[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">value[++ ord] = depth[root];</span><br><span class="line">bel[ord] = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ord; i ++) ST[i][<span class="number">0</span>] = make_pair (value[i], bel[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= ord; i ++)</span><br><span class="line"><span class="keyword">if</span> (ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first) ST[i][j] = ST[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> ST[i][j] = ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2 (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ST[l][k].first &lt; ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first) <span class="keyword">return</span> ST[l][k].second;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &gt; dfn[y]) swap (x, y);</span><br><span class="line"><span class="keyword">int</span> lca = LCA (dfn[x], dfn[y]);</span><br><span class="line"><span class="keyword">return</span> val[x] + val[y] + d[x] + d[y] - <span class="number">2l</span>l * d[lca];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">ord = <span class="number">0</span>;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); RMQ ();</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree3 T3;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">diam</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y; LL d;</span><br><span class="line">diam (<span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, LL fd = <span class="number">0</span>) : x (fx), y (fy), d (fd) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">diam f[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span> <span class="params">(diam A, diam B)</span> </span>&#123;</span><br><span class="line">LL d1 = max (T3.dist (A.x, B.x), T3.dist (A.x, B.y));</span><br><span class="line">LL d2 = max (T3.dist (A.y, B.x), T3.dist (A.y, B.y));</span><br><span class="line"><span class="keyword">return</span> max (d1, d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">diam <span class="title">merge</span> <span class="params">(diam A, diam B)</span> </span>&#123;</span><br><span class="line">LL maxi; diam ret;</span><br><span class="line">ret = A.d &gt; B.d ? diam (A.x, A.y, maxi = A.d) : diam (B.x, B.y, maxi = B.d);</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.x, B.x) &gt; maxi) &#123; ret = diam (A.x, B.x, maxi = T3.dist (A.x, B.x)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.x, B.y) &gt; maxi) &#123; ret = diam (A.x, B.y, maxi = T3.dist (A.x, B.y)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.y, B.x) &gt; maxi) &#123; ret = diam (A.y, B.x, maxi = T3.dist (A.y, B.x)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.y, B.y) &gt; maxi) &#123; ret = diam (A.y, B.y, maxi = T3.dist (A.y, B.y)); &#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"><span class="comment">//T2</span></span><br><span class="line"><span class="keyword">int</span> dye[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> iskey[MAXN]= &#123;<span class="number">0</span>&#125;, isdye[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree2</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ord;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], value[MAXN &lt;&lt; <span class="number">1</span>], bel[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">LL d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">dfn[root] = ++ ord;</span><br><span class="line">value[ord] = depth[root], bel[ord] = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">d[v] = d[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">value[++ ord] = depth[root];</span><br><span class="line">bel[ord] = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ord; i ++) ST[i][<span class="number">0</span>] = make_pair (value[i], bel[i]);</span><br><span class="line"><span class="keyword">int</span> MAX = log2 (ord) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MAX; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= ord; i ++)</span><br><span class="line"><span class="keyword">if</span> (ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first) ST[i][j] = ST[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> ST[i][j] = ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &gt; dfn[y]) swap (x, y);</span><br><span class="line"><span class="keyword">int</span> l = dfn[x], r = dfn[y];</span><br><span class="line"><span class="keyword">int</span> k = log2 (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ST[l][k].first &lt; ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first) <span class="keyword">return</span> ST[l][k].second;</span><br><span class="line"><span class="keyword">return</span> ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! top) &#123; <span class="built_in">stack</span>[++ top] = x; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> lca = LCA (<span class="built_in">stack</span>[top], x);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; depth[lca] &lt; depth[<span class="built_in">stack</span>[top - <span class="number">1</span>]]) &#123;</span><br><span class="line">Insert (<span class="built_in">stack</span>[top - <span class="number">1</span>], <span class="built_in">stack</span>[top], <span class="number">0</span>); top --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (depth[lca] &lt; depth[<span class="built_in">stack</span>[top]]) &#123; Insert (lca, <span class="built_in">stack</span>[top], <span class="number">0</span>); top --; &#125;</span><br><span class="line"><span class="keyword">if</span> (! top || <span class="built_in">stack</span>[top] != lca) <span class="built_in">stack</span>[++ top] = lca;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cstr</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 虚树构建</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">top = <span class="number">0</span>; <span class="keyword">if</span> (a[l] != <span class="number">1</span>) <span class="built_in">stack</span>[++ top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123; add (a[i]); val[a[i]] += d[a[i]]; iskey[a[i]] = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123; Insert (<span class="built_in">stack</span>[top - <span class="number">1</span>], <span class="built_in">stack</span>[top], <span class="number">0</span>); top --; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// dp</span></span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (iskey[u]) &#123;</span><br><span class="line">isdye[u][dye[u]] = <span class="literal">true</span>;</span><br><span class="line">f[u][dye[u]] = diam (u, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">dp (v);</span><br><span class="line"><span class="keyword">if</span> (isdye[u][<span class="number">0</span>] &amp;&amp; isdye[v][<span class="number">1</span>]) ans = max (ans, query (f[u][<span class="number">0</span>], f[v][<span class="number">1</span>]) - <span class="number">2l</span>l * d[u]);</span><br><span class="line"><span class="keyword">if</span> (isdye[u][<span class="number">1</span>] &amp;&amp; isdye[v][<span class="number">0</span>]) ans = max (ans, query (f[u][<span class="number">1</span>], f[v][<span class="number">0</span>]) - <span class="number">2l</span>l * d[u]);</span><br><span class="line"><span class="keyword">if</span> (isdye[v][<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (! isdye[u][<span class="number">0</span>]) f[u][<span class="number">0</span>] = f[v][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> f[u][<span class="number">0</span>] = merge (f[u][<span class="number">0</span>], f[v][<span class="number">0</span>]);</span><br><span class="line">isdye[u][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isdye[v][<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (! isdye[u][<span class="number">1</span>]) f[u][<span class="number">1</span>] = f[v][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> f[u][<span class="number">1</span>] = merge (f[u][<span class="number">1</span>], f[v][<span class="number">1</span>]);</span><br><span class="line">isdye[u][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to; del (v);</span><br><span class="line">&#125;</span><br><span class="line">Head[u] = val[u] = dye[u] = <span class="number">0</span>; iskey[u] = isdye[u][<span class="number">0</span>] = isdye[u][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">ord = <span class="number">0</span>;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); RMQ ();</span><br><span class="line">size = <span class="number">0</span>; <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = i;</span><br><span class="line">sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree2 T2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree1_ori</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree1_ori T1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line">LL w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size = - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = T1.Head[root]; i; i = T1.Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = T1.Link[i].to;</span><br><span class="line">LL w = T1.Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (! nf) &#123;</span><br><span class="line">Insert (root, v, w), Insert (v, root, w);</span><br><span class="line">nf = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = ++ m;</span><br><span class="line">Insert (nf, k, <span class="number">0</span>), Insert (k, nf, <span class="number">0</span>);</span><br><span class="line">Insert (k, v, w), Insert (v, k, w);</span><br><span class="line">nf = k;</span><br><span class="line">&#125;</span><br><span class="line">rebuild (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cet, mini; <span class="comment">// 重心边</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAXM &lt;&lt; <span class="number">3</span>]= &#123;<span class="literal">false</span>&#125;; <span class="comment">// 边是否已经被经过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">findc (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">int</span> maxpart = max (subsize[v], n - subsize[v]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) &#123; mini = maxpart; cet = i; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coll</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> root, <span class="keyword">int</span> father, LL d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root &lt;= N) &#123; dye[root] = p; val[root] = d; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">coll (p, v, root, d + w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tp[<span class="number">2</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">cet = - <span class="number">1</span>, mini = INF; findc (n, u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cet == - <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">visit[cet &gt;&gt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x = Link[cet].to, y = Link[cet ^ <span class="number">1</span>].to;</span><br><span class="line">coll (<span class="number">0</span>, x, y, Link[cet].w); coll (<span class="number">1</span>, y, x, <span class="number">0</span>);</span><br><span class="line">T2.cstr (l, r); T2.dp (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) tp[dye[a[i]]][++ cnt[dye[a[i]]]] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= l + cnt[<span class="number">0</span>] - <span class="number">1</span>; i ++) a[i] = tp[<span class="number">0</span>][i - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l + cnt[<span class="number">0</span>]; i &lt;= r; i ++) a[i] = tp[<span class="number">1</span>][i - l - cnt[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">T2.del (<span class="number">1</span>); <span class="keyword">int</span> szr = n - subsize[x];</span><br><span class="line">divide (x, subsize[x], l, l + cnt[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">divide (y, szr, l + cnt[<span class="number">0</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">T1.Insert (u, v, w), T1. Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">T2.build (); T3.build ();</span><br><span class="line"><span class="built_in">memset</span> (Head, - <span class="number">1</span>, <span class="keyword">sizeof</span> (Head));</span><br><span class="line">m = N; rebuild (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">divide (<span class="number">1</span>, m, <span class="number">1</span>, N);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 0</span></span><br><span class="line"><span class="comment">1 4 1</span></span><br><span class="line"><span class="comment">4 5 7</span></span><br><span class="line"><span class="comment">1 2 0</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">2 5 3</span></span><br><span class="line"><span class="comment">1 5 2</span></span><br><span class="line"><span class="comment">2 3 8</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">4 5 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上DP </tag>
            
            <tag> 边分治 </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「WC2008」游览计划 「斯坦那树模板」</title>
      <link href="/2020/08/04/%5BWC2008%5D%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92%20%E3%80%8C%E6%96%AF%E5%9D%A6%E9%82%A3%E6%A0%91%E6%A8%A1%E6%9D%BF%E3%80%8D/"/>
      <url>/2020/08/04/%5BWC2008%5D%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92%20%E3%80%8C%E6%96%AF%E5%9D%A6%E9%82%A3%E6%A0%91%E6%A8%A1%E6%9D%BF%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="斯坦那树"><a href="#斯坦那树" class="headerlink" title="斯坦那树"></a>斯坦那树</h3><p>百度释义</p><blockquote><p>斯坦纳树问题是组合优化问题，与最小生成树相似，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</p></blockquote><p>即最小斯坦那树即为并非选择所有的结点，而是选择一部分结点，为保证它们连通，且求解最小开销</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>斯坦那树模板</p><p>发现直接表示点的存在性没有意义</p><p>设函数 $f[i][state]$ 表示：对于点 $i$，其它结点与其连通情况</p><p>那么有两种转移</p><p>其一、由其子集转移<br>$$<br>f[i][state] = \min\limits_{sub \in state} \{f[i][sub] + f[i][\complement_{state}sub] - value_i\}<br>$$<br>之所以要减去 $value_i$ 是因为会算重</p><p>附：枚举子集的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sub = state &amp; (state - <span class="number">1</span>); sub; sub = (sub - <span class="number">1</span>) &amp; state)</span><br></pre></td></tr></table></figure><p>其二、由相邻当前状态下结点转移<br>$$<br>f[i][state] = \min\limits_{state_p = true} \{f[p][state] + value_i\}<br>$$<br>发现很像三角形不等式，故考虑 $SPFA$ 转移</p><p>总复杂度 $O (n3^n + kE2^n)$，$3^n$ 为枚举子集总复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NextX[<span class="number">4</span>]= &#123;- <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, NextY[<span class="number">4</span>]= &#123;<span class="number">0</span>, - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> Map[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">preSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">preSt (<span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, <span class="keyword">int</span> fs = <span class="number">0</span>) :</span><br><span class="line">x (fx), y (fy), state (fs) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXM];</span><br><span class="line">preSt pre[MAXN][MAXN][MAXM];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span> <span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; top = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = top.first, y = top.second;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + NextX[i];</span><br><span class="line"><span class="keyword">int</span> ty = y + NextY[i];</span><br><span class="line"><span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; N || ty &lt; <span class="number">1</span> || ty &gt; M)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (f[x][y][state] + Map[tx][ty] &lt; f[tx][ty][state]) &#123;</span><br><span class="line">f[tx][ty][state] = f[x][y][state] + Map[tx][ty];</span><br><span class="line">pre[tx][ty][state] = preSt (x, y, state);</span><br><span class="line">que.push(make_pair (tx, ty));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! x || ! y)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">tag[x][y] = <span class="number">1</span>;</span><br><span class="line">preSt pr = pre[x][y][state];</span><br><span class="line">traceback (pr.x, pr.y, pr.state);</span><br><span class="line"><span class="keyword">if</span> (pr.x == x &amp;&amp; pr.y == y)</span><br><span class="line">traceback (pr.x, pr.y, state - pr.state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">int</span> px, py;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line">Map[i][j] = getnum ();</span><br><span class="line"><span class="keyword">if</span> (! Map[i][j]) &#123;</span><br><span class="line">cnt ++, f[i][j][<span class="number">1</span> &lt;&lt; (cnt - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">px = i, py = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">1</span>; state &lt;= limit; state ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sub = state &amp; (state - <span class="number">1</span>); sub; sub = (sub - <span class="number">1</span>) &amp; state) <span class="comment">// from subset</span></span><br><span class="line"><span class="keyword">if</span> (f[i][j][sub] + f[i][j][state - sub] - Map[i][j] &lt; f[i][j][state]) &#123;</span><br><span class="line">f[i][j][state] = f[i][j][sub] + f[i][j][state - sub] - Map[i][j];</span><br><span class="line">pre[i][j][state] = preSt (i, j, sub);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f[i][j][state] &lt; INF)</span><br><span class="line">que.push(make_pair (i, j));</span><br><span class="line">&#125;</span><br><span class="line">SPFA (state); <span class="comment">// from other nodes</span></span><br><span class="line">&#125;</span><br><span class="line">traceback (px, py, limit);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[px][py][limit]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! Map[i][j])</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tag[i][j] ? <span class="built_in">putchar</span> (<span class="string">'o'</span>) : <span class="built_in">putchar</span> (<span class="string">'_'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">2 5 5 1</span></span><br><span class="line"><span class="comment">1 5 5 1</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SDOI2009」HH去散步 「矩阵乘法计数」</title>
      <link href="/2020/08/04/%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%20%E3%80%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E8%AE%A1%E6%95%B0%E3%80%8D/"/>
      <url>/2020/08/04/%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%20%E3%80%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E8%AE%A1%E6%95%B0%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计数问题也许可以转化为矩阵乘法形式</p><p>比如若该题没有不能在一条边上重复走的条件限制，那么直接将邻接矩阵转化为矩阵乘法即可</p><p>故</p><h3 id="矩阵乘法计数"><a href="#矩阵乘法计数" class="headerlink" title="矩阵乘法计数"></a>矩阵乘法计数</h3><p>对于计数问题，若可以将 $n$ 个点表示成 $n \times n$ 的矩阵，并且可以保证中途转移对象不会变化，即可用矩阵乘法计数</p><h3 id="至于该题"><a href="#至于该题" class="headerlink" title="至于该题"></a>至于该题</h3><p>那么考虑该题，加入了不能重复在一条边上走的限制，那么最简单的思想就是拆点，并且让改点屏蔽掉当前方向，但是如果考虑边，一条无向边可以拆成两条有向边，那拆出来的就比点少很多了，故考虑点边转化</p><p>那么只要在起始点加一条超级源边，同样矩阵乘法即可统计答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 45989</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">120</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> st, ed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">LL a[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; j ++)</span><br><span class="line">a[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">Matrix newmat;</span><br><span class="line">newmat.init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= size; k ++)</span><br><span class="line">newmat.a[i][j] = (newmat.a[i][j] + a[i][k] * p.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> newmat;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix mats, bem;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">mats = mats * bem;</span><br><span class="line">bem = bem * bem;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[ed]; i; i = Link[i].next)</span><br><span class="line">ans = (ans + mats.a[<span class="number">1</span>][i ^ <span class="number">1</span>]) % MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), K = getnum (), st = getnum () + <span class="number">1</span>, ed = getnum () + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum () + <span class="number">1</span>, v = getnum () + <span class="number">1</span>;</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[st]; i; i = Link[i].next)</span><br><span class="line">bem.a[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= size; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[v]; j; j = Link[j].next) &#123;</span><br><span class="line"><span class="keyword">if</span> ((j ^ <span class="number">1</span>) == i)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">bem.a[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line">mats.a[i][i] = <span class="number">1</span>;</span><br><span class="line">LL ans = power (K);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 3 0 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">0 3</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SCOI2016」萌萌哒</title>
      <link href="/2020/08/04/%5BSCOI2016%5D%E8%90%8C%E8%90%8C%E5%93%92/"/>
      <url>/2020/08/04/%5BSCOI2016%5D%E8%90%8C%E8%90%8C%E5%93%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次做到这种倍增题，有点有趣</p><p>首先区间内的每个点对应相等用并查集维护一下就好了，显然最后的答案就是（并查集个数为 $t$） $9 \cdot 10^{t - 1}$</p><p>当然这样会造成 $O (n^2)$ 的复杂度，那么通过倍增来优化，即将区间二进制拆分，然后每次将 $[l_1, l_1 + 2^k - 1]$ 与 $[l_2, l_2 +2^k - 1]$ 合并，其中 $k$ 为二进制拆分结果所得幂次的部分，那么这样修改就变成 $O (n \log n)$ 了</p><p>对于查询，显然是不能直接查询了，那么就通过由大区间到小区间的传递（即将大区间拆分为左右两段，然后分别与之祖先拆分得左右两段合并）来将信息转移到最小的（即以点为单位的）区间段上</p><p>那么最后即 $O (n)$ 查询并查集个数即可</p><p>故该倍增整体思想即为：将以点为单位处理改为以幂次区间段为单位处理 $\rightarrow$ 将幂次区间段的信息转移到小区间直至单位区间 $\rightarrow$ 答案处理</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> father[x][j] == x ? x : father[x][j] = find (father[x][j], j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (x, j), fy = find (y, j);</span><br><span class="line">father[fx][j] = fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (i, j);</span><br><span class="line">merge (i, fx, j - <span class="number">1</span>);</span><br><span class="line">merge (i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)), fx + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)), j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line">father[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l1 = getnum (), r1 = getnum ();</span><br><span class="line"><span class="keyword">int</span> l2 = getnum (), r2 = getnum ();</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (l1 + p + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= r1) &#123;</span><br><span class="line">merge (l1 + p, l2 + p, j);</span><br><span class="line">p += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pushdown ();</span><br><span class="line"><span class="keyword">int</span> group = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (find (i, <span class="number">0</span>) == i)</span><br><span class="line">group ++;</span><br><span class="line">LL ans = <span class="number">9l</span>l * power (<span class="number">10l</span>l, group - <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">3 3 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">100000 1</span></span><br><span class="line"><span class="comment">1 99999 2 100000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「POI2009」LYZ-Ice Skates</title>
      <link href="/2020/08/04/%5BPOI2009%5DLYZ-Ice%20Skates/"/>
      <url>/2020/08/04/%5BPOI2009%5DLYZ-Ice%20Skates/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前置「Hall定理」"><a href="#前置「Hall定理」" class="headerlink" title="前置「Hall定理」"></a>前置「Hall定理」</h3><blockquote><p> 二分图G中的两部分顶点组成的集合分别为X, Y(假设有|X|≤|Y||X|≤|Y|)。G中有一组无公共点的边，一端恰好为组成X的点(也就是存在完美匹配)的充分必要条件是：X中的任意k个点至少与Y中的k个点相邻，即对于X中的一个点集W ，令N(W)为W的所有邻居， 霍尔定理即对于任意W，|W|≤|N(W)</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于最坏情况任选 $k$ 个是选一端连续的区间 $[l, r]$，根据Hall定理的 $|W| \le N(W)$ 可以得到<br>$$<br>\begin{aligned}<br>sum[l, r] &amp;\le (r - l + 1 + d) \cdot k \\<br>sum[l, r] - (r - l +1) \cdot k &amp;\le d \cdot k<br>\end{aligned}<br>$$<br>那么就可以在线段树中将每个点的权值设为 $value - k$，然后维护最大子段和 $sumax$</p><p>那么最后 $sumax \le d \cdot k  ?  TAK  :  NIE$ 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> limit, N, k, d;</span><br><span class="line"></span><br><span class="line">LL subsum[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL lmax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, rmax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">subsum[root] = subsum[lson] + subsum[rson];</span><br><span class="line">lmax[root] = max (lmax[lson], subsum[lson] + lmax[rson]);</span><br><span class="line">rmax[root] = max (rmax[rson], rmax[lson] + subsum[rson]);</span><br><span class="line">sumax[root] = max (sumax[lson], max (sumax[rson], rmax[lson] + lmax[rson]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">subsum[root] = lmax[root] = rmax[root] = sumax[root] = - k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid), build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">subsum[root] += delta;</span><br><span class="line">lmax[root] += delta, rmax[root] += delta;</span><br><span class="line">sumax[root] += delta;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">posi &lt;= mid ? modify (lson, left, mid, posi, delta) : modify (rson, mid + <span class="number">1</span>, right, posi, delta);</span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">limit = getnum (), N = getnum (), k = getnum (), d = getnum ();</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, limit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> posi = getnum (), delta = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, limit, posi, delta);</span><br><span class="line">LL deal = sumax[<span class="number">1</span>];</span><br><span class="line">deal &lt;= <span class="number">1l</span>l * k * d ? <span class="built_in">puts</span> (<span class="string">"TAK"</span>) : <span class="built_in">puts</span> (<span class="string">"NIE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4 2 1</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">2 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「POI2006」MET-Subway</title>
      <link href="/2020/08/04/%5BPOI2006%5DMET-Subway/"/>
      <url>/2020/08/04/%5BPOI2006%5DMET-Subway/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一棵树上选出 $k$ 条可相交的链使得被覆盖的点数最多，求该最大值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>说实话这个解法是真的厉害</p><p>显然题目可以看作选出 $k \times 2$ 个叶子节点，然后将它们互相连接最终覆盖的点的最大值</p><p>再考虑删去选中的 $k \times 2$ 个叶子节点后，向内一层的点最多只会有 $k \times 2$ 个点有贡献</p><p>同理继续内推</p><p>于是上述过程即由叶子节点开始拓扑，对于拓扑的每一层，令点 $i$ 拓扑深度为 $depth_i$，$total_i$ 表示拓扑深度为 $i$ 的点的个数，即，将每一个拓扑层重新看作叶子节点，再在当前拓扑层中选出至多 $k \times 2$ 个“叶子节点”，故<br>$$<br>\min (k \times 2, total_i)<br>$$<br>即为拓扑深度为 $i$ 的层的答案贡献</p><p>将它们累加起来即可</p><p>复杂度 $O (n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> degree[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> total[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (degree[i] == <span class="number">1</span>) &#123;</span><br><span class="line">que.push(i);</span><br><span class="line">total[depth[i] = <span class="number">1</span>] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> ((-- degree[v]) == <span class="number">1</span>) &#123;</span><br><span class="line">total[depth[v] = depth[u] + <span class="number">1</span>] ++;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">degree[u] ++, degree[v] ++;</span><br><span class="line">&#125;</span><br><span class="line">toposort ();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">ans += min (K &lt;&lt; <span class="number">1</span>, total[i]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">17 3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">9 8</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">10 13</span></span><br><span class="line"><span class="comment">13 14</span></span><br><span class="line"><span class="comment">10 12</span></span><br><span class="line"><span class="comment">12 11</span></span><br><span class="line"><span class="comment">15 17</span></span><br><span class="line"><span class="comment">15 16</span></span><br><span class="line"><span class="comment">15 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2018」你的名字</title>
      <link href="/2020/08/04/%5BNOI2018%5D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/"/>
      <url>/2020/08/04/%5BNOI2018%5D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="主要题意"><a href="#主要题意" class="headerlink" title="主要题意"></a>主要题意</h3><p>求字符串$S$与$T$不同的子串总数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑$l = 1, r = |T|$的情况：</p><p>因为任意子串为字符串前缀的某些后缀，那么令$Lim[i]$表示$T[1…i]$在$S$上所能匹配的最大长度，$Posi[i]$表示$T$的后缀自动机上的点$i$的$endpos$集合中最靠前的位置，那么答案即为</p><p>$$Ans = \sum\limits_{i = 1}^{nodes} \max (0, Len[i] - min (Len[Father[i]], Lim[Posi[i]]))$$</p><p>接下来考虑$l, r$任意的情况：</p><p>原来能否在$S$的后缀自动机上往下走的判断依据只有当前节点是否存在$c$边，那么有了$l, r$的限制，就多需要判断向下的这个节点的$endpos$是否有存在于$[l + len, r]$（$len$表示已匹配长度）区间的位置，$endpos$集合用动态开点线段树维护一下就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">char</span> Orig[MAXN], Str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Root[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Left[MAXN * MAXL]= &#123;<span class="number">0</span>&#125;, Right[MAXN * MAXL]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tnodes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! root)</span><br><span class="line">        root = ++ tnodes;</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pos &lt;= mid ? Modify (Left[root], left, mid, pos) : Modify (Right[root], mid + <span class="number">1</span>, right, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tree_Merge</span> <span class="params">(<span class="keyword">int</span> sl, <span class="keyword">int</span> sr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! sl || ! sr)</span><br><span class="line">        <span class="keyword">return</span> sl + sr;</span><br><span class="line">    <span class="keyword">int</span> p = ++ tnodes;</span><br><span class="line">    Left[p] = Tree_Merge (Left[sl], Left[sr]);</span><br><span class="line">    Right[p] = Tree_Merge (Right[sl], Right[sr]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! root || left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)</span><br><span class="line">        <span class="keyword">if</span> (Query (Left[root], left, mid, L, R))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)</span><br><span class="line">        <span class="keyword">if</span> (Query (Right[root], mid + <span class="number">1</span>, right, L, R))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Tree[MAXN][<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> Father[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Len[MAXN], Posi[MAXN];</span><br><span class="line">    <span class="keyword">int</span> last, nodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span> (Tree[i], <span class="number">0</span>, <span class="keyword">sizeof</span> (Tree[i]));</span><br><span class="line">            Father[i] = <span class="number">0</span>, Posi[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nodes = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> pos, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = last, p = ++ nodes;</span><br><span class="line">        last = p;</span><br><span class="line">        Len[p] = Len[fa] + <span class="number">1</span>, Posi[p] = pos;</span><br><span class="line">        <span class="keyword">while</span> (fa &amp;&amp; ! Tree[fa][c])</span><br><span class="line">            Tree[fa][c] = p, fa = Father[fa];</span><br><span class="line">        <span class="keyword">if</span> (! fa)</span><br><span class="line">            Father[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Tree[fa][c];</span><br><span class="line">            <span class="keyword">if</span> (Len[x] == Len[fa] + <span class="number">1</span>)</span><br><span class="line">                Father[p] = x;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> np = ++ nodes;</span><br><span class="line">                Len[np] = Len[fa] + <span class="number">1</span>, Father[np] = Father[x], Posi[np] = Posi[x];</span><br><span class="line">                Father[p] = Father[x] = np;</span><br><span class="line">                <span class="built_in">memcpy</span> (Tree[np], Tree[x], <span class="keyword">sizeof</span> (Tree[x]));</span><br><span class="line">                <span class="keyword">while</span> (fa &amp;&amp; Tree[fa][c] == x)</span><br><span class="line">                    Tree[fa][c] = np, fa = Father[fa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">            Modify (Root[p], <span class="number">1</span>, N, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Minp[MAXN];</span><br><span class="line">    <span class="keyword">int</span> buck[MAXN];</span><br><span class="line">    <span class="comment">/*void Merge_Minp () &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= nodes; i ++)</span></span><br><span class="line"><span class="comment">            buck[i] = 0, Minp[i] = Posi[i];</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= nodes; i ++)</span></span><br><span class="line"><span class="comment">            buck[Len[i]] ++;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= N; i ++)</span></span><br><span class="line"><span class="comment">            buck[i] += buck[i - 1];</span></span><br><span class="line"><span class="comment">        for (int i = nodes; i &gt;= 1; i --)</span></span><br><span class="line"><span class="comment">            Topo[buck[Len[i]] --] = i;</span></span><br><span class="line"><span class="comment">        for (int i = nodes; i &gt;= 1; i --)</span></span><br><span class="line"><span class="comment">            Minp[Father[Topo[i]]] = min (Minp[Father[Topo[i]]], Minp[Topo[i]]);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge_Tree</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">            buck[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">            buck[Len[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">            buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">            Topo[buck[Len[i]] --] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">            Root[Father[Topo[i]]] = Tree_Merge (Root[Father[Topo[i]]], Root[Topo[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">SAM S, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Lim[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/*void Match (int l, int r) &#123;</span></span><br><span class="line"><span class="comment">    int p = 1, len = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= M; i ++) &#123;</span></span><br><span class="line"><span class="comment">        int c = Str[i] - 'a';</span></span><br><span class="line"><span class="comment">        while (p &amp;&amp; ! S.Tree[p][c])</span></span><br><span class="line"><span class="comment">            p = S.Father[p], len = S.Len[p];</span></span><br><span class="line"><span class="comment">        while (p &amp;&amp; ! Query (Root[S.Tree[p][c]], 1, N, l + len, r))</span></span><br><span class="line"><span class="comment">            p = S.Father[p], len = S.Len[p];</span></span><br><span class="line"><span class="comment">        S.Tree[p][c] ? (p = S.Tree[p][c], len ++) : (p = 1, len = 0);</span></span><br><span class="line"><span class="comment">        Lim[i] = len;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = Str[j] - <span class="string">'a'</span>;</span><br><span class="line">        T.Append (c, j, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.Tree[p][c] &amp;&amp; Query (Root[S.Tree[p][c]], <span class="number">1</span>, N, l + len, r)) &#123;</span><br><span class="line">                p = S.Tree[p][c], len ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! len)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            len --;</span><br><span class="line">            <span class="keyword">if</span> (len == S.Len[S.Father[p]])</span><br><span class="line">                p = S.Father[p];</span><br><span class="line">        &#125;</span><br><span class="line">        Lim[j] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// T.Merge_Minp ();</span></span><br><span class="line">    <span class="comment">// Match (l, r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T.nodes; i ++)</span><br><span class="line">        ans += max (<span class="number">0</span>, T.Len[i] - max (T.Len[T.Father[i]], Lim[T.Posi[i]]));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Orig + <span class="number">1</span>);</span><br><span class="line">    N = <span class="built_in">strlen</span> (Orig + <span class="number">1</span>);</span><br><span class="line">    S.init ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        S.Append (Orig[i] - <span class="string">'a'</span>, i, <span class="number">1</span>);</span><br><span class="line">    S.Merge_Tree ();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">        T.init ();</span><br><span class="line">        M = <span class="built_in">strlen</span> (Str + <span class="number">1</span>);</span><br><span class="line">        Work (l, r);</span><br><span class="line">        LL ans = Solve ();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">scbamgepe</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">smape 1 9</span></span><br><span class="line"><span class="comment">sbape 1 9</span></span><br><span class="line"><span class="comment">sgepe 1 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">scbamgepe</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">smape 2 7</span></span><br><span class="line"><span class="comment">sbape 3 8</span></span><br><span class="line"><span class="comment">sgepe 1 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2016」循环之美</title>
      <link href="/2020/08/04/%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/"/>
      <url>/2020/08/04/%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求解 $1 \le x \le n, ~ 1 \le y \le m$ 中满足在 $k$ 进制下 $\frac{x}{y}$ 是有限循环小数的个数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很好然后我一开始在计算器上敲了半个小时然后由于眼瞎并且归纳能力差并没有发现规律</p><p>设 $\frac{x}{y}$ 的循环节长度为 $l$，则有<br>$$<br>\begin{aligned}<br>\frac{xk^l}{y} - \left\lfloor\frac{xk^l}{y}\right\rfloor &amp;= \frac{x}{y} - \left\lfloor\frac{x}{y}\right\rfloor \\<br>xk^l - \left\lfloor\frac{xk^l}{y}\right\rfloor y &amp;= x - \left\lfloor\frac{x}{y}\right\rfloor y \\<br>xk^l &amp;\equiv x \pmod y \\<br>k &amp;\equiv 1 \pmod y<br>\end{aligned}<br>$$<br>也就是说只要满足 $y \bot k$ 即可满足题意，故可将问题化为<br>$$<br>\begin{aligned}<br>Ans &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1][(j, k) = 1] \\<br>&amp;= \sum\limits_{j = 1}^m [(j, k) = 1]\sum\limits_{d | j} \mu(d)\left\lfloor\frac{n}{d}\right\rfloor \\<br>&amp;= \sum\limits_{d = 1}^n \mu(d)\left\lfloor\frac{n}{d}\right\rfloor\sum\limits_{d | j}[(j, k) = 1] \\<br>&amp;将j除以d, 此时若后半部分的\sum要有贡献则需满足d \bot k \\<br>&amp;= \sum\limits_{d = 1}^n [(d, k) = 1]\mu(d)\left\lfloor\frac{n}{d}\right\rfloor\big(\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor}[(j, k) = 1]\big)<br>\end{aligned}<br>$$<br>于是接下来变为处理<br>$$<br>f_1(n, k) = \sum\limits_{d = 1}^n [(d, k) = 1]\mu(d) \\<br>f_2(n) = \sum\limits_{d = 1}^n [(d, k) = 1]<br>$$<br>先说 $f_2(n)$，较好处理，即考虑长度为 $k$ 的区间将 $n$ 分段，其中除了最后多出来的那一段其余的段得到的贡献是相同的，即 $\varphi(k)$，故<br>$$<br>f_2(n) = \left\lfloor\frac{n}{k}\right\rfloor\varphi(k) + f_2(n \% k)<br>$$<br>那么对于 $f_1(n, k)$，容易变换得<br>$$<br>f_1(n, k) = \sum\limits_{d | k}^n \mu(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(ld)<br>$$<br>然后我就不会了，看了下题解，可以发现若 $\mu(ld)$ 有贡献，<strong>则需满足 $l \bot d$，此时有 $\mu(ld) = \mu(l)\mu(d)$</strong>，故<br>$$<br>\begin{aligned}<br>f_1(n, k) &amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(l)\mu(d)[(d, l) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu^2(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(l)[(d, l) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu^2(d)f_1(\left\lfloor\frac{n}{d}\right\rfloor, d)<br>\end{aligned}<br>$$<br>很好我还是第一次写到莫反带递归的</p><p>注意边界条件 $n = 0$ 与 $k = 1$，对于 $n = 0$ 返回 $0$ 即可，对于 $k = 1$，$f_1(n, 1)$ 即为 $\sum\limits_{d = 1}^n \mu(d)$，杜教筛一下即可</p><p>最后再整除分块一次求总答案就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e06</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM / <span class="number">10</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXM]= &#123;<span class="number">0</span>&#125;, sumu[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">sumu[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! visit[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">&#125;</span><br><span class="line">sumu[i] = sumu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapmu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumu[n];</span><br><span class="line"><span class="keyword">if</span> (mapmu[n]) <span class="keyword">return</span> mapmu[n];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= (r - l + <span class="number">1</span>) * mu_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapmu[n] = total;</span><br><span class="line">&#125;</span><br><span class="line">LL f[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumr[MAXM]= &#123;<span class="number">0</span>&#125;; <span class="comment">// sigma ([(j, k) = 1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ! b ? a : GCD (b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + (GCD (i, K) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rval</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n / K) * f[K] + f[n % K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mapl;</span><br><span class="line"><span class="function">LL <span class="title">l_solve</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// S(n, K)</span></span><br><span class="line"><span class="keyword">if</span> (! n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = make_pair (n, k);</span><br><span class="line"><span class="keyword">if</span> (mapl[ret]) <span class="keyword">return</span> mapl[ret];</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> mu_sieve (n);</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (k % i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mu[i]) total += l_solve (n / i, i);</span><br><span class="line"><span class="keyword">if</span> (i * i != k &amp;&amp; mu[k / i])</span><br><span class="line">total += l_solve (n / (k / i), k / i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapl[ret] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">linear_sieve ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>, &amp; N, &amp; M, &amp; K);</span><br><span class="line">r_sieve ();</span><br><span class="line">LL ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min (N, M); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min (N / (N / l), M / (M / l));</span><br><span class="line">LL pl = l_solve (r, K);</span><br><span class="line">ans += <span class="number">1l</span>l * (pl - pre) * (N / l) * rval (M / l);</span><br><span class="line">pre = pl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 6 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">99 7689 100</span></span><br><span class="line"><span class="comment">ans: 257777</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>我没有写这种方法，但是这种真的很简单的说<br>$$<br>\begin{aligned}<br>f(n, m, k) &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1][(j, k) = 1] \\<br>&amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1]\sum\limits_{d | j, d | k} \mu(d) \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{d | j}^m [(i, j) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} [(i, jd) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} [(i, j) = 1][(i, d) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)f(\left\lfloor\frac{m}{d}\right\rfloor, n, d)<br>\end{aligned}<br>$$<br>边界 $n = 0$ 或者 $m = 0$ 返回 $0$，$k = 1$ 返回 $\sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1] = \sum\limits_{i = 1}^{\min (n, m)} \mu(d) \left\lfloor\frac{n}{d}\right\rfloor \left\lfloor\frac{m}{d}\right\rfloor$ 即可</p><p>不过说实话这个虽然简单但是至少对于我不大容易想到，毕竟我会先拆 $[(i, j) = 1]$ 部分，因为总感觉 $[(j, k) = 1]$ 会多出一个 $d | k$ 的限制条件</p><p>但是这个解法是真的厉害</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2014」购票 「树上斜率优化」</title>
      <link href="/2020/08/04/%5BNOI2014%5D%E8%B4%AD%E7%A5%A8%20%E3%80%8C%E6%A0%91%E4%B8%8A%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/"/>
      <url>/2020/08/04/%5BNOI2014%5D%E8%B4%AD%E7%A5%A8%20%E3%80%8C%E6%A0%91%E4%B8%8A%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先易得方程，且经过变换有</p><p>$$\begin{aligned} f_i &amp;= \min\limits_{dist_i - lim_i \le dist_j} \{f_j + (dist_i - dist_j)p_i + q_i\} \\ f_j &amp;= p_idist_j + f_i - dist_ip_i - q_i \end{aligned}​$$</p><p>在一条直线上时，斜率优化可以用普通$CDQ​$分治实现（会不会过于麻烦？），那么对于在树上斜率优化时，考虑点分治</p><p>这时就在点分治中运用$CDQ$分治的思想，即使用在当前重心管辖范围内的通向根节点的那一条链上的节点来更新其它节点就好了</p><p>注意在分治中的斜率优化时在凸包上加点和更新右侧节点答案要同时进行，不然当前最优解可能会在后面由于斜率被删去，导致答案错误，还有由于下面代码是由深度由小到大处理的，所以是反着维护下凸包，即上凸包</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-08</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dcmp</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CitySt</span> &#123;</span></span><br><span class="line">    LL p, q, lim;</span><br><span class="line"></span><br><span class="line">    CitySt () &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">CitySt City[MAXN];</span><br><span class="line"></span><br><span class="line">LL f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL Fdist[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL Dist[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Dist[v] = Dist[root] + Fdist[v];</span><br><span class="line">        DFS (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> grvy, minval = INF;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grvy_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    Size[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Grvy_Acqu (v, root);</span><br><span class="line">        Size[root] += Size[v];</span><br><span class="line">        maxpart = max (maxpart, Size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxpart = max (maxpart, total - Size[root]);</span><br><span class="line">    <span class="keyword">if</span> (maxpart &lt; minval)</span><br><span class="line">        grvy = root, minval = maxpart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[MAXN];</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Que[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dist[a] == Dist[b])</span><br><span class="line">        <span class="keyword">return</span> INFLL * <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (f[b] - f[a]) * <span class="number">1.0</span> / (<span class="keyword">double</span>) (Dist[b] - Dist[a]) * <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> listq[MAXN];</span><br><span class="line"><span class="keyword">int</span> lp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Dist[a] - City[a].lim &gt; Dist[b] - City[b].lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listq_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father)</span><br><span class="line">        listq[++ lp] = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        listq_Acqu (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[Que[mid + <span class="number">1</span>]] - f[Que[mid]] &lt;= p * (Dist[Que[mid + <span class="number">1</span>]] - Dist[Que[mid]]))</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = Binary_Search (left, right, City[tp].p);</span><br><span class="line">    f[tp] = min (f[tp], f[Que[p]] + (Dist[tp] - Dist[Que[p]]) * City[tp].p + City[tp].q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    minval = INF, total = Size[root], Grvy_Acqu (root, <span class="number">0</span>);</span><br><span class="line">    Vis[grvy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> fgrvy = grvy;</span><br><span class="line">    <span class="keyword">if</span> (grvy != root) &#123;</span><br><span class="line">        Size[root] -= Size[grvy];</span><br><span class="line">        Solve (root);</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    temp[++ p] = fgrvy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = fgrvy; nd != root; nd = Father[nd]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dist[fgrvy] - City[fgrvy].lim &lt;= Dist[Father[nd]])</span><br><span class="line">            f[fgrvy] = min (f[fgrvy], f[Father[nd]] + (Dist[fgrvy] - Dist[Father[nd]]) * City[fgrvy].p + City[fgrvy].q);</span><br><span class="line">        temp[++ p] = Father[nd];</span><br><span class="line">    &#125;</span><br><span class="line">    lp = <span class="number">0</span>;</span><br><span class="line">    listq_Acqu (fgrvy, <span class="number">0</span>);</span><br><span class="line">    sort (listq + <span class="number">1</span>, listq + lp + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p &amp;&amp; j &lt;= lp; i ++) &#123; <span class="comment">// 斜率优化</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= lp &amp;&amp; Dist[temp[i]] &lt; Dist[listq[j]] - City[listq[j]].lim)</span><br><span class="line">            Update (left, right, listq[j ++]);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; Dcmp (slope (Que[right - <span class="number">1</span>], Que[right]) - slope (Que[right], temp[i])) &lt;= <span class="number">0</span>) <span class="comment">// 注意是上凸包</span></span><br><span class="line">            right --;</span><br><span class="line">        Que[++ right] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= lp)</span><br><span class="line">        Update (left, right, listq[j ++]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fgrvy]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Solve (v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">getLL</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen ("Output.txt", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">    f[Root] = <span class="number">0</span>;</span><br><span class="line">    N = getint (), getint ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = getint ();</span><br><span class="line">        Father[i] = fa;</span><br><span class="line">        Fdist[i] = getLL ();</span><br><span class="line">        City[i].p = getLL (), City[i].q = getLL (), City[i].lim = getLL ();</span><br><span class="line">        Insert (fa, i), Insert (i, fa);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS (Root, <span class="number">0</span>);</span><br><span class="line">    Size[Root] = N;</span><br><span class="line">    Solve (Root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 3</span></span><br><span class="line"><span class="comment">1 2 20 0 3</span></span><br><span class="line"><span class="comment">1 5 10 100 5</span></span><br><span class="line"><span class="comment">2 4 10 10 10</span></span><br><span class="line"><span class="comment">2 9 1 100 10</span></span><br><span class="line"><span class="comment">3 5 20 100 10</span></span><br><span class="line"><span class="comment">4 4 20 0 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 树上DP </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2007」货币兑换 「CDQ分治实现斜率优化」</title>
      <link href="/2020/08/04/%5BNOI2007%5D%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2%20%E3%80%8CCDQ%E5%88%86%E6%B2%BB%E5%AE%9E%E7%8E%B0%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/"/>
      <url>/2020/08/04/%5BNOI2007%5D%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2%20%E3%80%8CCDQ%E5%88%86%E6%B2%BB%E5%AE%9E%E7%8E%B0%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先每次买卖一定是在某天 $k$ 以当时的最大收入买入，再到第 $i$ 天卖出，那么易得方程：</p><p>$$f_i = \max \{\frac{A_iRate_kf_k}{A_kRate_k + B_k} + \frac{B_if_k}{A_kRate_k + B_k}\}$$</p><p>再令</p><p>$$\left\{\begin{aligned} x_k = \frac{Rate_kf_k}{A_kRate_k + B_k} \\ y_k = \frac{f_k}{A_kRate_k + B_k}\end{aligned}\right.$$</p><p>则有</p><p>$$\begin{aligned} f_i &amp;= \max \{A_ix_k + B_iy_k\} \\ y_k &amp;= - \frac{A_i}{B_i}x_k + \frac{f_i}{B_i} \end{aligned}$$</p><p>那么现在需要找到一个点 $(x_k, y_k)$ 使得直线的截距最大</p><p>由于斜率和横坐标皆不满足单调性，可以用平衡树等维护，这里使用CDQ分治实现</p><p>实现过程如下：</p><p>Ⅰ 将数据按照斜率$\frac{A_i}{B_i}$降序排序</p><p>Ⅱ 将区间按照操作顺序分为左右两部分处理</p><p>Ⅲ 先处理左半部分，维护左半边凸包（注意，此时左半边已按照 $x$ 排序）</p><p>Ⅳ 处理左半边对右半边的影响，由于已按照斜率降序排序，所以普通斜率优化即可</p><p>Ⅴ 将区间按照 $x$ 排序</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-08</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dcmp</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CashSt</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b, rate;</span><br><span class="line">    <span class="keyword">double</span> k, x, y;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    CashSt () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> CashSt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Dcmp (x - p.x) == <span class="number">0</span> ? Dcmp (y - p.y) &lt; <span class="number">0</span> : Dcmp (x - p.x) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">CashSt Cash[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> CashSt&amp; a, <span class="keyword">const</span> CashSt&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Dcmp (a.k - b.k) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span> <span class="params">(CashSt a, CashSt b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dcmp (b.x - a.x) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> (b.y - a.y) / (b.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CashSt Que[MAXN];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">CashSt temp[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        f[left] = max (f[left], f[left - <span class="number">1</span>]);</span><br><span class="line">        Cash[left].y = f[left] / (Cash[left].a * Cash[left].rate + Cash[left].b);</span><br><span class="line">        Cash[left].x = Cash[left].y * Cash[left].rate;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = left - <span class="number">1</span>, p2 = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i ++)</span><br><span class="line">        Cash[i].index &lt;= mid ? temp[++ p1] = Cash[i] : temp[++ p2] = Cash[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i ++)</span><br><span class="line">        Cash[i] = temp[i];</span><br><span class="line">    CDQ (left, mid);</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= mid; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; Dcmp (slope (Que[r - <span class="number">1</span>], Que[r]) - slope (Que[r], Cash[i])) &lt; <span class="number">0</span>)</span><br><span class="line">            r --;</span><br><span class="line">        Que[++ r] = Cash[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; Dcmp (slope (Que[l], Que[l + <span class="number">1</span>]) - Cash[i].k) &gt; <span class="number">0</span>)</span><br><span class="line">            l ++;</span><br><span class="line">        f[Cash[i].index] = max (f[Cash[i].index], Cash[i].a * Que[l].x + Cash[i].b * Que[l].y);</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ (mid + <span class="number">1</span>, right);</span><br><span class="line">    l = left, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// if (Dcmp (Cash[l].x - Cash[r].x) &lt; 0 || (Dcmp (Cash[l].x - Cash[r].x) == 0 &amp;&amp; Dcmp (Cash[l].y - Cash[r].y) &lt; 0))</span></span><br><span class="line">        <span class="keyword">if</span> (Cash[l] &lt; Cash[r])</span><br><span class="line">            temp[++ p] = Cash[l], l ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[++ p] = Cash[r], r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid)</span><br><span class="line">        temp[++ p] = Cash[l], l ++;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= right)</span><br><span class="line">        temp[++ p] = Cash[r], r ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i ++)</span><br><span class="line">        Cash[i + left - <span class="number">1</span>] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">double</span> T = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = num * <span class="number">10.0</span> + (ch - <span class="string">'0'</span>) * <span class="number">1.0</span>, ch = getchar ();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">            num = num + (T /= <span class="number">10.0</span>) * (ch - <span class="string">'0'</span>), ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%lf"</span>, &amp; N, &amp; f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">double</span> a = getnum (), b = getnum (), rate = getnum ();</span><br><span class="line">        Cash[i].a = a, Cash[i].b = b, Cash[i].rate = rate;</span><br><span class="line">        Cash[i].index = i;</span><br><span class="line">        Cash[i].k = - a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort (Cash + <span class="number">1</span>, Cash + N + <span class="number">1</span>, comp);</span><br><span class="line">    CDQ (<span class="number">1</span>, N);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%.3f\n"</span>, f[N]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 100</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">2 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2007」生成树计数</title>
      <link href="/2020/08/04/%5BNOI2007%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/"/>
      <url>/2020/08/04/%5BNOI2007%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>后面发现这是某次考试的原题来着</p><p>怕是太久没打过状压然后连 $k \le 5$ 可能要状压这么明显的提示都给无视了然后就随便敲了个矩阵树骗了 $50$。。。</p><p>好所以这题是一道状压</p><p>令 $state$ 表示对于 $i$ 点（包括它本身）的前 $k$ 个点的连通状态，$e.g.   \{1, 1, 2\}$ 表示 $\{1, 2\}, \{3\}$ 点分别连通</p><p>注意为了去重要用最小表示，于是即使当 $k = 5$ 时状态数也不过就 $52$ 个而已了</p><p>再令 $f_{i, j}$ 表示前 $i$ 个点且 $i$ 点连通状态为 $j$ 时的方案数，$g_{i, j}$ 表示状态 $i$ 转移到状态 $j$ 时的方案数，则有方程<br>$$<br>f_{i, j} = \sum_k f_{i - 1, k} * g_{k, j}<br>$$<br>可以发现这就是一个矩阵转移式，故直接矩阵乘法即可</p><p>那么至于计算 $g_{i, j}$ 则枚举 $i$，及当前点与前面点的连通状态 $state$（二进制表示），然后并查集维护一下，判断当前 $state$ 是否会与之前冲突（连边后无环且原状态中的最前点（即会被刷掉的点）与当前的 $k$ 个点中至少一个点连边），然后计算出 $j$，最后累加即可</p><p>当然要注意考虑 $f$ 矩阵的初始状态，即对于 $i  \in [1, k]$，那么计算出里面每个连通块的大小 $a_i$，然后用 $Calley$ 公式 $n^{n - 2}$ 算一下就好了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 65521</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">52</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">6e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line">LL N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allst[MAXM], M = <span class="number">0</span>; <span class="comment">// 压位表示</span></span><br><span class="line"><span class="keyword">int</span> mapp[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> state, <span class="keyword">int</span> maxi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == K + <span class="number">1</span>) &#123;</span><br><span class="line">        allst[++ M] = state;</span><br><span class="line">        mapp[state] = M;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min (maxi + <span class="number">1</span>, K); i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nst = state * <span class="number">10</span> + i;</span><br><span class="line">        DFS (p + <span class="number">1</span>, nst, max (i, maxi));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    LL a[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line">    Matrix () &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; A, <span class="keyword">const</span> Matrix&amp; B) &#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= M; k ++)</span><br><span class="line">ret.a[i][j] = (ret.a[i][j] + A.a[i][k] * B.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">Matrix f, g;</span><br><span class="line"><span class="function">LL <span class="title">matpower</span> <span class="params">(LL p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">f = f * g;</span><br><span class="line">g = g * g;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[x] == x ? x : father[x] = find (father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> visit[MAXK]= &#123;<span class="number">0</span>&#125;, bit[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> con)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K + <span class="number">1</span>; i ++)</span><br><span class="line">        father[i] = i, visit[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> st = state, i = K; i &gt; <span class="number">0</span>; i --, st /= <span class="number">10</span>)</span><br><span class="line">        bit[i] = st % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= K; j ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find (i), fy = find (j);</span><br><span class="line">            <span class="keyword">if</span> (bit[i] != bit[j] || fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++)</span><br><span class="line">        <span class="keyword">if</span> (con &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find (K + <span class="number">1</span>), fy = find (j);</span><br><span class="line">            <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> ;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K + <span class="number">1</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span> (find (<span class="number">1</span>) == find (i)) &#123;</span><br><span class="line">            fail = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (fail) <span class="keyword">return</span> ; <span class="comment">// 之前的点都联通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        bit[i] = find (i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! visit[bit[i]])</span><br><span class="line">            visit[bit[i]] = ++ cnt;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">final</span> = <span class="keyword">final</span> * <span class="number">10</span> + visit[bit[i]];</span><br><span class="line">    g.a[mapp[state]][mapp[<span class="keyword">final</span>]] ++, g.a[mapp[state]][mapp[<span class="keyword">final</span>]] %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prep</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123; <span class="comment">// i in [1, k]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++) cnt[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> st = allst[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++, st /= <span class="number">10</span>)</span><br><span class="line">            cnt[st % <span class="number">10</span>] ++;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; cnt[j] &gt; <span class="number">0</span>; j ++)</span><br><span class="line">    ret = ret * power (cnt[j], cnt[j] - <span class="number">2</span>) % MOD;</span><br><span class="line">    f.a[<span class="number">1</span>][i] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) <span class="comment">// 枚举当前点及其与之前的连通状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++)</span><br><span class="line">            maintain (allst[i], state);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt;= M; i ++) &#123;</span></span><br><span class="line"><span class="comment">        for (int j = 1; j &lt;= M; j ++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; g.a[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        puts ("");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N;</span><br><span class="line">    DFS (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), prep ();</span><br><span class="line">    LL ans = matpower (N - K);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 23333333333333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JSOI2012」分零食</title>
      <link href="/2020/08/04/%5BJSOI2012%5D%E5%88%86%E9%9B%B6%E9%A3%9F/"/>
      <url>/2020/08/04/%5BJSOI2012%5D%E5%88%86%E9%9B%B6%E9%A3%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先普通 $DP$ 式子很好列</p><p>令 $f[i][j]$ 表示 $i$ 个小朋友分 $j$ 个糖果且每人至少一颗的答案，则有<br>$$<br>f[i][j] = \sum\limits_{k = 1}^j f[i - 1][j - k](Ok^2 + Sk + U)<br>$$<br>接下来用生成函数优化该式</p><p>令 $g[k] = Ok^2 + Sk + U$，则<br>$$<br>f_i(x) = f_{i - 1}(x)g(x)<br>$$<br>其中 $f_0(x) = 1$</p><p>所以答案即为<br>$$<br>[x^M] \sum\limits_{i = 0}^A f_i(x) = [x^M] \sum\limits_{i = 0}^A (g(x))^i = [x^M] \frac{1 - (g(x))^{A + 1}}{1 - g(x)}<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL MOD;</span><br><span class="line">LL O, S, U;</span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> a, b;</span><br><span class="line"></span><br><span class="line">mcomplex (<span class="keyword">double</span> fa = <span class="number">0.0</span>, <span class="keyword">double</span> fb = <span class="number">0.0</span>) :</span><br><span class="line">a (fa), b (fb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a + p.a, b + p.b);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a - p.a, b - p.b);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a * p.a - b * p.b, a * p.b + b * p.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">mcomplex omega = mcomplex (<span class="built_in">cos</span> (PI / (<span class="keyword">double</span>) mid), inv * <span class="built_in">sin</span> (PI / (<span class="keyword">double</span>) mid));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">mcomplex x = mcomplex (<span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega) &#123;</span><br><span class="line">mcomplex a1 = a[j + k], xa2 = x * a[j + mid + k];;</span><br><span class="line">a[j + k] = a1 + xa2;</span><br><span class="line">a[j + k + mid] = a1 - xa2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aclimit</span> <span class="params">(<span class="keyword">int</span> maxl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= maxl; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">limit = n;</span><br><span class="line">&#125;</span><br><span class="line">mcomplex a1[MAXN &lt;&lt; <span class="number">2</span>], a2[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span> <span class="params">(LL* A, LL* B, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">aclimit (n + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a2[i] = mcomplex ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">a1[i] = mcomplex ((<span class="keyword">double</span>) A[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">a2[i] = mcomplex ((<span class="keyword">double</span>) B[i], <span class="number">0</span>);</span><br><span class="line">FFT (a1, <span class="number">1</span>), FFT (a2, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a1[i] * a2[i];</span><br><span class="line">FFT (a1, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++)</span><br><span class="line">A[i] = (LL) (a1[i].a / limit + <span class="number">0.5</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL inv[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* A, LL* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B);</span><br><span class="line">aclimit (deg &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">temp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">temp[i] = A[i];</span><br><span class="line">multiply (temp, B, deg, deg);</span><br><span class="line">multiply (temp, B, deg, deg);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">B[i] = (<span class="number">2</span> * B[i] % MOD - temp[i] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span> <span class="params">(LL* A, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">multiply (ans, a, M, M);</span><br><span class="line">multiply (a, a, M, M);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">isneg = <span class="number">1</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">M = getnum (), MOD = getnum (), N = getnum ();</span><br><span class="line">O = getnum (), S = getnum (), U = getnum ();</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">a[i] = (O * i * i + S * i + U) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">b[i] = (- a[i] + MOD) % MOD;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">power (ans, N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">ans[i] = (- ans[i] + MOD) % MOD;</span><br><span class="line">ans[<span class="number">0</span>] = (ans[<span class="number">0</span>] + <span class="number">1</span>) % MOD;</span><br><span class="line">inverse (M + <span class="number">1</span>, b, inv);</span><br><span class="line">multiply (ans, inv, M, M);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 100</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JLOI2013」地形生成</title>
      <link href="/2020/08/04/%5BJLOI2013%5D%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/"/>
      <url>/2020/08/04/%5BJLOI2013%5D%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>挺有趣的一道 $dp$，两问实际上就相当于是第一问是第二问的部分分</p><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>一开始以为要 $dp$，然而并不用</p><p>对于这种高度然后求方案数的题，可以只考虑其相对位置，因为只要所有相对位置确定了，那么整个序列就唯一确定了</p><p>首先肯定要先将它们以高度为第一关键字（由大到小），关键值为第二关键字（从小到大）排序</p><p>那么对于第 $i$ 座山，它就会有 $\min (i, key_i)$ 个相对位置可以占，因为有相同高度的山峰，所以还会多出 $same$ （$i$ 前面与其高度相同的山峰的个数）个位置</p><p>那么 $ans_1 = \prod\limits_{i = 1}^n min (i, key_i + same)$</p><h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>症结还是在于相同高度的山峰会产生重复</p><p>但是显然如果一次性确定好所有相同山峰的位置是不会产生重复的，故考虑将每一组相同高度的山峰放在一起处理</p><p>为了避免重复，需要强制令这些相同高度的山峰放置有序，即后放的一定在先放的后面，那么就可以令 $f_{i, j}$ 表示（当前组相同高度山峰）前 $i$ 个放在前 $j$ 个位置上，并且第 $i$ 放在第 $j$ 个位置的方案数，则有（下示方程表示区间 $[l, r]$ 的相同高度山峰组）<br>$$<br>\begin{aligned}<br>f_{i, j} &amp;= \sum\limits_{k = 1}^j f_{i - 1, k}  (j \in [0, \min (l, key_i) - 1]) \\<br>&amp;= f_{i - 1, j} + f_{i, j - 1}<br>\end{aligned}<br>$$<br>然后实际上第一维是没用的，再省掉就行了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 2011</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hillSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">hillSt (<span class="keyword">int</span> fhigh = <span class="number">0</span>, <span class="keyword">int</span> fkey = <span class="number">0</span>) :</span><br><span class="line">high (fhigh), key (fkey) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> hillSt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (high == p.high)</span><br><span class="line"><span class="keyword">return</span> key &lt; p.key;</span><br><span class="line"><span class="keyword">return</span> high &gt; p.high;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">hillSt hill[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">hill[i].high = getnum (), hill[i].key = getnum ();</span><br><span class="line">sort (hill + <span class="number">1</span>, hill + N + <span class="number">1</span>);</span><br><span class="line">LL ans1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">hill[i].high == hill[i - <span class="number">1</span>].high ? same ++ : same = <span class="number">0</span>;</span><br><span class="line">ans1 = ans1 * <span class="number">1l</span>l * min (i, hill[i].key + same) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL ans2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N; l ++) &#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">for</span> (r = l; r &lt;= N &amp;&amp; hill[r + <span class="number">1</span>].high == hill[r].high; r ++);</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min (l, hill[i].key) - <span class="number">1</span>; j ++)</span><br><span class="line">f[j] = (f[j - <span class="number">1</span>] + f[j]) % MOD;</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min (l, hill[r].key) - <span class="number">1</span>; j ++)</span><br><span class="line">total = (total + f[j]) % MOD;</span><br><span class="line">ans2 = ans2 * total % MOD;</span><br><span class="line">swap (l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">' '</span> &lt;&lt; ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HNOI2007」梦幻岛宝珠 「套路：分层DP」</title>
      <link href="/2020/08/04/%5BHNOI2007%5D%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E3%80%8C%E5%A5%97%E8%B7%AF%EF%BC%9A%E5%88%86%E5%B1%82DP%E3%80%8D/"/>
      <url>/2020/08/04/%5BHNOI2007%5D%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E3%80%8C%E5%A5%97%E8%B7%AF%EF%BC%9A%E5%88%86%E5%B1%82DP%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>显然直接 $01$ 背包会超时并且超空间</p><p><strong>套路：分层 $DP$</strong></p><p>「考虑将每个子结构看作一层（也就是包含了不止 $1$ 个物品的信息），并且大层不会对小层造成影响，可以考虑先进行每一层的自我更新（即用当前层物品更新当前层答案），再进行层的合并，此时考虑低层对高层的影响」</p><p><strong>正题</strong></p><p>那么这题有一个特殊性质： $V_i = a \times 2^b$</p><blockquote><p>b值大的物品不会影响零碎剩余的重量上限。</p><p>将物品按b值分阶段处理。</p></blockquote><p>那么就是分层 $DP$</p><p>先通过普通的 $01$ 背包更新当前层自身最优解</p><p>再进行层合并：</p><p>令 $g_{i, j}​$ 表示第 $i​$ 层，$a​$ 为 $j​$ 的最优解，$f_{i, j}​$ 表示第 $i​$ 层，$a​$ 为 $j​$，并且再加上 $V_{total}​$ 的 $1…i - 1​$ 位的最优解</p><p>那么对于第 $i$ 层，枚举当前 $j$</p><p>对于转移，枚举在自身层内消耗的空间 $(j - k) \times 2^i$，那么还剩下 $k \times 2^i + V_{total}\{1…i - 1\}$ 的空间，分配给上一层，那么可得转移方程为</p><p>（注：$w_i$ 表示 $V_{total}$ 第 $i$ 位）<br>$$<br>f_{i, j} = \max \{g_{i, j - k} + f_{i - 1, 2k + w_i}\}<br>$$<br>同时，$g_{i, j}$ 可以通过由大到小枚举来消除</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">isneg = <span class="number">1</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~ (N = getnum ())) &#123;</span><br><span class="line">M = getnum ();</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> vol = getnum (), value = getnum ();</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (! (vol &amp; <span class="number">1</span>))</span><br><span class="line">vol &gt;&gt;= <span class="number">1</span>, b ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1000</span>; j &gt;= vol; j --)</span><br><span class="line">f[b][j] = max (f[b][j], f[b][j - vol] + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xm = M, maxb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (xm)</span><br><span class="line">xm &gt;&gt;= <span class="number">1</span>, maxb ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxb; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1000</span>; j ++)</span><br><span class="line">f[i][j] = max (f[i][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxb; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = min (<span class="number">1000</span>, M &gt;&gt; i); j &gt;= <span class="number">0</span>; j --) <span class="comment">// 注意此处上限是 min (100, M &gt;&gt; i)，M &gt;&gt; i 保证不会将高位拿多了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k ++) &#123;</span><br><span class="line">f[i][j] = max (f[i][j], f[i][j - k] + f[i - <span class="number">1</span>][min ((k &lt;&lt; <span class="number">1</span>) + ((M &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>), <span class="number">1000</span>)]);</span><br><span class="line">ans = max (ans, f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">4 13</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">16 75594681</span></span><br><span class="line"><span class="comment">393216 5533</span></span><br><span class="line"><span class="comment">2 77</span></span><br><span class="line"><span class="comment">32768 467</span></span><br><span class="line"><span class="comment">29360128 407840</span></span><br><span class="line"><span class="comment">112 68</span></span><br><span class="line"><span class="comment">24576 372</span></span><br><span class="line"><span class="comment">768 60</span></span><br><span class="line"><span class="comment">33554432 466099</span></span><br><span class="line"><span class="comment">16384 318</span></span><br><span class="line"><span class="comment">33554432 466090</span></span><br><span class="line"><span class="comment">2048 111</span></span><br><span class="line"><span class="comment">24576 350</span></span><br><span class="line"><span class="comment">9216 216</span></span><br><span class="line"><span class="comment">12582912 174768</span></span><br><span class="line"><span class="comment">16384 295</span></span><br><span class="line"><span class="comment">1024 76</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「FJOI2016」建筑师</title>
      <link href="/2020/08/04/%5BFJOI2016%5D%E5%BB%BA%E7%AD%91%E5%B8%88/"/>
      <url>/2020/08/04/%5BFJOI2016%5D%E5%BB%BA%E7%AD%91%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这题一直往 $\text{dp}$ 去想，然后就没了</p><p>所以其实并不用注意之前的可看见的建筑的最大值是多少，若把那些能够被看见的建筑之间构成的区间看作一个小组，那么能够被看见的建筑不过是在当前小组中选择一个最大值最为代表排在左（右）边罢了</p><p>所以现在问题转化为将 $n - 1$ 个建筑分在 $A + B - 2$ 个盒子，然后盒子内可以随意排列的个数</p><p>然后上述问题实际上可以将每个盒子看作一个圆，故问题又转化为 $n - 1$ 个建筑构成的 $A + B - 2$ 个圆排列方案数，即斯特林数 $S (n - 1, A + B - 2)$</p><p>然后要在其中选择一些放左（右）边，故答案即为<br>$$<br>ans = S (n - 1, A + B - 2) \times \dbinom{A + B - 2}{A - 1}<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXAB = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n, A, B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NMAX = <span class="number">5e04</span>, ABMAX = <span class="number">200</span>;</span><br><span class="line">LL S[MAXN][MAXAB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXAB]= &#123;<span class="number">0</span>&#125;, invfact[MAXAB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= NMAX; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min (i, ABMAX); j ++)</span><br><span class="line">S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + S[i - <span class="number">1</span>][j] * (i - <span class="number">1</span>) % MOD) % MOD;</span><br><span class="line">fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">0</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= ABMAX; i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ABMAX; i ++)</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * invfact[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">init ();</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">n = getnum (), A = getnum (), B = getnum ();</span><br><span class="line">LL ans = S[n - <span class="number">1</span>][A + B - <span class="number">2</span>] * C (A + B - <span class="number">2</span>, A - <span class="number">1</span>) % MOD;</span><br><span class="line">write (ans), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3 2 2</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CTSC2008」祭祀（DAG最长反链及其方案构造）</title>
      <link href="/2020/08/04/%5BCTSC2008%5D%E7%A5%AD%E7%A5%80%EF%BC%88DAG%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%8F%8A%E5%85%B6%E6%96%B9%E6%A1%88%E6%9E%84%E9%80%A0%EF%BC%89/"/>
      <url>/2020/08/04/%5BCTSC2008%5D%E7%A5%AD%E7%A5%80%EF%BC%88DAG%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%8F%8A%E5%85%B6%E6%96%B9%E6%A1%88%E6%9E%84%E9%80%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求一个 $n$ 点 $m$ 边的 $DAG$ 的最长反链，在第二行输出构造的其中一种方案，在第三行输出在保证最长反链的前提下，每个点是否能够设置为反链中的点</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反正证明也不会，就记录一下具体方法</p><blockquote><p>最长反链：对 $DAG$ 点集 $V$，最长反链为一个集合 $S \subseteq V$，满足 $\forall u \in S, v \in S$，$u$ 不能到达 $v$，$v$ 也不能到达 $u$</p></blockquote><p>根据 $\text{Dilworth}$ 定理，一个 $DAG$ 的最长反链大小等于其最小可重链覆盖大小</p><p>对 $DAG$ 传递闭包后，最小可重链覆盖大小可转化为最小<strong>不</strong>可重链覆盖大小，即最小路径点覆盖</p><blockquote><p>最小路径点覆盖：将 $DAG$ 用若干不相交的链覆盖，即每个点最多被经过一次，最小使用链的个数</p></blockquote><p>那么最小可重链覆盖则是类似，不同之处仅在于每个点可被经过多次</p><blockquote><p>最小路径点覆盖大小 $=$ $n$ $-$ 该 $DAG$ 拆点二分图的最大匹配大小</p></blockquote><p>那么 $\text{Subtask1}$ 就做完了</p><p>把 $DAG$ 拆点后最小路径点覆盖就相当于是求该拆点二分图的最大独立集</p><p>接下来开始构造方案</p><ul><li>找到拆点二分图中右侧的所有非匹配点</li><li>由这些非匹配点出发，右侧点只走非匹配边，左侧点只走匹配边</li><li>那么一种最小点覆盖的合法方案就是取左侧中被 $DFS$ 到的点，右侧中没被 $DFS$ 到的点</li><li>那么该拆点二分图的最大独立集的一种合法方案构造就是上述构造的补集</li></ul><p>这样就求出了最小路径点覆盖的一种方案，即最长反链的一种构造</p><p>那么 $\text{Subtask2}$ 就做完了</p><p>对 $\text{Subtask3}$，枚举每个点，将它会到达的点和会到达它的点删掉，强制假如该点，再跑一遍最长反链，若其得到最长反链长度等于原答案减一，则说明该点可以被设置为反链中的点</p><p>那么 $\text{Subtask3}$ 就做完了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">2</span> * MAXN + MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXL &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, size = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (x, y, cap); Insert (y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T, _N;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXL]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[p]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[p] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (cap, rest));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAXFLOW</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subtask2</span></span><br><span class="line"><span class="keyword">bool</span> tagl[MAXN]= &#123;<span class="literal">false</span>&#125;, tagr[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">tagr[u - N] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][u - N] &amp;&amp; ! tagl[i]) &#123;</span><br><span class="line">tagl[i] = <span class="literal">true</span>;</span><br><span class="line">DFS (match[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subtask3</span></span><br><span class="line"><span class="keyword">bool</span> del[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">g[u][v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][k])</span><br><span class="line">g[i] |= g[k];</span><br><span class="line">S = <span class="number">2</span> * N + <span class="number">1</span>, _N = T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = N - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! Link[<span class="number">4</span> * i - <span class="number">2</span>].cap)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next)</span><br><span class="line"><span class="keyword">if</span> (! Link[j].cap) &#123;</span><br><span class="line">match[i] = Link[j].to;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (Link[<span class="number">4</span> * i].cap)</span><br><span class="line">DFS (i + N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">printf</span> (<span class="string">"%d"</span>, ! tagl[i] &amp;&amp; tagr[i]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)); size = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span> (del, <span class="literal">false</span>, <span class="keyword">sizeof</span> (del));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (i == j || g[i][j] || g[j][i])</span><br><span class="line">del[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! del[i]) &#123;</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line">m ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! del[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j] &amp;&amp; ! del[j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ret = m - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ret == ans - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces Round 558 (Div. 2).F」Indecisive Taxi Fee</title>
      <link href="/2020/08/04/%5BCodeforces%20Round%20#558%20(Div.%202).F%5DIndecisive%20Taxi%20Fee/"/>
      <url>/2020/08/04/%5BCodeforces%20Round%20#558%20(Div.%202).F%5DIndecisive%20Taxi%20Fee/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>题意即为带修（临时）最短路</p><p>先随便提一条最短路出来，那么修改可分为四种情况：</p><ul><li>该边在最短路上，且数值变小</li><li>该边在最短路上，且数值变大</li><li>该边在最短路外，且数值变小</li><li>该边在最短路外，且数值变大</li></ul><p>那么对于情况 $1, 3, 4$，显然是十分容易处理的，那么问题就在情况 $2$</p><p>设最短路经过点 $e_1, e_2, e_3, …$</p><p>考虑到新的最短路必定与原最短路有相同的一段前缀与后缀（可以为空），设 $dis2_{i, j} (i &lt; j)$ 表示不经过路径 $e_ie_j$ 的最短路，所以答案即为 $\min \{dis2 (e_ie_j) (i &lt; j)\}$</p><p>那么便两遍 $Dijstra$ 分别求出 $1, n$ 到每个点 $p$ 的最短路 $pre_p, suf_p$，并且对于最短路上的点 $e_i$，求出其在最短路上的前驱边 $from_{e_i}$ 与后继边 $nxt_{e_i}$，对于每个不在最短路上的点 $p$，求出点 $1$ 至 $p$ 中最后一个在原最短路上的点的后继边 $from_p$ 及点 $p$ 至 $n$ 中第一个在原最短路上的点的后继边 $nxt_p$，故对于每个不在最短路上的边 $(u, v)$，它可以对 $dis2 (from_u, nxt_v - 1), dis2 (from_v, nxt_u - 1)$ 做贡献，然后用线段树维护一下就好了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要注意下列代码对于最短路上的点 $e_i$ 其 $from_{e_i}$ 实际上是后继边，这样子修改的区间才是对的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> w, id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].id = id;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line">LL dist;</span><br><span class="line"></span><br><span class="line">node (<span class="keyword">int</span> fp = <span class="number">0</span>, LL fdist = <span class="number">0</span>) :</span><br><span class="line">p (fp), dist (fdist) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dist &gt; p.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;node&gt; heap;</span><br><span class="line">LL dist[<span class="number">3</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> from[MAXN]= &#123;<span class="number">0</span>&#125;, nxt[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> occp[MAXN]= &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">dist[p][i] = INF, visit[i] = <span class="literal">false</span>;</span><br><span class="line">dist[p][S] = <span class="number">0</span>, heap.push(node (S, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) &#123;</span><br><span class="line">node top = heap.top();</span><br><span class="line">heap.pop();</span><br><span class="line"><span class="keyword">int</span> u = top.p;</span><br><span class="line">LL d = top.dist;</span><br><span class="line"><span class="keyword">if</span> (visit[u]) <span class="keyword">continue</span>;</span><br><span class="line">visit[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (d + w &lt; dist[p][v]) &#123;</span><br><span class="line">dist[p][v] = d + w;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">2</span>) from[v] = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; ! occp[v]) from[v] = from[u];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">1</span> &amp;&amp; ! occp[v]) nxt[v] = nxt[u];</span><br><span class="line">heap.push(node (v, dist[p][v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> path[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v != N;) &#123;</span><br><span class="line"><span class="keyword">int</span> ps = Link[from[v]].id;</span><br><span class="line">path[ps] = ++ pcnt, occp[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> nxn = Link[from[v] ^ <span class="number">1</span>].to;</span><br><span class="line">from[v] = nxt[v] = pcnt; <span class="comment">// attention</span></span><br><span class="line">v = nxn;</span><br><span class="line">&#125;</span><br><span class="line">occp[N] = <span class="literal">true</span>;</span><br><span class="line">from[N] = nxt[N] = pcnt + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL minv[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">minv[root] = INF;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid), build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, LL delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">minv[root] = min (minv[root], delta);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R, delta);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span> minv[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> min (minv[root], query (lson, left, mid, posi));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min (minv[root], query(rson, mid + <span class="number">1</span>, right, posi));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line"><span class="keyword">int</span> w = getnum ();</span><br><span class="line">Insert (u, v, w, i), Insert (v, u, w, i);</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra (<span class="number">2</span>, N), deal ();</span><br><span class="line">Dijkstra (<span class="number">0</span>, <span class="number">1</span>), Dijkstra (<span class="number">1</span>, N);</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, pcnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= size; i += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> u = Link[i].to, v = Link[i ^ <span class="number">1</span>].to;</span><br><span class="line"><span class="keyword">int</span> w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (path[Link[i].id]) <span class="keyword">continue</span>;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, pcnt, from[u], nxt[v] - <span class="number">1</span>, dist[<span class="number">0</span>][u] + dist[<span class="number">1</span>][v] + w);</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, pcnt, from[v], nxt[u] - <span class="number">1</span>, dist[<span class="number">0</span>][v] + dist[<span class="number">1</span>][u] + w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = getnum () &lt;&lt; <span class="number">1</span>, delta = getnum ();</span><br><span class="line"><span class="keyword">int</span> u = Link[cur].to, v = Link[cur ^ <span class="number">1</span>].to;</span><br><span class="line"><span class="keyword">int</span> w = Link[cur].w;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (path[Link[cur].id]) ans = min (dist[<span class="number">0</span>][N] - w + delta, query (<span class="number">1</span>, <span class="number">1</span>, pcnt, path[Link[cur].id]));</span><br><span class="line"><span class="keyword">else</span> ans = min (dist[<span class="number">0</span>][N], min (dist[<span class="number">0</span>][u] + dist[<span class="number">1</span>][v] + delta, dist[<span class="number">0</span>][v] + dist[<span class="number">1</span>][u] + delta));</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 6</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">1 4 7</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 1 1</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CERC2014」Outer space invaders</title>
      <link href="/2020/08/04/%5BCERC2014%5DOuter%20space%20invaders/"/>
      <url>/2020/08/04/%5BCERC2014%5DOuter%20space%20invaders/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个线段，每个线段有一个权值 $w_i$，每次取轴上一点，获得的权值为选择的覆盖在当前点上的线段的最大权值，求最终覆盖所有线段后需要的最小权值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>好吧是一道非常水的区间 $dp$ 然而我并没有想出来所以我是真的绝望</p><p>先把 $l_i, r_i$ 离散化后令 $f_{l, r}$ 表示<strong>完全覆盖</strong>区间 $[l, r]$ 的线段的最小权值，设完全处于 $[l, r]$ 的线段中权值取最大值的线段 $p$，则有转移方程<br>$$<br>f_{l, r} = \min \{f_{l, k - 1} + f_{k + 1, r} + w_p\} (l_p \le k \le r_p)<br>$$<br>所以注意一定要完全覆盖，$[l, k - 1], [k + 1, r]$ 才不会对 $[l, r]$ 造成影响，于是我就卡这儿了</p><p>谨以此文纪念我逝去的智商</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> l[MAXN], r[MAXN], value[MAXN];</span><br><span class="line"><span class="keyword">int</span> vcol[MAXN &lt;&lt; <span class="number">1</span>], vcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum ();</span><br><span class="line">vcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">l[i] = getnum (), r[i] = getnum (), value[i] = getnum ();</span><br><span class="line">vcol[++ vcnt] = l[i], vcol[++ vcnt] = r[i];</span><br><span class="line">&#125;</span><br><span class="line">sort (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>);</span><br><span class="line">vcnt = unique (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>) - vcol - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">l[i] = lower_bound (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>, l[i]) - vcol;</span><br><span class="line">r[i] = lower_bound (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>, r[i]) - vcol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= vcnt; len ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vcnt - len + <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxv = - <span class="number">1</span>, sl, sr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt;= l[k] &amp;&amp; r[k] &lt;= j) <span class="comment">// 完全覆盖</span></span><br><span class="line"><span class="keyword">if</span> (value[k] &gt; maxv) &#123;</span><br><span class="line">maxv = value[k];</span><br><span class="line">sl = l[k], sr = r[k];</span><br><span class="line">&#125;</span><br><span class="line">f[i][j] = maxv == - <span class="number">1</span> ? <span class="number">0</span> : INF;</span><br><span class="line"><span class="keyword">if</span> (maxv != - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sl; k &lt;= sr; k ++)</span><br><span class="line">f[i][j] = min (f[i][j], f[i][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][j] + maxv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[<span class="number">1</span>][vcnt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 4 4</span></span><br><span class="line"><span class="comment">4 7 5</span></span><br><span class="line"><span class="comment">3 4 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「APIO2013」机器人</title>
      <link href="/2020/08/04/%5BAPIO2013%5D%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2020/08/04/%5BAPIO2013%5D%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先因为点数不多，可以考虑先在 $4r \times c$ 时间内将每个点朝每个方向可以到达的位置预处理出来，建成图</p><p>那么现在容易看出是斯坦那树问题，所以考虑将问题简化一下：</p><blockquote><p>现在给定 $n$ 个不同级别的机器人，将两段级别的机器人合并需要花费 $c_i$，那么将所有机器人合并的最小花费是多少</p></blockquote><p>这个问题显然使用区间 $DP$ 可以解决，那么扩展到斯坦那树上即可</p><p>令 $f[l][r][i]$ 表示区间 $l, r$ 的机器人合并后位于位置 $i$ 的最小花费，则有<br>$$<br>f[l][r][i] = \min \{f[l][k][i] + f[k + 1][r][i]\}<br>$$<br>以及<br>$$<br>f[l][r][i] = \min\limits_{p  link  to  i} \{f[l][r][p] + 1\}<br>$$<br>第二个式子直接 $SPFA$ 会超时</p><p><strong>但是观察每条边的贡献都为 $1$，所以可以将 $SPFA$ 优化成 $BFS$ 的复杂度</strong></p><p>类似堆优化的思想，开两个队列，一个存初始的经过 $f$ 排序的点，一个存被松弛的点，由于边的性质及 $que1$ 经过排序的原因，所以 $que2$ 一定也是按 $f$ 递增的，从而优化成 $BFS$ 的复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXI = MAXL * MAXL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4</span> * MAXI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NextX[<span class="number">4</span>]= &#123;- <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, NextY[<span class="number">4</span>]= &#123;<span class="number">0</span>, - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, R, C;</span><br><span class="line"><span class="keyword">char</span> Map[MAXL][MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * C + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fto[MAXL][MAXL][<span class="number">4</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXL][MAXL][<span class="number">4</span>]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x][y][k])</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (fto[x][y][k])</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k];</span><br><span class="line"><span class="keyword">int</span> tx = x + NextX[k], ty = y + NextY[k];</span><br><span class="line">vis[x][y][k] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (Map[tx][ty] == <span class="string">'x'</span>)</span><br><span class="line">fto[x][y][k] = encode (x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Map[tx][ty] == <span class="string">'A'</span>)</span><br><span class="line">fto[x][y][k] = move (tx, ty, (k + <span class="number">1</span>) % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Map[tx][ty] == <span class="string">'C'</span>)</span><br><span class="line">fto[x][y][k] = move (tx, ty, (k + <span class="number">3</span>) % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fto[x][y][k] = move (tx, ty, k);</span><br><span class="line">vis[x][y][k] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXI];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que1, que2;</span><br><span class="line"><span class="keyword">int</span> inque[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> save[MAXI];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsort</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">limit = max (limit, f[l][r][i]), total ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i ++)</span><br><span class="line">buck[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">buck[f[l][r][i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i ++)</span><br><span class="line">buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = R * C; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">save[buck[f[l][r][i]] --] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">fsort (l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; i ++)</span><br><span class="line">que1.push(save[i]), inque[save[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (! que1.empty() || ! que2.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">int</span> f1 = ! que1.empty() ? que1.front() : INF;</span><br><span class="line"><span class="keyword">int</span> f2 = ! que2.empty() ? que2.front() : INF;</span><br><span class="line">f1 &lt; f2 ? (u = f1, que1.pop()) : (u = f2, que2.pop());</span><br><span class="line">inque[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][u] + <span class="number">1</span> &lt; f[l][r][v]) &#123;</span><br><span class="line">f[l][r][v] = f[l][r][u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! inque[v])</span><br><span class="line">que2.push(v), inque[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>, &amp; N, &amp; C, &amp; R);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, Map[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line">Map[i][<span class="number">0</span>] = Map[i][C + <span class="number">1</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line">Map[<span class="number">0</span>][j] = Map[R + <span class="number">1</span>][j] = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Map[i][j] == <span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++) &#123;</span><br><span class="line">move (i, j, k);</span><br><span class="line"><span class="keyword">if</span> ((~ fto[i][j][k]) &amp;&amp; fto[i][j][k] != encode (i, j))</span><br><span class="line">Insert (encode (i, j), fto[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span> (Map[i][j]))</span><br><span class="line">f[Map[i][j] - <span class="string">'0'</span>][Map[i][j] - <span class="string">'0'</span>][encode (i, j)] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= N; len ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N - len + <span class="number">1</span>; l ++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k ++)</span><br><span class="line">f[l][r][i] = min (f[l][r][i], f[l][k][i] + f[k + <span class="number">1</span>][r][i]);</span><br><span class="line">&#125;</span><br><span class="line">SPFA (l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line">ans = min (ans, f[<span class="number">1</span>][N][i]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans == INF ? - <span class="number">1</span> : ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10 5</span></span><br><span class="line"><span class="comment">1.........</span></span><br><span class="line"><span class="comment">AA...x4...</span></span><br><span class="line"><span class="comment">..A..x....</span></span><br><span class="line"><span class="comment">2....x....</span></span><br><span class="line"><span class="comment">..C.3.A...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n点基环树个数问题</title>
      <link href="/2020/08/04/n%E7%82%B9%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/04/n%E7%82%B9%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于 $n$ 个点组成的环大小为 $m$ 的基环树个数的问题，目前已知三种解法</p><h2 id="解法一「动态规划」"><a href="#解法一「动态规划」" class="headerlink" title="解法一「动态规划」"></a>解法一「动态规划」</h2><p>在环上每个点下面搭树的方案数，相当于是在完全图中制造生成树，然后提一个点（即环上那个点）为根，故可用 $n^{n - 2}$ 来计算</p><p>然后就可以很容易想到一种背包解法，把环随便找个地方断一下，把它看成序列，即可令 $f_{i, j}$ 表示环序列前 $i$ 个点，已经使用了 $j$ 个点做环下的树的方案数，显然<br>$$<br>f_{i, j} = \sum\limits_{k = 0}^j f_{i - 1, j - k} \times \dbinom{n - m - (j - k)}{k} \cdot (k + 1)^{k - 1}<br>$$<br>然后答案要对环进行圆排列，即 $ans = f_{m, n - m} \times \frac{A_n^m}{2m}$</p><p>复杂度 $O (n^3)$</p><p>当然这样复杂度比较高，可以考虑将已经拼好的连通块和已经拼好的一棵树连接起来，令 $f_n$ 表示 $n$ 个点的答案</p><p>当然，为了保证不会算重，需要有一个特征点，即保证点 $1$ 不会在环上，即<br>$$<br>f_n = \frac{n}{n - m}\sum\limits_{i = m}^{n - 1} f_i \times i \cdot (n - i)^{n - i - 2} \cdot \dbinom{n - 1}{i}<br>$$<br>注意，前面的 $\frac{n}{n - m}$ 是因为在你令每个点作为那个不在环上的那个点的时候，实际上对于每个点它会被其它点作为不在环上的点时算重 $n - m$ 次，故需要除以 $n - m$</p><p>复杂度 $O (n^2)$</p><h2 id="解法二「prufer序列」"><a href="#解法二「prufer序列」" class="headerlink" title="解法二「prufer序列」"></a>解法二「prufer序列」</h2><p>考虑在做prufer序列的时候，对于序列长度来讲，将其缩成一个点，即有 $n - m + 1$ 个位置，但是在实际放点的时候，却应当是有 $n$ 种选择，因为环上不同点作为父亲的情况是不一样的，即有 $n^{n - m - 1}$ 个位置，然后再做一次圆排列，即乘上 $\frac{A_n^m}{2m}$，但是可以发现环所称的点作为非根节点（相对意义上）的时候，需要选定一个环上的点作为与父节点连接的点，即还需要乘上 $m$</p><p>故最后答案为，$ans = \frac{A_n^m}{2m} \cdot n^{n - m - 1} \cdot m$</p><p>复杂度 $O (n)$</p><h2 id="解法三「生成函数」"><a href="#解法三「生成函数」" class="headerlink" title="解法三「生成函数」"></a>解法三「生成函数」</h2><p>考虑将基环树拆分为若干棵树的拼凑</p><p>注意此时需考虑的是有根树，即先将节点看作组合对象，根据 $Cayley$ 定理，$n$ 个节点的完全图有 $n^{n - 1}$ 棵有根树，则有根树的 EGF $T(x)$ 为<br>$$<br>T(x) = \sum\limits_{n = 1}^{\infty} n^{n - 1}\frac{x^n}{n!}<br>$$<br>那么此时将有根树看作组合对象，则将它们组成环，即基环树的 EGF $G(x)$ 为<br>$$<br>\begin{aligned}<br>G(x) &amp;= \frac{1}{2}\sum\limits_{k = 3}^{\infty} \frac{T(x)^k}{k} \\<br>&amp;= - \frac{1}{2}\ln (1 - T(x)) - \sum\limits_{k = 1}^2 \frac{T(x)^k}{k}<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> prufer序列 </tag>
            
            <tag> 归纳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTT（快速数论变换）</title>
      <link href="/2020/08/04/NTT%EF%BC%88%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%89/"/>
      <url>/2020/08/04/NTT%EF%BC%88%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><h3 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h3><p>对于$p \in N_+$且$(a,  p) = 1$，满足$a^r \equiv 1 (mod  p)$的最小的非负$r$为$a$模$p$意义下的阶，记作$\delta_p(a)$</p><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>定义：若$p \in N_+$且$a \in N$，若$\delta_p(a) = \phi(p)$，则称$a$为模$p$的一个原根<br>相关定理：</p><ul><li>若一个数$m$拥有原根，那么它必定为$2,  4,  p^t,  2p^t  (p$为奇质数$)$的其中一个<br>   每个数$p$都有$\phi(\phi(p))$个原根<br>   　　证明：若$p \in N_+$且$(a,  p) = 1$，正整数$r$满足$a^r \equiv 1 (mod  p)$，那么$\delta(p) | r$，由此推广，可知$\delta(p) | \phi(p)$，所以$p$的原根个数即为$p$之前与$\phi(p)$互质的数，即$\phi(p)$故定理成立<br>   　　　　　　- 若$g$是$m$的一个原根，则$g,  g^1,  g^2,  …,  g^{\phi(m)} (mod  p)$两两不同<br>   　　　　原根求法：<br>   　　将$\phi(m)$质因数分解，得$\phi(m) = p_1^{c_1} * p_2^{c_2} * … * p_k^{c_k}$<br>   　　那么所有$g$满足$g^{\frac{\phi(m)}{p_i}} \neq 1 (mod  m)$即为$m$的原根</li></ul><h2 id="NTT"><a href="#NTT" class="headerlink" title="$NTT$"></a>$NTT$</h2><p>　　由于$FTT$涉及到复数的运算，所以常数很大，而$NTT$仅需使用长整型，可大大优化常数</p><p>　　能够将原根代替单位根进行计算，是因为它们的性质相似，至少在单位根需要的那几个性质原根都满足，当然，要能够进行$NTT$，需要满足模数$p$为质数，且$p = ax + 1$其中$x$为$2$的次幂，那么一般能满足条件的数（常用）有：<br>　　$|            p             |    g     |$</p><p>　　$|    469762049     |    3     |$</p><p>　　$|    998244353     |    3     |$</p><p>　　$|   1004535809    |    3     |$<br>　　那么，就可以将单位根$\omega_n$替换为$g^{\frac{p - 1}{n}}$进行$NTT$了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % MOD;</span><br><span class="line"></span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">                LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD;</span><br><span class="line">                a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">                a[j + k + mid] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i] = (<span class="keyword">int</span>) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i] = (<span class="keyword">int</span>) getnum ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    limit = n;</span><br><span class="line">    NTT (A, <span class="number">1</span>);</span><br><span class="line">    NTT (B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        A[i] = A[i] * B[i] % MOD;</span><br><span class="line">    NTT (A, - <span class="number">1</span>);</span><br><span class="line">    LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i] * invn % MOD));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意模数-NTT-（三模数-NTT-法）"><a href="#任意模数-NTT-（三模数-NTT-法）" class="headerlink" title="任意模数$NTT$（三模数$NTT$法）"></a>任意模数$NTT$（三模数$NTT$法）</h3><p>有公式</p><p>$$<br>\left\{\begin{aligned} x \equiv a_1 (mod  m_1) \\ x \equiv a_2 (mod  m_2) \\ x \equiv a_3 (mod  m_3) \end{aligned}\right.<br>$$<br>直接乘会爆$long  long$，就先将上面的用$CRT$合并，得</p><p>$$<br>\left\{\begin{aligned} x \equiv A (mod  M) \\ x \equiv a_3 (mod  m_3) \end{aligned}\right.<br>$$<br>那么设$Ans = kM + A$，则有<br>$$<br>\begin{aligned}<br>kM + A &amp;\equiv a_3 \pmod{m_3} \\<br>k &amp;\equiv (a_3 - A)M^{- 1} \pmod{m_3}<br>\end{aligned}<br>$$<br>直接处理即可</p><h4 id="代码（任意模数-NTT-）"><a href="#代码（任意模数-NTT-）" class="headerlink" title="代码（任意模数$NTT$）"></a>代码（任意模数$NTT$）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL MOD[<span class="number">3</span>]= &#123;<span class="number">469762049</span>, <span class="number">998244353</span>, <span class="number">1004535809</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> LL g = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> eps = <span class="number">1e-03</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">multi</span> <span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">return</span> ((a * b - (LL) ((LL) ((<span class="keyword">long</span> <span class="keyword">double</span>) a / p * b + eps) * p)) % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p, LL mod)</span> </span>&#123;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % mod;</span><br><span class="line"></span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg[<span class="number">3</span>]= &#123;power (g, MOD[<span class="number">0</span>] - <span class="number">2</span>, MOD[<span class="number">0</span>]), power (g, MOD[<span class="number">1</span>] - <span class="number">2</span>, MOD[<span class="number">1</span>]), power (g, MOD[<span class="number">2</span>] - <span class="number">2</span>, MOD[<span class="number">2</span>])&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL P;</span><br><span class="line"></span><br><span class="line">LL A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL ome = power (inv == <span class="number">1</span> ? g : invg[type], (MOD[type] - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>), MOD[type]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            LL x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD[type]) &#123;</span><br><span class="line">                LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD[type];</span><br><span class="line">                a[j + k] = (a1 + xa2) % MOD[type];</span><br><span class="line">                a[j + k + mid] = (a1 - xa2 + MOD[type]) % MOD[type];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ntta[<span class="number">3</span>][MAXN], nttb[<span class="number">3</span>][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_Main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    limit = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            ntta[i][j] = A[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            nttb[i][j] = B[j];</span><br><span class="line">        NTT (ntta[i], <span class="number">1</span>, i);</span><br><span class="line">        NTT (nttb[i], <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            ntta[i][j] = ntta[i][j] * nttb[i][j] % MOD[i];</span><br><span class="line">        NTT (ntta[i], - <span class="number">1</span>, i);</span><br><span class="line">        LL invn = power (n, MOD[i] - <span class="number">2</span>, MOD[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N + M; j ++)</span><br><span class="line">            ntta[i][j] = ntta[i][j] * invn % MOD[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRT</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL m = MOD[<span class="number">0</span>] * MOD[<span class="number">1</span>];</span><br><span class="line">    LL M1 = MOD[<span class="number">1</span>], M2 = MOD[<span class="number">0</span>];</span><br><span class="line">    LL t1 = power (M1, MOD[<span class="number">0</span>] - <span class="number">2</span>, MOD[<span class="number">0</span>]), t2 = power (M2, MOD[<span class="number">1</span>] - <span class="number">2</span>, MOD[<span class="number">1</span>]), invM = power (m % MOD[<span class="number">2</span>], MOD[<span class="number">2</span>] - <span class="number">2</span>, MOD[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        LL a1 = ntta[<span class="number">0</span>][i], a2 = ntta[<span class="number">1</span>][i], a3 = ntta[<span class="number">2</span>][i];</span><br><span class="line">        LL A = (multi (a1 * M1 % m, t1 % m, m) + multi (a2 * M2 % m, t2 % m, m)) % m;</span><br><span class="line">        LL k = ((a3 - A % MOD[<span class="number">2</span>]) % MOD[<span class="number">2</span>] + MOD[<span class="number">2</span>]) % MOD[<span class="number">2</span>] * invM % MOD[<span class="number">2</span>];</span><br><span class="line">        ans[i] = ((k % P * (m % P) % P + A % P) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum (), P = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i] = (LL) getnum ();</span><br><span class="line"></span><br><span class="line">    NTT_Main ();</span><br><span class="line">    CRT ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ6039 - 「雅礼集训 2017 Day5」珠宝 「重量较小的大数据01背包」</title>
      <link href="/2020/08/04/LOJ%206039%20-%20%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202017%20Day5%E3%80%8D%E7%8F%A0%E5%AE%9D%20%E3%80%8C%E9%87%8D%E9%87%8F%E8%BE%83%E5%B0%8F%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE01%E8%83%8C%E5%8C%85%E3%80%8D/"/>
      <url>/2020/08/04/LOJ%206039%20-%20%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202017%20Day5%E3%80%8D%E7%8F%A0%E5%AE%9D%20%E3%80%8C%E9%87%8D%E9%87%8F%E8%BE%83%E5%B0%8F%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE01%E8%83%8C%E5%8C%85%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$01$ 背包，数据范围 $1 \le n \le 1e06, 1 \le weight_i \le 300$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>神仙 $01$ 背包</p><p>考虑重量较小，故可以考虑根据重量分层处理</p><p>令 $f_{i, j}$ 表示使用前 $i$ 个重量，总共花费 $j$ 容量的最大价值</p><p>容易注意到在同一重量中显然要优先选择价值大的，故将每种重量按价值排序，令 $sumv_{i, j}$ 表示重量为 $i$ 的前 $j$ 大的价值前缀和，则有<br>$$<br>f_{i, j} = \max\limits_k \{f_{i - 1, j - ki} + sumv_{i, k}\}<br>$$<br>然后（通过看题解）可以发现，因为是 $j - ki$，故可以考虑按照 $j \mod i$ 分类处理，这样是满足决策单调性的</p><p>至于证明，为了方便可以将式子简化成 $f_i = \max \{f_j +sumv_{i - j}\}$ 的形式，然后用反证法或是四边形不等式都容易证明</p><p>那么最后就可以用决策单调性的套路代码或者是用分治解决了</p><p>分治比较简单，大概就是看在处理区间 $[u, v]$， $[l, r]$ 决策区间内对于 $mid$ 位置在 $[l, r]$ 中最有决策在哪个位置，然后左右递归即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXC = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, C = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value[MAXC];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; prefix[MAXC];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXC][MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL trans[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">w</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = (i - j) / s;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= (<span class="keyword">int</span>) prefix[s].size())</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">return</span> f[s - <span class="number">1</span>][j] + prefix[s][p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 层数 处理区间 决策区间</span></span><br><span class="line"><span class="keyword">int</span> mid = (u + v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">LL maxi = - <span class="number">1</span>, posi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min (mid, r); i ++) &#123;</span><br><span class="line">LL cont = w (trans[mid], trans[i], p);</span><br><span class="line"><span class="keyword">if</span> (cont &gt; maxi)</span><br><span class="line">maxi = cont, posi = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">f[p][trans[u]] = maxi;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">solve (p, u, mid, l, posi);</span><br><span class="line">solve (p, mid + <span class="number">1</span>, v, posi, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = getnum (), v = getnum ();</span><br><span class="line">C = max (C, c), value[c].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i ++) &#123;</span><br><span class="line">sort (value[i].begin(), value[i].end(), comp);</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line">prefix[i].push_back(sum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) value[i].size(); j ++)</span><br><span class="line">sum += value[i][j], prefix[i].push_back(sum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line">trans[limit = <span class="number">1</span>] = j;</span><br><span class="line"><span class="keyword">while</span> (trans[limit] + i &lt;= K)</span><br><span class="line">limit ++, trans[limit] = trans[limit - <span class="number">1</span>] + i;</span><br><span class="line">solve (i, <span class="number">1</span>, limit, <span class="number">1</span>, limit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">write (f[C][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">1 48</span></span><br><span class="line"><span class="comment">3 25</span></span><br><span class="line"><span class="comment">2 76</span></span><br><span class="line"><span class="comment">4 83</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT（快速傅里叶变换）</title>
      <link href="/2020/08/04/FFT%EF%BC%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%89/"/>
      <url>/2020/08/04/FFT%EF%BC%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>　　<strong>- 点值表示</strong><br>　　　　对于一个$n - 1$次多项式$A(x)$，可以通过确定$n$个点与值（即$x$和$y$）来表示这唯一的$A(x)$</p><p>　　<strong>- 复数</strong><br>　　　　对于一元二次方程<br>　　　　$$x^2 + 1 = 0$$<br>　　　　在实数范围内无解，那么我们将实数范围扩充，就得到了复数，再令$i$为该方程的解，即<br>　　　　$$i^2 = - 1$$<br>　　　　那么就定义$z = a + bi$的数为复数，则有<br>　　　　当$b = 0$时，$z$为实数<br>　　　　当$b \neq 0$时，$z$为虚数<br>　　　　当$a = 0  \&amp;\&amp;  b \neq 0$时，$z$为纯虚数<br>　　　　其中，复数满足加法交换律、结合律、乘法分配率等</p><p>　　　　复数相乘：$z_1 = a_1 + b_1i,  z_2 = a_2 + b_2i$，则$z_1 × z_2 = (a_1 + b_1i)(a_2 + b_2i) = (a_1a_2 - b_1b_2) + (a_1b_2 + b_1a_2)i$，它们相乘还是一个复数，在复平面上理解，就是模长相乘，幅角相加</p><p>　　　　共轭复数：当两个复数实部相同，虚部为相反数时，两个复数被称为共轭复数</p><p>　　　　对于一个复数$z = a + bi$，还可以在复数平面上用向量表示出来，即有$\overrightarrow{OZ}$一一对应每个$z = a + bi$，那么就有复数的模等于$\overline{Z}$，即$|z| = \sqrt{a^2 + b^2}$<br>　　　　复数直接比较大小没有意义，除非它是一个实数</p><h3 id="FFT-作用"><a href="#FFT-作用" class="headerlink" title="$FFT$作用"></a>$FFT$作用</h3><p>　　那么，有了点值表示，对于多项式$A(x)$和$B(x)$相乘，就不需要$O(n^2)$，而只需要$O(n)$，因为$C(x_i) = A(x_i) * B(x_i)$，然后枚举$x_i$即可<br>　　于是现在的复杂度症结就在于将多项式转化成点值表示的$O(n^2)$了，于是就有$FFT$，可以实现在$O(n  logn)$的时间内转化</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>　　于是傅里叶规定，点值中的$x$为模长为$1$的复数<br>　　至于为什么要取复数而不是实数，因为它有很神奇的性质<br>　　那么对于这$n$个复数的取法，取的是复平面上半径为$1$的一个圆，将其$n$等分后得到的点，令第$i$个点表示为$\omega_n^k(0 \le k \le n - 1)$，那么这个点在复平面中的表示即为$(cos\frac{k}{n}2\pi,  sin\frac{k}{n}2\pi)$，那么根据复数乘法在复平面上的意义为模长相乘，幅长相加，即$\omega_n^k$相当于$(\omega_n^1)^k$，那么称$\omega_n^1$为单位根<br>　　我们就把这$\omega_n^0,  \omega_n^1,  …,  \omega_n^{n - 1}$作为点值表示的$x$，称作离散傅里叶变换的结果<br>　　先给出关于傅里叶逆变换的结论：<br>　　　　- 将多项式$A(x)$的离散傅里叶变换结果作为系数代入多项式$B(x)$，再将每个离散傅里叶变换结果的倒数，即$\omega_n^0,  \omega_n^{- 1},  …,  \omega_n^{- (n - 1)}$作为$x$代入$B(x)$得到点值表示，那么这些表示除以$n$就得到了$A(x)$的原系数 [至于证明：不存在的]<br>　　这就是傅里叶变换神奇的性质</p><h2 id="FFT"><a href="#FFT" class="headerlink" title="$FFT$"></a>$FFT$</h2><p>　　有了傅里叶变换，虽然多项式与点值表示相互转化已经很轻松了，但是复杂度仍然不理想，就有了快速傅里叶变换<br>　　结论：</p><ul><li>$\omega_{2n}^{2k} = \omega_n^k$ [证明：代进原公式显然]<ul><li>$\omega_n^{k + \frac{n}{2}} = - \omega_n^k$ [证明：关于复平面原点中心对称]<br>  对于多项式$A(x) = \sum\limits_{i = 0}^{n - 1} a_ix^i$，将它的奇偶项拆开，并将$x$转为$x^2$得到（此处先假定$n$为偶数）</li></ul></li></ul><p>$$<br>N(x) = a_0 + a_2x + a_4x^2 + … + a_{n - 2}x^{\frac{n}{2} - 1} \\<br>M(x) = a_1 + a_3x + a_5x^2 + … + a_{n - 1}x^{\frac{n}{2} - 1}<br>$$</p><p>　　    当然此时代入的是$N(x^2),  M(x^2)$，则有</p><p>$$<br>A(x) = N(x^2) + xM(x^2)<br>$$<br>​    　　此时就需要把$\omega_n^k$代入，分情况讨论：<br>　　    若$k &lt; \frac{n}{2}$，则有<br>$$<br>\begin{aligned}<br>A(\omega_n^k) &amp;= N(\omega_n^{2k}) + \omega_n^kM(\omega_n^{2k}) \\<br>&amp;= N(\omega_{\frac{n}{2}}^k) + \omega_n^kM(\omega_{\frac{n}{2}}^k)<br>\end{aligned}<br>$$</p><p>​    　　反之</p><p>$$<br>\begin{aligned}<br>A(\omega_n^k) &amp;= N(\omega_n^{2k + n}) + \omega_n^{k + \frac{n}{2}}M(\omega_n^{2k + n}) \\<br>&amp;= N(\omega_n^{2k} × \omega_n^n) + \omega_n^{k + \frac{n}{2}}M(\omega_n^{2k} × \omega_n^n)（这一步是通过复数乘法复平面上的意义化简的） \\<br>&amp;= N(\omega_{\frac{n}{2}}^k) - \omega_n^kM(\omega_{\frac{n}{2}}^k)<br>\end{aligned}<br>$$</p><p>　　于是，我们只要求得$\{\omega_{\frac{n}{2}}^0,  \omega_{\frac{n}{2}}^1,  …,  \omega_{\frac{n}{2}}^{\frac{n}{2} - 1}\}$，就可以得到$A(x)$的所有关于所有离散傅里叶变换结果的点值表示了，可用分治实现，复杂度$O(n  logn)$</p><h3 id="代码（分治FFT）"><a href="#代码（分治FFT）" class="headerlink" title="代码（分治FFT）"></a>代码（分治FFT）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">mcomplex () &#123;&#125;</span><br><span class="line">mcomplex (<span class="keyword">double</span> fx, <span class="keyword">double</span> fy) :</span><br><span class="line">x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x + p.x, y + p.y);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x - p.x, y - p.y);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x * p.x - y * p.y, x * p.y + y * p.x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">mcomplex <span class="title">omega</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (<span class="built_in">cos</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n), <span class="number">1.0</span> * inv * <span class="built_in">sin</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n));</span><br><span class="line">&#125;</span><br><span class="line">mcomplex A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">mcomplex a1[n &gt;&gt; <span class="number">1</span>], a2[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">a1[i &gt;&gt; <span class="number">1</span>] = a[i];</span><br><span class="line">a2[i &gt;&gt; <span class="number">1</span>] = a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">FFT (a1, m, inv);</span><br><span class="line">FFT (a2, m, inv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">mcomplex x = omega (n, i, inv);</span><br><span class="line">a[i] = a1[i] + x * a2[i];</span><br><span class="line">a[i + m] = a1[i] - x * a2[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">A[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">B[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">FFT (A, n, <span class="number">1</span>);</span><br><span class="line">FFT (B, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">A[i] = A[i] * B[i];</span><br><span class="line">FFT (A, n, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i].x / n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>　　于是这样还是会超时，那么还需要优化<br>　　根据表格，有一个考眼力的性质<br>　　$|0  1  2  3|$<br>　　$|0  2 | 1  3|$<br>　　$|0 | 2 | 1 | 3|$<br>　　会发现每个数字的目标位置的二进制是原数的二进制翻转的结果，比如$1 = (01)_2,  2 = (10)_2$恰好是相对应的，于是就可以根据这个性质先将每个数排列到最终位置，再逐一合并</p><h4 id="代码（迭代优化-FFT-）"><a href="#代码（迭代优化-FFT-）" class="headerlink" title="代码（迭代优化$FFT$）"></a>代码（迭代优化$FFT$）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    mcomplex () &#123;&#125;</span><br><span class="line">    mcomplex (<span class="keyword">double</span> fx, <span class="keyword">double</span> fy) :</span><br><span class="line">        x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x + p.x, y + p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x - p.x, y - p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x * p.x - y * p.y, x * p.y + y * p.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">mcomplex <span class="title">omega</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mcomplex (<span class="built_in">cos</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n), <span class="number">1.0</span> * inv * <span class="built_in">sin</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n));</span><br><span class="line">&#125;</span><br><span class="line">mcomplex A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        mcomplex ome = mcomplex (<span class="built_in">cos</span> (PI / (<span class="keyword">double</span>) mid), inv * <span class="built_in">sin</span> (PI / (<span class="keyword">double</span>) mid));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            mcomplex x = mcomplex (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome) &#123;</span><br><span class="line">                mcomplex a1 = a[j + k], xa2 = x * a[j + k + mid];</span><br><span class="line">                a[j + k] = a1 + xa2;</span><br><span class="line">                a[j + k + mid] = a1 - xa2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    limit = n;</span><br><span class="line">    FFT (A, <span class="number">1</span>);</span><br><span class="line">    FFT (B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        A[i] = A[i] * B[i];</span><br><span class="line">    FFT (A, - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i].x / n + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　这样的$FFT$可以在$O(n  logn)$的时间内求出多项式乘法的各项系数，主要流程：将两个多项式分别转化成点值表示 $\dashrightarrow$ 通过点值表示将两个多项式合并 $\dashrightarrow$ 通过离散傅里叶逆变换将点值表示转化成系数表示，即得解</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/RabbitHu/p/FFT.html" target="_blank" rel="noopener">[小学生都能看懂的FFT！！！]</a></p><p><a href="https://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">[快速傅里叶变换(FFT)详解]</a></p><p><a href="https://blog.csdn.net/qq_39670434/article/details/79678103" target="_blank" rel="noopener">[复数——概念和代数运算]</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF917D Stranger Trees</title>
      <link href="/2020/08/04/CF917D%20Stranger%20Trees/"/>
      <url>/2020/08/04/CF917D%20Stranger%20Trees/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Solution-Ⅰ"><a href="#Solution-Ⅰ" class="headerlink" title="Solution Ⅰ"></a>Solution Ⅰ</h2><p>一道有点有趣的树形 $dp$ + 容斥，反正绕了我半天，这么神仙我也不可能写出来</p><p>首先考虑基本思路，直接求解恰好 $k$ 个较难，故考虑先求解大于等于 $k$ 的相似度的方案数，然后再容斥</p><p>考虑选定了必选的若干条边后计算方案数。显然此时整个图被分成了若干连通块，假设有 $k$ 个连通块，将连通块缩点，考虑它们可以组成的树的方案数，本来应该是 $k^{k - 2}$，然而对于每个连通块的缩点，它可以向其它连通块中包含的任意一点连接，也就是说，在 purfer 序列中，应当考虑连通块内的点编号在序列中的出现情况，而不是仅仅考虑连通块编号出现在序列中，故 prufer 序列中的每个位置可以填 $n$ 个数，即 $n^{k - 2}$，然而考虑了父亲，还需要考虑儿子，作为叶子节点的缩点后的连通块，同样的里面也是任意点向外连边，故还需乘上 $\prod size_i$，其中，$size_i$ 为连通块 $i$ 的大小，那么综上，对于一个存在 $k$ 个连通块的图，其构造的生成树的方案数为 $n^{k - 2} \times \prod size_i$</p><p>那么现在考虑求解 $\prod size_i$，使用树形 $dp$ 求解</p><p>令 $f_{root, i, j}$ 表示以 $root$ 为根，总计 $j$ 个连通块，$root$ 所在的连通块大小为 $j$ 的方案数，那么对于 $root$ 的每个儿子有选或不选的两种情况，枚举其儿子 $son$ 的连通块个数 $k$ 及 $son$ 所在连通块大小 $l$：</p><ul><li>选：$f_{root, i + k - 1, j + l} += f_{root, i, j} \times f_{son, k, l}$</li><li>不选：$f_{root, i + k, j} = f_{root, i, j} \times f_{son, k, l} \times l$</li></ul><p>注意每次的 $\times size_i$ 是在整个连通块 $i$ 已经确定下来的时候才能乘，故在其父亲扫描到当前节点的时候才乘上其所在连通块大小</p><p>再给出 $g_i = \sum\limits_{i = 1}^n\sum\limits_{j = 1}^{n - i + 1} n^{i - 2}f_{1, i, j} \times j$</p><p>注意此时的 $g_k$ 并不是严格意义上的大于等于 $k$ 的相似度的答案，而是对于每一种使用大于等于 $k$ 条重复边分割连通块的方案数，再扩展成树时会重复，故 $g_i - g_{i + 1}$ 并不是 $ans_i$，那么此时再进行容斥，即<br>$$<br>g_i = g_i - \sum\limits_{j = i + 1}^{n - 1} g_j\dbinom{j}{i}<br>$$<br>即对于每一组恰好 $j$ 条重复边的方案数，那么在每一组方案中选出任意 $i$ 条边即可组成 $g_i$ 中的一种方案，故其方案数的总和即为 $g_i$ 多算的方案数</p><p>此时 $g_i$ 即为解</p><p>复杂度 $O (n^4)$</p><p>复杂度证明</p><p>求解 $S = \sum\limits_{i = 1}^n size_i^2 \big(\sum\limits size_{son}^2\big)$ 最大值</p><p>现在考虑对于每一个节点 $i$，求解 $size_i^2 \big(\sum\limits size_{son}^2\big)$ 最大值</p><p>令 $i$ 的儿子集合为 $SON$，则有 $\sum\limits_{j \in SON} size_j = size_i - 1$，求解 $\sum\limits_{j \in SON} size_j^2$ 最大值</p><p>因为 $(size_i - 1)^2 = (\sum\limits_{j \in SON} size_j)^2 \ge \sum\limits_{j \in SON} size_j^2$，故当 $SON$ 大小为 $1$ 时上式取最大值</p><p>显然 $S_{max}$ 随着 $n$ 而递增，又由于对于所有 $SON$ 大小为 $1$ 时的点 $i$ 其 $size_i^2 = t_1$，对于其它任意情况点 $i$ 的 $size_i^2 = t_2$，显然可以对这些有标号点找到一种排列使得对于 $\forall i$， 存在 $t_1 \ge t_2$，故这样则可使得 $S$ 取最大值，此时该树为一条链，$S_{max} = \sum\limits_{i = 1}^n i^2 = \frac{(2n +1)n(n + 1)}{6}$，故复杂度上限为 $O (n^4)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">p = (p + MOD - <span class="number">1</span>) % (MOD - <span class="number">1</span>);</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact[n] * power (fact[m], MOD - <span class="number">2</span>) % MOD * power (fact[n - m], MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = f[root][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = Head[root]; p; p = Link[p].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[p].to;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line"><span class="built_in">memset</span> (temp, <span class="number">0</span>, <span class="keyword">sizeof</span> (temp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= subsize[root]; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= subsize[root] - i + <span class="number">1</span>; j ++)</span><br><span class="line"><span class="keyword">if</span> (f[root][i][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= subsize[v]; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= subsize[v] - k + <span class="number">1</span>; l ++) &#123;</span><br><span class="line">temp[i + k - <span class="number">1</span>][j + l] = (temp[i + k - <span class="number">1</span>][j + l] + f[root][i][j] * f[v][k][l] % MOD) % MOD; <span class="comment">// select</span></span><br><span class="line">temp[i + k][j] = (temp[i + k][j] + f[root][i][j] * f[v][k][l] % MOD * l % MOD) % MOD; <span class="comment">// do not select</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span> (f[root], temp, <span class="keyword">sizeof</span> (f[root]));</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) output (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 相似度 n - k</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL base = power (<span class="number">1l</span>l * N, i - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N - i + <span class="number">1</span>; j ++) &#123;</span><br><span class="line">g[N - i] = (g[N - i] + base * f[<span class="number">1</span>][i][j] % MOD * j % MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (N - i == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Test: "</span> &lt;&lt; f[<span class="number">1</span>][i][j] % MOD % MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line">g[i] = (g[i] - g[j] * C (j, i) % MOD + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">output (g[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Solution-Ⅱ"><a href="#Solution-Ⅱ" class="headerlink" title="Solution Ⅱ"></a>Solution Ⅱ</h2><p>这是一个矩阵树定理的解法</p><p>这与「<a href="https://www.luogu.org/problem/P5296" target="_blank" rel="noopener">[北京省选集训2019]生成树计数</a>」极为相似，都是多项式矩阵树定理</p><p>对于不在给定树上的边将其权值赋为 $1$，对于在给定树上的边将其权值赋为 $x$（即多项式 $x$），然后矩阵树定理即可</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1187F Expected Square Beauty</title>
      <link href="/2020/08/04/CF1187F%20Expected%20Square%20Beauty/"/>
      <url>/2020/08/04/CF1187F%20Expected%20Square%20Beauty/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次做到这种类似代数方法运用期望性质的题的说</p><p>期望性质：</p><ul><li>对于两个独立的对象 $A, B$，则有 $E (AB) = E(A)E(B)​$</li><li>线性性：对于对象 $X, Y​$，存在 $E(aX + bY) = aE(x) + bE(Y)​$</li></ul><p>首先设计函数 $I_i(x) = \begin{cases} 1     x_i \neq x_{i - 1} \ 0     x_i = x_{i - 1} \end{cases} (i &gt; 1), ~ I_1(x) = 1​$，则有 $B(x) = \sum\limits_{i = 1}^n I_i(x)​$，故<br>$$<br>\begin{aligned}<br>E (B^2(x)) &amp;= E (\sum\limits_{i = 1}^n I_i(x)\sum\limits_{j = 1}^n I_j(x)) \\<br>&amp;= E (\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n I_i(x)I_j(x)) \\<br>&amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n E(I_i(x)I_j(x))<br>\end{aligned}<br>$$<br>易知，若 $x_i = x_{i - 1}​$ 的概率 $p_i = \frac{\min(r_{i - 1}, r_i) - \max (l_{i - 1}, l_i) + 1}{(r_{i - 1} - l_{i - 1} + 1)(r_i - l_i + 1)}​$，那么 $x_i \neq x_{i - 1}​$ 的概率，即 $E(I_i(x)) = 1 - p_i​$，特别地，$p_1 = 0, E(I_1(x)) = 1​$</p><p>那么此时对 $E (I_i(x)I_j(x))​$ 进行讨论：</p><p>若 $i = j$，则 $E(I_i(x)I_j(x)) = E(I_i(x))$</p><p>若 $|i - j| &gt; 1​$，那么 $I_i(x)​$ 与 $I_j(x)​$ 分别独立，故 $E(I_i(x)I_j(x)) = E(I_i(x))E(I_j(x))​$</p><p>若 $|i - j| = 1​$，令 $i + 1 = j​$，那么进行容斥，即 $E(I_i(x)I_{i- 1}(x)) = 1 - p_{i - 1} - p_i + P ((x_{i - 2} == x_{i - 1}) \bigcup (x_{i - 1} == x_i))​$，根据 $E(I_i(x))​$ 的计算方法，易知，$P ((x_{i - 2} = x_{i - 1}) \bigcup (x_{i - 1} = x_i)) =  \frac{\min(r_{i - 2}, r_{i - 1}, r_i) - \max (l_{i - 2}, l_{i - 1}, l_i) + 1}{(r_{i - 2} - l_{i - 2} + 1)(r_{i - 1} - l_{i - 1} + 1)(r_i - l_i + 1)}​$，特别地，$E(I_1(x)I_2(x)) = E(I_2(x))​$</p><p>综上，最后答案为</p><p>$E(B^2(x)) = \sum\limits_{i = 1}^n(p_i + \sum\limits_{|i - j| &gt; 1} p_j) + 2\sum\limits_{i = 2}^n E(I_i(x)I_{i - 1}(x))$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> l[MAXN], r[MAXN];</span><br><span class="line"><span class="keyword">int</span> size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL p[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL psum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) l[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) r[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) size[i] = r[i] - l[i] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL nume = max (<span class="number">0</span>, min (r[i - <span class="number">1</span>], r[i]) - max (l[i - <span class="number">1</span>], l[i]) + <span class="number">1</span>);</span><br><span class="line">LL base = <span class="number">1l</span>l * size[i - <span class="number">1</span>] * size[i] % MOD;</span><br><span class="line">p[i] = nume * power (base, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">psum[i] = (psum[i - <span class="number">1</span>] + (<span class="number">1l</span>l - p[i] + MOD) % MOD) % MOD;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">1</span>) ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD * psum[i - <span class="number">2</span>] % MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">2</span> &lt;= N)</span><br><span class="line">ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD * ((psum[N] - psum[i + <span class="number">1</span>] + MOD) % MOD) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL part3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (N &gt; <span class="number">1</span>) part3 = (<span class="number">1l</span>l - p[<span class="number">2</span>] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL nume = max (<span class="number">0</span>, min (r[i - <span class="number">2</span>], min (r[i - <span class="number">1</span>], r[i])) - max (l[i - <span class="number">2</span>], max (l[i - <span class="number">1</span>], l[i])) + <span class="number">1</span>);</span><br><span class="line">LL base = <span class="number">1l</span>l * size[i - <span class="number">2</span>] * size[i - <span class="number">1</span>] % MOD * size[i] % MOD;</span><br><span class="line">LL per = ((<span class="number">1l</span>l - p[i - <span class="number">1</span>] - p[i] + nume * power (base, MOD - <span class="number">2</span>) % MOD) % MOD + MOD) % MOD;</span><br><span class="line">part3 = (part3 + per) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">part3 = part3 * <span class="number">2l</span>l % MOD;</span><br><span class="line">ans = (ans + part3) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">4 5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3277 - 串</title>
      <link href="/2020/08/04/BZOJ3277%20-%20%E4%B8%B2/"/>
      <url>/2020/08/04/BZOJ3277%20-%20%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>现在给定你n个字符串，询问每个字符串有多少子串（不包括空串）是所有n个字符串中至少k个字符串的子串（注意包括本身）。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先是广义后缀自动机，就是每次将$last$归为$Root$，从而将几个后缀自动机拼在一起处理</p><p>那么现在需要知道每个字串在$n$个母串中的出现次数，所谓字串，就是所有前缀的所有后缀，所以可以顺着前缀走，那么通过$Parent$树找后缀，一直往上跳，那么需要加一的所有后缀就是所属母串并非当前母串的那几个</p><p>此时再整理出每个所属母串个数$Size &gt;= K$的初始贡献，即$Len[i] - Len[Father[i]]$，反之赋$0$</p><p>又子串为前缀的后缀，那么一个节点的贡献即为它祖先至它本身的贡献前缀和，即它所有后缀能够构成的子串数</p><p>最后再遍历一遍前缀统计答案即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="built_in">string</span> Str[MAXN &gt;&gt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Tree[MAXN][<span class="number">30</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Len[MAXN]= &#123;<span class="number">0</span>&#125;, Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Belong[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = Root, nodes = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> bel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = last, p = ++ nodes;</span><br><span class="line">    last = p;</span><br><span class="line">    Len[p] = Len[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fa &amp;&amp; ! Tree[fa][c])</span><br><span class="line">        Tree[fa][c] = p, fa = Father[fa];</span><br><span class="line">    <span class="keyword">if</span> (! fa)</span><br><span class="line">        Father[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Tree[fa][c];</span><br><span class="line">        <span class="keyword">if</span> (Len[x] == Len[fa] + <span class="number">1</span>)</span><br><span class="line">            Father[p] = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> np = ++ nodes;</span><br><span class="line">            Len[np] = Len[fa] + <span class="number">1</span>, Father[np] = Father[x];</span><br><span class="line">            Father[p] = Father[x] = np;</span><br><span class="line">            <span class="built_in">memcpy</span> (Tree[np], Tree[x], <span class="keyword">sizeof</span> (Tree[x]));</span><br><span class="line">            <span class="keyword">while</span> (fa &amp;&amp; Tree[fa][c] == x)</span><br><span class="line">                Tree[fa][c] = np, fa = Father[fa];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Topo[MAXN];</span><br><span class="line"><span class="keyword">int</span> W[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        <span class="keyword">int</span> p = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            p = Tree[p][Str[i][j] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> fa = p;</span><br><span class="line">            <span class="keyword">while</span> (fa &amp;&amp; Belong[fa] != i) &#123;</span><br><span class="line">                Size[fa] ++;</span><br><span class="line">                Belong[fa] = i;</span><br><span class="line">                fa = Father[fa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        buck[Len[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        Topo[buck[Len[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Size[i] &gt;= K)</span><br><span class="line">            W[i] = Len[i] - Len[Father[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        W[Topo[i]] += W[Father[Topo[i]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Answer[MAXN &gt;&gt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Str[i];</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        last = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            Append (Str[i][j] - <span class="string">'a'</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Merge ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        <span class="keyword">int</span> p = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            p = Tree[p][Str[i][j] - <span class="string">'a'</span>], Answer[i] += W[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld"</span>, Answer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">ab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aaa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2959 - 长跑</title>
      <link href="/2020/08/04/BZOJ%202959%20-%20%E9%95%BF%E8%B7%91/"/>
      <url>/2020/08/04/BZOJ%202959%20-%20%E9%95%BF%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>每个点有各自的权值，要求维护操作：动态加边、动态修改权值、询问在每个点只能经过一次的情况下两点间路程中的最大权值和</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对于一个静态的图，将其缩点，可以得到一棵树，那么两点间询问的答案即为它们之间经过的 $BCC$ 的权值和</p><p>支持动态加边，就需要用到 $LCT$ 去维护 $BCC$</p><p>如果两个点所在 $BCC$ 在不同树上，那么直接连边即可；反之，则说明形成了环，就暴力将这条链拖出来，用选定一个标准节点，用并查集将链上其它节点连到标准节点上，容易证明，这样的复杂度是均摊 $O (\log n)$ 的</p><p>查询即修改容易实现，不加赘述</p><p>注意，此题没有删边，所以 $findroot$ 可用另一个并查集代替，不然会 $T$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e04</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ances[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == ances[p] ? p : ances[p] = find (ances[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lctanc[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lctfind</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == lctanc[p] ? p : lctanc[p] = lctfind (lctanc[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL realval[MAXN];</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL Sum[MAXN]= &#123;<span class="number">0</span>&#125;, value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> revtag[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! p)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    swap (son[p][<span class="number">0</span>], son[p][<span class="number">1</span>]);</span><br><span class="line">    revtag[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Sum[p] = Sum[son[p][<span class="number">0</span>]] + Sum[son[p][<span class="number">1</span>]] + value[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (revtag[p]) &#123;</span><br><span class="line">        reverse (son[p][<span class="number">0</span>]), reverse (son[p][<span class="number">1</span>]);</span><br><span class="line">        revtag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line">    <span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">    son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[fa][s])</span><br><span class="line">        father[son[fa][s]] = fa;</span><br><span class="line">    <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">        son[anc][sonbel (fa)] = p;</span><br><span class="line">    father[p] = anc;</span><br><span class="line">    son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">    pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    top = <span class="number">0</span>, Stack[++ top] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = p; ! isroot (nd); nd = father[nd])</span><br><span class="line">        Stack[++ top] = father[nd];</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">        pushdown (Stack[top]), top --;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line">        <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">            sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tp = <span class="number">0</span>; p; tp = p, p = father[tp] = find (father[p])) <span class="comment">// 注意因为有并查集，所以也要同时更新father[tp]</span></span><br><span class="line">        splay (p), son[p][<span class="number">1</span>] = tp, pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Makeroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Access (p), splay (p), reverse (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Makeroot (x);</span><br><span class="line">    Access (y), splay (y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Makeroot (x);</span><br><span class="line">    father[x] = y;</span><br><span class="line">    <span class="keyword">int</span> fx = lctfind (x), fy = lctfind (y);</span><br><span class="line">    lctanc[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> root)</span> </span>&#123; <span class="comment">// 暴力合并</span></span><br><span class="line">    <span class="keyword">if</span> (! p)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p != root)</span><br><span class="line">        ances[p] = root, value[root] += value[p];</span><br><span class="line">    merge (son[p][<span class="number">0</span>], root), merge (son[p][<span class="number">1</span>], root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (lctfind (fx) != lctfind (fy)) &#123;</span><br><span class="line">        link (fx, fy);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Split (fx, fy);</span><br><span class="line">    merge (fy, fy);</span><br><span class="line">    son[fy][<span class="number">0</span>] = son[fy][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup (fy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x);</span><br><span class="line">    splay (fx);</span><br><span class="line">    value[fx] -= realval[x] - val, realval[x] = val;</span><br><span class="line">    pushup (fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line">    <span class="keyword">if</span> (lctfind (fx) != lctfind (fy))</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    Split (fx, fy);</span><br><span class="line">    <span class="keyword">return</span> Sum[fy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            isneg = <span class="number">1</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> answer[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        Sum[i] = value[i] = realval[i] = getnum (), lctanc[i] = ances[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = getnum ();</span><br><span class="line">        <span class="keyword">int</span> x = getnum (), y = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">            Add (x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">            Modify (x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query (x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 31</span></span><br><span class="line"><span class="comment">10 20 30 40 50 60 70 80 90</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 8 9</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 4 6</span></span><br><span class="line"><span class="comment">1 4 7</span></span><br><span class="line"><span class="comment">3 1 8</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">1 8 9</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">3 7 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">1 4 1</span></span><br><span class="line"><span class="comment">3 7 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">1 5 7</span></span><br><span class="line"><span class="comment">3 6 5</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 5 5</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">2 8 180</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">2 9 190</span></span><br><span class="line"><span class="comment">3 9 9</span></span><br><span class="line"><span class="comment">2 5 150</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">2 1 210</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论,数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC003解题报告</title>
      <link href="/2020/08/04/AGC003%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2020/08/04/AGC003%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="D-Anticube"><a href="#D-Anticube" class="headerlink" title="D - Anticube"></a>D - Anticube</h2><p>说实话质因数分解的题都挺有意思的</p><p>首先对于每个数，显然里面存在的质数三次方的因子都是无贡献的，那么将其的每个质因数化简，即对于质因子 $p^k$，将其变为 $p^{k ~ mod ~  3}$</p><p>那么两个数若乘积为完全立方数，则必须满足它们的每一个相同质因子都是“互补的”（即次数相加为 $0$ 或 $3$），同时显然一定不存在大于一个 $&gt; \sqrt[3]n$ 的质因数 $p$，那么解法就很显然了</p><p>就是筛出 $[2, \sqrt[3]n]$ 的质数，然后对每一个数进行化简，然后将化简后的数的计数器加一，最后在所有两两“互补”的数中取 $max$ 求和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL a[MAXN], newa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= MAX; j += i)</span><br><span class="line">visit[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;LL, <span class="keyword">int</span>&gt; mapp, ccnt;</span><br><span class="line"><span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; j ++)</span><br><span class="line">cnt *= x;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;LL, LL&gt; save[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">save[++ ind] = make_pair (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">mapp[<span class="number">0</span>] = mapp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL p = a[i];</span><br><span class="line">LL cnt = <span class="number">1</span>, ano = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j ++)</span><br><span class="line"><span class="keyword">if</span> (! (p % prime[j])) &#123;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (! (p % prime[j]))</span><br><span class="line">p /= prime[j], times ++;</span><br><span class="line">times %= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (times &gt; <span class="number">0</span>)</span><br><span class="line">ano *= power (prime[j], <span class="number">3</span> - times);</span><br><span class="line">cnt *= power (prime[j], times);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] != <span class="number">1</span> &amp;&amp; cnt == <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) &#123;</span><br><span class="line">ccnt[<span class="number">0</span>] ++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ccnt[cnt * p] ++, newa[i] = cnt * p;</span><br><span class="line"><span class="keyword">if</span> (mapp[cnt * p]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">LL sqr = <span class="built_in">sqrt</span> (p);</span><br><span class="line"><span class="keyword">if</span> (sqr * sqr == p) &#123;</span><br><span class="line">save[++ ind] = make_pair (cnt * p, ano * sqr);</span><br><span class="line">mapp[cnt * p] = mapp[ano * sqr] = ind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">save[++ ind] = make_pair (cnt, ano);</span><br><span class="line">mapp[cnt] = mapp[ano] = ind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ccnt[<span class="number">0</span>] = min (ccnt[<span class="number">0</span>], <span class="number">1</span>), ccnt[<span class="number">1</span>] = min (ccnt[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ind; i ++)</span><br><span class="line">ans += max (ccnt[save[i].first], ccnt[save[i].second]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! mapp[newa[i]])</span><br><span class="line">ans ++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T num = T ();</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum&lt;<span class="keyword">int</span>&gt; ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum&lt;LL&gt; ();</span><br><span class="line">sieve ();</span><br><span class="line"><span class="keyword">int</span> ans = solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1000000007</span></span><br><span class="line"><span class="comment">10000000000</span></span><br><span class="line"><span class="comment">1000000009</span></span><br><span class="line"><span class="comment">999999999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">2368593037</span></span><br><span class="line"><span class="comment">38192375</span></span><br><span class="line"><span class="comment">218391929</span></span><br><span class="line"><span class="comment">572421321</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="E-Sequential-operations-on-Sequence"><a href="#E-Sequential-operations-on-Sequence" class="headerlink" title="E - Sequential operations on Sequence"></a>E - Sequential operations on Sequence</h2><p>先考虑所有只存在增加长度的操作</p><p>那么可以从后往前枚举，考虑后面的操作对前面的贡献</p><p>那么对于每一个位置 $p$，它相当于是第一个小于它的位置 $q$ 算 $p / q$ 次，然后再算一次 $p ~ mod ~ q$，故递归即可</p><p>然后对于减少长度的操作，显然该操作之前所有长度大于等于当前长度的操作都是无用的，故只需初始化时取递增的操作即可转化为只存在增加长度的操作的集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL que[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LL suffix[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findpos</span> <span class="params">(<span class="keyword">int</span> limit, LL delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; que[<span class="number">1</span>]) <span class="keyword">return</span> delta;</span><br><span class="line"><span class="keyword">int</span> posi = upper_bound (que + <span class="number">1</span>, que + limit, delta) - que - <span class="number">1</span>;</span><br><span class="line">LL add = delta / que[posi], rest = delta % que[posi];</span><br><span class="line">suffix[posi] += suffix[limit] * add;</span><br><span class="line"><span class="keyword">return</span> findpos (limit, rest);</span><br><span class="line">&#125;</span><br><span class="line">LL subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">value[<span class="number">1</span>] = que[<span class="number">1</span>], suffix[tail] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tail; i &gt;= <span class="number">2</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> val = findpos (i, que[i]);</span><br><span class="line">value[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tail; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">subsum[value[i]] += suffix[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">subsum[i] += subsum[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T num = T ();</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">write (x), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum&lt;<span class="keyword">int</span>&gt; (), M = getnum&lt;<span class="keyword">int</span>&gt; ();</span><br><span class="line">que[++ tail] = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">LL posi = getnum&lt;LL&gt; ();</span><br><span class="line"><span class="keyword">while</span> (tail &gt;= <span class="number">1</span> &amp;&amp; que[tail] &gt;= posi) tail --;</span><br><span class="line">que[++ tail] = posi;</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">println (subsum[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">22</span></span><br><span class="line"><span class="comment">27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">22</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">26</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">24</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="F-Fraction-of-Fractal"><a href="#F-Fraction-of-Fractal" class="headerlink" title="F - Fraction of Fractal"></a><strong>F - Fraction of Fractal</strong></h2><p>于是我又看错了一次题目。。</p><p>对于左右、上下复制后都连通的情况，显然答案为 $1$</p><p>对于左右、上下复制后都不连通的情况，设其黑点个数为 $p$，则答案显然为 $p^{k - 1}$</p><p>那么现在假设左右复制后连通，上下复制后不连通，令其最终状态黑点个数 $x_n$，左右连通的点组（即 $##$）个数为 $y_n$，那么思考一下，答案即为 $x_n - y_n$，考虑转移，那么 $y_i$ 会只会在最左端和最右端连通时增加，故令 $z_i$ 表示 $i$ 状态时最左和最右连通的个数，则转移即为<br>$$<br>\begin{aligned}<br>x_i &amp;= x_{i - 1}^2 \\<br>y_i &amp;= x_{i - 1} \times y_{i - 1} + z_{i - 1} \times y_{i - 1} \\<br>z_i &amp;= z_{i - 1}^2<br>\end{aligned}<br>$$<br>然后发现这样子满足矩阵乘法，即可构造矩阵<br>$$<br>\begin{bmatrix}<br>x_1 &amp; y_1 \\<br>0 &amp; z_1<br>\end{bmatrix}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">LL a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">Matrix () &#123;</span><br><span class="line"><span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; A, <span class="keyword">const</span> Matrix&amp; B) &#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k ++)</span><br><span class="line">ret.a[i][j] = (ret.a[i][j] + A.a[i][k] * B.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">matpower</span> <span class="params">(Matrix x, LL k)</span> </span>&#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line">ret.a[<span class="number">1</span>][<span class="number">1</span>] = ret.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">ret = ret * x;</span><br><span class="line">x = x * x;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ret.a[<span class="number">1</span>][<span class="number">1</span>] - ret.a[<span class="number">1</span>][<span class="number">2</span>] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL k;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%lld"</span>, &amp; N, &amp; M, &amp; k);</span><br><span class="line"><span class="keyword">int</span> tol = <span class="number">0</span>, toup = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lr = <span class="number">0</span>, ud = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, <span class="built_in">map</span>[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">cnt ++;</span><br><span class="line">tol += <span class="built_in">map</span>[i][j - <span class="number">1</span>] == <span class="string">'#'</span>;</span><br><span class="line">toup += <span class="built_in">map</span>[i - <span class="number">1</span>][j] == <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[i][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; <span class="built_in">map</span>[i][M] == <span class="string">'#'</span>) lr ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[<span class="number">1</span>][j] == <span class="string">'#'</span> &amp;&amp; <span class="built_in">map</span>[N][j] == <span class="string">'#'</span>) ud ++;</span><br><span class="line"><span class="keyword">if</span> (! lr &amp;&amp; ! ud) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; power (<span class="number">1l</span>l * cnt, k - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lr &amp;&amp; ud) &#123;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! lr) swap (lr, ud), swap (tol, toup);</span><br><span class="line">Matrix x = Matrix ();</span><br><span class="line">x.a[<span class="number">1</span>][<span class="number">1</span>] = cnt, x.a[<span class="number">1</span>][<span class="number">2</span>] = tol, x.a[<span class="number">2</span>][<span class="number">2</span>] = lr;</span><br><span class="line">LL ans = matpower (x, k - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3 3</span></span><br><span class="line"><span class="comment">.#.</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment">#.#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11 15 1000000000000000000</span></span><br><span class="line"><span class="comment">.....#.........</span></span><br><span class="line"><span class="comment">....###........</span></span><br><span class="line"><span class="comment">....####.......</span></span><br><span class="line"><span class="comment">...######......</span></span><br><span class="line"><span class="comment">...#######.....</span></span><br><span class="line"><span class="comment">..##.###.##....</span></span><br><span class="line"><span class="comment">..##########...</span></span><br><span class="line"><span class="comment">.###.....####..</span></span><br><span class="line"><span class="comment">.####...######.</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment">#.##..##..##..#</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC002解题报告</title>
      <link href="/2020/08/04/AGC002%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2020/08/04/AGC002%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="D-Stamp-Rally"><a href="#D-Stamp-Rally" class="headerlink" title="D - Stamp Rally"></a>D - Stamp Rally</h2><p>整体二分 + 并查集常规操作</p><p>不过记得每次仅将当前递归时使用的并查集删去即可，之前的保留，所以对于那些被忽略的答案的位置，也需要递归到然后加入并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> answer[MAXQ]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">querySt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"></span><br><span class="line">querySt (<span class="keyword">int</span> find = <span class="number">0</span>, <span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, <span class="keyword">int</span> flim = <span class="number">0</span>) :</span><br><span class="line">index (find), x (fx), y (fy), lim (flim) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">querySt query[MAXQ];</span><br><span class="line"></span><br><span class="line">querySt q1[MAXQ], q2[MAXQ];</span><br><span class="line"><span class="keyword">int</span> father[MAXN], subsize[MAXN];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">stack</span>[MAXM];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> father[x] == x ? x : find (father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] &gt; subsize[fy]) swap (fx, fy);</span><br><span class="line">father[fx] = fy, subsize[fy] += subsize[fx];</span><br><span class="line"><span class="built_in">stack</span>[++ top] = make_pair (fx, fy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="comment">// if (left &gt; right || l &gt; r) return ; 注意若 l &gt; r 就退出那么有一些点无法加入并查集</span></span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "Test: " &lt;&lt; left &lt;&lt; ' ' &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line">answer[query[i].index] = left;</span><br><span class="line">merge (edge[left].first, edge[left].second);</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= mid; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].first, v = edge[i].second;</span><br><span class="line">merge (u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = query[i].x, y = query[i].y;</span><br><span class="line"><span class="keyword">int</span> lim = query[i].lim;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] &gt;= lim) q1[++ t1] = query[i];</span><br><span class="line"><span class="keyword">else</span> q2[++ t2] = query[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] + subsize[fy] &gt;= lim) q1[++ t1] = query[i];</span><br><span class="line"><span class="keyword">else</span> q2[++ t2] = query[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1; i ++)</span><br><span class="line">query[l + i - <span class="number">1</span>] = q1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2; i ++)</span><br><span class="line">query[l + t1 + i - <span class="number">1</span>] = q2[i];</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">stack</span>[top].first, y = <span class="built_in">stack</span>[top].second;</span><br><span class="line">top --;</span><br><span class="line">father[x] = x, subsize[y] -= subsize[x];</span><br><span class="line">&#125;</span><br><span class="line">solve (left, mid, l, l + t1 - <span class="number">1</span>), solve (mid + <span class="number">1</span>, right, l + t1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen ("stamp.in", "r", stdin);</span></span><br><span class="line"><span class="comment">// freopen ("stamp.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">edge[i] = make_pair (u, v);</span><br><span class="line">&#125;</span><br><span class="line">Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = getnum (), y = getnum (), z = getnum ();</span><br><span class="line">query[i] = querySt (i, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">father[i] = i, subsize[i] = <span class="number">1</span>;</span><br><span class="line">solve (<span class="number">1</span>, M, <span class="number">1</span>, Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">2 4 5</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 13</span></span><br><span class="line"><span class="comment">8 5</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">10 9</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">7 10</span></span><br><span class="line"><span class="comment">7 1</span></span><br><span class="line"><span class="comment">2 7</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">8 10</span></span><br><span class="line"><span class="comment">6 9</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4 9 11</span></span><br><span class="line"><span class="comment">6 2 2</span></span><br><span class="line"><span class="comment">5 4 5</span></span><br><span class="line"><span class="comment">10 8 4</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="E-Candy-Piles"><a href="#E-Candy-Piles" class="headerlink" title="E - Candy Piles"></a>E - Candy Piles</h2><p>神仙博弈论 + 模型转化</p><p>算是目前做过的为数极少的博弈论题之一，然而并不用 $SG$ 函数什么的</p><p>注意 $2$ 操作是对于每一堆都吃一个而不是任选一堆吃，然而我看完题解才发现我题目看错了。。。</p><p>将糖果堆按照个数排序后，得到如下图</p><blockquote><p>000</p><p>000</p><p>0000</p><p>00000</p></blockquote><p>将其看做以左下角为点 $(1, 1)$ 的坐标系，那么，对于吃最大的一堆糖果，就相当于向上移一格，对于每堆吃一个糖果，就相当于向右移一格，然后吃到不能吃为止，即到达点 $(3, 4), ~ (4, 2), ~ (1, 5)$ 的其中一个</p><p>显然，上述无法继续走动的三点是必输点，那么就可以通过上述点扩张将整幅图的必赢必输状态表示出来</p><p>根据定理</p><blockquote><p>若一个点是必赢点当且仅当其可转移的状态中存在必输点；若一个点是必输点当且仅当其可转移的状态中皆是必赢点</p></blockquote><p>就可以实现</p><p>当然，这样还是 $T$ 的，所以经过观察，可以发现</p><ul><li>一个点的必赢必输状态与其左上角的状态相同</li></ul><p>证明的话枚举然后简单反证一下就好了</p><p>故现在可以将点 $(1, 1)$ 一直向右上角移动到直到无法移动为止的点 $(k, k)$，那么它现在必处于图形的“边缘”上，显然，对于边缘的情况，一个点的状态必与其右（上）的点相反，那么只要判断一下 $(k, k)$ 可以向上或向右扩张直到无法移动的步数的奇偶性，若存在奇数，则为先手必赢；反之，则后手必赢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>, comp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt;= i) &#123;</span><br><span class="line"><span class="keyword">bool</span> win = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> ((a[i] - i) &amp; <span class="number">1</span>)</span><br><span class="line">win = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! win &amp;&amp; a[i + <span class="number">1</span>] == i) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; i) <span class="keyword">break</span>;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! (cnt &amp; <span class="number">1</span>))</span><br><span class="line">win = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">win ? <span class="built_in">puts</span> (<span class="string">"First"</span>) : <span class="built_in">puts</span> (<span class="string">"Second"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="F-Leftmost-Ball"><a href="#F-Leftmost-Ball" class="headerlink" title="F - Leftmost Ball"></a>F - Leftmost Ball</h2><p>动态规划</p><p>一开始我是按照常规思路想，并且将一个白球与一类颜色球当做一个整体来处理的，即设 $f_{i, j}$ 表示前 $i$ 个位置放置 $j$ 个白球的方案数，然而首先这样会 $T$，并且容易算重，于是我去康了眼题解</p><p>然后发现实际上白球不能与类颜色球整体考虑，不然会算重，但是显然一类颜色球是可以整体考虑的，故设状态 $f_{i, j}$ 表示放了 $i$ 个白球和 $j$ 个类颜色球的方案数 $(j \le i)$</p><p>那么问题来了，要如何知道每个球在当前状态下的位置关系呢？因为感觉不知道没法确定球的可放置方案数</p><p>当然假如真的要知道位置关系是不可能的，所以仔细思考一下，可以发现，若当前你要放一个白球，那么在你放当前白球的位置之前的位置必须已经被完全填满，不然必会存在该白球之后的类颜色球放置在当前白球前，使得方案不合法，故当前白球放置的相对位置一定只有一个，即 $f_{i, j} += f_{i - 1,j }$</p><p>对于放置类颜色球，由于当前类颜色球的白球已经放置完毕，故它还剩下 $n \times k - i - (k - 1) \times(j - 1)$ 个位置放其 $k - 1$ 个球，且当前还剩下 $n - (j - 1)$ 个颜色可供选择，故得 $f_{i, j} += f_{i, j - 1} \times (n - j + 1) \times \dbinom{n \times k - i - (k - 1) \times (j - 1)}{k - 1}$</p><p>然而你会发现这样连样例都过不了，因为你又算重了</p><p>比如对于</p><blockquote><p>{0, 0, 1, 2}</p></blockquote><p>就会存在先放 $\{0, 1\}$ 还是 $\{0, 2\}$ 的问题，然后会放两遍，所以理论上只要是存在连续的 $0$ 的都会算重</p><p>于是一时脑抽，又只能瞄题解了</p><p>其实解决方案极其简单，只要满足当前放的类颜色球的第一个一定是最接近 $0$ 的就行了，也就是规定其放置顺序</p><p>故综上所述，转移方程为<br>$$<br>f_{i, j} = f_{i - 1, j} + f_{i, j - 1} \times (n - j + 1) \times \dbinom{n \times k - i - (k - 1) \times (j - 1) - 1}{k - 2}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"></span><br><span class="line">LL fact[MAXM]= &#123;<span class="number">0</span>&#125;, invfact[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">0</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N * K; i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N * K; i ++)</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * invfact[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; K);</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">init ();</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">LL delta = f[i][j - <span class="number">1</span>] * (N - j + <span class="number">1</span>) % MOD * C (N * K - i - (K - <span class="number">1</span>) * (j - <span class="number">1</span>) - <span class="number">1</span>, K - <span class="number">2</span>) % MOD;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) delta = <span class="number">0</span>;</span><br><span class="line">f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j] + delta) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N][N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2000 2000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC001 E - Wide Swap</title>
      <link href="/2020/08/04/AGC001%20E%20-%20Wide%20Swap/"/>
      <url>/2020/08/04/AGC001%20E%20-%20Wide%20Swap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先显然要先把原数组重新映射一下，令映射过后的数组为 $a_i$</p><p>因为题目要求 $|a_j - a_i| &gt;= K$ 的可以置换，那么反之，则有 $|a_j - a_i| &lt; K$ 的 $i, j$ 相对位置不变</p><p>故最简单的方法就是对于每个 $i$，将其与所有满足 $|a_j - a_i| &lt; K$ 的 $j$ 连边，然后跑一边拓扑，复杂度 $O (n^2)$</p><p>然后考虑在 $a_i$ 连的这么多边中，若是存在边 $(i, j), (j, k), (i, k)$，其中 $i &lt; j &lt; k$，那么显然 $(i, k)$ 的存在性是无关紧要的</p><p>又 $a_i$ 可连边的权值范围是 $(a_i - K, a_i) \cup (a_i, a_i + K)$，那么只需要分别向两个区间中标号最小的那个点连边就好了（单向边，并且一定向标号比自己大的点连），这样就相当于是将原来的乱七八糟连接的图变成了一条条单向的链，并且这些链可以覆盖原来的所有情况</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minv[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">minv[root] = value;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson, left, mid, posi, value);</span><br><span class="line"><span class="keyword">else</span> modify (rson, mid + <span class="number">1</span>, right, posi, value);</span><br><span class="line">minv[root] = min (minv[lson], minv[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line"><span class="keyword">return</span> minv[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mv = INF;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) mv = min (mv, query (lson, left, mid, L, R));</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) mv = min (mv, query (rson, mid + <span class="number">1</span>, right, L, R));</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indeg[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="keyword">int</span> ret[MAXN]= &#123;<span class="number">0</span>&#125;, rcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! indeg[i])</span><br><span class="line">que.push(i);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.top();</span><br><span class="line">que.pop();</span><br><span class="line">ret[p] = ++ rcnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[p]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">indeg[v] --;</span><br><span class="line"><span class="keyword">if</span> (! indeg[v]) que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">b[a[i]] = i;</span><br><span class="line"><span class="built_in">memset</span> (minv, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (minv));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> p1 = query (<span class="number">1</span>, <span class="number">1</span>, N, max (<span class="number">1</span>, b[i] - K + <span class="number">1</span>), b[i] - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> p2 = query (<span class="number">1</span>, <span class="number">1</span>, N, b[i] + <span class="number">1</span>, min (N, b[i] + K - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (p1 &gt;= <span class="number">1</span> &amp;&amp; p1 &lt;= N) Insert (b[i], b[p1]), indeg[b[p1]] ++;</span><br><span class="line"><span class="keyword">if</span> (p2 &gt;= <span class="number">1</span> &amp;&amp; p2 &lt;= N) Insert (b[i], b[p2]), indeg[b[p2]] ++;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, b[i], i);</span><br><span class="line">&#125;</span><br><span class="line">topo ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ret[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">4 2 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">5 4 3 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 3</span></span><br><span class="line"><span class="comment">4 5 7 8 3 1 2 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
