<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>A.F.O.心路历程&amp;NOI2020游记</title>
      <link href="/2021/07/19/A_F_O/"/>
      <url>/2021/07/19/A_F_O/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以一块 $Cu$ 结束了这么多年的 $\text{OI}$ 生涯</p><p>$Day ~ ~ 0$ 的笔试十分顺利地拿到了 $100$ 分满分，晚上一直在肝模板，但好像实际上并没有啥用，需要模板的部分分估摸着大多都快到正解了，咱也想不到</p><p>$Day ~ ~ 1$ 开始前，按照往年成绩，我给自己定下地分数目标大概是 $Day ~ ~ 1$ 要大于等于 $150$，$Day ~ ~ 2$ 大于等于 $130$ 左右，但我认为这样的目标间接造成了 $Day ~~ 1$ 比较大的失利</p><p>$T1$ 看了大概 $20min$ 左右就想到了 $O (kn^3\log n)$ 矩阵乘法的思路，但好像怎么算都最多只能过 $k = 0$ 的点，剩下的怎么算都过不去（实际上我认为这矩乘可以过 $k = 0$ 的时候时间也已经过去了很久），结合暴力这样就有 $65 pts$ 了，但由于给自己定下的目标，我一直在想后续解法，一直犹豫到想到了  $1h45min$ 左右也没啥想法，这时我算是比较慌张了，因为我本来是打算每题整个 $1.5h$，比较从容，但这么优柔寡断一下导致我最简单的暴力都一直打错，最后到 $2.5h$ 才勉勉强强写完了 $50 pts$，剩下 $15 pts$ 没办法了只能先晾一边</p><p>这时候开 $T2$，简单容斥很好想，但我卡在了如何高效的计算选出的每种集合包含的点数，想来想去感觉树剖比较合理，但过 $5e05$ 还是比较悬，本来想着能不能对每条边考虑来计算答案看看能不能拿更高，但好像搞不出来，此时已经又过了 $1h$，吸取了 $T1$ 的教训，我果断开始树剖，花了 $15 \sim 20min$ 左右敲完，发现每次会多覆盖一个 $lca$，本来想着每次跳完把 $lca$ 再删去，结果线段树部分死活写不出来，只好放弃，改 $bitset$ 直接暴力整集合然后取并，写完已经 $4h20min$ 了</p><p>于是只剩下 $40min$ 写 $T3$，看完题目用 $5 \sim 10min$ 写了 $24 pts$ 的暴力，开始想剩下的部分分，还以为 $Subtask 2$ 可以直接一个主席树了事，写完了主席树才发现假了，这个时候大概就 $4h45min$ 了，想放弃了，差点 <code>freopen</code> 没开直接见祖宗，想着今天只有 $102 pts$ 有点心态爆炸，于是在一片混沌之下过完了剩下的 $15min$</p><p>最终 $T1$ 写挂了环的部分，$T3$ 多了 $8 pts$，最终 $40 + 28 + 32 = 104$，比预期高了 $2 pts$，出来一看几乎所有人都是 $190+$，还有 $270+$ 甚至 $AK$ 的，发现 $T1$ 用 $1 \times n$ 的矩阵来乘，同时二进制拆分一下的 $trick$ 就可以 $O (kn^2\log n)$ 直接切掉，好像这是一个比较常规的 $trick$？不过我没见过，算了。$T2$ 的 $40 pts$ 直接考虑每条边的贡献然后子集和一下就好，剩下的 $60 pts$ 是树形 $dp$，可惜了没想到 $40 pts$，这肯定在我能力范围之内</p><p>晚上听讲评 $T3$ 是 $lxl$ 出的大分块题，原来 $NOI$ 也考 $YnOI$ 那些玩意儿啊。。反正我分块写的比较少，什么高维莫队第十三分块啥的我也不会，不过 $lxl$ 的头发好长。。<code>朝田诗乃</code> 过来写说不定能切？最后说了下大概的成绩分布，算上集训队和 $D、E$ 类，$240+$ 队线，$148$ 前 $200$，我估摸着去掉那些人大概 $125 \sim 130$ 应该是正统的前 $200$，可惜了</p><p>$Day ~ ~ 1$ 下午和晚上就颓，然后买了两本书，看了会儿，睡觉</p><p>$Day ~ ~ 2$ 想着能不能翻盘，但好像又没啥希望，于是就在两种思想中挣扎</p><p>进考场开 $T1$，花了 $15min$ 随便想了一个贪心，试了一下，好像能过 $n \le 4$ 和 $m = n - 1$ 的？说不定 $m \ge n$ 的也能过，然后就假装有 $35 pts$，开始想剩下的，一直觉得这题应该是一个网络流，但只能选 $1 \sim 2$ 个的限制就让我死活构不出图来，几次想到了几个图感觉没毛病，结果等费用流的敲完了才发现假的不能再假，于是就这样混沌地度过了 $1h45min$，去瞄了一眼 $T2$，题面贼长但挺有意思，理解完题意觉得这玩意儿一看就知道不是我会写的，瞥了眼部分分，$12 pts$ 一眼，剩下的都不会，于是我打算写 $12 pts$，剩下的直接加一些特判然后 $rand ()$，然后滚回 $T1$</p><p>$Day ~ ~ 2$ 由于题目对我比较自闭所以时间也懒得管了，反正都不会。。不知何时开了下 $T3$，发现连 $30 pts$ 都不会，想着玩球了，然后敲了个深搜再随便输出了个最短路骗分</p><p>于是 $Day ~ ~ 2$ 就在题目交叉混想（主要在想 $T1$ 网络流）中结束了（最后我 $T1$ 用贪心骗分）</p><p>$CCF$ 晚了 $1.5h$ 才开成绩，在场外手机都快看没电了。。最终 $35 + 4 + 0 = 39$，$T2$ 估计是后面魔改完忘记再测一下 $h_{max} \le 2$ 的数据结果翻车了，$T3$ 忘记输出 $- 1$ 不然能有 $5 pts$，事实证明你不能用脸翻盘，粉兔 $T1$ 随机化 $70 +$，$nealchen$ 达到了 $200$ 整，他们看着必进队啊，很厉害</p><p>讲评也挺不太懂，好像我 $T1$ 的 $35 pts$ 的贪心跟正解不是一回事？反正就是会的会，不会的还是不会，这样的话总分 $100 + 104 + 39 = 243$，这成绩看着炼铜术士稳了，但还抱有一线能给铜抛光上银的希望，最终队线 $447$，银牌 $274$，$FJ$ 四个进队，兔差 $1$ 分 $Au$，但队是肯定进了</p><p>今年 $Ag$ 数目增加了 $50$ 个，省选前大半年没搞了，多少还是会有些心里没底，但还是认为拿 $Ag$ 还是比较稳的，况且没拿到 $Ag$ 强基也不会有什么优惠，所以等到两天成绩出来的时候，还算是比较失望的（虽然后面逐渐佛系），想着如果我 $T1$ 没丢那 $10 pts$，再把 $k = 0$ 敲完，$T2$ 捡回 $13 pts$，好像能压 $Ag$ 线呢？感觉今年的题比较偏，对我这种刷题比较少的很不友好，这些类型题我都几乎没做过，如果换像去年常规一点的我应该也能 $Ag$？不过这都是后话，多少会有些不甘心，不过自己的水平就摆在那儿，技不如人，甘拜下风</p><p>这样算是给整个 $\text{OI}$ 生涯划上了个圆满的句号，虽然没有强基的优惠还是会失落，但毕竟进过了省队，来过了国赛，见到甚至认识了那些之前只闻其名可望而不可及的神仙，眼界也不一样了</p><p>考完之后和其它强校的教练交流了一下，他们也说了他们的教学指导和方法，各个部分连接紧凑，有理有据，大部分采用的是单或双教师统一管理，有历届高手传承，学术交流范围更广，不至于说就我们同级团队内部交流，水平顶天了也就那么多，交流来交流去不过还是那一回事，进展缓慢，他校从一定程度开始就经常有比较密集的队内或多校互测，在作为选手的同时，还有很多作为出题人与老师的机会，所谓 <code>教学相长</code> 也正是如此，除此以外还有更多指导方法，若是在当时停课的时候，甚至是从初中开始以这种模式训练，我相信我还是有能力去接近那些高手的水平</p><p>说实话，这次最遗憾的倒不是拿了 $Cu$，因为虽然有一定失误因素，但主要还是技不如人，最遗憾的其实便是我本来可能可以拥有那些高手的实力，却成了现在的样子</p><p>好了，$\text{OI}$ 生涯就此结束，该滚回去肝文化课了</p><p>$\text{A.F.O.}$ 快乐</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说话</title>
      <link href="/2021/07/19/hello-world/"/>
      <url>/2021/07/19/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>终于搞完了。。</p><p>这是第三版的博客迁移</p><p>之前由于咕了一段时间OI</p><p>搞的原博客服务器过期域名过期数据全没了</p><p>然后就重新搞了这么一个玩意儿</p><p>至于原因</p><p>大概就是咕了半年后去省选摸个鱼一不小心进队了</p><p>于是就得准备NOI了</p><p>当然，这个“一不小心”不带有任何自傲的意思</p><p>我只是觉得自己的水平还没有达到标准。。</p><p>还有一个月，出去集训</p><p>希望到NOI的时候能达到自己想要的水平吧</p><p>保银争金</p><p>那么我的博客也得重新回来了</p><p>嗯</p><p>就这样</p><p>$\text{Upd:}$ <a href="https://colythme.github.io/2020/08/21/A_F_O/">A.F.O.心路历程&amp;NOI2020游记</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRT（中国剩余定理）及其扩展</title>
      <link href="/2021/07/19/CRT%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%89%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/"/>
      <url>/2021/07/19/CRT%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%89%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h2><p>用于求解类似<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2} \\<br>&amp;… \\<br>&amp;x \equiv a_n \pmod{m_n}<br>\end{aligned}<br>\right.<br>$$<br>其中，$\forall i, j, ~ (m_i, m_j) = 1$</p><p>设 $M = \prod_{i = 1}^n m_i, ~ M_i = \frac{M}{m_i}$，再设 $M_it_i \equiv 1 \pmod{m_i}$，其中 $1 \le i \le n$</p><p>则可构造一解 $x = \sum\limits_{i = 1}^n a_iM_it_i$，任意解 $x_0 = x + k \times M$</p><h2 id="ExCRT"><a href="#ExCRT" class="headerlink" title="ExCRT"></a>ExCRT</h2><p>用于求解类似<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2} \\<br>&amp;… \\<br>&amp;x \equiv a_n \pmod{m_n}<br>\end{aligned}<br>\right.<br>$$<br>其中，不一定满足 $\forall i, j, ~ (m_i, m_j) = 1$</p><p>考虑两个两个处理，然后合并</p><p>现在先考虑方程<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x \equiv a_1 \pmod{m_1} \\<br>&amp;x \equiv a_2 \pmod{m_2}<br>\end{aligned}<br>\right.<br>$$<br>将同余去掉，再进行变换<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;x = a_1 + k_1m_1 \\<br>&amp;x = a_2 + k_2m_2<br>\end{aligned}<br>\right. \\<br>\Rightarrow k_1m_1 - k_2m_2 = a_2 - a_1<br>$$</p><p>那么此时若 $(m_1, m_2) | (a_2 - a_1)$ 则有解，反之则无解</p><p>当然这时就可以用 $ExGCD$ 直接求解，但接下来把它化成逆元的形式会更容易解开也更不耗时</p><p>令 $d = (m_1, m_2)$，则<br>$$<br>\begin{aligned}<br>\frac{k_1m_1}d - \frac{k_2m_2}d &amp;= \frac{a_2 - a_1}d \\<br>\frac{k_1m_1}d &amp;\equiv \frac{a_2 - a_1}d \pmod{\frac{m_2}d} \\<br>k_1 &amp;\equiv inv (\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d \pmod{\frac{m_2}d} \\<br>k_1 &amp;= inv (\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d + t\frac{m_2}d \\<br>\end{aligned}<br>$$<br>其中 $inv (x, p)$ 表示 $x$ 在模 $p$ 意义下的逆元</p><p>此时将 $k_1$ 代入 $x = a_1 + k_1m_1$，则有<br>$$<br>x \equiv a_1 + m_1 \times inv(\frac{m_1}d, \frac{m_2}d)\frac{a_2 - a_1}d \pmod{\frac{m_1m_2}d}<br>$$<br>然后合并 $n - 1$ 次即可</p><h2 id="Ex-ExCRT"><a href="#Ex-ExCRT" class="headerlink" title="Ex-ExCRT"></a>Ex-ExCRT</h2><p>If we suppose that our equation set is something like this:<br>$$<br>\left\{<br>\begin{aligned}<br>&amp;b_1x \equiv a_1 \pmod{p_1} \\<br>&amp;b_2x \equiv a_2 \pmod{p_2} \\<br>&amp;… \\<br>&amp;b_nx \equiv a_n \pmod{p_n}<br>\end{aligned}<br>\right.<br>$$<br>then we need to change the way we process the equations</p><p>Suppose that we have got the answer of the first $i - 1$ congruence equations, we call it $ans$. And suppose $M$ to be the least common multiple of $\{p_1,p_2, p_3, …, p_n\}$, then obviously, the answer of the first $i$ congruence equations $ANS$ should be $ans + kM (k \in \mathbb Z)$. Let us start to derive:<br>$$<br>\begin{aligned}<br>&amp;ANS = ans + Mx \\<br>&amp;\Rightarrow b_i (ans + Mx) \equiv a_i \pmod{p_i} \\<br>&amp;\Rightarrow b_iMx \equiv a_i - b_i \times ans \pmod{p_i} \\<br>&amp;\Rightarrow b_iMx + p_iy = a_i - b_i \times ans<br>\end{aligned}<br>$$<br>Apparently, we can use $ExCRT$ to solve the last equation.</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRT/ExCRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十六）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>$\text{OEIS}$ $trick$</p><p>$\text{score：100 + 0 + 0 = 100            rk：6/35}$</p><h2 id="Problem-A：数排列"><a href="#Problem-A：数排列" class="headerlink" title="Problem A：数排列"></a>Problem A：数排列</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/L1XrIYc2SMA5eDV.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>打表，然后 $\text{OEIS}$ 第 <a href="http://oeis.org/A005802" target="_blank" rel="noopener">A005802</a> 序列</p><p>本来想着题解可能会给出正解，然而他这么说</p><blockquote><p>问题是求一个数列的第 $n$ 项，但该数列显然不是线性递推数列， 但可以猜想该数列是整式递推数列。利用高斯消元或扩展 $BM$，可得……</p></blockquote><p>好了那估摸着正解就 $\text{OEIS}$ 吧</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e05</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; LL MOD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL vis[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[MAX] = power (fact[MAX], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAX - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) invfact[i] = invfact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>, a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt; (MAX &gt;&gt; <span class="number">1</span>); n ++) &#123;</span><br><span class="line">LL add = (<span class="number">10l</span>l * n % MOD * n % MOD + <span class="number">10l</span>l * n % MOD + <span class="number">3</span>) % MOD * a[n] % MOD;</span><br><span class="line">add = (add - <span class="number">9l</span>l * n % MOD * n % MOD * a[n - <span class="number">1</span>] % MOD + MOD) % MOD;</span><br><span class="line">a[n + <span class="number">1</span>] = add * power (<span class="number">1l</span>l * (n + <span class="number">1</span>) * (n + <span class="number">1</span>) % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* (n+1)^2 a(n+1) = (10*n^2+10*n+3) * a(n) - 9*n^2 * a(n-1). */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (vis, - <span class="number">1</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">T = getnum (); <span class="built_in">cin</span> &gt;&gt; MOD;</span><br><span class="line">init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = getnum ();</span><br><span class="line"><span class="keyword">if</span> (~ vis[n]) &#123; <span class="built_in">cout</span> &lt;&lt; vis[n] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">LL ans = ((<span class="number">18l</span>l * n + <span class="number">45</span>) % MOD * a[n]- (<span class="number">7l</span>l + <span class="number">2</span> * n) % MOD * a[n + <span class="number">1</span>] % MOD + MOD) % MOD;</span><br><span class="line">ans = ans * power (<span class="number">6l</span>l * (n + <span class="number">2</span>) % MOD * (n + <span class="number">2</span>) % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vis[n] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a(n) = 2 * Sum_&#123;k=0..n&#125; binomial(2*k, k) * (binomial(n, k))^2 * </span></span><br><span class="line"><span class="comment">  (3*k^2 + 2*k+1 - n - 2*k*n)/((k+1)^2 * (k+2) * (n-k+1)).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Problem-B：排列"><a href="#Problem-B：排列" class="headerlink" title="Problem B：排列"></a>Problem B：排列</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/IZAX16L2sirGPgw.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/01/rZMB8nmuJ1YoweS.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>第一次订正的交互题</p><p>大概记录一下交互题咋玩</p><ul><li>编译可以通过在电脑 $\text{path}​$ 中添加编译器路径，通过 $\text{cmd}​$ $\text{cd}​$ 到指定文件夹，输入题目给定编译语句编译，再运行 $\text{xxx.exe}​$ 运行，输入数据，最后在 $\text{cmd}​$ 中返回答案正确性及询问次数</li><li>编译运行简易方法，可直接加入头文件 <code>#include &quot;grader.cpp&quot;</code>，此时可直接编译运行</li></ul><p>回到正题</p><p>随机一个排列 $q​$，再随机地改变 $q​$ 中的 $S​$ 个元素，使这 $S​$ 个元素重新错排，设得到排列 $r​$，改变了位置 $a_1, a_2, …, a_S​$，那么有一定概率满足所有 $|p_{a_i} - q_{a_i}|​$ 构成的数的集合 $A​$ 与 $|p_{a_i} - r_{a_i}|​$ 构成的数的集合 $B​$ 完全没有交集，此时取 $S = \frac{\sqrt n}{2}​$ 可以使该概率比较大（证明咱也不会）</p><p>假定此时满足 $|A \cup B| = 2S​$，即满足两个集合无交，那么我们由 $A​$ 可以对每个 $q_{a_i}​$ 得到最多 $2 \times S​$ 个它可以匹配的位置，同样对 $B​$ 与 $r_{a_i}​$ 也是一样，这实际上就变成了一个二分图，为了方便，将其反过来记，即每次由 $A​$ 得到每个 $q_{a_i}​$ 不可能匹配到的位置，然后在二分图上将这些边删去，那么最终找到答案的情况等价于二分图匹配具有唯一性，这个用网络流和 $Tarjan​$ 维护一下就好了</p><p>进一步优化，随机几次之后可能一些位置已经确定了唯一匹配性，那么每次随机选 $S$ 个元素的时候优先选还未成功匹配的位置</p><p>再者，在 $n$ 比较小时可能很难随到答案，就可以在开头时随十个 $q$，然后每次随机使用其中一个 $q$，这样可以比较大的概率避免这样的情况</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"perm.h"</span></span></span><br><span class="line"><span class="comment">// #include "grader.cpp"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN], bel[MAXN], ord = <span class="number">0</span>, bcc = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = ord = bcc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) dfn[i] = low[i] = bel[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top = <span class="number">0</span>; <span class="keyword">bool</span> insta[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ ord;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = u, insta[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (! dfn[v]) &#123;</span><br><span class="line">Tarjan (v);</span><br><span class="line">low[u] = min (low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (insta[v]) low[u] = min (low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">bcc ++; <span class="keyword">int</span> tp;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tp = <span class="built_in">stack</span>[top --];</span><br><span class="line">bel[tp] = bcc, insta[tp] = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (tp != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="keyword">if</span> (! dfn[i]) Tarjan (i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">bool</span> con[<span class="number">1000</span>]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">namespace</span> net &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (u, v, cap), Insert (v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, S, T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123; <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que; <span class="keyword">int</span> depth[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[u] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (rest, cap));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">graph::N = <span class="number">2</span> * n, graph::init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[j].to, cap = Link[j].cap;</span><br><span class="line"><span class="keyword">if</span> (! cap) graph::Insert (i, match[i] = v);</span><br><span class="line"><span class="keyword">else</span> graph::Insert (v, i);</span><br><span class="line">&#125;</span><br><span class="line">graph::work ();</span><br><span class="line"><span class="keyword">bool</span> suc = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph::bel[i] == graph::bel[match[i]]) suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> con[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ext[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> N, S, B = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">trans</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret; ret.resize(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) ret[p[i] - <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ask</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123; <span class="keyword">return</span> query (trans (p)); &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[<span class="number">11</span>], r, rkc, rkd, rk;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qq[<span class="number">11</span>], qr, f1, f2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> cnt1[MAXN]= &#123;<span class="number">0</span>&#125;, cnt2[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">net::init (), net::n = N, net::N = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line">net::S = <span class="number">2</span> * N + <span class="number">1</span>, net::T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (ext[i][j]) net::addedge (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) net::addedge (net::S, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) net::addedge (i + N, net::T, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis1[MAXN], vis2[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rand () % B + <span class="number">1</span>; rkc.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) <span class="keyword">if</span> (! con[i + <span class="number">1</span>]) rkc.push_back(i);</span><br><span class="line">random_shuffle (rkc.begin(), rkc.end());</span><br><span class="line">rkd.clear(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) <span class="keyword">if</span> (con[i + <span class="number">1</span>]) rkd.push_back(i);</span><br><span class="line">random_shuffle (rkd.begin(), rkd.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) rkd.size(); i ++) rkc.push_back(rkd[i]);</span><br><span class="line">rk.clear(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) rk.push_back(rkc[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S; i ++) swap (rk[i], rk[rand () % i]);</span><br><span class="line">r.resize(N); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) r[i] = q[p][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) r[rkc[i]] = q[p][rk[i]]; qr = ask (r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cnt1[i] = cnt2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cnt1[qq[p][i]] ++, cnt2[qr[i]] ++;</span><br><span class="line">f1.clear(), f2.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (cnt1[i] &gt; cnt2[i]) f1.push_back(i), cnt1[i] --;</span><br><span class="line"><span class="keyword">while</span> (cnt1[i] &lt; cnt2[i]) f2.push_back(i), cnt1[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) f1.size() != S || (<span class="keyword">int</span>) f2.size() != S) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x1 = q[p][rkc[i]], x2 = r[rkc[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) vis1[i] = vis2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x1 - f1[j] &gt;= <span class="number">1</span>) vis1[x1 - f1[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x1 + f1[j] &lt;= N) vis1[x1 + f1[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x2 - f2[j] &gt;= <span class="number">1</span>) vis2[x2 - f2[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x2 + f2[j] &lt;= N) vis2[x2 + f2[j]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (! vis1[j] || ! vis2[j]) ext[rkc[i] + <span class="number">1</span>][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">build (); <span class="keyword">int</span> flow = net::maxflow ();</span><br><span class="line"><span class="keyword">if</span> (flow &lt; N) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (! net::check ()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[net::match[i] - N - <span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">guess</span> <span class="params">(<span class="keyword">int</span> pn)</span></span>&#123;</span><br><span class="line">N = pn;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret.push_back(i);</span><br><span class="line"><span class="keyword">while</span> (query (ret).back()) next_permutation (ret.begin(), ret.end());</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">srand (time (<span class="literal">NULL</span>));</span><br><span class="line">S = <span class="built_in">sqrt</span> (N) / <span class="number">2</span>; S = max (S, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) q[i].push_back(j);</span><br><span class="line">random_shuffle(q[i].begin(), q[i].end());</span><br><span class="line">qq[i] = ask (q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">ext[i][j] = <span class="literal">true</span>;</span><br><span class="line">ret.resize(N); <span class="keyword">while</span> (! work ());</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ grader.cpp perm.cpp -o perm -O2 -std=c++11</span></span><br></pre></td></tr></table></figure><h2 id="Problem-C：塔"><a href="#Problem-C：塔" class="headerlink" title="Problem C：塔"></a>Problem C：塔</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训 </tag>
            
            <tag> OEIS </tag>
            
            <tag> 交互题 </tag>
            
            <tag> 随机化 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十五）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>$\text{score：0 + 0 + 0 = 0            rk：32/39}$</p><h2 id="Problem-A：最短路"><a href="#Problem-A：最短路" class="headerlink" title="Problem A：最短路"></a>Problem A：最短路</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/uskNSrKd29XJQVq.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/FSp9RLq7WQkXEou.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>该路径一定是从 $1$ 走到 $n$ 后，在从 $n$ 返回 $1$ 时在外围走一遭，再回到 $1 \rightarrow n$ 的路径走一段，再出去向 $1$ 走一段。。</p><p>设往外围走时的起点为 $a$ 类点，回到 $1 \rightarrow n$ 路径的点为 $b$ 类点，容易知道 $a$ 和 $b$ 交错出现才可能最优，那么整个图大概就这么个样（起点和终点不作标记）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/29/1OtoEkzY6W78NwX.png" alt=""></p><p>令 $f_{i, j}$ 表示从 $1$ 走到 $i$，最后一个点为 $i$，为 $a$ 类点，倒数第二个点为 $j$，为 $b$ 类点</p><p>令 $g_{i, j}$ 表示从 $1$ 走到 $i$，最后一个点为 $i$，$i, j$  都为 $b$ 类点</p><p>实际上 $f$ 可以直接转移，不需要 $g$，但这样复杂度时 $O (n^4)$ 的，故 $g$ 相当于辅助函数</p><p>用类似 $Dijkstra$ 的形式转移，设 $i$ 到 $j$ 的最短路径为 $d_{i, j}$（即使路径上所有点的权值和最小，包括 $i, j$）</p><p>假设此时取出 $f_{x, y}$ 则有<br>$$<br>g_{k, y} = \min\{f_{x, y} + d_{x, k} - p_x\}<br>$$<br>即多出一个 $a$ 类点 $x$ 到 $b$ 类点 $k$ 的路径</p><p>假设此时取出 $g_{x, y}$，则有<br>$$<br>f_{k, x} = \min \{g_{x, y} + d_{x, k} + d_{k, y} - p_x - p_y - p_k\}<br>$$<br>直接用堆维护是 $O (n^3 \log n)$ 的，但观察一下发现在 $j$ 相同时，每次可以枚举取最小值，故最终复杂度 $O (n^3)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, d[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">2</span>][MAXN][MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val, x, y;</span><br><span class="line">node (<span class="keyword">int</span> val = <span class="number">0</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : val (val), x (x), y (y) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node maxf[MAXN], maxg[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getm</span> <span class="params">(node&amp; a, node b)</span> </span>&#123; <span class="keyword">if</span> (b.val &lt; a.val) a = b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workf</span> <span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">maxf[j] = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! visit[<span class="number">0</span>][i][j])</span><br><span class="line">getm (maxf[j], node (f[i][j], i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workg</span> <span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">maxg[j] = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! visit[<span class="number">1</span>][i][j])</span><br><span class="line">getm (maxg[j], node (g[i][j], i, j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (d, INF, <span class="keyword">sizeof</span> (d));</span><br><span class="line"><span class="built_in">memset</span> (f, INF, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="built_in">memset</span> (g, INF, <span class="keyword">sizeof</span> (g));</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123; a[i] = getnum (); d[i][i] = a[i]; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">d[u][v] = a[u] + a[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">d[i][j] = min (d[i][j], d[i][k] + d[k][j] - a[k]);</span><br><span class="line"><span class="keyword">if</span> (d[<span class="number">1</span>][N] &gt;= INF || d[N][<span class="number">1</span>] &gt;= INF) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>]; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) workf (i), workg (i);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">node mf, mg; mf = mg = node (INF, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) getm (mf, maxf[i]), getm (mg, maxg[i]);</span><br><span class="line"><span class="keyword">int</span> type = mf.val &lt;= mg.val ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">getm (mf, mg);</span><br><span class="line"><span class="keyword">if</span> (mf.val &gt;= INF) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> x = mf.x, y = mf.y;</span><br><span class="line"><span class="keyword">if</span> (type) &#123;</span><br><span class="line">visit[<span class="number">1</span>][x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (k != y)</span><br><span class="line">f[k][x] = min (f[k][x], g[x][y] + d[x][k] + d[k][y] - a[x] - a[y] - a[k]);</span><br><span class="line">workf (x), workg (y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">visit[<span class="number">0</span>][x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line">g[k][y] = min (g[k][y], f[x][y] + d[x][k] - a[x]);</span><br><span class="line">workf (y), workg (y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N][N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训 </tag>
            
            <tag> 最短路DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>初来乍到，4h20min的题我打了2h，成功垫底，恭喜我自己</p><p>$\text{score：20 + 0 + 0 = 20   rk：26/27}$</p><h2 id="Problen-A"><a href="#Problen-A" class="headerlink" title="Problen A"></a>Problen A</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="http://xsy.gdgzez.com.cn/JudgeOnline/upload/attachment/image/20200701/20200701213322_88297.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看他们都会写。。这种比较复杂的容斥我几乎都没写过。。</p><h4 id="前置知识：高维前缀和"><a href="#前置知识：高维前缀和" class="headerlink" title="前置知识：高维前缀和"></a>前置知识：高维前缀和</h4><p>举个例子，对比如现在要求解 $\sum\limits_{s = 0}^{2^n - 1}\sum\limits_{j \in s} a_j$（此处 $\in$ 是二进制表示下的意义），直接枚举子集是 $O (3^n)$ 的，那么高维前缀和可以优化到 $O (n2^n)$</p><p>考虑低位前缀和，比如三位，我们是不是可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i - <span class="number">1</span>][j][k]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i][j - <span class="number">1</span>][k]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">            a[i][j][k] += a[i][j][k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>就是对每一维分别求前缀和，那么高维前缀和也是这个思想，即 $f_{s \oplus (1 &lt;&lt; j)} \rightarrow f_s$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= limit; s ++)</span><br><span class="line">        <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">            f[s] += f[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))];</span><br></pre></td></tr></table></figure><h4 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h4><p>令 $|s|$ 表示 $s$ 的二进制表示下 $1$ 的个数</p><p>设 $g_s$ 表示构成最终状态 $s$ 的方案数，$f_s$ 表示状态 $s$ 二进制表示中的为 $0$ 位的卡片<strong>至少</strong>不存在于最终收藏的方案数，那么容斥一下有<br>$$<br>g_s = \sum\limits_{j \in s} f_j \times (-1)^{|s - j|}（根据多出来的 0 的个数进行容斥）<br>$$<br>那么现在考虑求 $f_s$</p><p>先考虑暴力计算，枚举 $s$，将每一轮满足相位置是零的组合的概率加起来为 $sum_i$，最后则有 $f_s = \prod sum_i$，这样显然会 $T$</p><p>对每一轮，可能满足的组合的组合共有 $2^k$ 种，现在考虑这 $2^k$ 种可能性分别都贡献到哪儿了</p><p>设对于当前取 $2^k$ 种状态中的一种所表示出的二进制状态为 $s$，该种组合的组合对应的卡片集合 $card_s$，概率和 $p_s$，那么很明显它可以贡献到的就是 $card_s$ 的超集，当然由于它子集也会贡献到那些超集，故还需容斥掉，设它使超集需要乘上数 $L_{card_s}$<br>$$<br>L_{card_s} = \prod\limits_{j \in s} p_j^{(- 1)^{|s - j|}}<br>$$<br>之后就可以通过计算子集给 $f_s$ 的贡献直接求出 $f_s$ 了</p><p>需要注意的是，当 $j$ 取空集的时候，$p_j = 0$，而 $p_j$ 又有可能被作为除数，故此时需要开一个数组计算到此为止究竟乘和除以了多少个零，若最终乘的次数多，则直接将 $f_s$ 赋零</p><p>最后一遍容斥求出 $g_s$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> KTRS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="keyword">int</span> mp[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXK], p[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> suma[KTRS]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sump[KTRS]= &#123;<span class="number">0</span>&#125;, undp[KTRS]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> zocnt[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL f[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL g[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; i ++) mp[i] = mp[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i ++) pcnt[i] = pcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i ++) f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> K = getnum (), d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line">a[j] = getnum (), p[j] = getnum ();</span><br><span class="line">d += p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> poe = power (<span class="number">1l</span>l * d, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) p[j] = <span class="number">1l</span>l * p[j] * poe % MOD;</span><br><span class="line"><span class="keyword">int</span> lik = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>;</span><br><span class="line">sump[<span class="number">0</span>] = undp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lik; j ++) &#123;</span><br><span class="line">suma[j] = suma[j ^ lowbit (j)] | a[mp[lowbit (j)]];</span><br><span class="line">sump[j] = (sump[j ^ lowbit (j)] + p[mp[lowbit (j)]]) % MOD;</span><br><span class="line">undp[j] = power (sump[j], MOD - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">sump[<span class="number">0</span>] = undp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= lik; k ++)</span><br><span class="line"><span class="keyword">if</span> (k &amp; l) &#123;</span><br><span class="line">sump[k] = sump[k] * undp[k ^ l] % MOD;</span><br><span class="line">undp[k] = undp[k] * sump[k ^ l] % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">zocnt[<span class="number">0</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lik; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pcnt[j] &amp; <span class="number">1</span>) zocnt[suma[j]] --;</span><br><span class="line"><span class="keyword">else</span> zocnt[suma[j]] ++;</span><br><span class="line">f[suma[j]] = f[suma[j]] * sump[j] % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++)</span><br><span class="line"><span class="keyword">if</span> (j &amp; l) &#123;</span><br><span class="line">f[j] = f[j] * f[j ^ l] % MOD;</span><br><span class="line">zocnt[j] += zocnt[j ^ l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (zocnt[i] &gt; <span class="number">0</span>) g[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> g[i] = f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++)</span><br><span class="line"><span class="keyword">if</span> (j &amp; l) g[j] = (g[j] - g[j ^ l] + MOD) % MOD; <span class="comment">// 注意这里使容斥，某个g[j]被减两次则变成加</span></span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lim; j ++) ans ^= g[j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 个点 $m$ 条边的连通无向图，边上有边权，求该无向图的最小直径生成树，其具有最小的直径</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 500, ~ n - 1 \le m \le \frac{n(n - 1)}{2}, ~ 1 \le 边权 \le 10^9$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这玩意儿好像和求什么图的绝对中心是一样的，图的绝对中心就是指一个中心，到最远的点路径最短</p><p>那就通过图的绝对中心来求解这道题</p><p>假设改图的绝对中心为点 $p$，那么它可以是某条边的端点也可以在某条边上</p><p>首先有一个结论</p><blockquote><p>距离 $p$ 最远的点至少有两个点 $u, v$，并且它们到 $p$ 的距离相等</p></blockquote><p>这条结论很容易证明，若 $dis (u, p) \ne dis (v, p)$，那么将点 $p$ 往较远的那个端点稍微移动一下即可得到更优的答案此时假定 $p$ 在边 $(u, v)$ 上，$(u, v)$ 长 $L$，$p$ 距离点 $u$ 为 $x$，那么任意一点 $s$ 到 $p$ 的距离即为 $\min(dis (s, u) + x, dis (s, v) + L - x)$</p><p>可以发现，这个距离以函数形式表示出来是一条折线（上升部分斜率为 $1$，下降部分 $- 1$）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/13/Fn3jhbO9fVvUz2B.jpg" alt=""></p><p>（图源来自论文《Play with Trees Solutions》）</p><p>然后你就可以搞出 $n$ 条折线，其中横坐标对应每一种 $x$ 的取值，所以同一 $x$ 坐标对应同一个中心</p><p>而要求的是所有距离中的最大值，这对应实线部分</p><p>你又要保证最大的最小，故只需在实现部分取最小即为答案，通过图像可以看出，该最小值点一定为某两条折线的交点</p><p>那么就可以枚举所有点对 $(u, v)$，并按 $dis_{u, s}$ 进行排序，用扫描的做法求解了</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rnk[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">f[i][j] = f[j][i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">f[u][v] = f[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">f[i][j] = min (f[i][j], f[i][k] + f[k][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) rnk[i][j] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (f[i][rnk[i][j]] &gt; f[i][rnk[i][k]])</span><br><span class="line">swap (rnk[i][j], rnk[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">LL ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; u ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N; v ++) &#123;</span><br><span class="line">ans = min (ans, f[u][rnk[u][N]] &lt;&lt; <span class="number">1</span>); <span class="comment">// 中心取端点处</span></span><br><span class="line">ans = min (ans, f[v][rnk[v][N]] &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> k = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (f[v][rnk[u][i]] &gt; f[v][rnk[u][k]]) &#123; <span class="comment">// 判断两折线是否有交</span></span><br><span class="line">ans = min (ans, f[u][rnk[u][i]] + f[u][v] + f[v][rnk[u][k]]);</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 集训 </tag>
            
            <tag> 生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十四）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>成功由垫底转至中下水平。。</p><p>恭喜。。我？</p><p>$\text{score：55 + 0 + 0 = 55   rk：21/33}$</p><h2 id="Problem-A：猜想"><a href="#Problem-A：猜想" class="headerlink" title="Problem A：猜想"></a>Problem A：猜想</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/11/lzHy4UCcSLXmiVD.png" alt=""></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，记 $l$ 表示 $n$ 的长度，则 $1 \le l \le 2 \times 10^5$，保证 $n$ 的最高位为 $1$，且除此之外的 $l - 1$ 位使用 $\text{std::mt19937}$ 随机生成</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考场上敲了个 $55$ 分的暴力，本来想说看能不能枚举每一位然后直接算它的状态，然后不行</p><p>出题人提供的题解没看懂，就看了看其他 $A$ 掉的人的思路</p><p>首先考虑分块，使分出的块尽量大，取块大小 $L = 24$，对每一块分别处理</p><p>处理当前块时先不考虑右移删 $0$ 的情况，先只考虑乘三加一的情况，最后只要在答案上加上二进制位总数即可</p><p>设第 $i$ 块储存的数为 $a_i$</p><p>类似线段树处理乘法时的操作，记两个变量 $mul, add$ 记录总共乘了多少，总共进位多少，那么转移到 $a_j$ 时则有 $a_j = mul * a_j + add$，以此类推</p><p>细节就看代码吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">24</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;, bn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lowbit</span> <span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i ++) &#123;</span><br><span class="line">LL mul = <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a[i]) &#123;</span><br><span class="line">mul *= <span class="number">3</span>, add *= <span class="number">3</span>;</span><br><span class="line">a[i] = a[i] * <span class="number">3</span> + lowbit (a[i]); <span class="comment">// 此处由于没删0故加上的是lowbit</span></span><br><span class="line">add += a[i] &gt;&gt; L; a[i] &amp;= (<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>; <span class="comment">// 保持a[i]只有L位，同时计算进位add</span></span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= bn; j ++) &#123;</span><br><span class="line">a[j] = a[j] * mul + add;</span><br><span class="line">add = a[j] &gt;&gt; L; a[j] &amp;= (<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (add) &#123; a[++ bn] = add &amp; ((<span class="number">1</span> &lt;&lt; L) - <span class="number">1</span>); add &gt;&gt;= L; &#125;</span><br><span class="line">ans += L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a[bn] ^ <span class="number">1</span>) &#123;</span><br><span class="line">a[bn] = a[bn] &amp; <span class="number">1</span> ? a[bn] * <span class="number">3</span> + <span class="number">1</span> : a[bn] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">N = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span> &amp;&amp; str[<span class="number">1</span>] == <span class="string">'1'</span>) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">reverse (str + <span class="number">1</span>, str + N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! ((i - <span class="number">1</span>) % L)) bn ++;</span><br><span class="line">a[bn] |= (str[i] - <span class="string">'0'</span>) &lt;&lt; ((i - <span class="number">1</span>) % L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：覆盖"><a href="#Problem-B：覆盖" class="headerlink" title="Problem B：覆盖"></a>Problem B：覆盖</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/02/LuFUy4JASC3b1VZ.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/02/fe1ZOXTEyudg6m7.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>连神仙都说神仙的神仙题</p><p>设 $S_i$ 表示点 $i$ 连接的点的集合</p><p>从小问题开始思考，考虑点 $1, 2$，若有 $S_1 - \{2\} \neq S_2 - \{1\}$，那么交换节点 $1, 2$ 的标号得到一张新无向图，可以发现它们的最小点覆盖一定是相同的，那么它们的贡献和在 $\text{mod} ~~ 2$ 的情况下一定是 $0$，也就是说，对答案有贡献的无向图一定满足 $\forall u, v, S_u - \{v\} = S_v - \{u\}$</p><p>接下来考虑 $S_1 - \{2\} = S_2 - \{1\}$ 的情况，分类讨论</p><ul><li>若存在边 $(1, 2)$，则说明 $1, 2$ 中必须存在至少一个点加入覆盖点，否则边 $(1, 2)$ 就一定不会被覆盖到，不妨强制标号小的那个加入覆盖点，再删去所有与之相连的边，那么局面就变成了 $n’ = n - 1, k’ = k - 1$ 继续搞最小点覆盖</li><li>若不存在边 $(1, 2)$，那么可以选择 $S_1$ 中所有点加入覆盖点或 $1, 2$ 同时加入覆盖点，也就是说它们同时加入或不加入覆盖点，则它们可以合并成一个大点，并删去重复的边</li></ul><p>很容易发现，每次合并的两个点实际具有的节点数目一定是相同的</p><p>暴力计算则需要枚举 $S_1, S_2$ 等，但实际上在合并 $1, 2$ 后，$S_1$ 是不会发生变化的，也就是说枚举 $S_1$ 是在后面过程完成的，在不断合并、消去点的过程中，最终我们一定可以得到图，使之满足条件，所以就不需要所谓枚举 $S_1$ 这样的步骤了</p><p>为了方便计算，不妨假定每次合并，选择由具有相同节点数目，且该数目最小的两个点，并且这个数目一定是 $2$ 的幂次，设当前找到的这两个点具有 $2^t$ 个节点，可以发现任意具有 $2^d (d &lt; t)$ 个节点的点一定最多只有一个，且不存在具有 $2^{t + 2}$ 个节点的点，因为此时最多只会合并到 $2^{t + 1}$</p><p>那么设 $f_{n, k, t}$ 表示剩余节点数 $n$（即没加入覆盖点的剩余点的个数），还可以加入 $k$ 个覆盖点，$t$ 的意义如上所述</p><p>很明显在知道了 $n$ 之后我们就可以知道此时每种具有不同节点数的点的个数，此时有 $tot = n &gt;&gt; t$ 个由 $2^t$ 个节点组成的点，枚举在 $tot$ 中选择多少个进行留下、消失、合并的操作</p><p>设有 $r (r \in \{0, 1\})$ 个点留下，$m (0 \le m \le \frac{tot}2)$ <strong>对</strong>点合并，那么可以计算出有 $d = tot - 2 * m - r$ 个点消失，计算方案数，即要在 $m + d$ 个位置中选择 $d$ 个位置消失，即方案数为 $\dbinom{m + d}d$，但实际上这是错误的，因为</p><p>若 $r = 0$ 则必须强制要求最后一组点必须合并，假如一个都不剩且最后是消失的话，那就相当于在操作前最后是只有一个点的，而这唯一的最后一个点在不与其它点组合的情况下它独自消失是没有意义的，这种情况实际上应该是被 $r = 1$ 时计算到的，故若 $r = 0$ 则须强制令最后一个操作是合并，故方案数应为 $\dbinom{m + d - [rem = 0]}d$</p><p>记忆化一下即可，递归到最后 $n$ 不足以或恰只能提供 $2^t$ 个节点时，若该状态产生贡献则其必须满足 $n \neq k \cap lowbit(n) = k$，这是因为最后剩下若干个点，发现只有最小点覆盖为最小点的时候答案才是奇数，若此时最小点覆盖大于一，则覆盖点之间可以任意连边，则答案会是 $2$ 的幂次；若不是最小点，比这个点小的点可以选择连或不连这个点，则答案亦是 $2$ 的幂次</p><p>时间复杂度 $O (n^2\log^2n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (! k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((n &gt;&gt; t) &lt;= <span class="number">1</span>) <span class="keyword">return</span> n != k &amp;&amp; lowbit (n) == k;</span><br><span class="line"><span class="keyword">if</span> (~ f[n][k][t]) <span class="keyword">return</span> f[n][k][t];</span><br><span class="line">f[n][k][t] = <span class="number">0</span>; <span class="keyword">int</span> lim = n &gt;&gt; (t + <span class="number">1</span>), tot = n &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mer = <span class="number">0</span>; mer &lt;= lim; mer ++) <span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> rem = <span class="number">0</span>; rem &lt;= <span class="number">1</span>; rem ++) &#123; <span class="comment">// 留下</span></span><br><span class="line"><span class="keyword">int</span> des = tot - mer * <span class="number">2</span> - rem; <span class="comment">// 消失</span></span><br><span class="line"><span class="keyword">if</span> (des &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> c1 = mer + des - (! rem), c2 = des;</span><br><span class="line"><span class="keyword">if</span> ((c1 &amp; c2) == c2) f[n][k][t] ^= dp (n - (des &lt;&lt; t), k - (des &lt;&lt; t), t + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 对组合数 C (n, m) 若满足 (n &amp; m) == m 则说明 C (n, m) 是奇数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][k][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (f, - <span class="number">1</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = getnum (), k = getnum ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, dp (n, k, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 分块 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十六）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天是几场下来第一次完整搞出一道题</p><p>虽然跑的贼慢，方法不够优，比 $\text{std}$ 慢 $200ms$。。</p><p>$\text{score：0 + 100 + 0 = 100   rk：16/32}$</p><h2 id="Problem-A：Geometric-Progressions"><a href="#Problem-A：Geometric-Progressions" class="headerlink" title="Problem A：Geometric Progressions"></a>Problem A：Geometric Progressions</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>首项为 $a$ 且公比为 $b$ 的等比数列是一个形如 $a, ab, ab^2, ab^3, …$ 的数字序列</p><p>你被给定了 $n$ 个整数等比数列。你的任务是找出最小的整数 $x$，使得它是所有给定的序列的元素，或者声明这样的整数不存在</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 100, ~ 1 \le a, b \le 10^9$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://codeforces.com/problemset/problem/571/E" target="_blank" rel="noopener">CF571E</a></p><p>首先将所有 $a, b$ 分解质因数，得到大小为 $m$ 质因数集 $\{p_1, p_2, …, p_m\}$</p><p>设 $c_{i, j}$ 表示 $a_i$ 分解质因数后 $p_j$ 的幂次，$d_{i, j}$ 表示 $b_i$ 分解质因数后 $p_j$ 的幂次，那么答案即可被表示为 $\prod\limits_{i = 1}^m p_i^{c_{1, i} + k \times d_{1, i}}$，其中 $k \in N$</p><p>考虑每次将两对 $a, b$ 合并，设之前合并得到的 $a, b$ 分解质因数后的质因数幂次数组 $A, B$，其中 $A_i$ 表示第 $i$ 个质因数的幂次，再设准备与之合并的 $a, b$ 的质因数幂次数组 $C, D$</p><p>那么现在分为仅有一解、有无数解、无解三种情况</p><p>对 $A, B$ 单独考虑，设答案 $p_i$ 幂次 $t_i$，则有<br>$$<br>\left\{<br>    \begin{aligned}<br>        t_i &amp;= A_i + k \times B_i \\<br>        t_j &amp;= A_j + k \times B_j<br>    \end{aligned}<br>\right. \\<br>\Rightarrow<br>t_i = A_i + \frac{B_i}{B_j}(t_j - A_j)<br>$$<br>也就是说 $t_j$ 和 $t_i$ 的关系是一条斜率为 $\frac{B_i}{B_j}$ 的直线</p><p>同理对 $C, D$，有 $t_i = C_i + \frac{D_i}{D_j}(t_j - C_j)$</p><p>那么仅有一解的条件即为它们之间有交点，即 $\frac{B_i}{B_j} = \frac{D_i}{D_j}$，这种情况直接解出来就好了</p><p>那么考虑剩下的情况，$t_i = A_i + k_1 \times B_i = C_i + k_2 \times D_i$ 可以转化成 $k_2 \times D_i - k_1 \times B_i = A_i - C_i$，然后用 $ExGCD$ 求解，注意由于它们 $k_1, k_2$ 都相同，所以要满足每组方程是否满足比例关系，不满足则无解，其实我觉得上面那个 $\frac{B_i}{B_j} \ne \frac{D_i}{D_j}$ 则只有一解也应该可以用这个来理解，然后就相当于解一个二元一次方程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">900</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e04</span>;</span><br><span class="line"><span class="keyword">int</span> oa[MAXN], ob[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">GCD</span> <span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> ! b ? a : GCD (b, a % b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGCD</span> <span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line">exGCD (b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM]= &#123;<span class="number">0</span>&#125;, pn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separ</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (x % i)) &#123;</span><br><span class="line">prime[++ pn] = i;</span><br><span class="line"><span class="keyword">while</span> (! (x % i)) x /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) prime[++ pn] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pcnt[<span class="number">2</span>][MAXN][MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cencus</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> id, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (x % prime[i])) &#123;</span><br><span class="line"><span class="keyword">while</span> (! (x % prime[i])) &#123;</span><br><span class="line">x /= prime[i];</span><br><span class="line">pcnt[p][id][i] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a[MAXM], b[MAXM], c[MAXM], d[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL sb = <span class="number">0</span>, sd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) &#123; sb += b[i]; sd += d[i]; &#125;</span><br><span class="line"><span class="keyword">if</span> (! sb &amp;&amp; ! sd) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] != c[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! sb || ! sd) &#123;</span><br><span class="line"><span class="keyword">if</span> (! sd) &#123; swap (sb, sd); swap (a, c); swap (b, d); &#125;</span><br><span class="line">LL k = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (d[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[i] &gt; a[i] || (a[i] - c[i]) % d[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LL pk = (a[i] - c[i]) / d[i];</span><br><span class="line"><span class="keyword">if</span> (k != - <span class="number">1</span> &amp;&amp; pk != k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">k = pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (sb * d[i] != sd * b[i])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= pn) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= pn; j ++)</span><br><span class="line"><span class="keyword">if</span> (b[i] * d[j] != d[i] * b[j]) <span class="comment">// 只有一个解</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">LL ka = d[j] * (c[i] - a[i]) - d[i] * (c[j] - a[j]);</span><br><span class="line">LL kb = b[j] * (c[i] - a[i]) - b[i] * (c[j] - a[j]);</span><br><span class="line">LL down = d[j] * b[i] - d[i] * b[j];</span><br><span class="line"><span class="keyword">if</span> (down &lt; <span class="number">0</span>) ka = - ka, kb = - kb, down = - down;</span><br><span class="line"><span class="keyword">if</span> (ka &lt; <span class="number">0</span> || kb &lt; <span class="number">0</span> || ka % down || kb % down) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ka /= down, kb /= down;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= pn; k ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[k] + ka * b[k] != c[k] + kb * d[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">a[k] = a[k] + ka * b[k], b[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ExGCD合并</span></span><br><span class="line">LL rb = <span class="number">0</span>, rd = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (b[i]) &#123;</span><br><span class="line">LL g = GCD (b[i], d[i]);</span><br><span class="line">rb = b[i] / g, rd = d[i] / g;</span><br><span class="line"><span class="keyword">if</span> ((a[i] - c[i]) % g) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">r = (a[i] - c[i]) / g;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line"><span class="keyword">if</span> (r * (b[i] / rb) != a[i] - c[i]) <span class="comment">// 判断是否成比例</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>) swap (a, c), swap (b, d), swap (rb, rd), r = - r;</span><br><span class="line">LL ka, kb;</span><br><span class="line">exGCD (rb, rd, ka, kb);</span><br><span class="line">ka = (ka * (- r) % rd + rd) % rd;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++)</span><br><span class="line">a[i] += ka * b[i], b[i] *= rd;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) oa[i] = getnum (), ob[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) separ (oa[i]), separ (ob[i]);</span><br><span class="line">sort (prime + <span class="number">1</span>, prime + pn + <span class="number">1</span>);</span><br><span class="line">pn = unique (prime + <span class="number">1</span>, prime + pn + <span class="number">1</span>) - prime - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cencus (<span class="number">0</span>, i, oa[i]), cencus (<span class="number">1</span>, i, ob[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) a[i] = pcnt[<span class="number">0</span>][<span class="number">1</span>][i], b[i] = pcnt[<span class="number">1</span>][<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pn; j ++) c[j] = pcnt[<span class="number">0</span>][i][j], d[j] = pcnt[<span class="number">1</span>][i][j];</span><br><span class="line"><span class="keyword">if</span> (! merge ()) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pn; i ++) ans = ans * power (prime[i], a[i]) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：Bichrome-Spanning-Tree"><a href="#Problem-B：Bichrome-Spanning-Tree" class="headerlink" title="Problem B：Bichrome Spanning Tree"></a>Problem B：Bichrome Spanning Tree</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们有一个 $n$ 个点 $m$ 条边的带权无向图。图中的第 $i$ 条边连接了节点 $u_i, v_i,$，权重为 $w_i$。另外，你还被给定了一个整数 $X$。</p><p>请求出将每条边染成黑色或白色，且满足下面的条件的方案数模 $10^9 + 7$ 的值</p><ul><li>图中存在一棵同时包含染成白色的边和染成黑色的边的生成树。另外，在所有这种生成树中，权重最小的一棵的权重恰为 $X$</li></ul><p>这里，一棵生成树的权重定义为生成树中边的权重的和</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 1000, ~ 1 \le m \le 2000, ~ 1 \le w_i \le 10^9, ~ 1 \le X \le 10^{12}$</p><p>给出的数据保证图联通，不存在重边，不存在自环</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://atcoder.jp/contests/arc093/tasks/arc093_c" target="_blank" rel="noopener">ARC093C</a></p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>先讲讲我的方法吧</p><p>显然对一棵权重 $&lt; X$ 的树，它所有的边的颜色都应该相同，那么我们考虑对每条边判断它会不会有这种限制</p><p>此时直接用 $Kruskal$ 求出包含该边的最小生成树，若其权重 $&lt; X$，则该边的染色就会被限制，称一类边；若其权重 $&gt; X$，则它属于染色情况不论如何都不会对答案造成贡献的边，称二类边；若其权重 $= X$，则需要着重考虑，称三类边</p><p>这里考虑两棵在相同的图上但边集完全无交集的最小生成树，它们一定可以构成一个新的最小生成树，该最小生成树的边集与原两棵树的边集分别有交，这个也很好证明，因为最小生成树一定是最小瓶颈生成树，即最大边最小，那么它们之间一定可以互相替换，从而构成一棵新的 $MST$，至于对那些权重 $&lt; X$ 的树，也拥有类似该定理，证明类比一下就好了</p><p>自此我们就可以认为所有二类边的颜色一定是相同的</p><p>设某条三类边 $E$，三类边的总数为 $m$</p><p>现在只需枚举 $E$ 来进行组合计数，强制令 $E$ 染色与一类边不同，则剩余 $m - 1$ 条边则可随意染色，为避免算重，枚举 $m - 1$ 条边中与 $E$ 染色相同的个数 $j$，则 $E$ 在枚举到 $j$ 加上的贡献即为 $\frac{C (m - 1, j)}{j + 1}$，记得最后乘二，但对不存在一类边的情况要特判一下</p><p>那么最后再设三类边个数 $ext$，将之前统计得到的答案乘上 $2^{ext}$ 即可</p><p>时间复杂度 $O \big(nm \times \alpha(n)\big)$</p><h4 id="代码（方法一）"><a href="#代码（方法一）" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL pow2[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125;;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, sze = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ sze].to = v;</span><br><span class="line">Link[sze].w = w;</span><br><span class="line">Link[sze].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = sze;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXM]= &#123;<span class="number">0</span>&#125;, invfact[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL inv[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL X;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">Edge (<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u (u), v (v), w (w) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; p.w; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Edge edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find (fa[x]); &#125;</span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = edge[i].u, y = edge[i].v, w = edge[i].w;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">fa[fx] = fy; ret += w;</span><br><span class="line">Insert (x, y, w), Insert (y, x, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> white[MAXM]= &#123;<span class="number">0</span>&#125;, black[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> wn = <span class="number">0</span>, bn = <span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">cencus</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= bn; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> i = black[q];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123; fa[j] = j; Head[j] = <span class="number">0</span>; &#125;</span><br><span class="line">sze = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].u, v = edge[i].v, w = edge[i].w;</span><br><span class="line">fa[u] = v;</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">Kruskal ();</span><br><span class="line">LL add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bn - <span class="number">1</span> - (! wn); j ++)</span><br><span class="line">add = (add + C (bn - <span class="number">1</span>, j) * inv[j + <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">ret = (ret + add) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wn) ret = <span class="number">2l</span>l * ret % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>; <span class="keyword">int</span> ext = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1l</span>l * edge[i].w &gt; X) &#123; ext ++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123; fa[j] = j; Head[j] = <span class="number">0</span>; &#125;</span><br><span class="line">sze = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].u, v = edge[i].v, w = edge[i].w;</span><br><span class="line">fa[u] = v;</span><br><span class="line">LL x = w + Kruskal ();</span><br><span class="line"><span class="keyword">if</span> (x &lt; X) white[++ wn] = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == X) black[++ bn] = i;</span><br><span class="line"><span class="keyword">else</span> ext ++;</span><br><span class="line">&#125;</span><br><span class="line">ans = cencus ();</span><br><span class="line">ans = ans * pow2[ext] % MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (); <span class="built_in">cin</span> &gt;&gt; X;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span>) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max (N, M); i ++) pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2l</span>l % MOD;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">inv[<span class="number">1</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">edge[i] = Edge (u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">sort (edge + <span class="number">1</span>, edge + M + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>题解的方法，我觉着挺妙</p><p>先随便取一个 $MST$ 设为 $T$，设其权重和 $w(T)$，显然只需考虑 $w(T) \le X$</p><p>对 $w(T) = X$，可以先加上让其内部不全部染相同色，剩余边随意染色，即贡献 $(2^{n - 1} - 2) \cdot 2^{m - n + 1}$</p><p>接下来考虑 $T$ 染色全部相同的情况，不妨设 $T$ 中边均为黑边</p><blockquote><p>每次替换一个不在 $T$ 中的白边到 $T$，则最多替换一次</p></blockquote><p>证明反向思考一下就行了，每次替换权重一定不会减少，那么假定现在替换了两个白边，但全图的黑白边 $MST$ 仍不包括你第二次替换的边，因为第二次替换出来的黑边此时就满足条件了</p><p>对每次替换，若替换第 $i$ 条边，则会增大 $cost(i) = w_i - \max\{w_j | (u_j, v_j) 在T中(u_i, v_i)两点间路径上\}$（题解表述）的贡献，因此一定选最小边替换</p><p>求 $cost(i)$ 跳个倍增就好了</p><p>那么最后将所有 $i$ 的 $cost(i)$ 排个序，设排序后某条边排在位置 $p$，则其对答案贡献 $2^{n + m - 1 - p}$（只有后面的边才能任意染色）</p><p>时间复杂度 $O (m \log n)$</p><h2 id="Problem-C：Network"><a href="#Problem-C：Network" class="headerlink" title="Problem C：Network"></a>Problem C：Network</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/19/ZTh8wvO5FAqHKG4.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/19/DAaFX5Gpq2vzY8g.png" alt=""></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先计算在不反转用户的情况下，所有用户的 $MS(u)$</p><p>考虑点分治，现在递归到分治中心 $p$，设 $p$ 子树点 $x$ 到 $p$ 的边的最小值和最大值 $(mi_x, ma_x)$，假设现在有服务器 $i$，用户 $j$，都是 $p$ 的子树结点，计算 $MS(j)$，考虑有哪几种情况会贡献到 $MS(j)$，即是 $ma_i - mi_x$、$ma_i - mi_j$、$ma_j - mi_i$，同时 $(mi_i, ma_i), (mi_j, ma_j)$ 之间不存在任何关系，那么也就是说只需求得 $p$ 子树中满足 $ma_i - mi_i$ 最大，或 $ma_i$ 最大、或 $mi_i$ 最大，即可更新其它所有的用户（当然要与 $i$ 不同子树），又考虑到同子树不能互相更新，所以还得记录上面三者的次大值，这样就可以求出所有 $MS(u)$</p><p>接下来计算反转用户的情况，最小值最大，考虑二分答案</p><p>设此时二分答案 $mid$，继续考虑点分治（实际上只需要看点分树就好了），设分治中心 $p$，设在两个子树的用户 $i, j$，若使 $check$ 失败则需要找到一对 $i, j$，反转 $i$，使得 $Waste (j, i) &lt; mid$</p><p>将 $p$ 所有储存下来的 $(mi_x, ma_x)$ 按 $mi_x$ 排序，则对 $mi_j \le mi_x$，欲使其失败则需满足 $ma_i - mi_j &lt; mid$，即 $ma_x &lt; mi_j + mid$，对 $mi_j &gt; mi_x$，欲使其失败则需满足 $mi_i &gt; \max(ma_i, ma_j) - mid$，当然已经排除了所有满足 $ma_x - mi_x \ge mid$（对第一种情况）或 $MS(x) \ge mid$（对两种情况）的点，然后和前面相同可以线性处理</p><p>时间复杂度 $O (n \log n \log V)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> type[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rt, minval = INF, fa;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grvy</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">grvy (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">maxpart = max (maxpart, subsize[v]);</span><br><span class="line">&#125;</span><br><span class="line">maxpart = max (maxpart, n - subsize[root]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; minval) &#123; rt = root; fa = father; minval = maxpart; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, id, bel;</span><br><span class="line"><span class="comment">// min value, max value, original index, 子树从属</span></span><br><span class="line">node (<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>, <span class="keyword">int</span> bel = <span class="number">0</span>) : l (l), r (r), id (id), bel (bel) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l == p.l) <span class="keyword">return</span> r &lt; p.r;</span><br><span class="line"><span class="keyword">return</span> l &lt; p.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> minv[MAXN], maxv[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> bel)</span> </span>&#123;</span><br><span class="line">a[rt].push_back(node (minv[root], maxv[root], root, bel));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">minv[v] = min (minv[root], w);</span><br><span class="line">maxv[v] = max (maxv[root], w);</span><br><span class="line">DFS (v, root, bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MS[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">minv[rt] = INF, maxv[rt] = <span class="number">0</span>;</span><br><span class="line">a[rt].push_back(node (minv[rt], maxv[rt], rt, rt));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[rt]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">minv[v] = min (minv[rt], w);</span><br><span class="line">maxv[v] = max (maxv[rt], w);</span><br><span class="line">DFS (v, rt, v);</span><br><span class="line">&#125;</span><br><span class="line">sort (a[rt].begin(), a[rt].end());</span><br><span class="line">pair&lt;int, int&gt;  fir (- INF, 0), sec (- INF, 0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">int</span> ms = x.r - x.l;</span><br><span class="line"><span class="keyword">if</span> (ms &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (ms, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ms &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (ms, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second) &#123;</span><br><span class="line">MS[x.id] = max (MS[x.id], x.r - x.l);</span><br><span class="line">MS[x.id] = max (MS[x.id], now.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (- INF, <span class="number">0</span>), sec = make_pair (- INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.r &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.r &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second? sec : fir;</span><br><span class="line"><span class="keyword">int</span> r = max (x.r, now.first);</span><br><span class="line"><span class="keyword">if</span> (now.second) MS[x.id] = max (MS[x.id], r - x.l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (INF, <span class="number">0</span>), sec = make_pair (INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (type[x.id]) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.l &lt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.l, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.l &lt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.l, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[rt].size(); i ++) &#123;</span><br><span class="line">node x = a[rt][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second? sec : fir;</span><br><span class="line"><span class="keyword">int</span> l = min (x.l, now.first);</span><br><span class="line"><span class="keyword">if</span> (now.second) MS[x.id] = max (MS[x.id], x.r - l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">minval = INF; grvy (n, x, <span class="number">0</span>);</span><br><span class="line">visit[rt] = <span class="literal">true</span>;</span><br><span class="line">work ();</span><br><span class="line">grvy (n, rt, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[rt]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">divide (subsize[v], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> fail[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">pair&lt;int, int&gt; fir (- INF, 0), sec (- INF, 0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) a[u].size(); i ++) &#123;</span><br><span class="line">node x = a[u][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second &amp;&amp; x.r &lt; now.first) fail[x.id] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (MS[x.id] &gt;= mid || x.r - x.l &gt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (x.l + mid &gt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.l + mid, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.l + mid &gt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.l + mid, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fir = make_pair (INF, <span class="number">0</span>), sec = make_pair (INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a[u].size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">node x = a[u][i];</span><br><span class="line"><span class="keyword">if</span> (! type[x.id]) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = x.bel == fir.second ? sec : fir;</span><br><span class="line"><span class="keyword">if</span> (now.second &amp;&amp; x.l &gt; max (x.r, now.first) - mid) fail[x.id] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (MS[x.id] &gt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (x.r &lt;= fir.first) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.bel != fir.second) sec = fir;</span><br><span class="line">fir = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.r &lt; sec.first &amp;&amp; x.bel != fir.second) sec = make_pair (x.r, x.bel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fail[i] = type[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) doit (i, mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! fail[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) type[i] = getnum ();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) sum += type[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= N - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == N) &#123; <span class="built_in">puts</span> (<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! type[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d 0\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxi = <span class="number">0</span>, mini = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">maxi = max (maxi, w); mini = min (mini, w);</span><br><span class="line">&#125;</span><br><span class="line">divide (N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = maxi - mini, ans;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (mid)) &#123; ans = mid; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">check (ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! fail[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, i, ans);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
            <tag> 集训 </tag>
            
            <tag> ExGCD </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十八）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日依旧三道集训队原题，无部分分，连续三次</p><p>真该问候搬题人他母亲大人</p><p>$\text{score：NULL   rk：NULL}$</p><h2 id="Problem-A：Sasha-And-Circles"><a href="#Problem-A：Sasha-And-Circles" class="headerlink" title="Problem A：Sasha And Circles"></a>Problem A：Sasha And Circles</h2><h2 id="Problem-B：Choosing-Ads"><a href="#Problem-B：Choosing-Ads" class="headerlink" title="Problem B：Choosing Ads"></a>Problem B：Choosing Ads</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的序列和一个整数 $p$。</p><p>有 $m$ 个操作，操作要么是区间赋值，要么是询问区间内出现次数至少占 $p\%$ 的数。</p><p>输出询问的答案时，可以包含错的数，也可以重复输出，但对的数一定要在答案中，且输出的数的个数不超过 $\lfloor \frac{100}p \rfloor$</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n, m \le 1.5 \times 10^5, ~ 20 \le p \le 100$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑 $p = 51$ 的情况，很明显就是求区间众数</p><p>有一个经典区间众数套路，给数字 $i$ 一个数组 $c_i$，设当前众数 $p$，每次加一个数字 $t$，若该数字等于 $p$，则 $c_p ++$，反之则 $c_p –$，若删前 $c_p = 0$，则 $p = t$，同时 $c_p = 1$</p><p>这样子虽然没有计算每种数字的出现次数，但保留了相对数字个数大小的关系，毕竟若一个数的出现概率 $&gt; 50\%$，则它必定会留到最后</p><p>那么现在考虑 $20 \le p \le 50$，则考虑存每个出现次数至少占 $p\%$ 的数，则它们最多 $5$ 个，在线段树上维护，每次加入一个数，若它与其中一个数相等则对应的数的 $c$ 加一，反之所有数的 $c$ 减一，然后用该数替代最终应当被替代的数，合并复杂度最多 $5 \times 5 = 25$，复杂度正确</p><p>复杂度 $O (nk^2 \log n)$，其中 $k = \lfloor \frac{100}p \rfloor$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q, P, m;</span><br><span class="line"><span class="keyword">int</span> ori[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>], cnt[<span class="number">6</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line"><span class="built_in">memset</span> (cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> = (<span class="keyword">const</span> node&amp; p) &#123;</span><br><span class="line">n = p.n;</span><br><span class="line"><span class="built_in">memcpy</span> (a, p.a, <span class="keyword">sizeof</span> (a));</span><br><span class="line"><span class="built_in">memcpy</span> (cnt, p.cnt, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">node ret = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">bool</span> in = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] == ret.a[j]) &#123;</span><br><span class="line">ret.cnt[j] += cnt[i];</span><br><span class="line">in = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (in) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ret.n &lt; m) &#123;</span><br><span class="line">ret.a[++ ret.n] = a[i];</span><br><span class="line">ret.cnt[ret.n] = cnt[i];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> || ret.cnt[j] &lt; ret.cnt[k])</span><br><span class="line">k = j;</span><br><span class="line"><span class="keyword">if</span> (ret.cnt[k] &gt; cnt[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++) ret.cnt[j] -= cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tp = ret.cnt[k];</span><br><span class="line">ret.a[k] = a[i]; ret.cnt[k] = cnt[i] - ret.cnt[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.n; j ++)</span><br><span class="line"><span class="keyword">if</span> (j != k)</span><br><span class="line">ret.cnt[j] -= tp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node T[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> lazy[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setup</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">T[root].a[T[root].n = <span class="number">1</span>] = x;</span><br><span class="line">T[root].cnt[<span class="number">1</span>] = right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">T[root].init ();</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">setup (root, left, right, ori[left]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid); build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">T[root] = T[lson] + T[rson];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! lazy[root]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">setup (lson, left, mid, lazy[root]);</span><br><span class="line">setup (rson, mid + <span class="number">1</span>, right, lazy[root]);</span><br><span class="line">lazy[lson] = lazy[rson] = lazy[root];</span><br><span class="line">lazy[root] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">setup (root, left, right, x);</span><br><span class="line">lazy[root] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown (root, left, right);</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R, x);</span><br><span class="line">T[root] = T[lson] + T[rson];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) <span class="keyword">return</span> T[root];</span><br><span class="line">pushdown (root, left, right);</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">node ret; ret.init ();</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) ret = ret + query (lson, left, mid, L, R);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) ret = ret + query (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), Q = getnum (), P = getnum (); m = <span class="number">100</span> / P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ori[i] = getnum ();</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= Q; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> type = getnum ();</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum (), id = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, r, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">node ans = query (<span class="number">1</span>, <span class="number">1</span>, N, l, r);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ans.n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans.n; i ++) <span class="built_in">printf</span> (<span class="string">" %d"</span>, ans.a[i]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：Distance-Sums"><a href="#Problem-C：Distance-Sums" class="headerlink" title="Problem C：Distance Sums"></a>Problem C：Distance Sums</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出 $n$ 个互不相同的数 $d_i$，表示树上的节点 $i$ 到其他所有点的距离和。</p><p>请判断是否存在这样一棵树，其中每条边的长度均为 $1$。若存在请输出一种方案，否则输出 <code>-1</code>。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^5, ~ 1 \le d_i \le 10^{12}$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题感觉是一直来做的比较水的。。</p><p>先给所有结点 $i$ 按 $d_i$ 排个序，将 $d$ 最小的看作根节点，那么显然子结点的 $d$ 比其祖先节点小</p><p>设结点 $u$ 子树大小 $s_u$，则考虑由 $u$ 走到其子结点 $v$ 时 $d$ 的增量，有 $\Delta d = n - 2s_v$</p><p>那么从排序后第 $n$ 个结点开始往上扫，每次将它与计算后与它相连的父结点连边，如若找不到父结点则无解</p><p>注意最后建完树要计算新建出的树的根节点的 $d$ 是否与输入所给相同</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">pair&lt;LL, <span class="keyword">int</span>&gt; d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;, fa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">1</span>; i --) &#123;</span><br><span class="line">subsize[d[i].second] ++;</span><br><span class="line"><span class="keyword">int</span> up = N - <span class="number">2</span> * subsize[d[i].second];</span><br><span class="line"><span class="keyword">if</span> (up &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="built_in">exit</span> (<span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">int</span> p = lower_bound (d + <span class="number">1</span>, d + N + <span class="number">1</span>, make_pair (d[i].first - up, <span class="number">0</span>)) - d;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= i || d[p].first != d[i].first - up) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="built_in">exit</span> (<span class="number">0</span>); &#125;</span><br><span class="line">fa[d[i].second] = d[p].second;</span><br><span class="line">subsize[d[p].second] += subsize[d[i].second];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line">LL dist[MAXN]= &#123;<span class="number">0</span>&#125;, total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">total += dist[root];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[root].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[root][i];</span><br><span class="line">dist[v] = dist[root] + <span class="number">1</span>;</span><br><span class="line">DFS (v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) d[i].first = getnum (), d[i].second = i;</span><br><span class="line">sort (d + <span class="number">1</span>, d + N + <span class="number">1</span>);</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) G[fa[d[i].second]].push_back(d[i].second);</span><br><span class="line">DFS (d[<span class="number">1</span>].second);</span><br><span class="line"><span class="keyword">if</span> (total != d[<span class="number">1</span>].first) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, fa[d[i].second], d[i].second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十五）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天有点人品，T1的50pts暴力怒压正解。。这数据。。不言而喻</p><p>$\text{score: 100 + 0 + 0 = 100   rk: 7/36}$</p><h2 id="Problem-A：时间管理带师"><a href="#Problem-A：时间管理带师" class="headerlink" title="Problem A：时间管理带师"></a>Problem A：时间管理带师</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>众所周知，罗老师是时间管理带师</p><p>因为罗老师是时间管理带师，所以他的时间是以东为单位的</p><p>具体来讲，罗老师一天有nn东的时间</p><p>现在有很多妹子想跟罗老师约会</p><p>奇特的，她们每天总会提出两段约会时间（可能相同，代表一种），并且每天提出的总是一样的。</p><p>她们提出的约会时间形式形如i,j,代表希望在[i东,(i+1)东)[i东,(i+1)东)或[j东,(j+1)东)[j东,(j+1)东)与罗老师进行约会。</p><p>当然，罗老师可以这两段时间都与这个妹子约会,只选择一段，或者伤心地抛弃。</p><p>那么，作为时间管理带师的罗老师，<strong>每天会选择尽可能多的妹子进行约会</strong></p><p>但你一定要注意,<strong>罗老师最近并不打算进行多人运动，所以他不会在1东的时间同时与两个或多个妹子约会</strong></p><p><strong>罗老师并不脸盲，与一个妹子约会2次并不能算成”2”次的贡献，只能是”1”</strong></p><p><strong>罗老师是时间管理带师，只要满足以上条件，他就可以安排好他的时间，不用担心别的</strong></p><p><strong>而且,每天可能会有新的妹子向罗老师提出约会邀请</strong></p><p><strong>但是时间久了，一些妹子认识到<del>罗老师是个渣男</del>罗老师太忙了，就不再给罗老师提出约会邀请</strong></p><p><strong>每天要么有妹子加入，要么有妹子退出，这两种情况有且仅会发生一种，并且退出的妹子一定是当前想要和罗老师约会的妹子中时间最久的。其实，这就对应了双端队列的push和pop。我们保证，罗老师每天的妹子数量非负</strong></p><p>现在，作为罗老师的贴身秘书，你每天要给罗老师规划好他的时间，每天告诉罗老师他今天最多可以约会多少个妹子</p><p>不过本题中，操作可以强制在线</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n, m \le 10^5, 0 \le type \le 1, 0 \le op, a, b \le 10^6$</p><p>其中 $a, b$ 表示妹子的约会时间为 $a, b$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这神奇的题目描述，真的时间管理带师</p><p>先考虑暴力，每次替换实际上就是一个类似匈牙利算法的东西，然后它只删队首的妹子，所以我们要尽可能让队首的妹子对答案无影响，所以每次队尾加入一个妹子的时候，如果判断出可以为她凑出一个额外的位置那就直接做，加入不行则替换掉其中最早入队的妹子（实际上这整个可以看成多棵内向基环树，即假如编号为 $i$ 的妹子占了一个位置，并且占的是约会时间 $a$，那么她就连一条 $a \rightarrow b$ 的有向边，并给这个边以入队顺序的编号，那么每一次类似匈牙利算法的过程即是这个图中的一条链，那么就取编号最小的边就行了），那么在删队首妹子的时候她就只有对答案无影响或者占了一个位置而使答案减一两种情况了</p><p>这个理论复杂度显然不能过，随便出个一条链的数据就卡掉了，但我还是稍微放一下它的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXA = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> A, M, type;</span><br><span class="line"><span class="keyword">int</span> ns = <span class="number">1</span>, ne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> posi[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> visit[MAXA]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> who[MAXA]= &#123;<span class="number">0</span>&#125;, use[MAXN]= &#123;<span class="number">0</span>&#125;, in[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">pair&lt;int, int&gt; findpos (int u) &#123; // pair&lt;int, int&gt; 分别表示找到的空座位与占位置的编号最小妹子</span><br><span class="line">    <span class="keyword">if</span> (visit[u]) <span class="keyword">return</span> make_pair (- <span class="number">1</span>, who[u]);</span><br><span class="line">    <span class="keyword">if</span> (! who[u]) <span class="keyword">return</span> make_pair (u, <span class="number">0</span>);</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = findpos (posi[who[u]][use[who[u]] ^ <span class="number">1</span>]);</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> make_pair (ret.first, min (ret.second, who[u]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == aim) &#123;</span><br><span class="line">        in[who[u]] = <span class="number">0</span>; who[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((suc = select (posi[who[u]][use[who[u]] ^ <span class="number">1</span>], aim))) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = who[u]; who[u] = <span class="number">0</span>;</span><br><span class="line">        use[p] ^= <span class="number">1</span>; in[p] = posi[p][use[p]];</span><br><span class="line">        who[in[p]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    use[p] = tp, in[p] = posi[p][tp];</span><br><span class="line">    who[in[p]] = p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A = getnum (), M = getnum (), type = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            op = getnum ();</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) a = getnum (), b = getnum ();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            op = (getnum () + ans) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) a = (getnum () + ans) % A + <span class="number">1</span>, b = (getnum () + ans) % A + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            posi[++ ne][<span class="number">0</span>] = a, posi[ne][<span class="number">1</span>] = b;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret1 = findpos (a), ret2;</span><br><span class="line">            <span class="keyword">if</span> (ret1.first == - <span class="number">1</span>) &#123;</span><br><span class="line">                ret2 = findpos (b);</span><br><span class="line">                <span class="keyword">if</span> (~ ret2.first) &#123;</span><br><span class="line">                    select (b, ret2.first); add (ne, <span class="number">1</span>);</span><br><span class="line">                    ans ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret1.second &lt; ret2.second) &#123;</span><br><span class="line">                    select (posi[ne][<span class="number">0</span>], in[ret1.second]);</span><br><span class="line">                    add (ne, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    select (posi[ne][<span class="number">1</span>], in[ret2.second]);</span><br><span class="line">                    add (ne, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; select (a, ret1.first); add (ne, <span class="number">0</span>), ans ++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[ns]) &#123;</span><br><span class="line">                ans --;</span><br><span class="line">                who[in[ns]] = <span class="number">0</span>; in[ns] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ns ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来就是正解，用 $\text{LCT}$ 来维护这个最小编号妹子</p><p>现在先考虑连边整出来的连通块，设该连通块有点 $x$ 个，边 $y$ 个，那么显然若 $x &gt; y$，则答案为 $x - 1$，若 $x \le y$，就代表有环，那么答案即为 $x$</p><p>现在考虑用 $\text{LCT}$ 来维护，首先把这个连通块里选择的节点抽成一棵树，并且边化点，那么剩下的边无法在 $\text{LCT}$ 中表示，但是只要存在其中一条就说明一定会构成环，所以我们只需统计每个点它会连多少这样的边即可</p><p>每次删 $\text{LCT}$ 中边的时候，删完边就给该边连接的两个点权值各加一，说明它们之间的边变成了使成环的边，那么就得更新答案；同理加边则把它们原来加上的权值减掉</p><p>感觉说不清楚具体还是看代码注释吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, type, n;</span><br><span class="line"><span class="keyword">int</span> posi[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// n: 边化点</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rev[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vimi[MAXN]= &#123;<span class="number">0</span>&#125;, fic[MAXN]= &#123;<span class="number">0</span>&#125;, vism[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 当前节点连的非树节点个数、当前节点虚子树vimi和、当前节点虚实子树vimi和</span></span><br><span class="line"><span class="keyword">int</span> mini[MAXN]= &#123;<span class="number">0</span>&#125;; <span class="comment">// 最早入队边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! p) <span class="keyword">return</span> ;</span><br><span class="line">swap (son[p][<span class="number">0</span>], son[p][<span class="number">1</span>]); rev[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">vism[p] = vimi[p] + fic[p] + vism[son[p][<span class="number">0</span>]] + vism[son[p][<span class="number">1</span>]];</span><br><span class="line">mini[p] = min (p &lt;= N ? INF : p, min (mini[son[p][<span class="number">0</span>]], mini[son[p][<span class="number">1</span>]]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! rev[p]) <span class="keyword">return</span> ;</span><br><span class="line">reverse (son[p][<span class="number">0</span>]), reverse (son[p][<span class="number">1</span>]);</span><br><span class="line">rev[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line"><span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (son[fa][s]) father[son[fa][s]] = fa;</span><br><span class="line"><span class="keyword">if</span> (! isroot (fa)) son[anc][sonbel (fa)] = p;</span><br><span class="line">father[p] = anc;</span><br><span class="line">son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">top = <span class="number">0</span>; <span class="built_in">stack</span>[++ top] = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tp = p; ! isroot (tp); tp = father[tp]) <span class="built_in">stack</span>[++ top] = father[tp];</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">0</span>) pushdown (<span class="built_in">stack</span>[top]), top --;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line"><span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tp = <span class="number">0</span>; p; tp = p, p = father[p]) &#123;</span><br><span class="line">splay (p);</span><br><span class="line">fic[p] += vism[son[p][<span class="number">1</span>]] - vism[tp];</span><br><span class="line">son[p][<span class="number">1</span>] = tp; pushup (p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; access (p), splay (p); reverse (p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">access (p), splay (p);</span><br><span class="line"><span class="keyword">while</span> (son[p][<span class="number">0</span>]) &#123; pushdown (p); p = son[p][<span class="number">0</span>]; &#125;</span><br><span class="line">splay (p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">value</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> vism[p] &gt; <span class="number">0</span>; &#125; <span class="comment">// 判断是否成环，若成环则答案需要再点个数上加一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hideit</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> delta)</span> </span>&#123; <span class="comment">// 将树上边变为使成环边</span></span><br><span class="line">makeroot (p); ans -= value (p);</span><br><span class="line">vimi[p] += delta, pushup (p); ans += value (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> in[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot (x), makeroot (y);</span><br><span class="line">ans -= value (x) + value (y); <span class="comment">// 删去原来两个分开的连通块的贡献再加上新合成连通块贡献</span></span><br><span class="line">ans ++; father[x] = father[y] = id;</span><br><span class="line">fic[id] += vism[x] + vism[y], pushup (id);</span><br><span class="line">ans += value (id); in[id] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot (x), access (y), splay (id);</span><br><span class="line">ans --, ans -= value (id);</span><br><span class="line">father[x] = father[y] = <span class="number">0</span>; ans += value (x) + value (y);</span><br><span class="line">in[id] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PUSH</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y) &#123; hideit (x, <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">makeroot (x);</span><br><span class="line"><span class="keyword">if</span> (findroot (y) == x) &#123;</span><br><span class="line">access (y), splay (y); <span class="keyword">int</span> p = mini[y];</span><br><span class="line">cut (p, posi[p][<span class="number">0</span>], posi[p][<span class="number">1</span>]);</span><br><span class="line">hideit (posi[p][<span class="number">0</span>], <span class="number">1</span>), hideit (posi[p][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">link (id, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">POP</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! in[id]) &#123;</span><br><span class="line">hideit (x, - <span class="number">1</span>), hideit (y, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">cut (id, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">n = N = getnum (), M = getnum (), type = getnum ();</span><br><span class="line"><span class="keyword">int</span> st = N + <span class="number">1</span>; mini[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> op, a, b;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">op = getnum ();</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) a = getnum (), b = getnum ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">op = (getnum () + ans) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) a = (getnum () + ans) % N + <span class="number">1</span>, b = (getnum () + ans) % N + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">posi[++ n][<span class="number">0</span>] = a, posi[n][<span class="number">1</span>] = b; <span class="comment">// ++ n表示边化点</span></span><br><span class="line">PUSH (n, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; POP (st, posi[st][<span class="number">0</span>], posi[st][<span class="number">1</span>]); st ++; &#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：大猫熊和他的k边形"><a href="#Problem-B：大猫熊和他的k边形" class="headerlink" title="Problem B：大猫熊和他的k边形"></a>Problem B：大猫熊和他的k边形</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>菜鸡zjr今天被一道幼儿园几何题打爆了，一分都拿不到。</p><p>于是他向你求助QwQ:</p><p>给定 $n,k$，求出 $i(k \le i \le n)$ 边形的所有三角剖分中, $k$ 边形的总数的和对 $1e9 + 7$ 取模的结果。</p><p>$k$ 边形指的是 $n$ 个点中的 $k$ 个点，他们在这个剖分中构成一个封闭图形。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $100\%$ 的数据，$3 \le k \le n \le 5 \times 10^6$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>官方题解看不懂。。看别人的题解。。</p><p>首先这个问题可以看成求所有 $n - 2$ 个节点的二叉树中大小为 $k - 2$ 的连通块的数量之和</p><p>那么现在直接令 $n, k$ 减二</p><p>单独考虑每个连通块的贡献，首先它有 $Cat_k$ 种形态，该树有 $k + 1$ 种接子树的方案（数一下就知道了，不包括该树根节点往其父亲连），那么第一部分（接儿子）方案数即为<br>$$<br>\sum\limits_{i = 0}^{n - k} Cat_k[x^i]C^{k + 1}<br>$$<br>其中 $i$ 表示接儿子子树的总大小，$C$ 表示卡特兰数列的生成函数</p><p>那么现在考虑接父亲，容易知道方案数为<br>$$<br>\sum\limits_{j = 0}^{n - k - i} Cat_j(j + 1)<br>$$<br>其中 $j$ 表示接的树的大小，$j + 1$ 也是一样表示对接的树来讲有 $j + 1$ 种接儿子的方案</p><p>现在时间复杂度的症结在于 $[x^n]C^m$ 的计算，考虑它的几何意义</p><p>它相当于 $i$ 个折线图拼起来，现在考虑如何将这些折线图分段，就是将每一段折线图的结尾 $-1$，那么总共会减 $m - 1$ 次（最后一段是不需要减的），也就是说“第一次出现 $0$ 到第一次出现 $- 1$ 的位置”对应第一段折线，“第一次出现 $- 1$ 到第一次出现 $- 2$ 的位置”对应第二段折线。。。</p><p>那么现在就是给 $n$ 个 $+ 1$，$n + m - 1$ 个 $- 1$，计算其由 $(0, 0)$ 到 $(2n + m - 1, - m + 1)$，并且保证前缀和 $\ge - m + 1$ 的方案数，故显然有<br>$$<br>[x^n]C^m = \dbinom{2n + m - 1}{n} - \dbinom{2n + m - 1}{n - 1}<br>$$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我的 $\text{code}$ 跑的贼慢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e07</span>;</span><br><span class="line"> </span><br><span class="line">LL inv[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">LL cat[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD; &#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (C (<span class="number">2</span> * n + m - <span class="number">1</span>, n) - C (<span class="number">2</span> * n + m - <span class="number">1</span>, n - <span class="number">1</span>) + MOD) % MOD; &#125;</span><br><span class="line"><span class="comment">// [x^n]C^m</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    n -= <span class="number">2</span>, k -= <span class="number">2</span>;</span><br><span class="line">    fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    fact[<span class="number">1</span>] = invfact[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">        invfact[i] = invfact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cat[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cat[i] = cat[i - <span class="number">1</span>] * (<span class="number">4</span> * i  - <span class="number">2</span>) % MOD * inv[i + <span class="number">1</span>] % MOD;</span><br><span class="line">        g[i] = (g[i - <span class="number">1</span>] + cat[i] * (i + <span class="number">1</span>) % MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)</span><br><span class="line">        ans = (ans + cat[k] * calc (i, k + <span class="number">1</span>) % MOD * g[n - i - k] % MOD) % MOD;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：SUMMER-WC"><a href="#Problem-C：SUMMER-WC" class="headerlink" title="Problem C：SUMMER WC"></a>Problem C：SUMMER WC</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>OIer是个可爱的群体，他们有很多的禁忌词汇，对此他们会有坏感度，我们表示成 $- x$ 的形式，$x$ 为正整数，越大，表示他们越讨厌，比如:</p><p>$\text{ccf}$ $-250250$ $\text{summerwc}$ $-2600$ $\text{unitedshengxuan}$ $-700$</p><p>但他们也会对一些东西有好感度，类似的，我们列出例子:</p><p>$\text{frog}$ $+1000000$（其实远远不止，但本题的权值上限 $1e6$）$\text{apiadu}$ $+3681$ $\text{txdy}$ $+3669$</p><p>类似的，我们还有很多例子</p><p>一个字符串的好感度就是里面出现过的词汇的感觉的和，一个词汇出现多次算多次</p><p>例如 $\text{frogfrog}$ 的好感度就是 $2e6$</p><p>特别的，我们考虑空串，其好感度为 $0$</p><p>现在我么给出一个大的串，同时给出所有词汇(好感度可以为负，表示有多讨厌),我们需要求出里面最大好感度子串，可以为空</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p>设 $n$ 个词汇的长度和为 $L$，$L_{max}$ 为其中的最大长度</p><p>对 $100\%$ 的数据，$1 \le n, m, L, L_{max} \le 10^6, ~ 1 \le x \le 10^6$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>完全不会。。我字符串实在太菜了。。</p><p>好像这是 $\text{GDOI2019}$ 的 $D2T3$ 的原题</p><p>主要思路就先建出一个$\text{AC}$自动机然后在上面$dp$</p><p>建出自动机后那些结尾节点都会有一个权值 $val$，那么对文本串 $[l, r]$ 的子串就是在自动机上走然后把路径上所有 $val$ 加起来即可得到它的好感度和</p><p>此时不妨设计状态 $f_{i, j}$ 表示文本串匹配到 $i$ 时，$\text{AC}$自动机上走到节点 $j$ 时的最大值，而造成这个最大值的子串即是 $1…i$ 的其中一个后缀子串</p><p>假设文本串子串 $[1, i]$ 在自动机上走到节点 $node_i$，那么现在考虑有可能被 $1…i$ 的后缀子串遍历到的 $j$，则 $j$ 一定在 $fail$ 树上是 $node_i$ 的祖先，故总状态有 $mL_{max}$ 个，此时复杂度为 $O (mL_{max})$</p><p>现在对上述 $dp$ 进行优化</p><p>在往$\text{AC}$自动机里插入的时候，建立父子关系（即$\text{trie}$树上的父子关系），用 $fa_i$ 表示</p><p>每经过自动机上某一条边，转移一定是相同的，故简化一下，令 $f_i$ 表示自动机上走到 $i$ 的答案（此时与文本串无关，因为节点 $i$ 已经确定了唯一一个后缀），考虑 $f_i$ 都从哪里转移，令字符串 $S_i$ 表示节点 $i$ 表示后缀</p><ul><li>直接等于 $f_{fail_i}$</li><li>由 $fa_i$ 及其后缀再加上 $val_{fail_i}$ 转移（即不取 $S_i$ 的第一个字符，那么 $val_i$ 也不能加上了）</li><li>直接取整个 $S_i$</li></ul><p>故此时再设两个状态 $g_i, h_i$，其中 $g_i$ 表示第三种情况，$h_i$ 表示第二种情况，那么 $f_i$ 的转移就表示为<br>$$<br>f_i = \max (f_{fail_i}, \max (g_i, h_i))<br>$$<br>至于为什么还要设 $h_i$，因为假如直接从 $f_{fail_i}$ 转移的话可能 $S_i$ 的某些有贡献后缀就无法被遍历到了，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e</span><br><span class="line">de</span><br><span class="line">bd</span><br><span class="line">abde</span><br></pre></td></tr></table></figure><p>那么在计算 $f(abde)$ 的时候，若只取其 $fail$ 树上父亲，则只会访问到 $\text{de}$，那么 $\text{bd}$ 后面拼上一个 $e$ 的情况就遍历不到了</p><p>其中对 $h_i$ 的转移只要考虑 $S_i$ 与 $S_{fail_i}$ 的差值部分就好了，故总转移复杂度是 $O (m + L)$ 的</p><p>注意记得将文本串插入到自动机中，不然显然无法统计答案</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tr[MAXN][<span class="number">26</span>]= &#123;<span class="number">0</span>&#125;, fail[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; <span class="keyword">int</span> n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (! tr[p][c]) &#123; tr[p][c] = ++ m; father[m] = p; &#125;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">&#125;</span><br><span class="line">value[p] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;, h[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">que.push(tr[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">value[u] += value[fail[u]];</span><br><span class="line">g[u] = g[father[u]] + value[u];</span><br><span class="line"><span class="keyword">if</span> (! fail[u]) h[u] = h[father[u]];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">h[u] = - INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = father[u]; j != father[fail[u]]; j = fail[j])</span><br><span class="line">h[u] = max (h[u], h[j] + value[fail[u]]);</span><br><span class="line">&#125;</span><br><span class="line">f[u] = max (f[fail[u]], max (g[u], h[u]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u][i]) &#123;</span><br><span class="line">fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">que.push(tr[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>, n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">ans = max (ans, f[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">insert (getnum ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>); insert (<span class="number">0</span>);</span><br><span class="line">build ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 卡特兰数 </tag>
            
            <tag> 集训 </tag>
            
            <tag> AC自动机 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十二）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日继续垫底系列</p><p>T1题意理解错误暴力写挂</p><p>T2怒敲 $n \le 4$ 求根公式然后发现答案还得排序。。</p><p>$\text{score：0 + 10 + 0 = 10   rk：27/27}$</p><h2 id="Problem-A：游戏"><a href="#Problem-A：游戏" class="headerlink" title="Problem A：游戏"></a>Problem A：游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh是一名Herthstone大师。现在他遇到了一个很严峻的问题：</p><p>场上总共有 $n+m$ 个随从，其中ysgh控制着 $n$ 个，对手控制着 $m$ 个。每个随从有自己的血量。</p><p>如果ysgh在这一回合成功解掉了对手的所有随从，则ysgh获胜。否则下一回合对手直接骑脸，ysgh就会输掉。</p><p>ysgh现在手里仅有一场牌，属性如下：</p><p>进行 $d$ 次，每一次等概率随机一个在场上的未死亡随从（包括自己和对手的）并且对其造成一点伤害。若不存在未死亡随从，则不进行此次攻击。一个随从未死亡当且仅当其血量严格大于 $0$。每一次攻击后，所有血量小于等于 $0$ 的随从立即死亡。</p><p>ysgh想要知道，他有多大概率可以取胜，也就是多大的概率使得在使用这张牌后，对手的随从全部死亡。</p><p><strong>特别提醒：由于描述与实际游戏规则有出入，一切以实际题面描述为准。</strong></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，满足 $1 \le n, m \le 6, ~ 1 \le d \le 400$</p><p>保证所有随从血量均为 $1 \sim 12$ 之间的正整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我没玩过炉石还真是对不起哦。。原来假如这一个技能结束全场都没了的话是算我方胜利而不是平手。。</p><p>将 $n + m$ 个随从一起考虑，设第 $i$ 个随从血量 $a_i$</p><p>很容易可以想到设 $f_{i, state}$ 表示前 $i$ 轮，死亡状态为为 $state$ 的概率</p><p>显然一个随从死亡后会分一段，就是你接下来要乘的概率分母要减一</p><p>多加一个死亡随从很好转移，但是当时我就卡在如何计算该随从的血量分配在前面几段需要乘上的概率</p><p>实际上很简单，只要在转移该轮攻击后无新人死亡的时候“预支”一下这个概率就好了，$\text{dp}$ 式子如下，其中，令 $|state|$ 表示 $state$ 二进制表示 $1$ 的个数，$s (state)$ 表示 $state$ 表示出的死亡随从的总血量<br>$$<br>\begin{aligned}<br>攻击后无新人死亡：&amp;f_{i, state} \times \frac1{n + m - |state|} \rightarrow f_{i + 1, state} \\<br>攻击后存在新随从k(k \not\in state)死亡：&amp;f_{i, state} \times \frac{\dbinom{i - s (state)}{a_k - 1}}{n + m - |state|} \rightarrow f_{i, state | (1 &lt;&lt; (k - 1))}<br>\end{aligned}<br>$$<br>“预支”过后在死亡随从转移时就只要直接在前面预留下的位置中选几个就好了</p><p>当然现在还需要将剩下的未死亡的随从的血量分配（即他们可能被攻击但未死亡），一个多重背包就好了</p><p>时间复杂度 $O (2^{n + m}144^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">12</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXD = <span class="number">144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, M, D;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL inv[MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXD]= &#123;<span class="number">0</span>&#125;, ifact[MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * ifact[m] % MOD * ifact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXD][MAX]= &#123;<span class="number">0</span>&#125;, g[MAXN][MAXD]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt ++; state ^= lowbit (state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), D = getnum (); T = N + M;</span><br><span class="line">fact[<span class="number">0</span>] = ifact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">fact[<span class="number">1</span>] = ifact[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max (T, D); i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">ifact[i] = ifact[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + M; i ++) &#123; a[i] = getnum (); tot += a[i]; &#125;</span><br><span class="line">D = min (D, tot);</span><br><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; T) - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++) &#123;</span><br><span class="line"><span class="keyword">int</span> s = calc (state), sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j ++)</span><br><span class="line"><span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">sum += a[j];</span><br><span class="line"><span class="keyword">if</span> (i &lt; sum) <span class="keyword">continue</span>;</span><br><span class="line">f[i + <span class="number">1</span>][state] = (f[i + <span class="number">1</span>][state] + f[i][state] * inv[T - s] % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= T; k ++)</span><br><span class="line"><span class="keyword">if</span> (! (state &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)))) &#123;</span><br><span class="line">LL mul = C (i - sum, a[k] - <span class="number">1</span>) % MOD * inv[T - s] % MOD;</span><br><span class="line">f[i + <span class="number">1</span>][state | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] = (f[i + <span class="number">1</span>][state | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] + f[i][state] * mul % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stan = <span class="number">0</span>;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = N + <span class="number">1</span>; j &lt;= T; j ++) stan |= (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++)</span><br><span class="line"><span class="keyword">if</span> ((state &amp; stan) == stan) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) sum += a[j];</span><br><span class="line"><span class="keyword">else</span> b[++ m] = a[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> V = D - sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= V; k ++) &#123;</span><br><span class="line">g[j][k] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= min (k, b[j] - <span class="number">1</span>); l ++)</span><br><span class="line">g[j][k] = (g[j][k] + g[j - <span class="number">1</span>][k - l] * C (V - (k - l), l) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + f[D][state] * g[m][V] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：方程"><a href="#Problem-B：方程" class="headerlink" title="Problem B：方程"></a>Problem B：方程</h2><h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h3><p>求解一元 $n$ 次方程 $f(x) = \sum a_ix^i = 0$ 的所有实数根</p><p>有 $T$ 组数据</p><p><strong>注意输出的实数根要按从大到小排序</strong></p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 6$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>（百度长的跟什么一样的求根公式的卑微的我）</p><p>对 $f(x)$，考虑其导数 $f’(x)$，对于 $f’(x)$ 的相邻两实数根 $x_1, x_2$ 显然有 $f(x)$ 在 $(x_1, x_2)$ 单调</p><p>那么求出 $f’(x)$ 实数根后在上述单调区间二分答案即可</p><p>递归处理</p><p>时间复杂度 $O (Tn^3)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> Ld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Ld eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="keyword">const</span> Ld INF = <span class="number">1e20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span> <span class="params">(Ld p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Ld zero[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">Ld <span class="title">value</span> <span class="params">(<span class="keyword">int</span> n, Ld val)</span> </span>&#123;</span><br><span class="line">Ld x = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++, x = x * val)</span><br><span class="line">ret += t[n][i] * x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> n, Ld L, Ld R, Ld&amp; ze)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d1 = dcmp (value (n, L));</span><br><span class="line"><span class="keyword">int</span> d2 = dcmp (value (n, R));</span><br><span class="line"><span class="keyword">if</span> (d1 * d2 &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (d1 * d2 == <span class="number">0</span>) &#123; ze = d1 == <span class="number">0</span> ? L : R; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (d1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld left = L, right = R;</span><br><span class="line"><span class="keyword">while</span> (dcmp (right - left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld mid = (left + right) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (value (n, mid)) &lt;= <span class="number">0</span>) left = mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line">ze = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Ld left = L, right = R;</span><br><span class="line"><span class="keyword">while</span> (dcmp (right - left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">Ld mid = (left + right) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (value (n, mid)) &gt;= <span class="number">0</span>) left = mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line">ze = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">Ld a = t[n][<span class="number">1</span>], b = t[n][<span class="number">0</span>];</span><br><span class="line">zero[n][++ cnt[n]] = - b / a;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">Ld a = t[n][<span class="number">2</span>], b = t[n][<span class="number">1</span>], c = t[n][<span class="number">0</span>];</span><br><span class="line">Ld delta = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp (delta) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>) delta = <span class="number">0</span>;</span><br><span class="line">Ld x1, x2;</span><br><span class="line"><span class="keyword">if</span> (dcmp (a) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">x1 = (- b - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">x2 = (- b + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = (- b + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">x2 = (- b - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>) zero[n][++ cnt[n]] = x1;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">zero[n][++ cnt[n]] = x1;</span><br><span class="line">zero[n][++ cnt[n]] = x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">work (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (! cnt[n - <span class="number">1</span>]) &#123;</span><br><span class="line">Ld posi;</span><br><span class="line"><span class="keyword">if</span> (find (n, - INF, INF, posi))</span><br><span class="line">zero[n][++ cnt[n]] = posi;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">zero[n - <span class="number">1</span>][<span class="number">0</span>] = - INF, zero[n - <span class="number">1</span>][cnt[n - <span class="number">1</span>] + <span class="number">1</span>] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt[n - <span class="number">1</span>]; i ++) &#123;</span><br><span class="line">Ld posi;</span><br><span class="line"><span class="keyword">if</span> (find (n, zero[n - <span class="number">1</span>][i], zero[n - <span class="number">1</span>][i + <span class="number">1</span>], posi))</span><br><span class="line">zero[n][++ cnt[n]] = posi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">t[i][j] = t[i + <span class="number">1</span>][j + <span class="number">1</span>] * (j + <span class="number">1</span>);</span><br><span class="line">work (n);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, cnt[n]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[n]; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.8Lf\n"</span>, zero[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> (t));</span><br><span class="line"><span class="built_in">memset</span> (cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (cnt));</span><br><span class="line"><span class="built_in">memset</span> (zero, <span class="number">0</span>, <span class="keyword">sizeof</span> (zero));</span><br><span class="line"><span class="keyword">int</span> n = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) t[n][i] = getnum ();</span><br><span class="line">solve (n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：旅游"><a href="#Problem-C：旅游" class="headerlink" title="Problem C：旅游"></a>Problem C：旅游</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh是最优化大师</p><p>ysgh想去旅游，他所在的城市共有 $n$ 个景点，景点之间有 $m$ 条双向道路连接。保证 $n$ 个景点可以通过 $m$ 条道路互相到达。道路长度均为 $1$。</p><p>ysgh可以通过乘坐出租车完成旅行。具体的，第 $i$ 个景点的出租车最多可以将其载到距离 $i$ 不超过 $f_i$ 的地方。在第 $T$ 天，搭乘从第 $i$ 个景点出发的出租车需要花费 $c_i \times T + w_i$ 元。</p><p>ysgh的钱已经在小卖部中挥霍一空，因此他想要选择 $1$ 至 $T_{max}$ 中的一天，从景点 $1$ 出发，搭乘出租车到达景点$x$，同时花费尽量地小。</p><p>由于他没有定下来在那个城市游玩，因此他想要对所有的 $x \in [1, n]$ 求出答案。</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/06/52phqVItFKWuRNg.png" alt=""></p><p>保证对所有 $1 \le T \le T_{max}, c_i \times T + w_i &gt; 0$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>设 $v_i = c_i \times T + w_i$</p><p>考虑暴力，对每个点向它能到达的所有点连一个边权为 $v_i$ 的边，且容易发现，答案一定在 $T$ 取 $1$ 或 $T_{max}$ 中选，然后从 $1$ 开始跑最短路</p><p>由于每个点向外出边边权相同，所以考虑用数据结构优化建图过程</p><p>从 $m = n - 1$ 的情况开始说明，首先贪心思想，每个点只会被更新一次，每次使用堆中 $d$（已知最短路）最小的点来更新其它点</p><p>设 $dist(u, v)$ 表示 $u, v$ 的最短距离（此时即树上距离）建立点分树，假设现在最短路跑到从 $u$ 开始更新其它节点，那么枚举 $u$ 在点分树上的每个祖先，那么其每个祖先 $fa$ 包含的节点中，满足 $dist (u, fa) + dist (fa, v) \le f_u$ 的所有节点 $v$ 是 $u$ 应当去更新的，不难发现，这样的 $v$ 一定是按它到 $fa$ 的距离被顺序更新的，所以可以记录每个点 $p$ 在点分树上按到 $p$ 距离递增排列的子节点，并记录一个指针，即已经更新到哪个子节点，以后在点分树上枚举到 $p$ 只需从指针记录位置开始枚举即可，这样子每个节点被访问到 $log n$ 次，故总时间复杂度 $O (n \log n)$</p><p>对于 $m \ge n$ 的情况，用与上面类似的算法，由于它最多多出 $50$ 条边，不妨就以 $m = n + 50$ 来论</p><p>在图中随意抽出一棵生成树，那么那些不在生成树中的边 $(u, v)$ 我们将 $u$ 记作冗余节点，即这样的边为冗余边，很显然这样的节点最多 $50$ 个</p><p>那么从点 $u$ 到点 $v$ 的最短距离就有两种情况</p><ul><li>全部走树上路径</li><li>交替走树上路径与冗余路径，那么它一定至少经过一个冗余节点 $x$，满足 $dist (u, x) + dist (x, v) \le f_u$</li></ul><p>对第一种情况，在生成树中运行上面所述 $m = n - 1$ 同样的算法即可，问题在于第二种情况</p><p>实际上两种情况本质上是一样的，对每个冗余节点 $p$，将所有 $n$ 个节点按到 $p$ 的距离递增排序存在数组中，那么最短路运行到 $u$ 时同样也只要用指针在数组里走就好了，步骤和 $m = n - 1$ 的情况也是一样的</p><p>这样每个节点最多被访问 $50 + \log n$ 次，总时间复杂度 $O \left(n (50 + \log n)\right)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> LL LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span>  <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, E = <span class="number">0</span>, Tm;</span><br><span class="line"><span class="keyword">int</span> b[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], c[MAXN], w[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pt[MAXN], ex[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> poi[MAXN]= &#123;<span class="number">0</span>&#125;, pex[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ances[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ances[x] == x ? x : ances[x] = find (ances[x]); &#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ances[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = edge[i].first, y = edge[i].second;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123; b[++ E] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">ances[fx] = fy; Insert (x, y), Insert (y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN], g, mini;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acsize</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>; <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">acsize (v, root, n);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">maxpart = max (maxpart, subsize[v]);</span><br><span class="line">&#125;</span><br><span class="line">maxpart = max (maxpart, n - subsize[root]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) g = root, mini = maxpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lev[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> depth[<span class="number">25</span>][MAXN], d[MAXN], m = <span class="number">0</span>, mdep = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">d[++ m] = root; mdep = max (mdep, depth[l][root]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">depth[l][v] = depth[l][root] + <span class="number">1</span>;</span><br><span class="line">DFS (v, root, l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXN]= &#123;<span class="number">0</span>&#125;, topo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">mini = INF, acsize (u, <span class="number">0</span>, n);</span><br><span class="line">father[g] = fa; visit[g] = <span class="literal">true</span>;</span><br><span class="line">mdep = m = <span class="number">0</span>, lev[g] = l, depth[l][g] = <span class="number">0</span>; DFS (g, <span class="number">0</span>, l);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mdep; i ++) buck[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) buck[depth[l][d[i]]] ++, topo[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mdep; i ++) buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) topo[buck[depth[l][d[i]]] --] = d[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) pt[g].push_back(topo[i]);</span><br><span class="line">acsize (g, <span class="number">0</span>, n); <span class="keyword">int</span> fg = g;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fg]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">divide (v, subsize[v], l + <span class="number">1</span>, fg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> deep[<span class="number">51</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkit</span> <span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">que.push(S), deep[id][S] = <span class="number">0</span>, vis[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[u].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">deep[id][v] = deep[id][u] + <span class="number">1</span>;</span><br><span class="line">que.push(v); vis[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) buck[i] = topo[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) buck[deep[id][i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) topo[buck[deep[id][i]] --] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ex[id].push_back(topo[i]);</span><br><span class="line">&#125;</span><br><span class="line">LL value[MAXN], ans[MAXN]= &#123;<span class="number">0</span>&#125;, dist[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id; LL d;</span><br><span class="line">node (<span class="keyword">int</span> id = <span class="number">0</span>, LL d = <span class="number">0</span>) : id (id), d (d) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; p.d; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;node&gt; heap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span> <span class="params">(<span class="keyword">int</span> u, LL d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = u; p; p = father[p]) &#123;</span><br><span class="line"><span class="keyword">int</span> l = lev[p];</span><br><span class="line"><span class="keyword">for</span> ( ; poi[p] &lt; (<span class="keyword">int</span>) pt[p].size(); poi[p] ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = pt[p][poi[p]];</span><br><span class="line"><span class="keyword">if</span> (depth[l][u] + depth[l][v] &gt; f[u]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[v] &lt; LINF) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[u] + value[v];</span><br><span class="line">heap.push(node (v, dist[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; pex[i] &lt; (<span class="keyword">int</span>) ex[i].size(); pex[i] ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = ex[i][pex[i]];</span><br><span class="line"><span class="keyword">if</span> (deep[i][u] + deep[i][v] &gt; f[u]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[v] &lt; LINF) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[u] + value[v];</span><br><span class="line">heap.push(node (v, dist[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) value[i] = <span class="number">1l</span>l * c[i] * T + w[i];</span><br><span class="line"><span class="built_in">memset</span> (poi, <span class="number">0</span>, <span class="keyword">sizeof</span> (poi)); <span class="built_in">memset</span> (pex, <span class="number">0</span>, <span class="keyword">sizeof</span> (pex));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) heap.pop();</span><br><span class="line"><span class="built_in">memset</span> (dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (dist));</span><br><span class="line">dist[<span class="number">1</span>] = value[<span class="number">1</span>], heap.push(node (<span class="number">1</span>, dist[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) &#123;</span><br><span class="line">node top = heap.top(); heap.pop();</span><br><span class="line"><span class="keyword">int</span> u = top.id; LL d = top.d;</span><br><span class="line">trans (u, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ans[i] = min (ans[i], dist[i] - value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Tm = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) f[i] = getnum (), c[i] = getnum (), w[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">edge[i] = make_pair (u, v);</span><br><span class="line">&#125;</span><br><span class="line">build ();</span><br><span class="line">sort (b + <span class="number">1</span>, b + E + <span class="number">1</span>);</span><br><span class="line">E = unique (b + <span class="number">1</span>, b + E + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">divide (<span class="number">1</span>, N, <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; i ++) linkit (b[i], i);</span><br><span class="line"><span class="built_in">memset</span> (ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (ans));</span><br><span class="line">solve (<span class="number">1</span>), solve (Tm);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) write (ans[i]), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 概率DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十九）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>再次垫底$\text{.jpg}$</p><p>$\text{score：20 + 0 + 10 = 30   rk：27/29}$</p><h2 id="Problem-A：sign"><a href="#Problem-A：sign" class="headerlink" title="Problem A：sign"></a>Problem A：sign</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/v9ViJtBL6OAnzYG.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题贼水，但我没想出来。。</p><p>我大概以为这不是数学所以没想到代入，或者是我忘记该点值表示可以 $O (\log A)$</p><p>反正全村就我没到及格线</p><p>题解懒得写了，就搬出题人给的吧</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/Pu2fmObx8V4RDnZ.png" alt=""></p><p>事实上，这个做法不能通过。</p><p>考虑上面做法复杂度瓶颈是快速幂。一个简单的$\text{trick}$是对于一个固定的 $son_u = k$，令 $M = \lceil \sqrt{A} \rceil$，预处理出 $k^0, k^1, k^2, …, k^{M - 1}$ 以及 $(k^M)^0, (k^M)^1, …, (k^M)^{M - 1}$。这样单次求某个点值就可以用 $O (1)$ 次算术运算求得。</p><p>时间复杂度为 $O ((n + \sqrt{A})\sqrt{n})$。</p><p>以上是出题人提供题解</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e04</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">LL ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL inv;</span><br><span class="line">LL f1[MAXN]= &#123;<span class="number">0</span>&#125;, f2[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = p / M, rest = p - base * M;</span><br><span class="line"><span class="keyword">return</span> f2[base] * f1[rest] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">LL r;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) r = a[root] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = (<span class="number">1</span> - calc (a[root] + <span class="number">1</span>) + MOD) % MOD * inv % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">r = r * work (v, t) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t == son[root]) ans[root] = r;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa = getnum ();</span><br><span class="line">Insert (fa, i); son[fa] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) b[++ m] = son[i];</span><br><span class="line">sort (b + <span class="number">1</span>, b + m + <span class="number">1</span>);</span><br><span class="line">m = unique (b + <span class="number">1</span>, b + m + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">inv = power (<span class="number">1</span> - b[i] + MOD, MOD - <span class="number">2</span>);</span><br><span class="line">f1[<span class="number">0</span>] = <span class="number">1</span>, f2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) f1[j] = f1[j - <span class="number">1</span>] * b[i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) f2[j] = f2[j - <span class="number">1</span>] * f1[M] % MOD;</span><br><span class="line">work (<span class="number">1</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：match"><a href="#Problem-B：match" class="headerlink" title="Problem B：match"></a>Problem B：match</h2><h2 id="Problem-C：tree"><a href="#Problem-C：tree" class="headerlink" title="Problem C：tree"></a>Problem C：tree</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/18/rxE7RpM2lkOtGWi.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题最基本的思路我一开始想了一下，然后马上扔了。。</p><p>首先考虑每个点它能够作为被 $LCA$ 的情况</p><p>考虑重链剖分，启发式合并，设点 $u$ 重子树 $A$，另一子树 $B$，则对 $i \in B, j \in A$，满足 $LCA (i, j) = u$，此时选择 $i, j$，$u$ 可以贡献给区间 $[l, r]$ 满足 $l \in [1, i], r \in [j, n]$（假定 $i &lt; j)$，也就是说，极限情况即是取 $i$ 在 $A$ 中的前驱 $pre$ 与后继 $nxt$，则最大 $u$ 可贡献区间即为 $[1, pre] \cup [i, n]$ 与 $[1, i] \cup [nxt, n]$</p><p>此时不妨把区间 $l, r$ 视为二维平面上的点 $(l, r)$，那么上面所说的 $i$ 导致的 $u$ 的最大可贡献区间在平面上则投影为矩形 $(1, i), (1, n), (pre, i), (pre, n)$ 与矩形 $(1, nxt), (1, n), (i, nxt), (i, n)$（取矩形的四个角）</p><p>考虑把所有  $depth$ 一致的点所贡献的矩形涂上相同的颜色，求每种颜色的矩形各自的并，那么最终询问点 $(l, r)$ 被多少种颜色的面积所覆盖则是答案</p><p>求矩形的并也很简单，因为这些矩形都是严格贴着平面左上角（即 $(1, n)$）的</p><p>然后扫描线一波就做完了</p><p>不过不要忘了题面所说的 $i, j$ 可以相同，所以对每个 $i, i \in [1, n]$，还得加上 $(1, i), (1, n), (i, i), (i, n)$ 的矩形</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[MAXN]= &#123;<span class="number">0</span>&#125;, subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> d[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL dist[MAXN]= &#123;<span class="number">0</span>&#125;, mpp[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line">mpp[++ m] = dist[root];</span><br><span class="line">son[root] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">dist[v] = dist[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span> || subsize[v] &gt; subsize[son[root]])</span><br><span class="line">son[root] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; mat[MAXN]; <span class="comment">// &lt;纵坐标, 横坐标&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st[MAXN];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it, it2;</span><br><span class="line"><span class="keyword">int</span> ext[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (it = st[y].begin(); it != st[y].end(); it ++) &#123;</span><br><span class="line"><span class="keyword">int</span> i = * it;</span><br><span class="line">it2 = st[x].lower_bound(i);</span><br><span class="line"><span class="keyword">int</span> pre = i, nxt = i;</span><br><span class="line"><span class="keyword">if</span> (it2 != st[x].begin()) &#123; it2 --; pre = * it2; &#125;</span><br><span class="line">it2 = st[x].upper_bound(i);</span><br><span class="line"><span class="keyword">if</span> (it2 != st[x].end()) nxt = * it2;</span><br><span class="line"><span class="keyword">if</span> (nxt != i) mat[id].push_back(make_pair (nxt, i));</span><br><span class="line"><span class="keyword">if</span> (pre != i) mat[id].push_back(make_pair (i, pre));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (it = st[y].begin(); it != st[y].end(); it ++) st[x].insert(* it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span>) &#123;</span><br><span class="line">st[root].insert(root); ext[root] = root;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">make (son[root], root);</span><br><span class="line">ext[root] = ext[son[root]];</span><br><span class="line">st[ext[root]].insert(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father || v == son[root]) <span class="keyword">continue</span>;</span><br><span class="line">make (v, root);</span><br><span class="line">merge (ext[root], ext[v], d[root]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, type, id;</span><br><span class="line"><span class="comment">// type: - 1, + 1, 2(dot)</span></span><br><span class="line">node (<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> type = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>) : x (x), y (y), type (type), id (id) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x == p.x) <span class="keyword">return</span> type &lt; p.type;</span><br><span class="line"><span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">node a[MAXM &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mesh</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">sort (mat[id].begin(), mat[id].end());</span><br><span class="line"><span class="keyword">int</span> lx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) mat[id].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = mat[id][i].first, x = mat[id][i].second;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= lx) &#123;</span><br><span class="line">a[++ n] = node (lx, y, <span class="number">1</span>, id);</span><br><span class="line">a[++ n] = node (x + <span class="number">1</span>, y, - <span class="number">1</span>, id);</span><br><span class="line">lx = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> answer[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (- x); &#125;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= N) &#123;</span><br><span class="line">subsum[x] += delta;</span><br><span class="line">x += lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret += subsum[x];</span><br><span class="line">x -= lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">sort (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = a[i].y, type = a[i].type, id = a[i].id;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">2</span>) answer[id] = query (y);</span><br><span class="line"><span class="keyword">else</span> add (y, type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum (), w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">sort (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>);</span><br><span class="line">m = unique (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>) - mpp - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) d[i] = lower_bound (mpp + <span class="number">1</span>, mpp + m + <span class="number">1</span>, dist[i]) - mpp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) mat[d[i]].push_back(make_pair (i, i));</span><br><span class="line">make (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) mesh (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">a[++ n] = node (l, r, <span class="number">2</span>, q);</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十七）</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今日又是三道集训队作业原题。。又没部分分。。</p><p>反正我都不会必定爆零就没交了。。</p><p>$\text{score：NULL   rk：NULL}$</p><h2 id="Problem-A：Birthday"><a href="#Problem-A：Birthday" class="headerlink" title="Problem A：Birthday"></a>Problem A：Birthday</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 $n$ 个仅包含 <code>a,b</code> 的字符串。</p><p>你需要去掉尽可能少的字符串，使得剩下的字符串中不存在某一个串是另一个串的子串。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 750, ~ \sum\limits_{i = 1}^n |s_i \le 10^7$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://codeforces.com/problemset/problem/590/E?f0a28=2" target="_blank" rel="noopener">CF590E</a></p><p>由于 $n$ 很小，很显然可以对每一对字符串判断一个是不是另一个的子串，如果是就连个单向边，最终形成一个 $DAG$ 然后在上面搞</p><p>那么对于建图，先建个$\text{AC}$自动机，在 $trie$ 的结尾存一下编号，然后把每个串扔上去匹配，每次匹配与走到节点 $fail$ 树上的所有编号（即它的子串）连边</p><p>当然直接连边肯定会 $T$，实际上你只要往在 $fail$ 树往上找到的第一个编号以及本身节点的编号（如果存在的话）连边，然后传递闭包就好了，这样复杂度就正确了</p><p>那么接下来的任务就是在 $DAG$ 上求出最长反链并构造方案</p><p>那这就是 <a href="https://colythme.github.io/2020/07/15/[CTSC2008]祭祀（DAG最长反链及其方案构造）/">[CTSC2008]祭祀</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">750</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">2</span> * MAXN + MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFDS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125;;</span><br><span class="line">LFDS iLink[MAXN * MAXN];</span><br><span class="line"><span class="keyword">int</span> iHead[MAXM]= &#123;<span class="number">0</span>&#125;, isize = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">iLink[++ isize].to = v;</span><br><span class="line">iLink[isize].next = iHead[u];</span><br><span class="line"></span><br><span class="line">iHead[u] = isize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXM];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sve[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[MAXM][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>, n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">sve[ind].push_back(c);</span><br><span class="line"><span class="keyword">if</span> (! tr[p][c]) tr[p][c] = ++ m;</span><br><span class="line">p = tr[p][c];</span><br><span class="line">&#125;</span><br><span class="line">Insert (p, ind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fail[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> lastp[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">que.push(tr[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">lastp[u] = iHead[fail[u]] ? fail[u] : lastp[fail[u]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u][i]) &#123;</span><br><span class="line">fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">que.push(tr[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) sve[ind].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = sve[ind][i];</span><br><span class="line">p = tr[p][c];</span><br><span class="line"><span class="keyword">int</span> tp = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = iHead[tp]; k; k = iLink[k].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = iLink[k].to;</span><br><span class="line"><span class="keyword">if</span> (v == ind) <span class="keyword">continue</span>;</span><br><span class="line">g[v][ind] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">tp = lastp[tp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXL &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, size = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (x, y, cap); Insert (y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T, _N;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[p]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[p] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (cap, rest));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAXFLOW</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> tagl[MAXN]= &#123;<span class="literal">false</span>&#125;, tagr[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">tagr[u - N] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][u - N] &amp;&amp; ! tagl[i]) &#123;</span><br><span class="line">tagl[i] = <span class="literal">true</span>;</span><br><span class="line">DFS (match[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">insert (i);</span><br><span class="line">&#125;</span><br><span class="line">build ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) work (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][k])</span><br><span class="line">g[i] |= g[k];</span><br><span class="line">S = <span class="number">2</span> * N + <span class="number">1</span>, _N = T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = N - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! Link[<span class="number">4</span> * i - <span class="number">2</span>].cap)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next)</span><br><span class="line"><span class="keyword">if</span> (! Link[j].cap) &#123;</span><br><span class="line">match[i] = Link[j].to;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (Link[<span class="number">4</span> * i].cap)</span><br><span class="line">DFS (i + N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! tagl[i] &amp;&amp; tagr[i])</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d "</span>, i);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：A-Sequence-of-Permutations"><a href="#Problem-B：A-Sequence-of-Permutations" class="headerlink" title="Problem B：A Sequence of Permutations"></a>Problem B：A Sequence of Permutations</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个长为 $n$ 的排列 $p, q$，设 $f(p, q)$ 为使第 $p_i$ 个数为 $q_i$ 的排列</p><p>已知 $a_1 = p, a_2 = q, a_{n + 2} = f(a_n, a_{n + 1})$，求 $a_k$</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n \le 10^5, ~ k \le 10^9$</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>定义两个排列 $p, q$ 的乘法为，设 $r = pq$，则有<br>$$<br>r_i = p_{q_i}<br>$$<br>该乘法满足结合律，但不满足交换律</p><p>该乘法的单位元为 $e$ 满足 $e_i = i$，那么排列 $p$ 的逆元 $p^{- 1}$ 即可定义为 $p^{- 1}$ 满足 $p^{- 1}_{p_i} = i$</p><p>对逆元，有 $(pq)^{- 1} = q^{- 1}p^{- 1}$，同理对多个排列相乘的逆元，将它们反过来再分别求逆，最后按顺序相乘即可</p><p>下面给出该逆元公式的简单证明：</p><ul><li>设 $A = (pq)^{- 1}$，则有 $A_{p_{q_i}} = i$</li><li>设 $B = q^{-  1}p^{- 1}$，则有 $B_i = q^{- 1}<em>{p^{- 1}_i}$，令 $i = p_i$，有 $B</em>{p_i} = q^{- 1}<em>i$，再令 $i = q_i$，最后有 $B</em>{p_{q_i}} = i$</li><li>即 $A_{p_{q_i}} = B_{p_{q_i}}$，故等式成立</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$$<br>\begin{aligned}<br>&amp;f(p, q)_{p_i} = q_i \\<br>\Rightarrow &amp;f(p, q) * p = q \\<br>\Rightarrow &amp;f(p, q) = qp^{- 1}<br>\end{aligned}<br>$$</p><p>然后打表找规律<br>$$<br>\begin{aligned}<br>a_1 &amp;= p \\<br>a_2 &amp;= q \\<br>a_3 &amp;= qp^{- 1} \\<br>a_4 &amp;= qp^{- 1}q^{- 1} \\<br>a_5 &amp;= qp^{- 1}q^{- 1}pq^{- 1} \\<br>a_6 &amp;= qp^{- 1}q^{- 1}p^2q^{- 1} \\<br>a_7 &amp;= qp^{- 1}q^{- 1}pqpq^{- 1} \\<br>a_8 &amp;= qp^{- 1}q^{- 1}pqp^{- 1}qpq^{- 1} \\<br>\cdots<br>\end{aligned}<br>$$<br>令 $t = qp^{- 1}q^{- 1}p$，则 $a_7 = tpt^{- 1}, a_8 = tqt^{- 1}$，那么可以得到 $a_{6k + 1} = t^kpt^{- k}, a_{6k + 2} = t^kqt^{- k}$，对 $t$ 做个快速幂，然后剩下的几项暴力一下就好了</p><p>时间复杂度 $O (n \log \frac{k}{6})$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> P[MAXN], Q[MAXN];</span><br><span class="line"><span class="keyword">int</span> IP[MAXN], IQ[MAXN];</span><br><span class="line"><span class="keyword">int</span> T[MAXN], IT[MAXN];</span><br><span class="line"><span class="keyword">int</span> Tk[MAXN], ITk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(<span class="keyword">int</span>* ret, <span class="keyword">int</span>* p, <span class="keyword">int</span>* q)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = p[q[i]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span>* I, <span class="keyword">int</span>* p)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) I[p[i]] = i; &#125;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], ret[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = i;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) &#123; mul (A, ret, x); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ret[i] = A[i]; &#125;</span><br><span class="line">mul (A, x, x); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) x[i] = A[i];</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) x[i] = ret[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, a[i]);</span><br><span class="line">&#125; <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) n = <span class="number">6</span>;</span><br><span class="line">mul (a[<span class="number">1</span>], P, ITk), mul (A, Tk, a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[<span class="number">1</span>][i] = A[i];</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123; print (a[<span class="number">1</span>]); <span class="keyword">return</span> ; &#125;</span><br><span class="line">mul (a[<span class="number">2</span>], Q, ITk), mul (A, Tk, a[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[<span class="number">2</span>][i] = A[i];</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) &#123; print (a[<span class="number">2</span>]); <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) a[i + <span class="number">2</span>][a[i][j]] = a[i + <span class="number">1</span>][j];</span><br><span class="line">print (a[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) P[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) Q[i] = getnum ();</span><br><span class="line">inv (IP, P), inv (IQ, Q);</span><br><span class="line">mul (T, IQ, P), mul (A, IP, T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) T[i] = A[i];</span><br><span class="line">mul (A, Q, T); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) T[i] = A[i];</span><br><span class="line">inv (IT, T); <span class="keyword">int</span> k = K / <span class="number">6</span>; <span class="keyword">if</span> (! (K % <span class="number">6</span>)) k --;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) Tk[i] = T[i]; power (Tk, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ITk[i] = IT[i]; power (ITk, k);</span><br><span class="line"><span class="keyword">int</span> r = K % <span class="number">6</span>; solve (r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C：Synchronized-Subsequence"><a href="#Problem-C：Synchronized-Subsequence" class="headerlink" title="Problem C：Synchronized Subsequence"></a>Problem C：Synchronized Subsequence</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 $2n$ 的仅由字符 $\mathtt{a}, \mathtt{b}$ 构成的字符串，且 $\mathtt{a}$ 的个数恰好等于 $\mathtt{b}$ 的个数，都出现了 $n$ 次</p><p>你需要保留一些字符，剩下的字符删掉。对于一个 $i$，你可以保留从左往右数的第 $i$ 个 $\mathtt{a}$ 和第 $i$ 个 $\mathtt{b}$</p><p>注意，对于这两个字符，只能同时保留或同时删掉，不能只保留其中一个</p><p>请你求出能得到的字典序最大的串</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 3000$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>其实好像可以直接贪心来着，但我觉得 贪心 + $dp$ 的方法更值得记录</p><p>现在考虑若强制要求第 $i$ 对 $a, b$ 存在有什么样的局面，设第 $i$ 对 $a, b$ 在字符串中的位置 $apos_i. bpos_i$</p><ul><li>若 $apos_i &lt; bpos_i$，那么在把该对 $a, b$ 之间的 $a$ 全部删掉之前都不是更优的，故它们之间的 $a$ 应全部删去，最终留下 $ab$</li><li>若 $apos_i &gt; bpos_i$，显然它们之间的 $b$ 都必须全部存在</li></ul><p>那么现在记 $f_i$ 表示强制选第 $i$ 对 $a,b$，对 $i…n$ 对 $a, b$ 组合成的最大串，记 $g_i$ 表示 $\max (f_i, f_i + 1, …, f_n)$</p><p>注意 $f, g$ 都是 $\text{string}$ 类型</p><p>转移就看代码把</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">char</span> str[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> apos[MAXN]= &#123;<span class="number">0</span>&#125;, bpos[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> an = <span class="number">0</span>, bn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="comment">// f[i]: 强制选第i对a、b，对i...n对a、b的最大串</span></span><br><span class="line"><span class="comment">// g[i]: max (f[i], f[i + 1], ..., f[n])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%s"</span>, &amp; N, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N &lt;&lt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'a'</span>) apos[++ an] = i;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'b'</span>) bpos[++ bn] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">if</span> (apos[i] &lt; bpos[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= N &amp;&amp; apos[j] &lt; bpos[i]) j ++;</span><br><span class="line">f[i] = <span class="string">"ab"</span> + g[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= N &amp;&amp; bpos[j] &lt; apos[i]) j ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - i; k ++) f[i] += <span class="string">'b'</span>;</span><br><span class="line">f[i] += <span class="string">'a'</span> + (i + <span class="number">1</span> == j ? g[i + <span class="number">1</span>] : f[i + <span class="number">1</span>]).substr(j - i - <span class="number">1</span>, <span class="built_in">string</span>::npos); <span class="comment">// j-i-1表示i...j-1都已经放完，取g[i+1]或f[i+1]的j...n段</span></span><br><span class="line">&#125;</span><br><span class="line">g[i] = max (f[i], g[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 集训 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（二十一）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>好了，又是爆零的一天，恭喜我自己</p><p>$\text{score：0 + 0 + 0 = 0   rk：27/27}$</p><h2 id="Problem-A：小卖部"><a href="#Problem-A：小卖部" class="headerlink" title="Problem A：小卖部"></a>Problem A：小卖部</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh 是一名数数大师。</p><p>现在小卖部有 $n$ 种商品，第 $i$ 种有 $a_i$ 个，价格为 $b_i$。</p><p>ysgh 总共去了 $Q$ 天小卖部，第 $i$ 天他只会购买编号在 $l_i \sim r_i$ 的商品。他的卡里有 $c_i$ 元，因此他只能购买价值和不超过 $c_i$ 元的物品。</p><p>ysgh 想要知道有多少种购买物品的方案。由于答案很大，你只需要输出答案对 $1000000007$ 取模后的结果。两种方案被认为是不同的当且仅当存在一种物品，其购买数量不同。</p><p>当然，ysgh玩了个小花招，你需要通过上一个询问的答案来推导下一个询问的参数。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有测试数据，满足 $1 \le n \le 10000, ~ 1 \le Q \le 50000, ~ 1 \le a_i, b_i, c_i \le 1000, 1 \le l’_i, r’_i \le n$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令 $C = 1000$</p><p>首先看得出来可以用生成函数搞，显然答案为 $F_i(x) = \prod\limits_{i = 1}^n \left(\sum\limits_{k = 0}^{a_i}x^{k \times b_i}\right)$</p><p>对 $F(x)$ 求个前缀和 $SF_n (x)$，并设 $SF_n(x)$ 逆元为 $I_n(x)$，答案就是 $SF_r(x)I_{l - 1}(x)$ 的前 $c$ 项系数和</p><p>然后我就开始 $FFT$、多项式求逆什么的乱搞，时间爆炸，然后爆零（虽然我连每次询问的 $l, r$ 都算错了）</p><p>好吧实际上上面那玩意儿继续化，可以变成 $F_i(x) = \frac{1 - x^{(a_i + 1)b_i}}{1 - x^{b_i}}$</p><p>接下来的步骤我觉着很有意思</p><p>首先把分子分母分开，就变成 $F_i(x) = (1 + x^{b_i} + x^{2b_i} + …)(1 - x^{(a_i + 1)b_i})$</p><p>假设现在要处理 $SF_i(x) = SF_{i - 1}(x)F_i(x)$，那么设 $SF_i(X), SF_{i - 1}(x)$ 的第 $k$ 项分别为 $g_k, f_k$，则有 $g_k = f_k + f_{k - b_i} + f_{k - 2b_i} + …$（乘 $F(x)$ 前半部分），然后 $g_k = g_k - g_{k - (a_i + 1)b_i}$（乘 $F(x)$ 后半部分），记得第二部分要倒推</p><p>接下来只需处理逆元，先直接 $O (C^2)$ 求出 $I_{n}(x)$，然后 $I_i(x) = I_{i + 1}(x)F_{i + 1}(x)$ 处理即可</p><p>还有一部处理，假设得到的最终多项式 $A(x) = SF_r(x)I_{l - 1}(x)$，然后要求 $\sum\limits_{i = 0}^cA(x)[x^i]$，这样还是需要一次多项式乘法，时间还是不行</p><p>此时可以令 $B(x) = \frac{A(x)}{1 - x} = A(x)(1 + x + x^2 + …)$，那么 $\sum\limits_{i = 0}^cA(x)[x^i] = B(x)[x^c]$，就可以 $O (C)$ 处理</p><p>说实话我觉得这些处理是真挺厉害的（但我觉得只是因为我太菜了）</p><p>时间复杂度 $O \left((n + Q)C\right)$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXC = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = <span class="number">1l</span>l * cnt * x % MOD;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % MOD, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span>* B, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= C; i ++) A[i] = (B[i] + (i &gt;= b[p] ? A[i - b[p]] : <span class="number">0</span>)) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = C; i &gt;= (a[p] + <span class="number">1</span>) * b[p]; i --)</span><br><span class="line">A[i] = (A[i] - A[i - (a[p] + <span class="number">1</span>) * b[p]] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span>* inv)</span> </span>&#123;</span><br><span class="line">inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">inv[i] = (inv[i] - <span class="number">1l</span>l * inv[j] * A[i - j] % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN][MAXC]= &#123;<span class="number">0</span>&#125;, inv[MAXN][MAXC]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen ("A.in", "r", stdin);</span></span><br><span class="line"><span class="comment">// freopen ("A.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">N = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum (), b[i] = getnum ();</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, inv[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) mul (sum[i], sum[i - <span class="number">1</span>], i);</span><br><span class="line">inverse (sum[N], inv[N]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) mul (inv[i], inv[i + <span class="number">1</span>], i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line">inv[i][j] = (inv[i][j] + inv[i][j - <span class="number">1</span>]) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= Q; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum (), V = getnum ();</span><br><span class="line">l = (l + ans) % N + <span class="number">1</span>, r = (r + ans) % N + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) swap (l, r);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i ++) ans = (ans + <span class="number">1l</span>l * sum[r][i] * inv[l - <span class="number">1</span>][V - i] % MOD) % MOD;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Problem-B：博弈"><a href="#Problem-B：博弈" class="headerlink" title="Problem B：博弈"></a>Problem B：博弈</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>ysgh 有一棵 $n$ 个节点的树，树上在 $1$ 有一颗棋子。</p><p>ysgh 和 ysgs 利用这个棋子开始 van 游戏。具体的，ysgh 和 ysgs 轮流移动这个棋子，ysgh 先手。每次移动时，需要满足本次移动的树上距离严格大于上一次移动的树上距离（第一次移动需要满足树上距离不为 $0$），无法移动着输。他们称此游戏为 ogsc。ysgh 和 ysgs 都会做出游戏的最优决策。</p><p>ysgh 和 ysgs van 了很多游戏，渐渐觉得无聊了。</p><p>现在他们打算 van 以下游戏：</p><p>给定一颗 $n$ 个节点的树。ysgs 会选出一个包含节点 $1$ 的联通子树进行 ogsc 游戏。在两人均作最优决策的情况下，有多少个 ysgs 必胜的游戏。由于答案很大，只需要算对 $998244353$ 取膜的结果。</p><p>ysgs 花了 $0.5s$ 报出了答案，但是 ysgh 不知道是不是对的，于是他们找到了在一旁吃瓜的你。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 2e05, ~ T \le 10$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>后手必胜的条件：$1$ 位于树直径的中点上</p></blockquote><p>此时若先手到达一个距离 $1$ 为 $d$ 的点上，那么后手总是可以合法地到达与先手不在同一棵 $1$ 的子树，并且<strong>距离 $1$ 也为 $d$</strong> 的点，那么先手最终一定会被迫到达直径的一个端点，之后后手走到另一个直径的端点，那么先手就无法移动了</p><p>而若 $1$ 不在树直径的中点上，那么先手可以移动到树直径中点，而使得后手必输</p><p>现在问题转化为有多少棵连通子树满足 $1$ 位于树直径中点上</p><p>设 $f_{u, j}$ 表示以点 $u$ 为根，有多少个连通子树 $T’$ 满足 $\forall p \in T’, ~ dist (u, p) \le j$，其中 $dist (u, v)$ 表示点 $u, v$ 的树上距离</p><p>假设我们求出所有以 $1$ 为根的连通子树个数为 $tot$，那么此时只需枚举 $1$ 的每个儿子 $u$，以及 $u$ 的连通子树离 $u$ 的最大距离 $j$，强制令 $u$ 的连通子树为深度最深的，以其余 $1$ 的儿子为根的连通子树最大深度都小于它，那么这样的方案一定是不合法的，因为直径中点不可能是 $1$，统计方案数</p><p>令 $S_u$ 表示 $u$ 的儿子集合，$l_u$ 表示点 $u$ 在子树中可以到达的最远距离，公式化地，有<br>$$<br>ans = tot - \sum\limits_{u \in S_1}\sum\limits_{j = 0}^{l_u} (f_{u, j} - f_{u, j - 1}) \prod\limits_{v \in S_1 \cap u \neq v} f_{v, \min(l_v, j - 1)}<br>$$<br>那么现在问题转化为求解 $f_{u, j}$</p><p>考虑暴力，显然有<br>$$<br>\begin{aligned}<br>&amp;f_{u, 0} = 2 \\<br>&amp;f_{u, j} = 1 + \prod\limits_{v \in S_u} f_{v, j - 1}<br>\end{aligned}<br>$$<br>复杂度的症结在于 $j$ 的大小是由 $l_1$ 决定的，但实际上我们观察 $f_{v, j - 1}$ 对 $f_{u, j}$ 的贡献，只有满足 $j \le l_v$ 的才有可能被贡献到，因为 $\forall j \in (l_v, l_1], f_{v, j} = f_{v, l_v}$，看到这公式可以想到什么？长链剖分！</p><p>需要额外处理的是 $f_{v, l_v}$ 对 $f_{u, j}, j \in (l_v + 1, l_u]$，不妨用一个数组 $g$ 来储存它，即 $g_u = f_{u, l_u}$，而显然我们又不能枚举 $l_u$，这一部分的答案一开始是由重儿子继承过来的，但它们都乘上相同的 $g_v$，那么不妨用类似标记永久化的方法来记录这个 $g_v$，标记 $\forall j \in [0, l_u] f_{u, j} = f_{u, j} \times g_v$，很显然对 $j \in [0, l_v + 1]$ 还需要把 $g_v$ 除掉，因为它们不需要这个贡献</p><p>然而转移公式里还有一个 $+ 1$，那么用 $mul_u, add_u$ 分别表示标记永久化的乘和加，还需要记录一个 $imul_u$ 来记录需要除掉的 $g_v$，用 $dp_{u, j}$ 来表示没有乘上过标记的数值，它可以和 $f$ 互相转化<br>$$<br>\begin{aligned}<br>&amp;f_{u, j} = dp_{u, j} \times mul_u + add_u \\<br>&amp;dp_{u, j} = \frac{f_{u, j} - add_u}{mul_u}<br>\end{aligned}<br>$$<br>不妨用函数来表示这么一个变换，$f(u, j) = dp_{u, j} \times mul_u + add_u$ 以及 $df (u, r) = \frac{r - add_u}{mul_u}$，那么 $dp_{u, j}$ 在转移的时候就需要一直保持没累计过标记的数值，即 $dp_{u, j} = df (u, f(u, j) \times f(v, j - 1))$</p><p>但是注意，可能会存在某时刻 $f (v, l_u) \equiv 0 \pmod{998244353}$，也就是 $\forall j \in (l_v, l_u], f (u, j) = 0$，用 $lim_u$ 来记录这种 $l_v + 1$，$z_u$ 来记录在当前情况下，$0$ 所对应的未累计标记过的数值，即 $df (u, 0)$，那么对 $j &lt; lim_u$ 则照常，对 $j \ge lim_u$ 则有 $f(u, j) = z_u \times mul_u + add_u$，其实就是直接赋值 $z_u \rightarrow dp_{u, j}$</p><p>时间复杂度 $O (T \times n)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = <span class="number">1l</span>l * cnt * x % MOD;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = power (<span class="number">2</span>, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[MAXN]= &#123;<span class="number">0</span>&#125;, son[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">len[root] = <span class="number">0</span>, son[root] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line"><span class="keyword">if</span> (son[root] == - <span class="number">1</span> || len[v] &gt; len[son[root]])</span><br><span class="line">son[root] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (~ son[root]) len[root] = len[son[root]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[MAXN &lt;&lt; <span class="number">1</span>], *dp[MAXN], *id;</span><br><span class="line"><span class="keyword">int</span> mul[MAXN], imul[MAXN], add[MAXN], g[MAXN], ig[MAXN];</span><br><span class="line"><span class="keyword">int</span> lim[MAXN], zero[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">k = min (k, len[n]);</span><br><span class="line"><span class="keyword">if</span> (lim[n] &lt;= k) <span class="keyword">return</span> (<span class="number">1l</span>l * zero[n] * mul[n] % MOD + add[n]) % MOD;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1l</span>l * dp[n][k] * mul[n] % MOD + add[n]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">df</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * r - add[n] + MOD) % MOD * imul[n] % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (son[u] == - <span class="number">1</span>) &#123;</span><br><span class="line">mul[u] = imul[u] = <span class="number">1</span>;</span><br><span class="line">add[u] = g[u] = <span class="number">2</span>;</span><br><span class="line">lim[u] = N + <span class="number">1</span>, ig[u] = inv2;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">dp[son[u]] = dp[u] + <span class="number">1</span>;</span><br><span class="line">DP (son[u], u);</span><br><span class="line">mul[u] = mul[son[u]], imul[u] = imul[son[u]], add[u] = add[son[u]];</span><br><span class="line">lim[u] = lim[son[u]], zero[u] = zero[son[u]];</span><br><span class="line">dp[u][<span class="number">0</span>] = df (u, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == fa || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">dp[v] = id, id += len[v] + <span class="number">1</span>, DP (v, u);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[v] + <span class="number">1</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (lim[u] == j) dp[u][j] = zero[u], lim[u] ++;</span><br><span class="line">dp[u][j] = df (u, <span class="number">1l</span>l * f (u, j) * f (v, j - <span class="number">1</span>) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! g[v]) &#123; lim[u] = len[v] + <span class="number">2</span>, zero[u] = df (u, <span class="number">0</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">mul[u] = <span class="number">1l</span>l * mul[u] * g[v] % MOD;</span><br><span class="line">imul[u] = <span class="number">1l</span>l * imul[u] * ig[v] % MOD;</span><br><span class="line">add[u] = <span class="number">1l</span>l * add[u] * g[v] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v] + <span class="number">1</span>; j ++)</span><br><span class="line">dp[u][j] = df (u, <span class="number">1l</span>l * f (u, j) * ig[v] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">add[u] = (<span class="number">1l</span>l * add[u] + <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="keyword">if</span> (son[fa] != u) &#123; g[u] = f (u, len[u]); ig[u] = power (g[u], MOD - <span class="number">2</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> gr[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stati</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">gr[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">stati (v, u);</span><br><span class="line">gr[u] = <span class="number">1l</span>l * gr[u] * (gr[v] + <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> subpro[MAXN], subflo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)), size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span> (tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> (tmp));</span><br><span class="line">id = tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">mul[i] = imul[i] = add[i] = lim[i] = zero[i] = g[i] = ig[i] = <span class="number">0</span>;</span><br><span class="line">subpro[i] = subflo[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); dp[<span class="number">1</span>] = id, id += len[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[<span class="number">1</span>]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">dp[v] = id, id += len[v] + <span class="number">1</span>; DP (v, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v]; j ++)</span><br><span class="line">subpro[j] = <span class="number">1l</span>l * subpro[j] * f (v, j) % MOD;</span><br><span class="line"><span class="keyword">if</span> (len[v] + <span class="number">1</span> &lt;= len[<span class="number">1</span>]) subflo[len[v] + <span class="number">1</span>] = <span class="number">1l</span>l * subflo[len[v] + <span class="number">1</span>] * f (v, len[v]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len[<span class="number">1</span>]; i ++) subflo[i] = <span class="number">1l</span>l * subflo[i - <span class="number">1</span>] * subflo[i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len[<span class="number">1</span>]; i ++) subpro[i] = <span class="number">1l</span>l * subpro[i] * subflo[i] % MOD;</span><br><span class="line">stati (<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> ans = gr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[<span class="number">1</span>]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[v]; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> del = (<span class="number">1l</span>l * f (v, j) - (j &gt; <span class="number">0</span> ? f (v, j - <span class="number">1</span>) : <span class="number">1</span>) + MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) del = <span class="number">1l</span>l * del * subpro[j - <span class="number">1</span>] % MOD * power (f (v, j - <span class="number">1</span>), MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">ans = (<span class="number">1l</span>l * ans - del + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum (); init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Problem-C：网络流"><a href="#Problem-C：网络流" class="headerlink" title="Problem C：网络流"></a>Problem C：网络流</h3>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 树上DP </tag>
            
            <tag> 集训 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>晚了几天写，暴力场</p><p>$\text{score：40 + 40 + 45 = 125   rk：17/30}$</p><h2 id="Problem-A：Tree"><a href="#Problem-A：Tree" class="headerlink" title="Problem A：Tree"></a>Problem A：Tree</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/At2B5jTuCRhF9Yv.png" alt=""></p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^8, ~ 1000 \le k \le 10^8$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很容易发现，满足条件等价于要求树中没有任意一条从根出发的路径经过超过 $k - 1$ 个左儿子</p><p>然后就是一个很妙的转换，将树按如下规则变为括号序列：</p><p>子树 $u$ 括号序 = ‘(‘ + ‘$u$ 左子树括号序’ + ‘)’ + ‘$u$ 右子树括号序</p><p>给个题解的图例</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/UzbMDAGx3FZ7nJX.jpg" alt=""></p><p>实际上可以不用考虑叶节点，那么现在将 $n$ 变为 $n - 1$，$k$ 变为 $k - 2$</p><p>那么现在的任务就变为在坐标系中将左括号看作往右上角走，右括号看作往右下角走，从 $(0, 0)$ 最终走到 $(2n, 0)$ 的方案数，并需要满足过程中纵坐标始终在 $[0, k]$ 中的方案数（注意此时 $n, k$ 已变化）</p><p>这就是类似卡特兰数，但是有两条限制，即不能碰到 $y = - 1$ 也不能碰到 $y = k + 1$</p><p>又从 $(x1, y1)$ 走到 $(x_2, y_2)$ 无限制的方案数为 $f(x_1, y_1, x_2, y_2) = \dbinom{|x_1 - x_2|}{\frac{|x_1 - x_2| + |y_1 - y_2|}{2}}$</p><p>考虑容斥，首先有总方案数 $f(0, 0, 2n, 0)$，再取对称一次、两次、三次。。求方案数</p><p>对称一次即对称到 $(0, -2), (0, 2k + 2)$，减去其到 $(2n, 0)$ 的方案数</p><p>对称两次分类讨论，先经过 $y = - 1$ 再经过 $y = k + 1$ 或先经过 $y = k + 1$ 再经过 $y = - 1$，对第一种情况，对称两次后到 $(0, 2k + 4)$，对第二种，到 $(0, - 2k - 4)$，再加上它们到 $(2n, 0)$ 的方案数</p><p>但是会发现这样会多加上对称三次的答案，所以还需减去对称三次中讨论的答案</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/22/7TaRXmWoSwKB61p.png" alt=""></p><p>举个例子，考虑上图这样一个运动轨迹，那么它一共会被这些所计算到：先下再上、先上再下、下上下、上下上、下上下上</p><p>实际上有应该作贡献的只有最后一个“下上下上”而已，所以是要容斥的</p><p>可以知道没两次对称就可以使纵坐标绝对值增加 $2k + 4$，当纵坐标绝对值超过 $2n$ 时，显然贡献为 $0$，此时就可以停止，那么计算总次数大约为 $\frac{4n}{k}$</p><p>时间复杂度 $O (\frac{n}k \log_p n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = MOD + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;, invfact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lucas</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MOD &amp;&amp; m &lt;= MOD) <span class="keyword">return</span> C (n, m);</span><br><span class="line"><span class="keyword">return</span> C (n % MOD, m % MOD) * lucas (n / MOD, m / MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sym</span> <span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p ? - y - <span class="number">2</span> : - y + <span class="number">2</span> * k + <span class="number">2</span>; &#125; <span class="comment">// y = - 1 &amp; y = k + 1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">path</span> <span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> lucas (<span class="number">2</span> * n, n + y / <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">n = N - <span class="number">1</span>, k = K - <span class="number">2</span>;</span><br><span class="line">fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MOD; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[MOD - <span class="number">1</span>] = power (fact[MOD - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MOD - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i --) invfact[i] = invfact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">2</span> * k + <span class="number">2</span>, down = - <span class="number">2</span>, p = <span class="number">1</span>;</span><br><span class="line">LL ans = lucas (<span class="number">2</span> * n, n);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span> (up) &gt; <span class="number">2</span> * n &amp;&amp; <span class="built_in">abs</span> (down) &gt; <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> t = p == <span class="number">1</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">ans = (ans + t * path (up) % MOD + MOD) % MOD;</span><br><span class="line">ans = (ans + t * path (down) % MOD + MOD) % MOD;</span><br><span class="line">up = sym (up, p), down = sym (down, p ^ <span class="number">1</span>);</span><br><span class="line">p ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：文本编辑器"><a href="#Problem-B：文本编辑器" class="headerlink" title="Problem B：文本编辑器"></a>Problem B：文本编辑器</h2><h2 id="Problem-C：第k深-kth"><a href="#Problem-C：第k深-kth" class="headerlink" title="Problem C：第k深(kth)"></a>Problem C：第k深(kth)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个 $n$ 个点的有根树，$1$ 为根，带边权，有 $m$ 次操作</p><ul><li>操作 $1$：求 $x$ 的子树中第 $k$ 小的深度的值，如果子树中没有 $k$ 个点则输出 $- 1$</li><li>操作 $2$：将 $x$ 与 $x$ 父亲的边权加上 $k$</li></ul><p>保证每次操作 $2$ 的 $k$ 以及原树的边权小于等于一个数 $len$<br>如果操作 $2$ 中 $x$ 为 $1$，那么视为将 $x$ 的基础深度加上了 $k$</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n, m \le 10^5, ~ 1 \le len \le 10, ~ k \in N^+$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原题 <a href="https://www.luogu.com.cn/problem/P3712" target="_blank" rel="noopener">少女与战车</a></p><p>$\text{lxl}$ 分块题。。</p><p>首先搞出每个点的 $DFS$ 序，那么每次修改就是区间加</p><p>现在考虑如何分块，据说这种分块方式可能叫双关键字分块？</p><p>对每一块，保证</p><ul><li>每一块最大（小）值 $max(min)$，块左右端点 $l, r$，满足，$max - min \le 2\sqrt{10m}$ 且 $r - l + 1 \le \sqrt n$</li></ul><p>那么这样就可以保证块的分割点个数不超过 $\frac{10m}{\sqrt{10m}} + \frac{n}{\sqrt n}$</p><p>查询二分，然后在每个块内存块每个元素比块中最小值大多少，并记录它们的个数，那么每次 $check$ 的时候就可以 $O (1)$ 查询块内比 $mid$ 小的点的个数</p><p>然后每修改 $1000$ 重新分块，修改 $1000$ 次后块内最大最小值差不会新增超过 $20000$，这也是数组能存下的极限</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXB = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, w, next; &#125; ;</span><br><span class="line">LFS Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN]= &#123;<span class="number">0</span>&#125;, ord = <span class="number">0</span>;</span><br><span class="line">LL d[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, LL dist)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line">dfn[root] = ++ ord; d[ord] = dist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line">DFS (v, dist + w);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="keyword">int</span> bel[MAXN]= &#123;<span class="number">0</span>&#125;, bl[MAXB]= &#123;<span class="number">0</span>&#125;, br[MAXB]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">LL mini[MAXB]= &#123;<span class="number">0</span>&#125;, maxi[MAXB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXB][MAXV]= &#123;<span class="number">0</span>&#125;, lazy[MAXB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">mini[i] = LINF, maxi[i] = - LINF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bl[i]; j &lt;= br[i]; j ++) &#123;</span><br><span class="line">d[j] += lazy[i];</span><br><span class="line">mini[i] = min (mini[i], d[j]);</span><br><span class="line">maxi[i] = max (maxi[i], d[j]);</span><br><span class="line">&#125;</span><br><span class="line">lazy[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxi[i] - mini[i]; j ++) subsum[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bl[i]; j &lt;= br[i]; j ++) subsum[i][d[j] - mini[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxi[i] - mini[i]; j ++) subsum[i][j] += subsum[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! lazy[p]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[p]; i &lt;= br[p]; i ++) d[i] += lazy[p];</span><br><span class="line">lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) pushdown (i);</span><br><span class="line">LL mi = LINF, ma = - LINF; m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">mi = min (mi, d[i]), ma = max (ma, d[i]);</span><br><span class="line"><span class="keyword">if</span> (ma - mi &gt; V || i - br[m - <span class="number">1</span>] &gt; lim) &#123;</span><br><span class="line">bl[m] = br[m - <span class="number">1</span>] + <span class="number">1</span>, br[m] = i - <span class="number">1</span>;</span><br><span class="line">mi = ma = d[i]; m ++;</span><br><span class="line">&#125;</span><br><span class="line">bel[i] = m;</span><br><span class="line">&#125;</span><br><span class="line">bl[m] = br[m - <span class="number">1</span>] + <span class="number">1</span>, br[m] = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) maintain (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bel[l] + <span class="number">1</span> &gt;= bel[r]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) d[i] += x;</span><br><span class="line">maintain (bel[l]); maintain (bel[r]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= br[bel[l]]; i ++) d[i] += x;</span><br><span class="line">maintain (bel[l]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l] + <span class="number">1</span>; i &lt;= bel[r] - <span class="number">1</span>; i ++) &#123; lazy[i] += x; mini[i] += x, maxi[i] += x; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[bel[r]]; i &lt;= r; i ++) d[i] += x;</span><br><span class="line">maintain (bel[r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, LL mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bel[l] + <span class="number">1</span> &gt;= bel[r]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= br[bel[l]]; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l] + <span class="number">1</span>; i &lt;= bel[r] - <span class="number">1</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (mid - mini[i] &gt;= <span class="number">0</span>)</span><br><span class="line">cnt += subsum[i][min (maxi[i] - mini[i], mid - mini[i])];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bl[bel[r]]; i &lt;= r; i ++) cnt += d[i] &lt;= mid;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">pushdown (bel[l]); pushdown (bel[r]);</span><br><span class="line">LL left = LINF, right = - LINF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bel[l]; i &lt;= bel[r]; i ++) &#123;</span><br><span class="line">left = min (left, mini[i]);</span><br><span class="line">right = max (right, maxi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> left;</span><br><span class="line">LL ans = left;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">LL mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (l, r, k, mid)) &#123; ans = mid; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), len = getnum ();</span><br><span class="line">lim = <span class="built_in">sqrt</span> (N); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa = getnum (), w = getnum ();</span><br><span class="line">Insert (fa, i, w);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> modi = <span class="number">0</span>;</span><br><span class="line">build ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), x = getnum (), k = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[x] &lt; k) &#123; <span class="built_in">puts</span> (<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, query (dfn[x], dfn[x] + subsize[x] - <span class="number">1</span>, k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">modi ++;</span><br><span class="line"><span class="keyword">if</span> (! (modi % <span class="number">1000</span>)) build ();</span><br><span class="line">modify (dfn[x], dfn[x] + subsize[x] - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十二）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>中下</p><p>$\text{score：24 + 40 + 0 = 64   rk：23/34}$</p><h2 id="Problem-A：Mythological-V"><a href="#Problem-A：Mythological-V" class="headerlink" title="Problem A：Mythological V"></a>Problem A：Mythological V</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小S打算送给小M一棵 $n$ 个点的圣诞树，点从 $1$ 到 $n$ 标号，他打算给树上挂上 $m$ 个礼物，每个礼物在树上的某个点上，礼物可以重叠。</p><p> 小M给了小S $q$ 个限制，其中第 $i$ 个形如“第 $a_i$ 个礼物和第 $b_i$ 个礼物在树上的最短路径经过了点 $c_i$”。</p><p> 小S想要构造出符合小M条件的挂礼物方案。可怜的小S当然不会啦，所以他向你求助。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$n, m \le 250, ~ q \le 5 \times 10^4$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>好久没写过 $2-SAT$ 了</p><p>虽然我的暴力虽然 $\text{WA}$ 了但竟然没有 $\text{T}$？说不定改对了能过呢</p><p>考虑两个礼物 $a, b$ 放置位置经过 $c$ 代表着什么，说明 $a, b$ 放置的位置在以 $c$ 为根的树上位于不同的 $c$ 儿子的子树上</p><p>那么现在以 $1$ 为根，设 $g_{i, j, 0}$ 表示第 $j$ 个礼物不在 $i$ 点的子树上，而 $g_{i, j, 1}$ 表示在</p><p>对每个题目所给限制，连边有 $g_{c, a, 0} \rightarrow g_{c, b, 1}$（表示 $a$ 在 $c$ 祖先不包括 $c$ 的子树中，那么 $b$ 一定在 $c$ 子树中）、$g_{i, a, 1} \rightarrow g_{i, b, 0}$、$g_{i, b, 1} \rightarrow g_{i, a, 0}$（其中 $i$ 表示 $c$ 的儿子结点）</p><p>当然还有最基本的限制，对某个节点 $u$ 以及某个礼物 $i$，$g_{1, i, 0} \rightarrow g_{1, i, 1}$（强制要求 $i$ 在 $1$ 的子树中）、$g_{u, i, 1} \rightarrow g_{fa_u, i, 1}$、$g_{u, i, 0} \rightarrow g_{son_u, i, 0}$、$g_{u, i, 1} \rightarrow g_{v, i, 0}$（其中 $u, v$ 的两个子树无交集）</p><p>时间复杂度 $O (N + M) = O (n^2m + qn^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">250</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = MAXN * MAXN * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">3e07</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, next; &#125; ;</span><br><span class="line">LFS Link[MAXL];</span><br><span class="line"><span class="keyword">int</span> Head[MAXK]= &#123;<span class="number">0</span>&#125;, size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;, depth[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">father[root] = fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) G[root].size(); i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[root][i];</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isanc</span> <span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> x == y ? <span class="literal">true</span> : isanc (y, father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[MAXK]= &#123;<span class="number">0</span>&#125;, low[MAXK]= &#123;<span class="number">0</span>&#125;, ord = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXK]= &#123;<span class="number">0</span>&#125;, top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> insta[MAXK]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> bel[MAXK]= &#123;<span class="number">0</span>&#125;, co = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ ord;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = u; insta[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (! dfn[v]) &#123;</span><br><span class="line">Tarjan (v);</span><br><span class="line">low[u] = min (low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (insta[v]) low[u] = min (low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">co ++; <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">x = <span class="built_in">stack</span>[top --];</span><br><span class="line">insta[x] = <span class="literal">false</span>, bel[x] = co;</span><br><span class="line">&#125; <span class="keyword">while</span> (x != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">G[u].push_back(v); G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">depth[<span class="number">1</span>] = <span class="number">1</span>, DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">g[i][j][<span class="number">1</span>] = ++ m, g[i][j][<span class="number">0</span>] = ++ m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = getnum (), b = getnum (), u = getnum ();</span><br><span class="line"><span class="keyword">if</span> (father[u]) &#123; Insert (g[u][a][<span class="number">0</span>], g[u][b][<span class="number">1</span>]); Insert (g[u][b][<span class="number">0</span>], g[u][a][<span class="number">1</span>]); &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) G[u].size(); j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][j];</span><br><span class="line"><span class="keyword">if</span> (v != father[u]) &#123;</span><br><span class="line">Insert (g[v][a][<span class="number">1</span>], g[v][b][<span class="number">0</span>]);</span><br><span class="line">Insert (g[v][b][<span class="number">1</span>], g[v][a][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (father[i]) Insert (g[i][j][<span class="number">1</span>], g[father[i]][j][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="keyword">int</span>) G[i].size(); k ++)</span><br><span class="line"><span class="keyword">if</span> (G[i][k] != father[i])</span><br><span class="line">Insert (g[i][j][<span class="number">0</span>], g[G[i][k]][j][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) Insert (g[<span class="number">1</span>][i][<span class="number">0</span>], g[<span class="number">1</span>][i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (! isanc (i, j) &amp;&amp; ! isanc (j, i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= M; k ++)</span><br><span class="line">Insert (g[i][k][<span class="number">1</span>], g[j][k][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line"><span class="keyword">if</span> (! dfn[i])</span><br><span class="line">Tarjan (i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (bel[g[i][j][<span class="number">1</span>]] &lt; bel[g[i][j][<span class="number">0</span>]])</span><br><span class="line">ans[j] = depth[ans[j]] &lt; depth[i] ? i : ans[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">&#125; <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：Mythological-IV"><a href="#Problem-B：Mythological-IV" class="headerlink" title="Problem B：Mythological IV"></a>Problem B：Mythological IV</h2><h2 id="Problem-C：Mythological-VII"><a href="#Problem-C：Mythological-VII" class="headerlink" title="Problem C：Mythological VII"></a>Problem C：Mythological VII</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>数轴上有一行 $n$ 个点，每个点有权值。小M和小S在上面玩游戏。</p><p>小M和小S一开始都在第 $k$ 号点上，小M只能向左移动，小S只能向右移动。</p><p>令 $p_x$ 表示当前时刻小M的位置，$p_y$ 表示当前时刻小S的位置，要求任意时刻都满足 $(p_x, p_y]$ 这个区间的所有数和都 $\le 0$。</p><p>现在，小M想要知道 $p_x, p_y$ 能否同时等于 $1, n$。可怜的小M当然不会啦，所以她向你求助。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对 $100\%$ 的数据，$1 \le n \le 10^5, ~ T \le 20, ~ a_i \in [- 10^{13}, 10^{13}]$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题目是要满足前缀和 $sum_l \ge sum_r$</p><p>与 <a href="https://colythme.github.io/2020/07/26/「JOISC%202017%20Day%201」烟花棒/">「JOISC 2017 Day 1」烟花棒</a> 贪心部分是相同的</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e09</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, K;</span><br><span class="line">LL a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] &lt; a[N]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> l = K, r = K, ll = K, lr = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[ll])</span><br><span class="line">ll = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[lr])</span><br><span class="line">lr = i;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &gt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl - <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &lt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr + <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">1</span>, r = N;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &lt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl + <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &gt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr - <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">solve () ? <span class="built_in">puts</span> (<span class="string">"Yes"</span>) : <span class="built_in">puts</span> (<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长乐集训 - NOI模拟赛（三十三）「订正未完成」</title>
      <link href="/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/"/>
      <url>/2020/08/04/%E9%95%BF%E4%B9%90%E9%9B%86%E8%AE%AD%20-%20NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89%E3%80%8C%E8%AE%A2%E6%AD%A3%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>没交</p><p>$\text{score：NULL            rk：NULL}$</p><h2 id="Problem-A：区间第k小"><a href="#Problem-A：区间第k小" class="headerlink" title="Problem A：区间第k小"></a>Problem A：区间第k小</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/znS2C4hFuYj79VT.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/c8je9HNIn4CoEyW.png" alt=""></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑离线，整体二分，二分答案 $mid$，处理所有 $\le mid$ 的数，那么此时问题就转化为在区间出现次数不超过 $w$ 的数有多少个</p><p>不妨关注每个数对询问区间 $[L, R]$ 的贡献，对某个数 $a$，若它是从左往右后 $w$ 个出现为 $a$ 的数，则它的贡献为 $1$，若为倒数第 $w + 1$ 个则贡献为 $- w$，剩下的贡献都为 $0$，那么我们就可以开一个队列，首先总大小（即不删去超过 $w$ 的）算出来，此时计算需要删去的，队列大小未到 $w$ 时没有需要删的，若大于 $w$ 时每次就让队首点贡献减去 $w + 1$，当然之前多减的还要加回来</p><p>那么现在就可以考虑从离线转成在线，在整体二分的过程中每一层（即每一次二分的 $[l, r]$）都会建一些可持久化线段树，而它又最多会修改 $O (n \log n)$ 次，开 $O (n \log^2 n)$ 个节点，所以把每一层的可持久化线段树都存下来，在线二分时即可直接查找，总时间复杂度 $O (n \log^2 n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXL * MAXL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, W, Q, type;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[MAXM]= &#123;<span class="number">0</span>&#125;, rson[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsum[MAXM]= &#123;<span class="number">0</span>&#125;, nd = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span>&amp; p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">lson[p = ++ nd] = lson[pre], rson[p] = rson[pre];</span><br><span class="line">subsum[p] = subsum[pre] + x;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson[pre], lson[p], left, mid, posi, x);</span><br><span class="line"><span class="keyword">else</span> modify (rson[pre], rson[p], mid + <span class="number">1</span>, right, posi, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123; <span class="comment">// &gt;= posi的和</span></span><br><span class="line"><span class="keyword">if</span> (right &lt; posi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= left) <span class="keyword">return</span> subsum[p];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> subsum[rson[p]] + query (lson[p], left, mid, posi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query (rson[p], mid + <span class="number">1</span>, right, posi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rt[MAXN &lt;&lt; <span class="number">2</span>], posi[MAXL + <span class="number">10</span>], use[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que[MAXN];</span><br><span class="line"><span class="keyword">int</span> ldel[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>, n = posi[d].size();</span><br><span class="line">use[p].resize(n); posi[d + <span class="number">1</span>].clear(), posi[d + <span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d][i];</span><br><span class="line"><span class="keyword">if</span> (a[t] &lt;= mid) &#123;</span><br><span class="line">posi[d + <span class="number">1</span>].push_back(t);</span><br><span class="line">use[p][i] = use[p][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">ldel[a[t]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> use[p][i] = use[p][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lim = posi[d + <span class="number">1</span>].size();</span><br><span class="line">rt[p].resize(lim);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d + <span class="number">1</span>][i], x = a[t];</span><br><span class="line">que[x].push(i);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) que[x].size() &gt; W) &#123;</span><br><span class="line">modify (rt[p][i - <span class="number">1</span>], rt[p][i], <span class="number">1</span>, lim - <span class="number">1</span>, que[x].front(), - W - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ldel[x]) modify (rt[p][i], rt[p][i], <span class="number">1</span>, lim - <span class="number">1</span>, ldel[x], W);</span><br><span class="line">ldel[x] = que[x].front(); que[x].pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> rt[p][i] = rt[p][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d + <span class="number">1</span>][i], x = a[t];</span><br><span class="line"><span class="keyword">while</span> (! que[x].empty()) que[x].pop();</span><br><span class="line">&#125;</span><br><span class="line">build (left, mid, lp, d + <span class="number">1</span>);</span><br><span class="line">posi[d + <span class="number">1</span>].clear(), posi[d + <span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = posi[d][i];</span><br><span class="line"><span class="keyword">if</span> (a[t] &gt; mid) posi[d + <span class="number">1</span>].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">build (mid + <span class="number">1</span>, right, rp, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = use[p][L], r = use[p][R], n = rt[p].size();</span><br><span class="line"><span class="keyword">int</span> sum = r - l + query (rt[p][r], <span class="number">1</span>, n - <span class="number">1</span>, l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= k) <span class="keyword">return</span> solve (lp, left, mid, l, r, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> solve (rp, mid + <span class="number">1</span>, right, L - l, R - r, k - sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), W = getnum (), Q = getnum (), type = getnum ();</span><br><span class="line">posi[<span class="number">1</span>].resize(N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123; a[i] = getnum (); posi[<span class="number">1</span>][i] = i; &#125;</span><br><span class="line">build (<span class="number">0</span>, N, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> xxo = type * ans;</span><br><span class="line"><span class="keyword">int</span> l = getnum () ^ xxo, r = getnum () ^ xxo, k = getnum () ^ xxo;</span><br><span class="line">ans = solve (<span class="number">1</span>, <span class="number">0</span>, N, l - <span class="number">1</span>, r, k);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B：求和"><a href="#Problem-B：求和" class="headerlink" title="Problem B：求和"></a>Problem B：求和</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/eBd1iKnvg7Gf92A.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/YW1rji2cIUylMm5.png" alt=""></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先对式子进行变换<br>$$<br>\begin{aligned}<br>ans &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n\sum\limits_{d = 1}^k f_d(gcd(i, j)) \\<br>&amp;= \sum\limits_{x = 1}^n\sum\limits_{d = 1}^k f_d(x)\sum\limits_{i = 1}^{\lfloor\frac{n}{x}\rfloor}\sum\limits_{j = 1}^{\lfloor\frac{n}{x}\rfloor}[(i, j) = 1] \\<br>&amp;= \sum\limits_{x = 1}^n\sum\limits_{d = 1}^k f_d(x)\left((2\sum\limits_{i = 1}^{\lfloor\frac{n}{x}\rfloor}\varphi(i)) - 1\right)<br>\end{aligned}<br>$$<br>那么这时对 $n$ 整除分块到，$\sum\limits_{i = 1}^n \varphi(i)$ 就可以直接杜教筛求出，设此时分块到 $[l, r]$，现在考虑求解 $\sum\limits_{x = l}^r\sum\limits_{d = 1}^k f_d(x)$，当然前缀和是肯定的</p><p>令 $F_d(x) = \sum\limits_{i = 1}^n f_d(i)$，设质因数分解 $n = \prod\limits_i p_i^{c_i}$，令 $\lambda(x) = \prod\limits_i (- 1)^{c_i}$，$F_d(x)$ 则可以通过容斥求出<br>$$<br>\begin{aligned}<br>F_d(x) &amp;= \sum\limits_{i = 1}^x \mu(i)\sum\limits_{j = 1}^{\lfloor\frac{x}{i^{d + 1}}\rfloor}\lambda(i^{d + 1}j) \\<br>&amp;= \sum\limits_{i = 1}^x \lambda^{d + 1}(i)\mu(i)\sum\limits_{j = 1}^{\lfloor\frac{x}{i^{d + 1}}\rfloor}\lambda(j)<br>\end{aligned}<br>$$<br>第一步实际上就是类似求 $n$ 以内无平方因子数的方法，$i = 1$ 时为总方案，后面容斥删去不合法</p><p>而第二步是因为 $\lambda(x)$ 是一个完全积性函数</p><p>现在问题转化为求 $\sum\limits_{i = 1}^n \lambda(i)$，可以发现一个性质，$\sum\limits_{d |n} \lambda(i) = [n为完全平方数]$</p><p>下面给出证明</p><ul><li>设 $n = \prod\limits_i p_i^{c_i}$，考虑两个数 $p_1^2x, p_1^3x$，满足 $p_1^2x, p_1^3x | n$，若 $p_1^2x$ 的贡献为 $1$，那么 $p_1^3x$ 的贡献则一定为 $- 1$，那么以此类推，也就是 $0, 1$ 次、$2, 3$ 次、$4, 5$ 次…分别两两配对，若 $c_i$ 为奇数，则最后贡献总和一定为 $0$，若为偶数，最后则一定为 $1$</li></ul><p>这样的话就是 $\sqrt n = \lambda * 1$，就可以杜教筛了</p><p>那么对 $F_d(x)$，类似杜教筛预处理 $x$ 比较小的（注意用原式，即 $F_d(x) = \sum\limits_{i = 1}^n f_d(i)$ 来预处理），然后大的就直接暴力枚举，最多 $O (\sqrt n)$，那么这样总时间复杂度是 $O (n^{\frac23})$ 的</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e06</span> + <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N; <span class="keyword">int</span> K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN / <span class="number">10</span>], pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint phi[MAXN]= &#123;<span class="number">0</span>&#125;, sphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint lamda[MAXN]= &#123;<span class="number">0</span>&#125;, suml[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">uint sumf[MAXN]= &#123;<span class="number">0</span>&#125;; <span class="comment">// sumf(x): Σ(d=1~k)f[d](x)</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e06</span> + <span class="number">5e05</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = lamda[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">sumf[<span class="number">1</span>] = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! visit[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">phi[i] = i - <span class="number">1</span>, lamda[i] = - <span class="number">1</span>;</span><br><span class="line">a[i] = b[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">lamda[i * prime[j]] = - lamda[i];</span><br><span class="line">a[i * prime[j]] = a[i] + <span class="number">1</span>;</span><br><span class="line">b[i * prime[j]] = max (a[i * prime[j]], b[i]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">lamda[i * prime[j]] = - lamda[i];</span><br><span class="line">a[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">b[i * prime[j]] = b[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">suml[i] = suml[i - <span class="number">1</span>] + lamda[i];</span><br><span class="line">sphi[i] = sphi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">sumf[i] = sumf[i - <span class="number">1</span>]  + lamda[i] * max (<span class="number">0</span>, K - max (b[i], <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vp[MAXM]= &#123;<span class="literal">false</span>&#125;, vl[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint sp[MAXM], sl[MAXM];</span><br><span class="line"><span class="function">uint <span class="title">phi_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (vp[N / n]) <span class="keyword">return</span> sp[N / n];</span><br><span class="line">uint ret = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ret -= <span class="number">1u</span> * (r - l + <span class="number">1</span>) * phi_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vp[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sp[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint <span class="title">lamda_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> suml[n];</span><br><span class="line"><span class="keyword">if</span> (vl[N / n]) <span class="keyword">return</span> sl[N / n];</span><br><span class="line">uint ret = <span class="built_in">sqrt</span> (n);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ret -= <span class="number">1u</span> * (r - l + <span class="number">1</span>) * lamda_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vl[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sl[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL mpow[MAXL][<span class="number">42</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lim = <span class="built_in">sqrt</span> (N) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i ++) &#123;</span><br><span class="line">mpow[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K + <span class="number">1</span>; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mpow[i][j - <span class="number">1</span>] &gt; N) <span class="keyword">break</span>;</span><br><span class="line">mpow[i][j] = mpow[i][j - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vf[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">uint sf[MAXM];</span><br><span class="line"><span class="function">uint <span class="title">work</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumf[n];</span><br><span class="line"><span class="keyword">if</span> (vf[N / n]) <span class="keyword">return</span> sf[N / n];</span><br><span class="line">uint ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= K; d += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; mpow[i][d + <span class="number">1</span>] &amp;&amp; mpow[i][d + <span class="number">1</span>] &lt;= n; i ++)</span><br><span class="line">ret += mu[i] * lamda_sieve (n / mpow[i][d + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt;= K; d += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; mpow[i][d + <span class="number">1</span>] &amp;&amp; mpow[i][d + <span class="number">1</span>] &lt;= n; i ++)</span><br><span class="line">ret += lamda[i] * mu[i] * lamda_sieve (n / mpow[i][d + <span class="number">1</span>]);</span><br><span class="line">vf[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sf[N / n] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">init (); sieve ();</span><br><span class="line">uint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = N / (N / l);</span><br><span class="line">ans += (<span class="number">2u</span> * phi_sieve (N / l) - <span class="number">1</span>) * (work (r) - work (l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C-树"><a href="#Problem-C-树" class="headerlink" title="Problem C: 树"></a>Problem C: 树</h2>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
            <tag> 集训 </tag>
            
            <tag> 整体二分 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树求树的直径</title>
      <link href="/2020/08/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2020/08/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>线段树求直径可以求任意子树（包括连子树都不算的分散节点集合）的直径，适用范围广。</p><p>线段树的每个节点所对应的区间$[L, R]$，指代了$Dfn$在$[L, R]$内节点，其中线段树上每个节点存储了$diam$（当前区间直径）及$lp,  rp$（当前直径对应的左右端点），每次$Merge$操作分为全左区间、全右区间和横跨两个区间作讨论，对于第三种情况，选择两侧原直径端点求$Dist$取最值即可，正确性显然，查询直接通过$Dfn$查询即可。</p><p>当然可能有一些区间内的点不连通，先当作它们连通即可。</p><p>对于删除某些子树，相当于把整棵树分为$n$部分，查询每个部分，全部$Merge$起来即可。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/T55282" target="_blank" rel="noopener">Snow的追寻</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line">  <span class="number">6</span> </span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"> <span class="number">13</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"> <span class="number">16</span>     <span class="keyword">int</span> to;</span><br><span class="line"> <span class="number">17</span> </span><br><span class="line"> <span class="number">18</span>     <span class="keyword">int</span> next;</span><br><span class="line"> <span class="number">19</span> &#125; ;</span><br><span class="line"> <span class="number">20</span> </span><br><span class="line"> <span class="number">21</span> LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> <span class="number">22</span> <span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="number">23</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> <span class="number">24</span> </span><br><span class="line"> <span class="number">25</span> <span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"> <span class="number">26</span>     Link[++ size].to = v;</span><br><span class="line"> <span class="number">27</span>     Link[size].next = Head[u];</span><br><span class="line"> <span class="number">28</span> </span><br><span class="line"> <span class="number">29</span>     Head[u] = size;</span><br><span class="line"> <span class="number">30</span> &#125;</span><br><span class="line"> <span class="number">31</span> </span><br><span class="line"> <span class="number">32</span> <span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"> <span class="number">33</span> </span><br><span class="line"> <span class="number">34</span> <span class="keyword">int</span> Deep[MAXN];</span><br><span class="line"> <span class="number">35</span> <span class="keyword">int</span> Size[MAXN];</span><br><span class="line"> <span class="number">36</span> <span class="keyword">int</span> Val[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> <span class="number">37</span> <span class="keyword">int</span> Dfn[MAXN], DDfn[MAXN];</span><br><span class="line"> <span class="number">38</span> <span class="keyword">int</span> Rank[MAXN];</span><br><span class="line"> <span class="number">39</span> <span class="keyword">int</span> dfsord = <span class="number">0</span>, dod2 = <span class="number">0</span>;</span><br><span class="line"> <span class="number">40</span> </span><br><span class="line"> <span class="number">41</span> <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"> <span class="number">42</span>     Size[root] = <span class="number">1</span>;</span><br><span class="line"> <span class="number">43</span>     Dfn[root] = ++ dfsord;</span><br><span class="line"> <span class="number">44</span>     Rank[dfsord] = root;</span><br><span class="line"> <span class="number">45</span>     DDfn[root] = ++ dod2;</span><br><span class="line"> <span class="number">46</span>     Val[dod2] = Deep[root];</span><br><span class="line"> <span class="number">47</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"> <span class="number">48</span>         <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"> <span class="number">49</span>         <span class="keyword">if</span> (v == father)</span><br><span class="line"> <span class="number">50</span>             <span class="keyword">continue</span>;</span><br><span class="line"> <span class="number">51</span> </span><br><span class="line"> <span class="number">52</span>         Deep[v] = Deep[root] + <span class="number">1</span>;</span><br><span class="line"> <span class="number">53</span>         DFS (v, root);</span><br><span class="line"> <span class="number">54</span>         Size[root] += Size[v];</span><br><span class="line"> <span class="number">55</span>         Val[++ dod2] = Deep[root];</span><br><span class="line"> <span class="number">56</span>     &#125;</span><br><span class="line"> <span class="number">57</span> &#125;</span><br><span class="line"> <span class="number">58</span> </span><br><span class="line"> <span class="number">59</span> <span class="keyword">int</span> ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">30</span>];</span><br><span class="line"> <span class="number">60</span> </span><br><span class="line"> <span class="number">61</span> <span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">62</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dod2; i ++)</span><br><span class="line"> <span class="number">63</span>         ST[i][<span class="number">0</span>] = Val[i];</span><br><span class="line"> <span class="number">64</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line"> <span class="number">65</span>         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dod2; i ++)</span><br><span class="line"> <span class="number">66</span>             <span class="keyword">if</span> (i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) &lt;= dod2)</span><br><span class="line"> <span class="number">67</span>                 ST[i][j] = min (ST[i][j - <span class="number">1</span>], ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"> <span class="number">68</span> &#125;</span><br><span class="line"> <span class="number">69</span> </span><br><span class="line"> <span class="number">70</span> <span class="function"><span class="keyword">int</span> <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"> <span class="number">71</span>     <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line"> <span class="number">72</span>     <span class="keyword">return</span> min (ST[L][k], ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line"> <span class="number">73</span> &#125;</span><br><span class="line"> <span class="number">74</span> </span><br><span class="line"> <span class="number">75</span> <span class="function"><span class="keyword">int</span> <span class="title">Dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="number">76</span>     <span class="keyword">if</span> (DDfn[x] &gt; DDfn[y])</span><br><span class="line"> <span class="number">77</span>         swap (x, y);</span><br><span class="line"> <span class="number">78</span> </span><br><span class="line"> <span class="number">79</span>     <span class="keyword">int</span> deeplca = Query (DDfn[x], DDfn[y]);</span><br><span class="line"> <span class="number">80</span>     <span class="keyword">return</span> Deep[x] + Deep[y] - <span class="number">2</span> * deeplca;</span><br><span class="line"> <span class="number">81</span> &#125;</span><br><span class="line"> <span class="number">82</span> </span><br><span class="line"> <span class="number">83</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"> <span class="number">84</span>     <span class="keyword">int</span> diam;</span><br><span class="line"> <span class="number">85</span>     <span class="keyword">int</span> lp, rp;</span><br><span class="line"> <span class="number">86</span> </span><br><span class="line"> <span class="number">87</span>     Node () &#123;</span><br><span class="line"> <span class="number">88</span>         diam = <span class="number">0</span>;</span><br><span class="line"> <span class="number">89</span>         lp = rp = <span class="number">0</span>;</span><br><span class="line"> <span class="number">90</span>     &#125;</span><br><span class="line"> <span class="number">91</span> </span><br><span class="line"> <span class="number">92</span>     Node (<span class="keyword">int</span> fdiam, <span class="keyword">int</span> flp, <span class="keyword">int</span> frp) :</span><br><span class="line"> <span class="number">93</span>         diam (fdiam), lp (flp), rp (frp) &#123;&#125;</span><br><span class="line"> <span class="number">94</span> &#125; ;</span><br><span class="line"> <span class="number">95</span> </span><br><span class="line"> <span class="number">96</span> Node Tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"> <span class="number">97</span> </span><br><span class="line"> <span class="number">98</span> </span><br><span class="line"> <span class="number">99</span> <span class="function">Node <span class="title">Merge</span> <span class="params">(Node s1, Node s2)</span> </span>&#123;</span><br><span class="line"><span class="number">100</span>     <span class="keyword">if</span> (s1.diam == - <span class="number">1</span>)</span><br><span class="line"><span class="number">101</span>         <span class="keyword">return</span> s2;</span><br><span class="line"><span class="number">102</span>     Node news = s1.diam &gt;= s2.diam ? s1 : s2; <span class="comment">// 以下讨论</span></span><br><span class="line"><span class="number">103</span>     <span class="keyword">if</span> (Dist (s1.lp, s2.lp) &gt; news.diam)</span><br><span class="line"><span class="number">104</span>         news = Node (Dist (s1.lp, s2.lp), s1.lp, s2.lp);</span><br><span class="line"><span class="number">105</span>     <span class="keyword">if</span> (Dist (s1.lp, s2.rp) &gt; news.diam)</span><br><span class="line"><span class="number">106</span>         news = Node (Dist (s1.lp, s2.rp), s1.lp, s2.rp);</span><br><span class="line"><span class="number">107</span>     <span class="keyword">if</span> (Dist (s1.rp, s2.lp) &gt; news.diam)</span><br><span class="line"><span class="number">108</span>         news = Node (Dist (s1.rp, s2.lp), s1.rp, s2.lp);</span><br><span class="line"><span class="number">109</span>     <span class="keyword">if</span> (Dist (s1.rp, s2.rp) &gt; news.diam)</span><br><span class="line"><span class="number">110</span>         news = Node (Dist (s1.rp, s2.rp), s1.rp, s2.rp);</span><br><span class="line"><span class="number">111</span> </span><br><span class="line"><span class="number">112</span>     <span class="keyword">return</span> news;</span><br><span class="line"><span class="number">113</span> &#125;</span><br><span class="line"><span class="number">114</span> </span><br><span class="line"><span class="number">115</span> <span class="function"><span class="keyword">void</span> <span class="title">Build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="number">116</span>     Tree[root] = Node ();</span><br><span class="line"><span class="number">117</span> </span><br><span class="line"><span class="number">118</span>     <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="number">119</span>         Tree[root].diam = <span class="number">0</span>;</span><br><span class="line"><span class="number">120</span>         Tree[root].lp = Tree[root].rp = Rank[left];</span><br><span class="line"><span class="number">121</span>         <span class="keyword">return</span> ;</span><br><span class="line"><span class="number">122</span>     &#125;</span><br><span class="line"><span class="number">123</span> </span><br><span class="line"><span class="number">124</span>     <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">125</span>     Build (lson, left, mid);</span><br><span class="line"><span class="number">126</span>     Build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="number">127</span> </span><br><span class="line"><span class="number">128</span>     Tree[root] = Merge (Tree[lson], Tree[rson]);</span><br><span class="line"><span class="number">129</span> &#125;</span><br><span class="line"><span class="number">130</span> </span><br><span class="line"><span class="number">131</span> <span class="function">Node <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="number">132</span>     <span class="keyword">if</span> (L == left &amp;&amp; R == right)</span><br><span class="line"><span class="number">133</span>         <span class="keyword">return</span> Tree[root];</span><br><span class="line"><span class="number">134</span> </span><br><span class="line"><span class="number">135</span>     <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">136</span>     <span class="keyword">if</span> (R &lt;= mid)</span><br><span class="line"><span class="number">137</span>         <span class="keyword">return</span> Query (lson, left, mid, L, R);</span><br><span class="line"><span class="number">138</span>     <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid)</span><br><span class="line"><span class="number">139</span>         <span class="keyword">return</span> Query (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="number">140</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">141</span>         <span class="keyword">return</span> Merge (Query (lson, left, mid, L, mid), Query (rson, mid + <span class="number">1</span>, right, mid + <span class="number">1</span>, R));</span><br><span class="line"><span class="number">142</span> &#125;</span><br><span class="line"><span class="number">143</span> </span><br><span class="line"><span class="number">144</span> <span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="number">145</span> </span><br><span class="line"><span class="number">146</span> <span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">147</span>     <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="number">148</span>     <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="number">149</span> </span><br><span class="line"><span class="number">150</span>     <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line"><span class="number">151</span>         ch = getchar ();</span><br><span class="line"><span class="number">152</span>     <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line"><span class="number">153</span>         num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="number">154</span> </span><br><span class="line"><span class="number">155</span>     <span class="keyword">return</span> num;</span><br><span class="line"><span class="number">156</span> &#125;</span><br><span class="line"><span class="number">157</span> </span><br><span class="line"><span class="number">158</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">159</span>     <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line"><span class="number">160</span> </span><br><span class="line"><span class="number">161</span>     N = getnum (), Q = getnum ();</span><br><span class="line"><span class="number">162</span> </span><br><span class="line"><span class="number">163</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="number">164</span>         <span class="keyword">int</span> u, v;</span><br><span class="line"><span class="number">165</span>         u = getnum (), v = getnum ();</span><br><span class="line"><span class="number">166</span>         Insert (u, v), Insert (v, u);</span><br><span class="line"><span class="number">167</span>     &#125;</span><br><span class="line"><span class="number">168</span> </span><br><span class="line"><span class="number">169</span>     DFS (Root, <span class="number">0</span>);</span><br><span class="line"><span class="number">170</span>     RMQ ();</span><br><span class="line"><span class="number">171</span> </span><br><span class="line"><span class="number">172</span>     Build (Root, <span class="number">1</span>, dfsord);</span><br><span class="line"><span class="number">173</span>     <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line"><span class="number">174</span>         <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="number">175</span>         x = getnum (), y = getnum ();</span><br><span class="line"><span class="number">176</span> </span><br><span class="line"><span class="number">177</span>         Node res = Node (- <span class="number">1</span>, - <span class="number">1</span>, - <span class="number">1</span>);</span><br><span class="line"><span class="number">178</span>         <span class="keyword">if</span> (Dfn[x] &gt; Dfn[y])</span><br><span class="line"><span class="number">179</span>             swap (x, y);</span><br><span class="line"><span class="number">180</span>         <span class="keyword">int</span> sx = Dfn[x], ex = sx + Size[x] - <span class="number">1</span>;</span><br><span class="line"><span class="number">181</span>         <span class="keyword">int</span> sy = Dfn[y], ey = sy + Size[y] - <span class="number">1</span>;</span><br><span class="line"><span class="number">182</span>         <span class="keyword">if</span> (sx &gt; <span class="number">1</span>) <span class="comment">// 第一部分</span></span><br><span class="line"><span class="number">183</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, <span class="number">1</span>, sx - <span class="number">1</span>));</span><br><span class="line"><span class="number">184</span>         <span class="keyword">if</span> (ex + <span class="number">1</span> &lt; sy) <span class="comment">// 第二部分</span></span><br><span class="line"><span class="number">185</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, ex + <span class="number">1</span>, sy - <span class="number">1</span>));</span><br><span class="line"><span class="number">186</span>         <span class="keyword">int</span> fen = max (ex, ey);</span><br><span class="line"><span class="number">187</span>         <span class="keyword">if</span> (fen &lt; dfsord) <span class="comment">// 第三部分</span></span><br><span class="line"><span class="number">188</span>             res = Merge (res, Query (Root, <span class="number">1</span>, dfsord, fen + <span class="number">1</span>, dfsord));</span><br><span class="line"><span class="number">189</span>         <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, res.diam == - <span class="number">1</span> ? <span class="number">0</span> : res.diam);</span><br><span class="line"><span class="number">190</span>     &#125;</span><br><span class="line"><span class="number">191</span> </span><br><span class="line"><span class="number">192</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">193</span> &#125;</span><br><span class="line"><span class="number">194</span> </span><br><span class="line"><span class="number">195</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">196 5 2</span></span><br><span class="line"><span class="comment">197 1 3</span></span><br><span class="line"><span class="comment">198 3 2</span></span><br><span class="line"><span class="comment">199 3 4</span></span><br><span class="line"><span class="comment">200 2 5</span></span><br><span class="line"><span class="comment">201 2 4</span></span><br><span class="line"><span class="comment">202 5 4</span></span><br><span class="line"><span class="comment">203 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竞赛图染色</title>
      <link href="/2020/08/04/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E6%9F%93%E8%89%B2/"/>
      <url>/2020/08/04/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>给定一个 $n$ 个点的竞赛图，给该图的每条边染色，颜色数量不能超过 $m$ 个，一个染色合法当且仅当不存在长度为 $2$ 的路径，即对有向图中任意路径 $i \rightarrow j \rightarrow k$ 均有边 $i \rightarrow j$ 和边 $j \rightarrow k$ 颜色不同</p></blockquote><blockquote><p>$2 \le n \le 3000, ~ 2 \le m \le 26$</p></blockquote><p>设该竞赛图点集 $V$</p><p>考虑染每一种颜色意味着什么，相当于选择一个点集 $S \subseteq V$，将所有边 $(u, v)$ 满足 $u \in S \cap v \in \complement_VS$ 染上该颜色，也就是说我们要找到至多 $m$ 个这样的集合来覆盖所有的边</p><p>这样可以给出一个 $m = 2\log n$ 的染色方案，对所有点分治，每次一分为二，给 $S, \complement_V S$ 之间的边按两种方向染上不同的颜色，这样总共需要颜色是 $2\log n$ 的</p><p>但实际上可以用二进制来表示这种是否在每个 $S$ 中的关系，对每个 $S_i$，若当前点 $u$ 得到的二进制位为 $1$，则代表 $u \in S_i$，否则 $u \in \complement_VS_i$，即代表 $i$ 不存在颜色为 $i$ 的外向边，那么点 $i$ 的选择方案可以看作 $\{1, 2, …, m\}$ 的一个子集，设为 $A_i$，我们则要选出 $n$ 个集合满足 $\forall i, j$，有 $\exists x, y, ~ x \in A_i, y \in A_j$ 满足 $x \notin A_j, y \notin A_i$</p><p>那么一个比较好的构造方法就是取所有大小恰为 $\lfloor\frac{m}2\rfloor$ 的集合，又 $\dbinom{14}{7} = 3432 \ge 3000$，故实际上 $m \le 14$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3432</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sve[MAXN]= &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= lim; state ++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = __builtin_popcount (state);</span><br><span class="line"><span class="keyword">if</span> (cnt == (M &gt;&gt; <span class="number">1</span>)) sve[++ m] = state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">if</span> (M &gt; <span class="number">14</span>) M = <span class="number">14</span>;</span><br><span class="line">work ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, in + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M; k ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[j] == <span class="string">'1'</span> &amp;&amp; ((sve[i] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((sve[j] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span> (k + <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (in[j] == <span class="string">'0'</span> &amp;&amp; ((sve[i] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((sve[j] &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span> (k + <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成函数与组合计数初步</title>
      <link href="/2020/08/04/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/"/>
      <url>/2020/08/04/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>该文为（金策《生成函数的运算与组合计数问题》）学习笔记</p><h3 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h3><p>级数：一个有穷或无穷序列 $a_0, a_1, a_2, …$ 的形式和「即 $\sum\limits_{i = 0} a_i$」被称为级数，序列中的项称作级数的通项</p><p>敛散性：极限是无穷即为发散「如 $f(x) = x$」；极限不为无穷即为收敛「如 $f(x) = \frac{1}{x}$」</p><p>那么幂级数即为形如 $\sum\limits_{n = 0}^{\infty} a_n(x - c)^n$ 或者化简为 $\sum\limits_{n = 0}^{\infty} a_nx^n$ 的形式</p><h3 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h3><p>形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} a_nx^n<br>$$<br>形式与幂级数很像，但这里 $x$ 作为一个符号而不用具体数值带进去算，也不研究敛散性什么的</p><p>形式幂级数的加减乘法与多项式的有着类似的定义</p><p>实际运算时一般在 $\bmod{x^n}$ 的意义下进行，即仅取次数不超过 $n - 1$ 的项</p><h3 id="笛卡儿积「直积」"><a href="#笛卡儿积「直积」" class="headerlink" title="笛卡儿积「直积」"></a>笛卡儿积「直积」</h3><p>有集合 $A, B$，则 $A, B$ 的笛卡儿积记作 $A \times B$，是所有可能组成的有序对的集合，且分别为 $A, B$ 的成员，即 $A \times B = \{(a, b) | a \in A \land b \in B\}$</p><ul><li><p>笛卡儿积一般不满足交换律与结合律</p></li><li><p>笛卡儿积对集合的并和交满足分配律<br>$$<br>A \times (B \cup C) = (A \times B) \cup (A \times C) \\<br>A \times (B \cap C) = (A \times B) \cap (A \times C) \\<br>(A \times B) \cap (C \times D) = (A \cap C) \times (B \cap D)<br>$$</p></li></ul><h2 id="生成函数与组合计数"><a href="#生成函数与组合计数" class="headerlink" title="生成函数与组合计数"></a>生成函数与组合计数</h2><h3 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h3><p>在组合计数问题中，一般定义了一类组合对象，该对象可能是满足某一性质的树、图等的集合，且一类组合对象 $A$ 其中的对象 $a \in A$ 有大小 $size(a)$，那么通常的计数任务即为求出 $A_n = (size (a) = n)$ 的数值</p><p>组合对象分为有标号与无标号，就比如结点有标号的无向图个数与结点无标号的无向图个数</p><p><strong>这一部分非常重要，对于题目必须先明确组合对象，才可以通过 OGF 或 EGF 的公式来进行求解</strong></p><h3 id="普通生成函数「OGF」"><a href="#普通生成函数「OGF」" class="headerlink" title="普通生成函数「OGF」"></a>普通生成函数「OGF」</h3><p>数列 $A_0, A_1, A_2, …$ 的 OGF 定义为形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} A_nx^n<br>$$</p><p>其中，$A$ 是一类无标号对象，$A_n$ 表示满足 $size(a) = n$ 的对象 $a \in A$ 的数量</p><p>或者可以这么理解，对于集合 $A = \{A_0, A_1, A_2, …\}$，其中 $A_i$ 的出现集合为 $M_i$，那么 $A$ 的 OGF 即为 $\prod\limits_{n = 0}^{\infty} \left(\sum\limits_{m \in M_n} x^m\right)$</p><p>考虑集合 $A, B$ 的笛卡儿积 $D = A \times B$，并有 $size(d) = size(a) + size(b)$，那么显然<br>$$<br>D_k = \sum\limits_{i + j = k} A_iB_j<br>$$<br>则有<br>$$<br>D(x) = A(x)B(x)<br>$$</p><h4 id="生成函数-frac-1-1-x-n"><a href="#生成函数-frac-1-1-x-n" class="headerlink" title="生成函数 $\frac{1}{(1 - x)^n}$"></a>生成函数 $\frac{1}{(1 - x)^n}$</h4><p>这是一个比较常见的生成函数，接下来证明它的原数列为<br>$$<br>\sum\limits_{k = 0}^{\infty} \dbinom{k + n - 1}{n - 1} x^k<br>$$<br>有两种方法</p><h5 id="证明方法一"><a href="#证明方法一" class="headerlink" title="证明方法一"></a>证明方法一</h5><p>首先显然<br>$$<br>\frac{1}{(1 - x)^n} = \prod_{i = 1}^n\left(\sum\limits_{k = 0}^{\infty} x^k\right)<br>$$<br>那么使用隔板法就可以直接证明了</p><h5 id="证明方法二"><a href="#证明方法二" class="headerlink" title="证明方法二"></a>证明方法二</h5><ul><li>结论：若数列 $a_0, a_1, a_2, …$ 的 OGF 是 $A(x)$，令 $s_n = \sum\limits_{i = 0}^n a_i$，则 $s_0, s_1, s_2, …$ 的 OGF $B(x)$ 为 $\frac{A(x)}{1 - x}$</li><li>证明：显然 $B(x) = \sum\limits_{n = 0}^{\infty} x^nA(x)$，得证</li></ul><p>那么对于 $\frac{1}{(1 - x)^n}$ 的系数来讲，假如按照括号顺序合并，那么第 $n$ 项的系数就是第 $n - 1$ 项的系数加上上一版的第 $n$ 项系数，又初始系数全部为 $1$，所以这就是杨辉三角的递推关系，得证</p><h3 id="指数生成函数「EGF」"><a href="#指数生成函数「EGF」" class="headerlink" title="指数生成函数「EGF」"></a>指数生成函数「EGF」</h3><p>数列 $A_0, A_1, A_2, …$ 的 EGF 定义为形式幂级数<br>$$<br>A(x) = \sum\limits_{n = 0}^{\infty} A_n\frac{x^n}{n!}<br>$$<br>其中，$A$ 是一类有标号对象，$A_n$ 的意义同 OGF</p><p>OGF 表示的是序列，而 EGF 表示的是集合，而集合不同于序列的就是其没有顺序关系，故需除以 $n!$</p><p>换个层面理解，对于多重集 $A = \{\infty \times A_0, \infty \times A_1, \infty \times A_2, …\}$</p><p>首先多重集的排列数为 $\frac{n!}{n_0!n_1!n_2!…}$</p><p>又其中 $A_i$ 的出现集合为 $M_i$，那么 $A$ 的 EGF 即为 $\prod\limits_{n = 0}^{\infty} \left(\sum\limits_{m \in M_n} \frac{x^m}{m!}\right)$</p><p>这个式子和上面那个定义式是一样的</p><p>同样地，考虑有标号对象的拼接，从 $A, B$ 中各选 $n, m$ 件，因为是有标号的，所以需要令其保持顺序，故选择方法共有<br>$$<br>\dbinom{n + m}{n}<br>$$<br>种，那么<br>$$<br>\begin{aligned}<br>D_k &amp;= \sum\limits_{i + j = k} a_ib_j\frac{k!}{i!j!} \\<br>\frac{D_k}{k!} &amp;= \sum\limits_{i + j = k} \frac{a_i}{i!}\frac{b_j}{j!}<br>\end{aligned}<br>$$<br>说明<br>$$<br>\begin{aligned}<br>D(x) &amp;= \sum\limits_{k = 0}^{\infty}\left(\sum\limits_{i = 0}^{\infty} \dbinom{k}{i} a_ib_{k - i}\right)\frac{x^k}{k!} \\<br>&amp;= \sum\limits_{k = 0}^{\infty}\sum\limits_{i = 0}^{\infty} \frac{a_i}{i!}\frac{b_{k - i}}{(k - i)!} \\<br>&amp;= A(x)B(x)<br>\end{aligned}<br>$$</p><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>该部分见 <a href="https://colythme.github.io/2020/07/01/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/">多项式求逆</a></p><h3 id="生成函数相关应用"><a href="#生成函数相关应用" class="headerlink" title="生成函数相关应用"></a>生成函数相关应用</h3><h4 id="OGF-求-Fibonacci-数列通项"><a href="#OGF-求-Fibonacci-数列通项" class="headerlink" title="OGF 求 $Fibonacci$ 数列通项"></a>OGF 求 $Fibonacci$ 数列通项</h4><p>定义 $Fibonacci$ 数列的 OGF<br>$$<br>F(x) = \sum\limits_{n = 1}^{\infty} fibo_n x^n<br>$$<br>因为 $Fibonacci$ 数列与其右移一位的 $Fibonacci$ 数列的差是其右移两位，得<br>$$<br>\begin{aligned}<br>F(x) - xF(x) &amp;= x + x^2 \times F(x) \\<br>F(x) &amp;= \frac{x}{1 - x - x^2} \\<br>&amp;= \frac{x}{(1 - \frac{1 - \sqrt5}{2}x)(1 - \frac{1 + \sqrt5}{2}x)}<br>\end{aligned}<br>$$<br>现在要将该式裂项，假定 $F(x) = \frac{x}{(x - x_1)(x - x_2)}$，则裂项结果为 $\frac{t_1}{x - x_1} + \frac{t_2}{x - x_2}$，通项，得<br>$$<br>F(x) = \frac{t_1x - t_1x_2 + t_2x - t_2x_1}{(1 - x_1)(1 - x_2)}<br>$$<br>现在求解 $t_ 1, t_2$，有方程组<br>$$<br>\begin{cases}<br>t_1 + t_2 = 1 \\<br>t_1x_1 + t_2x_2 = 0<br>\end{cases}<br>$$<br>解出 $t_1, t_2$ 即可裂项，得<br>$$<br>F(x) = -\frac{1}{\sqrt5}\frac{1}{1 - \frac{1 - \sqrt5}{2}x} + \frac{1}{\sqrt5}\frac{1}{1 - \frac{1 + \sqrt5}{2}x}<br>$$<br>注意式子 $\frac{1}{1 - \frac{1 - \sqrt5}{2}x}$ ，这和式子 $\sum\limits_{n = 0}^{\infty} x^n = \frac{1}{1 - x}$，是一样的，可以直接还原为数列，故<br>$$<br>fibo_n = - \frac{1}{\sqrt5}\left(\frac{1 - \sqrt5}{2}\right)^n + \frac{1}{\sqrt5}\left(\frac{1 + \sqrt5}{2}\right)^n<br>$$</p><h4 id="生成函数求伯努利数"><a href="#生成函数求伯努利数" class="headerlink" title="生成函数求伯努利数"></a>生成函数求伯努利数</h4><h5 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h5><p>伯努利数分为两类：</p><p>$B_n^-$ 表示第一类伯努利数，$B_n^+$ 表示第二类伯努利数，它们的差别在于第一项，分别为 $B_1^- = - \frac{1}{2}, B_1^+ = + \frac{1}{2}$</p><p>并且对于所有大于 $1$ 的奇数 $n$，其伯努利数 $B_n = 0$</p><p>现在定义等幂和<br>$$<br>S_m(n) = \sum\limits_{k = 1}^n k^m<br>$$<br>该式成为伯努利多项式，变量为 $n$，次数为 $m$，又<br>$$<br>S_m(n) = \frac{1}{m + 1}\sum\limits_{k = 0}^n \dbinom{m + 1}{k} B_k^+ n^{m + 1 - k}<br>$$<br>这就是伯努利数与伯努利多项式的关系</p><p>伯努利数可以通过递推式计算<br>$$<br>\sum\limits_{j = 0}^m \dbinom{m + 1}{j} B_j = 0  (B_0 = 1)<br>$$<br>它还可以通过 EGF 表达「证明占坑」<br>$$<br>\frac{x}{e^x - 1} = \sum\limits_{n = 0}^{\infty} B_n\frac{x^n}{n!}<br>$$</p><h5 id="乘法逆元求伯努利数"><a href="#乘法逆元求伯努利数" class="headerlink" title="乘法逆元求伯努利数"></a>乘法逆元求伯努利数</h5><p>$$<br>\begin{aligned}<br>\sum\limits_{n = 0}^{\infty} B_n\frac{x^n}{n!} &amp;= \frac{x}{e^x - 1} \\<br>&amp;= \frac{x}{\sum\limits_{n = 1}^{\infty} \frac{x^n}{n!}} \\<br>&amp;= \frac{1}{\left(\sum\limits_{n = 0}^{\infty} \frac{x^n}{(n + 1)!}\right)}<br>\end{aligned}<br>$$</p><p>那么求一次乘法逆元即可</p><h4 id="生成函数优化-DP"><a href="#生成函数优化-DP" class="headerlink" title="生成函数优化 $DP$"></a>生成函数优化 $DP$</h4><p>先给出一道来自论文的例题</p><blockquote><p>字符集大小为 $m$。给定一个长度为 $k$ 的字符串 $s$，求出所有长为 $n$ 的串中，不包含子串 $s$ 的有多少个。$(n, m, k \le 10^5)$</p></blockquote><p>直接 $DP$ 很好想，令 $f_i$ 表示前 $i$ 个位置填字符，并且第一次满足 $substr[i - k + 1, i] = s$<br>$$<br>f_i = m^{i - k} - \sum\limits_{j = 1}^{i - k} f_jm^{i - j - k} - \sum\limits_{j \in Next} f_{i - j}<br>$$<br>注意，此处的 $Next$ 集合定义为 $\{j \ge 0 | s[1, k - j] = s[j + 1, k]\}$，不然下面不好进行优化</p><p>接下来对 $DP$ 进行优化</p><p>考虑生成函数 $f(x) = \sum\limits_{n = 0}^{\infty} f_nx^n, N(x) = \sum\limits_{j \in Next} x^j$，根据上面的 $DP$ 方程，可以得到<br>$$<br>f(x) = \frac{x^k}{1 - mx} + \frac{x^k}{1 - mx}f(x) + f(x)(N(x) - 1)<br>$$<br>其中，第一项直接等比数列求和即可得到，至于 $2, 3$ 项，会发现这实际上就是两个生成函数相乘每一项的系数变化，并且注意此时 $N(x)$ 需减 $1$，防止计算到 $f_i$，故得该表示</p><p>化简，得<br>$$<br>f(x) = \frac{x^k}{x^k + (1 - mx)N(x)}<br>$$</p><p>那么最终答案为 $g_n = m^n - \sum\limits_{j = 1}^n f_jm^{n - j}$，其 OGF $g(x)$ 为<br>$$<br>\begin{aligned}<br>g(x) &amp;= \frac{1}{1 - mx} - \frac{1}{1 - mx}f(x) \\<br>&amp;= \frac{N(x)}{x^k + (1 - mx)N(x)}<br>\end{aligned}<br>$$<br>然后把下面那东西乘出来化简一下就又可以得到一个新的多项式，然后就可直接解了</p><p>复杂度 $O (n \log n)$</p><h3 id="对数与指数运算"><a href="#对数与指数运算" class="headerlink" title="对数与指数运算"></a>对数与指数运算</h3><h4 id="形式幂级数的复合运算"><a href="#形式幂级数的复合运算" class="headerlink" title="形式幂级数的复合运算"></a>形式幂级数的复合运算</h4><p>设 $A(x) = \sum\limits_{i = 0}^{\infty} a_ix^i, B(x) = \sum\limits_{i = 1}^{\infty} b_ix^i$，那么它们的复合为<br>$$<br>C(x) = A(B(x)) = \sum\limits_{i = 0}^{\infty} a_i(B(x))^i<br>$$<br>显然最终 $C(x)$ 可以归纳成 $C(x) = \sum\limits_{i = 0}^{\infty} c_ix^i$ 的形式</p><p>注意因为 $B(x)$ 是没有常数项的，所以 $B(x)^i$ 是从 $x^i$ 起步的，故 $B(x)$ 与 $A(x)$ 的复合可以定义「猜测是这样，真正原因占坑」</p><h4 id="形式导数"><a href="#形式导数" class="headerlink" title="形式导数"></a>形式导数</h4><p>对于 $A(x) = \sum\limits_{n = 0} ^{\infty} a_nx^n$，定义其形式导数<br>$$<br>A’(x) = \sum\limits_{n = 1}^{\infty} na_nx^{n - 1}<br>$$<br>经过验证可知<br>$$<br>\begin{matrix}<br>&amp;(cA(x))’ = cA’(x) \\<br>&amp;(A(x) \pm B(x))’ = A’(x) \pm B’(x) \\<br>&amp;(A(x)B(x))’ = A’(x)B(x) + A(x)B’(x) \\<br>&amp;\left(\frac{1}{A(x)}\right) = - \frac{A’(x)}{A(x)^2} \\<br>&amp;(A(B(x))’ = A’(B(x))B’(x)<br>\end{matrix}<br>$$<br>这些基本求导法则对形式导数仍然成立</p><h4 id="可微函数"><a href="#可微函数" class="headerlink" title="可微函数"></a>可微函数</h4><p>可微函数指那些在其定义域中所有点都存在导数的函数，因此，可微函数的图像不存在任何间断点、尖点或是有垂直切线的点</p><h4 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h4><p>对于一个在实数或复数 $a$ 邻域上，以实数或复数作为变量，并且是无穷且可微的函数，其泰勒级数定义为以下形式的幂级数<br>$$<br>\sum\limits_{n = 0}^{\infty} \frac{f^{(n)}(a)}{n!}(x - a)^n<br>$$<br>如果 $a = 0$，那么该级数亦称作麦克劳林级数</p><p>实际上该式也就是泰勒展开的式子，证明：<a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/7681487?fr=aladdin" target="_blank" rel="noopener">泰勒展开证明</a></p><h5 id="常用函数的麦克劳林序列"><a href="#常用函数的麦克劳林序列" class="headerlink" title="常用函数的麦克劳林序列"></a>常用函数的麦克劳林序列</h5><p>$$<br>\begin{matrix}<br>\frac{1} {1 - x} = \sum\limits_{n = 0}^{\infty} x^n ~ ~ ~ ~ \forall x \in (- 1, 1) \\\<br>e^x = \sum\limits_{n = 0}^{\infty} \frac{x^n} {n!}  ~ ~ ~ ~ \forall x \\\<br>\ln (1 + x) = \sum\limits_{n = 1}^{\infty} \frac{(- 1)^{n + 1} } {n}x^n ~ ~ ~ ~ \forall x \in (- 1, 1) \\\<br>\ln (1 - x) = - \sum\limits_{n = 1}^{\infty} \frac{x^i} {i}<br>\end{matrix}<br>$$</p><h4 id="对数函数的计算"><a href="#对数函数的计算" class="headerlink" title="对数函数的计算"></a>对数函数的计算</h4><p>给定 $A(x) = 1 + \sum\limits_{n = 1}^{\infty} a_nx^n$ 「此处 $+ 1$ 是为了保证多项式求逆有解」<br>$$<br>\begin{aligned}<br>B(x) &amp;= ln (A(x)) \\\<br>B’(x) &amp;= \frac{A(x)}{A’(x)} \\\<br>B(x) &amp;= \int \frac{A(x)}{A’(x)} \mathrm{d}x<br>\end{aligned}<br>$$<br>时间复杂度 $O (n \log n)$</p><h4 id="指数函数的计算"><a href="#指数函数的计算" class="headerlink" title="指数函数的计算"></a>指数函数的计算</h4><p>给定 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，令<br>$$<br>B(x) = e^{A(x)}<br>$$<br>那么经过归纳之后可以表示为 $B(x) = \sum\limits_{i = 0}^{\infty} b_ix^i$</p><p>那么接下来的事情就是要计算系数 $b_i$</p><p>显然 $b_0 = 1$，那么扩展，得<br>$$<br>b_i = \frac{1}{i}\sum\limits_{k = 1}^i a_kb_{i - k}<br>$$<br>接下来证明这个结论</p><h5 id="证明方法一-1"><a href="#证明方法一-1" class="headerlink" title="证明方法一"></a>证明方法一</h5><p>先从简单的开始看起<br>$$<br>\begin{aligned}<br>&amp;b_1 = \frac{a_1}{1!} \\\<br>&amp;b_2 = \frac{a_2}{1!} + \frac{a_1 \times a_1}{2!} \\\<br>&amp;b_3 = \frac{a_3}{1!} + \frac{a_1 \times a_2 + a_2 \times a_1}{2!} + \frac{a_1 \times a_1 \times a_1}{3!}<br>\end{aligned}<br>$$<br>对于 $b_4$ 先只列举一个：<br>$$<br>b_4 = … + \frac{a_1 \times a_1 \times a_2 + a_1 \times a_2 \times a_1 + a_2 \times a_1 \times a_1}{3!} + …<br>$$<br>可以发现，相当于现在处理的问题是，令 $n = \sum\limits_{i = 1}^{total} m_ip_i$，那么可以得到一个集合 $\{m_1 \times p_1, m_2 \times p_2, …\}$，那么要如何通过集合 $\{\{m_1 \times p_1, …, (m_i - 1) \times p_i, …, m_{total} \times p_{total}\}(i = 1, 2, …, total)\}$ 转移到该集合</p><p>由于最终得到的 $a_{p_1}a_{p_2}a_{p_3}…$ 无关紧要，故只考虑其系数</p><p>先考虑最终需要的值<br>$$<br>\begin{aligned}<br>final &amp;= \frac{\frac{m!}{m_1!m_2!m_3!…}}{m!} \\\<br>&amp;= \frac{1}{m_1!m_2!m_3!…}<br>\end{aligned}<br>$$<br>对于每个 $i$，容易知道它的贡献为 $\frac{1}{m_1!…(m_i - 1)!…m_{total}!}$</p><p>现在只有 $n$ 关于 $m_i, p_i$，的公式，考虑将每个 $i$ 的贡献乘上 $p_i$，求和，则有<br>$$<br>\frac{\sum\limits_i m_ip_i}{m_1!m_2!m_3!…} = \frac{n}{m_1!m_2!m_3!…}<br>$$<br>上下同除一个 $n$ 即可得解</p><p>好像这个证明有点麻烦，那么还有一个</p><h5 id="证明方法二-1"><a href="#证明方法二-1" class="headerlink" title="证明方法二"></a>证明方法二</h5><p>两边求导，得<br>$$<br>B’(x) = A’(x)B(x)<br>$$<br>那么展开一下就得到该式了</p><p>那么有了这个结论之后求 $b_i$ 直接分治 $FFT$ 解决即可</p><p>时间复杂度 $O (n \log^2 n)$</p><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>给定 $g(x)$，求解 $f(x)$<br>$$<br>g(f(x)) = 0<br>$$<br>假设已经处理出 $f(x)$ 的前 $n$ 项 $f_0(x)$，则有<br>$$<br>\begin{aligned}<br>f(x) &amp;\equiv f_0(x) &amp;\pmod{x^n} \\\<br>f(x) - f_0(x) &amp;\equiv 0 &amp;\pmod{x^n} \\\<br>(f(x) - f_0(x))^2 &amp;\equiv 0 &amp;\pmod{x^{2n}}<br>\end{aligned}<br>$$<br>那么将 $g(f(x))$ 泰勒展开，得<br>$$<br>\begin{aligned}<br>0 &amp;= g(f(x)) \\\<br>&amp;= \sum\limits_{n = 0}^{\infty} \frac{g^{(n)}(f_0(x))}{n!}(f(x) - f_0(x))^n \\\<br>&amp;\equiv g(f_0(x)) + g’(f_0(x))(f(x) - f_0(x)) \pmod{x^{2n}} \\\<br>f(x) &amp;\equiv f_0(x) - \frac{g(f_0(x))}{g’(f_0(x))} \pmod{x^{2n}}<br>\end{aligned}<br>$$<br>那么就可以 $O (n \log n)$ 求解 $f(x)$ 了</p><h5 id="牛顿迭代法计算指数函数"><a href="#牛顿迭代法计算指数函数" class="headerlink" title="牛顿迭代法计算指数函数"></a>牛顿迭代法计算指数函数</h5><p>给定 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，求解 $e^{A(x)}$</p><p>令 $g(x) = \ln (x) - A(x)$，则有<br>$$<br>\begin{aligned}<br>f(x) &amp;= f_0(x) - \frac{\ln (f_0(x)) - A(x)}{\frac{1}{f_0(x)}} \\<br>&amp;= f_0(x)\left(1 - \ln (f_0(x)) + A(x)\right)<br>\end{aligned}<br>$$</p><h4 id="牛顿迭代法计算-k-次幂"><a href="#牛顿迭代法计算-k-次幂" class="headerlink" title="牛顿迭代法计算 $k$ 次幂"></a>牛顿迭代法计算 $k$ 次幂</h4><p>给定多项式 $A(x) = \sum\limits_{i = 0}^n a_ix^i$ 及正整数 $k$，求解 $A(x)^k$</p><p>直接快速幂复杂度 $O (n \log^2 n)$，复杂度较高</p><p>接下来讨论：</p><p>若 $A(x)$ 常数项为 $1$，则<br>$$<br>A(x)^k = e^{k \ln A(x)}<br>$$<br>若 $A(x)$ 常数项不为 $1$，则进行转化</p><p>设 $A(x)$ 得最低次项为 $a_tx^t$，转化为常数项为 $1$，即<br>$$<br>A(x)^k = a_t^kx^{kt}\left(\frac{A(x)}{a_tx^t}\right)^k<br>$$<br>同样牛顿迭代法即可</p><p>时间复杂度 $O (n \log n)$</p><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><h4 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h4><p>有一类组合对象 $A$，$A$ 的元素可以组成序列「最简单的例子就是由 $\{n_1 \times l_1, n_2 \times l_2, …\}$ 这样的长度集合拼成长度为 $k (k = 1, 2, …)$ 的方案数所构成的序列」，则这些序列定义了新的一类组合对象 $B$，即<br>$$<br>B(x) = \sum\limits_{k = 0}^{\infty} A(x)^k = \frac{1}{1 - A(x)}<br>$$<br>该结论对有无标号都成立</p><h4 id="集合计数"><a href="#集合计数" class="headerlink" title="集合计数"></a>集合计数</h4><h5 id="有标号的集合计数"><a href="#有标号的集合计数" class="headerlink" title="有标号的集合计数"></a>有标号的集合计数</h5><p>集合与序列的区别在于元素没有顺序，故需去除重复的，则<br>$$<br>B(x) = \sum\limits_{n = 0}^{\infty} \frac{A(x)^n}{n!} = e^{A(x)}<br>$$</p><h6 id="有标号的连通图计数"><a href="#有标号的连通图计数" class="headerlink" title="有标号的连通图计数"></a>有标号的连通图计数</h6><p>设 $G$ 是所有简单连通图，则其 EGF 为<br>$$<br>G(x) = \sum\limits_{n = 0}^{\infty} 2^{\frac{n(n - 1)}{2}}\frac{x^n}{n!}<br>$$<br>可以将所有简单连通图看作连通分量「其集合为 $C(x)$」的集合，故<br>$$<br>\begin{aligned}<br>G(x) &amp;= e^{C(x)} \\<br>C(x) &amp;= \ln G(x)<br>\end{aligned}<br>$$<br>时间复杂度 $O (n \log n)$</p><h5 id="无标号的集合计数"><a href="#无标号的集合计数" class="headerlink" title="无标号的集合计数"></a>无标号的集合计数</h5><h6 id="完全背包计数"><a href="#完全背包计数" class="headerlink" title="完全背包计数"></a>完全背包计数</h6><blockquote><p>体积为 $i$ 的有 $a_i$ 种不同的物品，每种物品有无限个，那么最终装满体积为 $V$ 的背包的方案数</p></blockquote><p>显然答案为<br>$$<br>\begin{aligned}<br>Ans &amp;= \prod_{i = 1}^n\left(\sum\limits_{j = 0}x^{ij}\right)^{a_i} \\<br>&amp;= \prod_{i = 1}^n\left(\frac{1}{1 - x^i}\right)^{a_i} \\<br>\end{aligned}<br>$$</p><p>接下来用对数函数化乘为加<br>$$<br>\begin{aligned}<br>Ans &amp;= \exp (\sum\limits_{i = 1}^n \ln \left(\left(\frac{1}{1 - x^i}\right)^{a_i}\right)) \\<br>&amp;= \exp (- \sum\limits_{i = 1}^n a_i\ln(1 - x^i)) \\<br>&amp;= \exp (\sum\limits_{i = 1}^na_i\left(\sum\limits_{n = 1}^{\infty} \frac{x^{in}}{n}\right)) \\<br>\end{aligned}<br>$$<br>接下来令 $A(x) = \sum\limits_{i = 1}^{\infty} a_ix^i$，换为枚举 $n$，得<br>$$<br>Ans = \exp (\sum\limits_{n = 1}^{\infty} \frac{1}{n}A(x^n))<br>$$<br>那么时间复杂度的计算就是调和级数，总时间复杂度 $O (n \log n)$</p><h4 id="环的计数"><a href="#环的计数" class="headerlink" title="环的计数"></a>环的计数</h4><h5 id="有标号的环的计数"><a href="#有标号的环的计数" class="headerlink" title="有标号的环的计数"></a>有标号的环的计数</h5><h6 id="圆排列问题"><a href="#圆排列问题" class="headerlink" title="圆排列问题"></a>圆排列问题</h6><blockquote><p>从 $n$ 个元素中不重复地取出 $m$ 个元素在一个圆周上，并且每个排列经过旋转后不会与其它任意一个排列相同，叫做这 $n$ 个元素的圆排列</p></blockquote><p>显然 $n$ 个元素取 $m$ 个作圆排列的方案数为<br>$$<br>total = \frac{A_n^m}{m}<br>$$<br>那么，对于一类组合对象 $A$，其圆排列的生成函数为<br>$$<br>\sum\limits_{k = 1}^{\infty} \frac{A(x)^k}{k} = - \ln (1 - A(x))<br>$$</p><h6 id="有标号的无向连通图中的基环树个数计数"><a href="#有标号的无向连通图中的基环树个数计数" class="headerlink" title="有标号的无向连通图中的基环树个数计数"></a>有标号的无向连通图中的基环树个数计数</h6><p>考虑将基环树拆分为若干棵树的拼凑</p><p>注意此时需考虑的是有根树，即先将节点看作组合对象，根据 $Cayley$ 定理，$n$ 个节点的完全图有 $n^{n - 1}$ 棵有根树，则有根树的 EGF $T(x)$ 为<br>$$<br>T(x) = \sum\limits_{n = 1}^{\infty} n^{n - 1}\frac{x^n}{n!}<br>$$<br>那么此时将有根树看作组合对象，则将它们组成环，即基环树的 EGF $G(x)$ 为<br>$$<br>\begin{aligned}<br>G(x) &amp;= \frac{1}{2}\sum\limits_{n = 3}^{\infty} \frac{T(x)^k}{k} \\<br>&amp;= - \frac{1}{2}\ln (1 - T(x)) - \sum\limits_{k = 1}^2 \frac{T(x)^k}{k}<br>\end{aligned}<br>$$</p><h5 id="无标号的环的计数"><a href="#无标号的环的计数" class="headerlink" title="无标号的环的计数"></a>无标号的环的计数</h5><p>「由于需要群论知识，故留坑」</p><p>「以下留坑」</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狄利克雷卷积与莫比乌斯反演</title>
      <link href="/2020/08/04/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2020/08/04/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><h3 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h3><p>　　　　指定义域为正整数的函数<br>　　　　定义其加法为逐项相加，即$(f + g)(n) = f(n) + g(n)$<br>　　　　定义其数乘为逐项相乘，即$(xf)(n) = x × f(n)$</p><h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>　　　　单位元是集合中一种特别的元素，当单位元与其它元素相结合时，不会改变其它元素的值</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>　　　　逆元是指可以取消另一给定元素运算的元素，即将其变回单位元</p><h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><p>　　　　$[A]$表示条件$A$是否为真<br>　　　　此处的符号”$*$”表示狄利克雷卷积</p><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>　　令$t(n) = f(n) * g(n)$，则　　</p><p>$$<br>t(n) = \sum\limits_{i | n} f(i)g(\frac{n}{i})<br>$$</p><p>　　那么狄利克雷卷积显然有下面几个性质：</p><h3 id="满足乘法交换律、结合律、分配律"><a href="#满足乘法交换律、结合律、分配律" class="headerlink" title="满足乘法交换律、结合律、分配律"></a>满足乘法交换律、结合律、分配律</h3><ul><li>对于单位元$\epsilon(n) = [n = 1]$，满足$\epsilon(n)*f(n) = f(n)$<br>　　　　- 对于每一个$f(1) \ne 1$的数论函数$f(n)$，皆存在其逆元$f^{- 1}(n)$，满足$f(n) * f^{- 1}(n) = \epsilon(n)$，那么对于这个结论，可以令$f^{- 1}(n) = \frac{1}{f(1)}\left(\epsilon(n) - \sum\limits_{i | n, i \ne 1} f(i)f^{- 1}(\frac{n}{i})\right)$，再代回原式，满足条件</li></ul><h3 id="狄利克雷卷积与积性函数"><a href="#狄利克雷卷积与积性函数" class="headerlink" title="狄利克雷卷积与积性函数"></a>狄利克雷卷积与积性函数</h3><h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>　　　　积性函数满足当$(n, m) = 1$，有$f(nm) = f(n)f(m)$</p><h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ul><li><p>若$(n, m) = 1,  d | nm$，则必定存在$a | n,  b | m$且满足$ab = d$，证明显然</p></li><li><p>若$(n, m) = 1,  a | n,  b | m$，则有$(a, b) = 1$，证明显然</p></li></ul><p>​       这样的话，就有性质：两个积性函数的狄利克雷卷积仍是积性函数，证明：<br>　　若$(n, m) = 1$，则有<br>$$<br>\begin{aligned}<br>t(nm) &amp;= \sum\limits_{i | nm} f(i)g(\frac{nm}{i}) \\<br>&amp;= \sum\limits_{a | n, b | m} f(ab)g(\frac{nm}{ab}) \\<br>&amp;= \sum\limits_{a | n, b | m} f(a)f(b)g(\frac{n}{a})g(\frac{m}{b}) \\<br>&amp;= t(n) * t(m)<br>\end{aligned}<br>$$</p><p>　　另外一个性质，就是两个积性函数的逆元仍是积性函数，是用数学归纳法证明：<br>　　　　令$(n, m) = 1$，当$nm = 1$时，结论显然成立<br>　　　　当$nm &gt; 1$且$n_1m_1 &lt; nm$时$n_1m_1$结论成立，再假设$nm$时结论成立，则有（注意，积性函数中一定满足$f(1) = 1$）<br>$$<br>\begin{aligned} f^{- 1}(nm) &amp;= - \sum\limits_{i | nm, i \ne 1} f(i)f^{- 1}(\frac{nm}{i}) \\ &amp;= - \sum\limits_{a | n, b | m, ab \ne 1} f(a)f(b)f^{- 1}(\frac{n}{a})f^{- 1}(\frac{m}{b}) \\ &amp;= f(1)f(1)f^{- 1}(n)f^{- 1}(m) - \sum\limits_{a | n, b | m, ab \ne 1} f(a)f(b)f^{- 1}(\frac{n}{a})f^{- 1}(\frac{m}{b}) \\ &amp;= f^{- 1}(n)f^{- 1}(m) - \epsilon(n)\epsilon(m) \\ &amp;= f^{- 1}(n)f^{- 1}(m) \end{aligned}<br>$$<br>　　注：积性函数$f(1) = 1$</p><h3 id="狄利克雷卷积与莫比乌斯反演"><a href="#狄利克雷卷积与莫比乌斯反演" class="headerlink" title="狄利克雷卷积与莫比乌斯反演"></a>狄利克雷卷积与莫比乌斯反演</h3><p>　　令$\mu$表示$1$在狄利克雷卷积意义下的逆元，令$g = f * 1$，则有$f = f * 1 * \mu = g * \mu$，再令$g(n) = \sum\limits_{d | n} f(d)$，则有</p><p>$$<br>f(n) = g(n) * \mu(n) = \sum\limits_{d | n} g(d)\mu(\frac{n}{d})<br>$$<br>　　这就是莫比乌斯反演的式子了<br>　　那么对于函数$\mu(n)$，由于$1$是积性函数，则$\mu$也是积性函数，又易知（代回原式就好了）<br>$$<br>\mu(p^k) = \left\{\begin{aligned} 1     k = 0 \\ - 1     k = 1 \\ 0     k &gt; 1 \end{aligned}\right.<br>$$<br>　　那么由积性函数，可得<br>　　- 若$n = p_1p_2…p_k$且$p_1 \ne p_2 \ne … \ne p_k$，则有</p><p>$$<br>\mu(n) = (- 1)^k<br>$$</p><p>　　- 若$p_k^r | n (r &gt; 1)$，则有</p><p>$$<br>\mu(n) = 0<br>$$</p><p>　　那么积性筛即可</p><h4 id="另附"><a href="#另附" class="headerlink" title="另附"></a>另附</h4><p>　　莫比乌斯反演的另一种形式，有</p><p>$$<br>g(n) = \sum\limits_{n | d}f(d)<br>$$<br>　　则有</p><p>$$<br>f(n) = \sum\limits_{n | d} \mu(\frac{d}{n})g(d)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3768 - 简单的数学题</title>
      <link href="/2020/08/04/%E6%B4%9B%E8%B0%B7%203768%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/2020/08/04/%E6%B4%9B%E8%B0%B7%203768%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据<a href="https://www.cnblogs.com/Colythme/p/10275893.html" target="_blank" rel="noopener">Crash的数字表格</a>，很容易可以将式子化简为<br>$$<br>\begin{aligned} Ans &amp;= \sum\limits_{i = 1}^n \sum\limits_{j = 1} ij(i, j) \\ &amp;= \sum\limits_{d = 1}^n d^3 \sum\limits_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(k) k^2 \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{kd}\right\rfloor} i \right)^2 \end{aligned}<br>$$<br>感觉 $d, k$ 放在一起式子无法继续化简，主要是有 $kd$ 存在，故令 $T = kd$ ，则有<br>$$<br>Ans = \sum\limits_{T = 1}^n \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} i \right)^2 T^2 \sum\limits_{d | T} d \mu(\frac{T}{d})<br>$$<br>那么考虑整除分块，现在需要处理的是后半部分</p><p>通过观察（看题解）可以发现， $\sum\limits_{d | T} d \mu(\frac{T}{d})$ 可以看成 $\mu * id$ ，故可替换成 $\phi(T)$ ，则有<br>$$<br>Ans = \sum\limits_{T = 1}^n \left( \sum\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} i \right)^2 T^2 \phi(T)<br>$$<br>现在考虑将 $T^2 \phi(T)$ 部分用杜教筛解决<br>$$<br>h(n) = \sum\limits_{d | n} d^2 \phi(d) g(\frac{n}{d})<br>$$<br>为了消除 $d^2$ ，令 $g(\frac{n}{d}) = n^2$ ，则有<br>$$<br>h(n) = n^3<br>$$<br>故得<br>$$<br>S(n) = \sum\limits_{i = 1}^n i^3 - \sum\limits_{d = 2}^n d^2 S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>又（通过看题解）有一个知识点<br>$$<br>\sum\limits_{i = 1}^n i^3 = \left( \sum\limits_{i = 1}^n i \right)<br>$$<br>那么就可以直接杜教筛了</p><p>至于复杂度，将最外围的整除分块与杜教筛看为一体，故复杂度为 $O (n^{\frac{2}{3}})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL MOD, N;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL inv2, inv6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line">LL phi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">6e06</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">phi[i] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * <span class="number">1l</span>l * prime[j] % MOD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * prime[j]] = phi[i] * <span class="number">1l</span>l * (prime[j] - <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++)</span><br><span class="line">sumphi[i] = (sumphi[i - <span class="number">1</span>] + <span class="number">1l</span>l * i % MOD * <span class="number">1l</span>l * i % MOD * phi[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;LL, LL&gt; maphi;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">sqr</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * x % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">eqm</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n + <span class="number">1</span>) % MOD * (n % MOD) % MOD * (<span class="number">2</span> * n % MOD + <span class="number">1</span>) % MOD * inv6 % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">oseqm</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n % MOD * ((n + <span class="number">1</span>) % MOD) % MOD * inv2 % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">phi_sieve</span> <span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX)</span><br><span class="line"><span class="keyword">return</span> sumphi[n];</span><br><span class="line"><span class="keyword">if</span> (maphi[n])</span><br><span class="line"><span class="keyword">return</span> maphi[n];</span><br><span class="line">LL total = sqr (oseqm (n));</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total = (total - (eqm (r) - eqm (l - <span class="number">1</span>) + MOD) % MOD * phi_sieve (n / l) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maphi[n] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = N / (N / l);</span><br><span class="line">ans = (ans + sqr (oseqm (N / l)) * ((phi_sieve (r) - phi_sieve (l - <span class="number">1</span>) + MOD) % MOD) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>, &amp; MOD, &amp; N);</span><br><span class="line">inv2 = power (<span class="number">2l</span>l, MOD - <span class="number">2</span>), inv6 = power (<span class="number">6l</span>l, MOD - <span class="number">2</span>);</span><br><span class="line">MAX = (<span class="keyword">int</span>) min (<span class="number">1l</span>l * MAX, N), linear_sieve ();</span><br><span class="line">LL ans = Solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">998244353 2000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1000000007 9786510294</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3676 - 小清新数据结构题</title>
      <link href="/2020/08/04/%E6%B4%9B%E8%B0%B7%203676%20-%20%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98/"/>
      <url>/2020/08/04/%E6%B4%9B%E8%B0%B7%203676%20-%20%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>说实话这题写树剖 $LCT$ 什么的真的思想又不难又好实现的样子，但是我还是选择自虐选择了动态点分治</p><p>那就两种做法都稍微提一下：</p><h3 id="树链剖分-LCT"><a href="#树链剖分-LCT" class="headerlink" title="树链剖分 / $LCT$"></a>树链剖分 / $LCT$</h3><p>很容易可以发现一个换根操作只会对当前根在原树（根为 $1$ ）上的祖先一条链造成影响，也就是将它们的子树变成除当前链方向其它与之相连的点集，那么用树剖跳，用线段树维护一下原树上从上面来的和从下面来的，再将所有涉及的节点合并，并且删去算重复的和不该算的即可（虽然我没实现但是这个思路应该是对的</p><h3 id="动态点分治"><a href="#动态点分治" class="headerlink" title="动态点分治"></a>动态点分治</h3><p>首先有两篇博客：<a href="https://www.luogu.org/blog/user4134/solution-p3676" target="_blank" rel="noopener">zzq</a>、<a href="http://www.cnblogs.com/zhoushuyu/p/8309410.html" target="_blank" rel="noopener">租酥雨</a></p><p>因为我们要算 $\sum\limits_{i = 1}^n s_i^2$ ，可以先想一下 $\sum\limits_{i = 1}^n s_i$ 怎么算，因为每个点的贡献只会被祖先计算到，那么易知 $\sum\limits_{i = 1}^n s_i = \sum\limits_{i = 1}^n value_i * (depth_i + 1)$ ，这个直接用动态点分治维护三个变量 $sumo_i, sumt_i, sumfa_i$ （sumo -&gt; $p$ 子节点权值之和,  $sumt$ -&gt; 子节点权值与距离的乘积到 $p$ 之和,  $sumfa$ -&gt; 子节点权值与距离的乘积到 $fa$ （点分树上）之和）即可得到</p><p>接下来有个很重要的结论（反正我是肯定想不到</p><p>​    - 不论根如何换， $\sum\limits_{i = 1}^n s_i (sum - s_i)$ 一定是一个定值（说实话一开始一直想着如何化简 $\sum\limits_{i = 1}^n s_i$ ，所以是真的没有想到可以通过构造定值的方法来解出 $\sum\limits_{i = 1}^n s_i^2$ ）</p><p>先来意会一下这个结论：就是每一条边连接的两个点在他们的子树中各自选两个点让它们权值相乘，求总权值</p><p>那么就比较容易知道证明了：每条边的边权为所有对应路径经过这条边的两个点的权值和，求总边权，即求的是 $\sum\limits_{i = 1}^n \sum\limits_{j = 1}^n value_i * value_j * dist (i, j)$ ，所以有 $\sum\limits_{i = 1}^n s_i (sum - s_i) = \sum\limits_{i = 1}^n \sum\limits_{j = 1}^n value_i * value_j * dist (i, j)$</p><p>因为该式是个定值，所以求出 $\sum\limits_{i = 1}^n s_i$ 后直接解出 $Ans$ 就完成了查询操作</p><p>对于修改操作，若修改完后与原权值的差值为 $\Delta value$ ，那么 $\Delta total = \Delta value \sum\limits_{j = 1}^n value_j * dist (p, j)$ （ $p$ 为修改点）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> value[MAXN];</span><br><span class="line"></span><br><span class="line">LL Deep[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Dfn[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, belong[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dfsord = <span class="number">0</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line">LL subtree[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL s1 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    Dfn[root] = ++ dfsord;</span><br><span class="line">    val[dfsord] = Deep[root], belong[dfsord] = root;</span><br><span class="line">    sum += value[root];</span><br><span class="line">    subtree[root] = value[root];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Deep[v] = Deep[root] + <span class="number">1</span>;</span><br><span class="line">        DFS (v, root);</span><br><span class="line">        val[++ dfsord] = Deep[root], belong[dfsord] = root;</span><br><span class="line">        subtree[root] += subtree[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfsord; i ++)</span><br><span class="line">        ST[i][<span class="number">0</span>] = make_pair (val[i], belong[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= dfsord; i ++)</span><br><span class="line">            ST[i][j] = ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first ? ST[i][j - <span class="number">1</span>] : ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = Dfn[x], R = Dfn[y];</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        swap (L, R);</span><br><span class="line">    <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ST[L][k].first &lt; ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first ? ST[L][k].second : ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA (x, y);</span><br><span class="line">    <span class="keyword">return</span> Deep[x] + Deep[y] - (Deep[lca] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> minv = INF, grvy;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grvy_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    Size[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Grvy_Acqu (v, root);</span><br><span class="line">        Size[root] += Size[v];</span><br><span class="line">        maxpart = max (maxpart, Size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxpart = max (maxpart, total - Size[root]);</span><br><span class="line">    <span class="keyword">if</span> (maxpart &lt; minv)</span><br><span class="line">        minv = maxpart, grvy = root;</span><br><span class="line">&#125;</span><br><span class="line">LL sumo[MAXN]= &#123;<span class="number">0</span>&#125;, sumt[MAXN]= &#123;<span class="number">0</span>&#125;, sumfa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// sumo -&gt; p子节点权值之和, sumt -&gt; 子节点权值与距离的乘积到p之和, sumfa -&gt; 子节点权值与距离的乘积到fa(点分树上)之和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sums_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sumo[grvy] += value[root], sumt[grvy] += value[root] * dist (root, grvy);</span><br><span class="line">    <span class="keyword">if</span> (father[grvy])</span><br><span class="line">        sumfa[grvy] += value[root] * dist (root, father[grvy]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i =    Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sums_Acqu (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">point_DAC</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    minv = INF, grvy = p, total = Size[p];</span><br><span class="line">    Grvy_Acqu (p, <span class="number">0</span>);</span><br><span class="line">    Vis[grvy] = <span class="literal">true</span>, father[grvy] = pre;</span><br><span class="line">    sums_Acqu (grvy, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fgrvy = grvy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fgrvy]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        point_DAC (v, fgrvy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    LL tsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = op; p; p = father[p]) &#123;</span><br><span class="line">        tsum += sumt[p];</span><br><span class="line">        <span class="keyword">if</span> (p != op)</span><br><span class="line">            tsum += sumo[p] * dist (p, op);</span><br><span class="line">        <span class="keyword">if</span> (father[p])</span><br><span class="line">            tsum -= sumo[p] * dist (father[p], op) + sumfa[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = op; p; p = father[p]) &#123;</span><br><span class="line">        sumo[p] -= value[op] - delta;</span><br><span class="line">        sumt[p] -= value[op] * dist (p, op) - delta * dist (p, op);</span><br><span class="line">        <span class="keyword">if</span> (father[p])</span><br><span class="line">            sumfa[p] -= value[op] * dist (father[p], op) - delta * dist (father[p], op);</span><br><span class="line">    &#125;</span><br><span class="line">    sum -= value[op] - delta;</span><br><span class="line">    LL s = Query (op);</span><br><span class="line">    s1 += (delta - value[op]) * s;</span><br><span class="line">    value[op] = delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            isneg = <span class="number">1</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), Q = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">        Insert (u, v), Insert (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        value[i] = getnum ();</span><br><span class="line">    DFS (<span class="number">1</span>, <span class="number">0</span>), RMQ ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        s1 += subtree[i] * (sum - subtree[i]);</span><br><span class="line">    Size[<span class="number">1</span>] = N, point_DAC (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*cout &lt;&lt; "Next----------------------" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= N; i ++)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; sumo[i] &lt;&lt; ' ' &lt;&lt; sumt[i] &lt;&lt; ' ' &lt;&lt; sumfa[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "End-----------------------" &lt;&lt; endl;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum (), delta = getnum ();</span><br><span class="line">            Modify (p, delta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum ();</span><br><span class="line">            LL ans = (Query (p) + sum) * sum - s1;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">4 3 2 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">4 3 2 1</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根号算法相关</title>
      <link href="/2020/08/04/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/08/04/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><p>首先有一道题</p><h3 id="王室联邦"><a href="#王室联邦" class="headerlink" title="王室联邦"></a>王室联邦</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一棵树，将树分为大小范围为 $[B, 3B]$ 的连通块集，求方案</p><h4 id="树上分块方法之一"><a href="#树上分块方法之一" class="headerlink" title="树上分块方法之一"></a>树上分块方法之一</h4><p>类似贪心，用栈维护还没有在连通块中的子节点，对于递归到的当前的点 $p$ ，扫描它的子树，能拼凑就拼凑</p><p>但是注意最后可能还会有一些点（一定包括根）剩下，那么将这些点并到最后一个连通块即可</p><p>显然每个连通块都满足大小为 $[B, 3B]$</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bot = top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS (v, root);</span><br><span class="line">        <span class="keyword">if</span> (top - bot &gt;= B) &#123;</span><br><span class="line">            capt[++ bind] = root;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; bot)</span><br><span class="line">                belong[Stack[top --]] = bind;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack[++ top] = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树上莫队-1"><a href="#树上莫队-1" class="headerlink" title="树上莫队"></a>树上莫队</h3><p>首先用王室联邦的方法将树分块</p><p>用一个数组 $state_p$ 来维护 $p$ 点是否在当前询问的路径上，那么每次访问就将 $state_p$ 翻转，顺便修改 $ans$ ，相当于原序列上莫队的 $add, del$ 操作</p><p>那么，每次需要修改那些点呢？</p><p>假设当前处理到 $(px, py)$ ，现在需要处理 $(x, y)$ ，那么只需修改 $px$ 到 $x$ 以及 $py$ 到 $y$ 的路径上的点即可</p><p>接下来证明该操作的正确性：</p><p>令 $T (x, y)$ 表示 $x$ 到 $y$ 路径上的点集， $xor$ 操作类似位运算的异或，即有相同点则删去，无则加入</p><p>则有 $T (x, y) = T (x, root) xor T (y, root)$ （注意，这里的 $T (x, y)$ 是不包括 $lca$ 的，故 <strong>$lca$ 需单独处理</strong>）</p><p>接下来是证明<br>$$<br>\begin{aligned} &amp;T (px, py)  xor  T (x, y) \\ &amp;= [T (px, root)  xor  T (py, root)]  xor  [T (x, root)  xor  T (y, root)] \\ &amp;=  [T (px, root)  xor  T (x, root)]  xor  [T (py, root)  xor  T (y, root)] \\ &amp;= T (px, x)  xor  T (py, y) \end{aligned}<br>$$<br>那么其它的修改什么的就和序列上莫队一样了</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P4074" target="_blank" rel="noopener">[WC2013]糖果公园</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line">LL V[MAXN], W[MAXN];</span><br><span class="line"><span class="keyword">int</span> pcol[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> belong[MAXN];</span><br><span class="line"><span class="keyword">int</span> lind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_bel</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bot = top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS_bel (v, root);</span><br><span class="line">        <span class="keyword">if</span> (top - bot &gt;= limit) &#123;</span><br><span class="line">            lind ++;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; bot)</span><br><span class="line">                belong[Stack[top --]] = lind;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack[++ top] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> deep[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN];</span><br><span class="line"><span class="keyword">int</span> value[MAXN &lt;&lt; <span class="number">1</span>], ranking[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfsord = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_LCA</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    father[root] = fa;</span><br><span class="line">    dfn[root] = ++ dfsord;</span><br><span class="line">    value[dfsord] = deep[root], ranking[dfsord] = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        deep[v] = deep[root] + <span class="number">1</span>;</span><br><span class="line">        DFS_LCA (v, root);</span><br><span class="line">        value[++ dfsord] = deep[root], ranking[dfsord] = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfsord; i ++)</span><br><span class="line">        ST[i][<span class="number">0</span>] = make_pair (value[i], ranking[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= dfsord; i ++)</span><br><span class="line">            ST[i][j] = ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first ? ST[i][j - <span class="number">1</span>] : ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = dfn[x], R = dfn[y];</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        swap (L, R);</span><br><span class="line">    <span class="keyword">int</span> k = log2 (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ST[L][k].first &lt; ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first ? ST[L][k].second : ST[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuerySt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    QuerySt (<span class="keyword">int</span> find = <span class="number">0</span>, <span class="keyword">int</span> ftime = <span class="number">0</span>, <span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>) :</span><br><span class="line">        index (find), time (ftime), x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> QuerySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (belong[x] != belong[p.x])</span><br><span class="line">            <span class="keyword">return</span> belong[x] &lt; belong[p.x];</span><br><span class="line">        <span class="keyword">if</span> (belong[y] != belong[p.y])</span><br><span class="line">            <span class="keyword">return</span> belong[y] &lt; belong[p.y];</span><br><span class="line">        <span class="keyword">return</span> time &lt; p.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">QuerySt Query[MAXQ];</span><br><span class="line"><span class="keyword">int</span> qind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> modposi[MAXQ], modtime[MAXQ];</span><br><span class="line"><span class="keyword">int</span> modpre[MAXQ], modval[MAXQ];</span><br><span class="line"><span class="keyword">int</span> mind = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> state[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> donet[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state[p])</span><br><span class="line">        ans -= V[pcol[p]] * W[donet[pcol[p]]], donet[pcol[p]] --;</span><br><span class="line">    state[p] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (state[p])</span><br><span class="line">        donet[pcol[p]] ++, ans += V[pcol[p]] * W[donet[pcol[p]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA (u, v);</span><br><span class="line">    <span class="keyword">while</span> (u != lca)</span><br><span class="line">        reverse (u), u = father[u];</span><br><span class="line">    <span class="keyword">while</span> (v != lca)</span><br><span class="line">        reverse (v), v = father[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extime</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> exist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state[modposi[p]]) &#123;</span><br><span class="line">        exist = <span class="literal">true</span>;</span><br><span class="line">        reverse (modposi[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        modpre[p] = pcol[modposi[p]];</span><br><span class="line">        pcol[modposi[p]] = modval[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pcol[modposi[p]] = modpre[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exist)</span><br><span class="line">        reverse (modposi[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timemod</span> <span class="params">(<span class="keyword">int</span> ptime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; mind &amp;&amp; modtime[cur + <span class="number">1</span>] &lt;= ptime)</span><br><span class="line">        extime (++ cur, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; modtime[cur] &gt; ptime)</span><br><span class="line">        extime (cur --, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL answer[MAXQ]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moqueue</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> px = <span class="number">1</span>, py = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qind; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = Query[i].index, time = Query[i].time;</span><br><span class="line">        <span class="keyword">int</span> x = Query[i].x, y = Query[i].y;</span><br><span class="line">        timemod (time);</span><br><span class="line">        move (px, x), px = x;</span><br><span class="line">        move (py, y), py = y;</span><br><span class="line">        <span class="keyword">int</span> lca = LCA (px, py);</span><br><span class="line">        reverse (lca);</span><br><span class="line">        answer[ind] = ans;</span><br><span class="line">        reverse (lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line">    limit = (<span class="keyword">int</span>) <span class="built_in">ceil</span> (<span class="built_in">pow</span> ((<span class="keyword">double</span>) N, <span class="number">2.0</span> / <span class="number">3.0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">        V[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        W[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">        Insert (u, v), Insert (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        pcol[i] = getnum ();</span><br><span class="line">    DFS_bel (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">        belong[Stack[top --]] = lind;</span><br><span class="line">    DFS_LCA (<span class="number">1</span>, <span class="number">0</span>), RMQ ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getnum (), col = getnum ();</span><br><span class="line">            modposi[++ mind] = p, modtime[mind] = i, modval[mind] = col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getnum (), y = getnum ();</span><br><span class="line">            qind ++, Query[qind] = (QuerySt (qind, i, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort (Query + <span class="number">1</span>, Query + qind + <span class="number">1</span>);</span><br><span class="line">    Moqueue ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qind; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 3 5</span></span><br><span class="line"><span class="comment">1 9 2</span></span><br><span class="line"><span class="comment">7 6 5 1</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1 2 3 2</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">0 2 1</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="二次离线莫队"><a href="#二次离线莫队" class="headerlink" title="二次离线莫队"></a>二次离线莫队</h2><p>考虑某个莫队的复杂度是 $O (n\sqrt{n}T)$，其中 $x$ 是某种复杂度，即莫队在移动端点时的更新不是 $O (1)$ 而是 $O (x)$ 的，即可用二次离线莫队优化掉 $O (T)$</p><p>考虑右端点的一次由 $R_{i - 1}$ 到 $R_i (R_i &gt; R_{i - 1})$ 的一次移动，对于 $x \in (R_{i - 1}, R_i]$，令其对区间 $[l, r]$ 的贡献为 $c (x, [l, r])$，那么也就是说 $x$ 每次移动我们需要知道 $c (x, [l, x - 1])$，差分，得<br>$$<br>c (x, [l, x - 1]) = c (x, [1, x - 1]) - c (x, [1, l - 1])<br>$$<br>对于 $c (x, [1, x - 1])$，显然可以直接前缀和维护；对于 $c (x, [1, l - 1])$，由于在一次移动中永远都是给 $[1, l - 1]$ 做贡献，那么可以只在 $l - 1$ 的位置打个标记说有哪些 $x$ 需要了解它在该区间的贡献，再计算一下就好了</p><p>也就是说第一次离线处理出 $c (x, [1, x - 1])$ 并且给每个端点打上标记说明仍需计算的区间，第二次离线则处理第一次离线分离出的区间</p><p>故总时间复杂度 $O (nT + n\sqrt{n})$，空间复杂度 $O (n)$</p><hr><p>以 「第十四分块(前体)」 为例</p><p>题目描述：查询 $l \le i &lt; j \le r$，且 $a_i \bigoplus a_j$ 的二进制表示下存在 $k$ 个 $1$ 的二元组 $(i, j)$ 个数</p><p>令二进制下有 $k$ 个 $1$ 的数的集合为 $A$（最多有 $3432$ 个），数字 $x$ 出现的次数为 $ap (x)$，那么加入一个数 $y$ 时所增加的贡献即为<br>$$<br>\Delta c(x, [l, r]) = \sum\limits_{x \in A} ap (x \bigoplus y)<br>$$<br>二次离线莫队即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXU = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">0</span>, bel[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits;</span><br><span class="line">LL buck[MAXU]= &#123;<span class="number">0</span>&#125;, preans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">querySt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, ind;</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line">querySt () &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> querySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bel[l] == bel[p.l] ? r &lt; p.r : l &lt; p.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">querySt query[MAXM];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span><span class="keyword">int</span> l, r, delt;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; subs[MAXN];</span><br><span class="line"></span><br><span class="line">LL answer[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), K = getnum ();</span><br><span class="line">limit = <span class="built_in">sqrt</span> (N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">bel[i] = (i - <span class="number">1</span>) / limit + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">query[i].l = getnum (), query[i].r = getnum ();</span><br><span class="line">query[i].ind = i, query[i].ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16384</span>; i ++)</span><br><span class="line"><span class="keyword">if</span> (__builtin_popcount (i) == K)</span><br><span class="line">bits.push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">preans[i] = buck[a[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) bits.size(); j ++)</span><br><span class="line">buck[a[i] ^ bits[j]] ++;</span><br><span class="line">&#125;</span><br><span class="line">sort (query + <span class="number">1</span>, query + M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pl = <span class="number">1</span>, pr = <span class="number">0</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = query[i].l, r = query[i].r;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l) subs[pr].push_back((T) &#123;pl, l - <span class="number">1</span>, - i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pl &lt; l) query[i].ans += preans[pl], pl ++;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l) subs[pr].push_back((T) &#123;l, pl - <span class="number">1</span>, i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pl &gt; l) query[i].ans -= preans[pl - <span class="number">1</span>], pl --;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r) subs[pl - <span class="number">1</span>].push_back((T) &#123;pr + <span class="number">1</span>, r, - i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pr &lt; r) query[i].ans += preans[pr + <span class="number">1</span>], pr ++;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r) subs[pl - <span class="number">1</span>].push_back((T) &#123;r + <span class="number">1</span>, pr, i&#125;);</span><br><span class="line"><span class="keyword">while</span> (pr &gt; r) query[i].ans -= preans[pr], pr --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span> (buck, <span class="number">0</span>, <span class="keyword">sizeof</span> (buck));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) bits.size(); j ++)</span><br><span class="line">buck[a[i] ^ bits[j]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) subs[i].size(); j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = subs[i][j].l, r = subs[i][j].r, ind = subs[i][j].delt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k ++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = buck[a[k]];</span><br><span class="line"><span class="keyword">if</span> (k &lt;= i &amp;&amp; ! K) tmp --;</span><br><span class="line"><span class="keyword">if</span> (ind &gt; <span class="number">0</span>) query[ind].ans += tmp;</span><br><span class="line"><span class="keyword">else</span> query[- ind].ans -= tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i ++) query[i].ans += query[i - <span class="number">1</span>].ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) answer[query[i].ind] = query[i].ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">write (answer[i]), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5 2</span></span><br><span class="line"><span class="comment">3 4 8 0 2</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归纳 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教筛</title>
      <link href="/2020/08/04/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
      <url>/2020/08/04/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置相关"><a href="#前置相关" class="headerlink" title="前置相关"></a>前置相关</h2><ul><li><p>类型积性函数（注：以下皆为完全积性函数，即无需满足 $x \perp y$ 即有 $f(x) · f(y) = f(xy)$</p><p>$\epsilon (n) = [n = 1]$</p><p>$id (n) = n$</p></li><li><p><a href="https://www.cnblogs.com/Colythme/p/9972264.html" target="_blank" rel="noopener">狄利克雷卷积与莫比乌斯函数</a></p></li><li><p>狄利克雷卷积与欧拉函数</p><p>此处若以 $id $ 作单位元，则 $1$ 为 $\phi$ 的逆，即 $\phi * 1 = id$</p><p>证明：由 $\sum\limits_{d | n} \phi (d) = n$ ，再带回原式可证</p></li><li><p>莫比乌斯函数与欧拉函数的转化<br>$$<br>\begin{aligned} \phi * 1 &amp;= id \ \phi * 1 * \mu &amp;= id * \mu \ \phi * \epsilon &amp;= id * \mu \ \phi &amp;= \sum\limits_{d | n} \mu(d) \frac{n}{d} \ \frac{\phi}{n} &amp;= \sum\limits_{d | n} \frac{\mu(d)}{d} \end{aligned}<br>$$</p></li></ul><h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><ul><li><p>杜教筛用于求解积性函数前缀和一类问题</p></li><li><p>下面求解积性函数 $f$ 的前缀和</p></li><li><p>设积性函数 $f, g, h$ ，且 $h = f * g$ ，则有</p></li></ul><p>$$<br>\begin{aligned} \sum\limits_{i = 1}^n h(n) &amp;= \sum\limits_{i = 1}^n \sum\limits_{d | n} g(d)f(\frac{n}{d}) \\ &amp;= \sum\limits_{d = 1}^n g(d) \sum\limits_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} f(i) \end{aligned}<br>$$</p><ul><li>令 $S(n) = \sum\limits_{i = 1}^n f(i)$</li><li>将 $d = 1$ 时的提出，再移项，得</li></ul><p>$$<br>S(n) = \sum\limits_{i = 1}^n h(i) - \sum\limits_{d = 2}^n g(d)S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$</p><ul><li>那么预处理 $h, g$ 的前缀和（一般预处理 $n^{\frac{2}{3}}$ 个？），再递归整除分块即可处理，不过一般 $h, g$ 需要自己配</li><li>但实际上并不需要用 $\text{unordered_map}$ 来记忆化，设题目给定 $N$，当前递归到 $n$，则 $n$ 的答案可以被 $N / n$ 记录，也就是用 $visit(\lfloor\frac{N}n\rfloor)$ 来判断是否已被搜过，下面给出别人的简单证明为什么不会判重</li><li><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/07/25/sG79MC6wLoOvu8k.png" alt=""></li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><h3 id="求-sum-limits-i-1-n-mu-i-sum-limits-i-1-n-phi-i"><a href="#求-sum-limits-i-1-n-mu-i-sum-limits-i-1-n-phi-i" class="headerlink" title="求$\sum\limits_{i = 1}^n \mu(i), \sum\limits_{i = 1}^n \phi(i)$"></a>求$\sum\limits_{i = 1}^n \mu(i), \sum\limits_{i = 1}^n \phi(i)$</h3><p>由 $\mu * 1 = \epsilon$ ，可令 $g = 1, h = \epsilon$ ，那么得到<br>$$<br>S(n) = 1 - \sum\limits_{d = 2}^n S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>求 $\sum \phi$ 同理</p><h3 id="求-sum-limits-i-1-n-i-phi-i-（需要用配的）"><a href="#求-sum-limits-i-1-n-i-phi-i-（需要用配的）" class="headerlink" title="求$\sum\limits_{i = 1}^n i \phi(i) （需要用配的）$"></a>求$\sum\limits_{i = 1}^n i \phi(i) （需要用配的）$</h3><p>$$<br>h(n) = \sum\limits_{d | n} d \phi(d) g(\frac{n}{d})<br>$$</p><p>希望将 $d$ 消去，故配 $g = id$ ，得 $h(n) = n^2$<br>$$<br>S(n) = \sum\limits_{i = 1}^n i - \sum\limits_{d = 2}^n d S(\left\lfloor\frac{n}{d}\right\rfloor)<br>$$<br>即可解</p><h2 id="代码（求解-sum-mu-sum-phi-）"><a href="#代码（求解-sum-mu-sum-phi-）" class="headerlink" title="代码（求解$\sum \mu, \sum \phi$ ）"></a>代码（求解$\sum \mu, \sum \phi$ ）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN / <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL phi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sumu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumphi[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e06</span> + <span class="number">5e05</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line">sumu[i] = sumu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">sumphi[i] = sumphi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> mapmu[MAXM];</span><br><span class="line">LL maphi[MAXM];</span><br><span class="line"><span class="keyword">bool</span> vmu[MAXM]= &#123;<span class="literal">false</span>&#125;, vphi[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumu[n];</span><br><span class="line"><span class="keyword">if</span> (vmu[N / n]) <span class="keyword">return</span> mapmu[N / n];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= (r - l + <span class="number">1</span>) * mu_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vmu[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> mapmu[N / n] = total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">phi_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumphi[n];</span><br><span class="line"><span class="keyword">if</span> (vphi[N / n]) <span class="keyword">return</span> maphi[N / n];</span><br><span class="line">LL total = n * <span class="number">1l</span>l * (n + <span class="number">1</span>) / <span class="number">2l</span>l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= <span class="number">1l</span>l * (r - l + <span class="number">1</span>) * phi_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line">vphi[N / n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> maphi[N / n] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">linear_sieve ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (vmu, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vmu));</span><br><span class="line"><span class="built_in">memset</span> (vphi, <span class="literal">false</span>, <span class="keyword">sizeof</span> (vphi));</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line">LL ans1 = phi_sieve (N);</span><br><span class="line"><span class="keyword">int</span> ans2 = mu_sieve (N);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld %d\n"</span>, ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速沃尔什变换「FWT」</title>
      <link href="/2020/08/04/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%E3%80%8CFWT%E3%80%8D/"/>
      <url>/2020/08/04/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%E3%80%8CFWT%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p>$$<br>C_i = \sum\limits_{i \oplus j} A_iB_j<br>$$</p><h2 id="离散沃尔什变换「DWT」"><a href="#离散沃尔什变换「DWT」" class="headerlink" title="离散沃尔什变换「DWT」"></a>离散沃尔什变换「DWT」</h2><p>设 $DWT_i (A) = \sum\limits_{j = 0}^n A_jf(i, j)$ （第一次知道原来离散变换是这么设的）</p><p>又由于<br>$$<br>\begin{aligned}<br>DWT_i(A)DWT_i(B) &amp;= DWT_i(C) \\<br>\sum\limits_{j = 0}^{n - 1} \sum\limits_{k = 0}^{n - 1} A_jB_kf(i, j)f(i, k) &amp;= \sum\limits_{j = 0}^{n - 1} \sum\limits_{k = 0}^{n - 1} A_jB_kf(i, j \oplus k)<br>\end{aligned}<br>$$<br>故 $f(i, j)f(i, k) = f(i, j \oplus k)​$</p><p>于是就有一些结论</p><ul><li>$and:  f(i, j) = [(i  and   j) = i]$ </li><li>$or:  f(i, j) = [(i  and  j) = j]$</li><li>$xor:  f(i, j) = (- 1)^{cnt (i  and  j)}$ （$cnt (x)$ 是 $x$ 的二进制位数）</li></ul><p>至于证明自己意会一下就好了</p><p>又由于 $f(i, j)$ 满足二进制拆分，即<br>$$<br>f(i, j) = \prod\limits_{bit = 0}^{cntbit - 1} f(i_{bit}, j_{bit})<br>$$<br>那么将其左右拆分，推一下式子，得（注意下面的 $i_{bit}$ 表示的是<strong>从高到低</strong>的第 $bit​$ 位）<br>$$<br>\begin{aligned}<br>DWT_i(A) &amp;= \sum\limits_{j = 0}^n A_jf(i, j) \\<br>&amp;= \sum\limits_{j = 0}^{\frac{n}{2} - 1} A_jf(i, j) + \sum\limits_{j = \frac{n}{2}}^{n - 1} A_jf(i, j)<br>\end{aligned}<br>$$<br>然后将它们的最高位提出来，得<br>$$<br>\begin{aligned}<br>DWT_i(A) = f(i_0, 0)\sum\limits_{j = 0}^{\frac{n}{2} - 1} A_j\prod_{bit = 1}^{cntbit - 1}  f(i_{bit}, j_{bit}) + f(i_0, 1)\sum\limits_{j = \frac{n}{2}}^{n - 1}A_j\prod_{bit = 1}^{cntbit - 1} f(i_{bit}, j_{bit})<br>\end{aligned}<br>$$<br>整理一下，得 $(i \in [0, \frac{n}{2} - 1])$<br>$$<br>\begin{aligned}<br>DWT_i(A) &amp;= f(0, 0)DWT_{\frac{n}{2}}(A_{left}) + f(0, 1)DWT_{\frac{n}{2}}(A_{right}) \\<br>DWT_{i + \frac{n}{2}}(A) &amp;= f(1, 0))DWT_{\frac{n}{2}}(A_{left}) + f(1, 1)DWT_{\frac{n}{2}}(A_{right})<br>\end{aligned}<br>$$<br>至于 $iDWT$，就是解个二元一次方程的问题</p><p>接下来只要把 $FFT$ 的部分程序改一下就好了</p><p>下面记录一些常见公式<br>$$<br>and:  a[i + j] += a[i + j + k]  (DWT) \\<br>and:  a[i + j] -= a[i + j + k]  (iDWT) \\<br> \\<br>or:  a[i + j + k] += a[i + j]  (DWT) \\<br>or:  a[i + j + k] -= a[i + j]  (iDWT) \\<br> \\<br>xor:  a[i + j] = a[i + j] + a[i + j + k],  a[i + j + k] = a[i + j] - a[i + j + k]  (DWT) \\<br>xor:  a[i + j] = \frac{a[i + j] + a[i + j + k]}{2},  a[i + j + k] = \frac{a[i + j] - a[i + j + k]}{2}  (iDWT)<br>$$</p><h2 id="代码「-and-or-xor-」"><a href="#代码「-and-or-xor-」" class="headerlink" title="代码「$and,  or,  xor$」"></a>代码「$and,  or,  xor$」</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常系数线性递推</title>
      <link href="/2020/08/04/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
      <url>/2020/08/04/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多项式除法-取模"><a href="#多项式除法-取模" class="headerlink" title="多项式除法|取模"></a>多项式除法|取模</h3><p>该部分见 <a href="https://colythme.github.io/2020/07/22/多项式操作/">多项式操作</a></p><h3 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h3><p>（这部分我也不怎么理解，就大概记个结论）</p><p>对 $n$ 阶矩阵 $A$ 的特征向量 $\vec{v}$ 与，有特征值 $\lambda$ 满足<br>$$<br>A\vec v = \lambda\vec v<br>$$<br>移项则有 $(\lambda I - A)\vec v = 0$，其中 $I$ 为单位矩阵</p><p>那么有解的充要条件是 $det(\lambda I - A) = 0$</p><p>令 $f(\lambda) = det(\lambda I - A)$，即此时可将 $det (\lambda I - A)$ 看作一个 $n$ 阶多项式，则称 $f(\lambda)$ 为矩阵 $A$ 的特征多项式，对矩阵 $A$，其任意特征值 $\lambda_0$ 都满足 $f(\lambda_0) = 0$</p><h3 id="text-Hamiton-Cayley-定理"><a href="#text-Hamiton-Cayley-定理" class="headerlink" title="$\text{Hamiton-Cayley}$定理"></a>$\text{Hamiton-Cayley}$定理</h3><p>对矩阵 $A$ 及其特征多项式 $f(x)$，满足 $f(A) = O$，其中 $O$ 为零矩阵</p><p>证明留坑</p><h2 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h2><p>求一个满足 $k$ 阶齐次线性递推数列 $h_i$ 的第 $n$ 项，即<br>$$<br>h_n = \sum\limits_{i = 1}^k f_i \times h_{n - i}<br>$$<br>它有三个特点</p><ul><li>常系数：递推系数与下标无关</li><li>齐次：递推式不存在常数项，就类似 $y = ax + b$ 中 $b = 0$</li><li>线性：都为一次项</li></ul><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>加速矩阵 $A$ $\times$ 初始矩阵 $H$：<br>$$<br>\begin{pmatrix}<br>f_1 &amp; f_2 &amp; f_3 &amp; \cdots &amp; f_n \\<br>1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \cdots &amp; \vdots \\<br>0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1<br>\end{pmatrix}<br>\times<br>\begin{pmatrix}<br>h_k \\<br>\vdots \\<br>h_3 \\<br>h_2 \\<br>h_1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>h_{k + 1} \\<br>\vdots \\<br>h_4 \\<br>h_3 \\<br>h_2<br>\end{pmatrix}<br>$$<br>那么快速幂 $A^nH$ 即可，复杂度 $O (k^3 \log n)$</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>考虑 $A\vec v = \lambda\vec v$，也就是说现在存在<br>$$<br>\begin{pmatrix}<br>h_{k + 1} \\<br>\vdots \\<br>h_4 \\<br>h_3 \\<br>h_2<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\lambda h_k \\<br>\vdots \\<br>\lambda h_3 \\<br>\lambda h_2 \\<br>\lambda h_1<br>\end{pmatrix}<br>$$<br>推广一下，$h_n = \lambda^{n - 1} h_1$，则<br>$$<br>\begin{aligned}<br>h_{k + 1} &amp;= f_1h_{k -1} + f_2h_{k - 2} + … + f_kh_1 \\<br>\lambda^kh_1 &amp;= f_1\lambda^{k - 1}h_1 + f_2\lambda^{k - 2}h_2 + … + f_kh_1 \\<br>\lambda^k &amp;= f_1\lambda^{k - 1} + f_2\lambda^{k - 2} + … + f_k<br>\end{aligned}<br>$$<br>将 $\lambda$ 替换为 $x$，则有 $F(x) = x^k - f_1x^{k - 1} - f_2x^{k - 2} - … - f_k$</p><p>此时 $F(x)$ 就是矩阵 $A$ 的特征多项式，有 $F(A) = 0$</p><p>考虑等式<br>$$<br>x^n = F(x)Q(x) + R(x)<br>$$<br>以 $A$ 代入，则有<br>$$<br>A^n = R(A)<br>$$<br>别忘了现在要求的是 $A^n\vec v$，那么两边同乘 $\vec v$，有 $A^n\vec v = R(A)\vec v$</p><p>$R(x)$ 可以通过由 $A(x) = x^n$ 对 $F(x)$ 取模求得，注意此时不能直接取模，因为 $n$ 可以非常大（比如 $n = 1e9）$，无法存下多项式 $x^n$，需要通过快速幂求解</p><p>设 $R(x) = \sum\limits_{i = 0}^{k - 1} c_ix^i$，则<br>$$<br>A^n\vec v = \sum\limits_{i = 0}^{k - 1}c_iA^i\vec v<br>$$<br>而 $A^i\vec v$ 实际上就是<br>$$<br>\begin{pmatrix}<br>h_{k + i} \\<br>\vdots \\<br>h_{i + 3} \\<br>h_{i + 2} \\<br>h_{i + 1}<br>\end{pmatrix}<br>$$<br>$A$ 的次数最多 $k - 1$，也就是说最多只会取到前 $2k - 1$ 个 $h_i$，我们最后要取得是 $A^n\vec v$ 的第一位，每次乘上一个 $A$ 则令 $h$ 数组向下移一位，那么最终答案即为 $ans = \sum\limits_{i = 0}^{k - 1} c_ih_i$</p><p>时间复杂度 $O (k \log k \log n)$</p><p>其实每次在求多项式取模的时候都是对 $F(x)$ 取模，所以可以提前对 $F(x)$ 预处理，求出其逆，那么可以少很多常数（虽然我的常数还是贼大就是了。。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">32000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;, limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL A[MAXN], B[MAXN], O[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(LL* X, LL* Y, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm, <span class="keyword">int</span> rst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= fn + fm; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn; i ++) A[i] = X[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fm; i ++) B[i] = Y[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = A[i] * B[i] % MOD;</span><br><span class="line">NTT (A, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rst; i ++) X[i] = A[i] * invn % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = rst + <span class="number">1</span>; i &lt;= fn + fm; i ++) X[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123; a[<span class="number">0</span>] = power (O[<span class="number">0</span>], MOD - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= deg &lt;&lt; <span class="number">1</span>; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) A[i] = O[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++) B[i] = a[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) a[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL R[MAXN], INVG[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prep</span> <span class="params">(LL* G, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) O[i] = G[i];</span><br><span class="line">reverse (O, O + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= m; i ++) O[i] = <span class="number">0</span>;</span><br><span class="line">inverse (n - m + <span class="number">1</span>, INVG);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyMod</span> <span class="params">(LL* F, LL* G, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123; <span class="comment">// F mod G = R</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) R[i] = F[i];</span><br><span class="line">reverse (R, R + n + <span class="number">1</span>); mul (R, INVG, n, n - m + <span class="number">1</span>, n);</span><br><span class="line">reverse (R, R + n - m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i ++) R[i] = <span class="number">0</span>;</span><br><span class="line">mul (R, G, n - m, m, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) R[i] = (F[i] - R[i] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123; F[i] = i &lt; m ? R[i] : <span class="number">0</span>; R[i] = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, L;</span><br><span class="line">LL F[MAXK]= &#123;<span class="number">0</span>&#125;, h[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL X[MAXN]= &#123;<span class="number">0</span>&#125;, ANS[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPow</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// X ^ p (mod F)</span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) &#123; mul (ANS, X, K - <span class="number">1</span>, K - <span class="number">1</span>, L); PolyMod (ANS, F, L, K); &#125;</span><br><span class="line">mul (X, X, K - <span class="number">1</span>, K - <span class="number">1</span>, L); PolyMod (X, F, L, K);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum (); L = (K - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++) F[K - i] = (MOD - getnum () % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) h[i] = getnum () % MOD;</span><br><span class="line">F[K] = X[<span class="number">1</span>] = ANS[<span class="number">0</span>] = <span class="number">1</span>; prep (F, L, K);</span><br><span class="line">PolyPow (N);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) ans = (ans + ANS[i] * h[i] % MOD + MOD) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常系数非齐次线性递推"><a href="#常系数非齐次线性递推" class="headerlink" title="常系数非齐次线性递推"></a>常系数非齐次线性递推</h2><p>求一个满足 $k$ 阶齐次线性递推数列 $h_i$ 的第 $n$ 项，即<br>$$<br>h_n = P(n) + \sum\limits_{i = 1}^k f_i \times h_{n - i}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷4233 - 射命丸文的笔记</title>
      <link href="/2020/08/04/%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/04/%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>显然答案是总哈密顿回路数除以值得记录的竞赛图数</p><p>那么先求解总哈密顿回路数，考虑每个哈密顿回路会在几个值得记录的竞赛图中，则有<br>$$<br>Hamitons = (n - 1)!2^{C_n^2 - n}<br>$$<br>即总共有 $(n - 1)!$ 种哈密顿回路，然后剩下的边随便选</p><p>于是现在考虑值得记录的竞赛图数</p><p>首先如果一个竞赛图要有哈密顿回路，那么它至少要有一个包含所有节点的环，即该图是强连通的，并且显然非强连通竞赛图它一定不存在哈密顿回路，所以有结论</p><blockquote><p>有且仅有强连通竞赛图存在哈密顿回路</p></blockquote><p>那么问题转化为求解强连通竞赛图</p><p>发现正面难以求解，就考虑反面求解</p><p>设 $f_n$ 表示 $n$ 个节点的强连通竞赛图数，$g_n$ 表示 $n$ 个节点的竞赛图数（即 $2^{C_n^2}$），可得 $DP$ 方程<br>$$<br>f_n = g_n - \sum\limits_{j = 1}^{n - 1} f_jg_{n - j}\dbinom{n}{j}<br>$$<br>其中求解非强连通竞赛图部分是每次将拓扑序最小的强连通分量提取出来计数，那么剩下的点随意连接（注意，此时取的是<strong>拓扑序最小的强联通分量</strong>，故该强联通分量与其它连通分量的连边方向是固定的）</p><p>现在考虑优化<br>$$<br>\frac{f_n}{n!} = \frac{g_n}{n!} - \sum\limits_{j = 1}^{n - 1} \frac{f_j}{j!}\frac{g_{n - j}}{(n - j)!}<br>$$</p><p>令指数型生成函数 $F(x) = \sum\limits_n^{\infty} \frac{f_n}{n!}, G(x) = \sum\limits_n^{\infty} \frac{g_n}{n!}$，易知<br>$$<br>\begin{aligned}<br>F(x) &amp;= G(x) - F(x)G(x) \\<br>F(x) &amp;= \frac{G(x)}{1 + G(x)}<br>\end{aligned}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span> <span class="params">(LL* a, <span class="keyword">int</span> limit, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL omega = power (inv == <span class="number">1</span> ? g : invg, <span class="number">1l</span>l * (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL a1[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, a2[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* A, LL* B, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> limit, lim;</span><br><span class="line"><span class="keyword">for</span> (limit = <span class="number">1</span>, lim = <span class="number">0</span>; limit &lt; n + m; limit &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">a1[i] = A[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">a2[i] = B[i];</span><br><span class="line">DFT (a1, limit, <span class="number">1</span>), DFT (a2, limit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a1[i] * a2[i] % MOD;</span><br><span class="line">DFT (a1, limit, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (limit, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">A[i] = a1[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL temp[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* A, LL* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">temp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">temp[i] = A[i];</span><br><span class="line">NTT (temp, B, deg, deg), NTT (temp, B, deg, deg);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">B[i] = (<span class="number">2l</span>l * B[i] % MOD - temp[i] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL F[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL G[MAXN]= &#123;<span class="number">0</span>&#125;, invG[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL answer[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; N);</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">F[i] = G[i] = power (<span class="number">2l</span>l, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * power (fact[i], MOD - <span class="number">2</span>);</span><br><span class="line">G[<span class="number">0</span>] ++;</span><br><span class="line">inverse (N, G, invG);</span><br><span class="line">NTT (F, invG, N, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">answer[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">answer[i] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">answer[i] = fact[i - <span class="number">1</span>] * power (<span class="number">2l</span>l, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) / <span class="number">2l</span>l - i) % MOD * power (F[i] * fact[i] % MOD, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导数与积分</title>
      <link href="/2020/08/04/%E5%AF%BC%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/"/>
      <url>/2020/08/04/%E5%AF%BC%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><h3 id="平均变化率"><a href="#平均变化率" class="headerlink" title="平均变化率"></a>平均变化率</h3><p>函数 $y = f(x)$ 从 $x_1$ 到 $x_2$ 的平均变化率为 $\frac{f(x_2) - f(x_1)}{x_2 - x_1}$，简记作 $\frac{\Delta y}{\Delta x}$</p><h3 id="瞬时变化率与导数"><a href="#瞬时变化率与导数" class="headerlink" title="瞬时变化率与导数"></a>瞬时变化率与导数</h3><p>函数 $y = f(x)$ 在 $x = x_0$ 处的瞬时变化率是函数 $f(x)$ 从 $x_0$ 到 $x_0 + \Delta x$ 的平均变化率在 $\Delta x \to 0$ 时的极限，记作 $\lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x)}{\Delta x} = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}$</p><p>一般地，我们称上文的瞬时变化率为函数 $y = f(x)$ 在 $x = x_0$ 处的导数，记作 $f’(x_0)$ 或 $\frac{\mathrm{d} y}{\mathrm{d} x} \bigg|_{x = x_0}$</p><p>实际上，导数描述的即为任何事物的瞬时变化率</p><p>Example：</p><p>求 $y = f(x) = x^2 - 7x + 5$ 在 $x = 2$ 的导数，则有<br>$$<br>\begin{aligned} \frac{\Delta y}{\Delta x} &amp;= \frac{f(2 + \Delta x) - f(2)}{\Delta x} \\ &amp;= \Delta x - 3  \end{aligned}<br>$$<br>所以<br>$$<br>f’(2) = \lim\limits_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim\limits_{\Delta x \to 0} (\Delta x - 3) = - 3<br>$$</p><h3 id="常见的基本初等函数的导数公式"><a href="#常见的基本初等函数的导数公式" class="headerlink" title="常见的基本初等函数的导数公式"></a>常见的基本初等函数的导数公式</h3><table><thead><tr><th align="center">$f(x)$</th><th align="center">$f’(x)$</th><th align="center">$f(x)$</th><th align="center">$f’(x)$</th></tr></thead><tbody><tr><td align="center">$c$</td><td align="center">$0$</td><td align="center">$x^a$</td><td align="center">$ax^{a - 1}$</td></tr><tr><td align="center">$\sin x$</td><td align="center">$\cos x$</td><td align="center">$\cos x$</td><td align="center">$- \sin x$</td></tr><tr><td align="center">$a^x$</td><td align="center">$a^x \ln a$</td><td align="center">$e^x$</td><td align="center">$e^x$</td></tr><tr><td align="center">$\log_a x$</td><td align="center">$\frac{1}{x \ln a}$</td><td align="center">$\ln x$</td><td align="center">$\frac{1}{x}$</td></tr><tr><td align="center">$\tan x$</td><td align="center">$\sec^2 x = \frac{1}{\cos^2 x}$</td><td align="center">$\cot x$</td><td align="center">$- \csc^2 x = - \frac{1}{\sin^2 x}$</td></tr></tbody></table><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p>$$<br>[f(x) \pm g(x)]’ = f’(x) \pm g’(x) \\<br>[cf(x)]’ = cf’(x) \\<br>[f(x) \cdot g(x)]’ = f’(x)g(x) + f(x)g’(x) \\<br>[\frac{f(x)}{g(x)}]’ = \frac{f’(x)g(x) - f(x)g’(x)}{[g(x)]^2}<br>$$</p><p>复合函数 $y = f(g(x))​$ 的导数和函数 $y = f(u), u = g(x)​$ 的导数间的关系为 $y_x’ = y_u’ \cdot u_x’​$，即 $y​$ 对 $x​$ 的导数，等于 $y​$ 对 $u​$ 的导数与 $u​$ 对 $x​$ 的导数的乘积</p><p>Example：</p><p>对 $y = cos^2 \left(2x + \frac{\pi}{3}\right)$ 求导<br>$$<br>这个复合函数是 f(x) = x^2 套 f(x) = \cos x 套 f(x) = 2x + \frac{\pi}{3} \\<br>容易得到 y’ = -4\sin (2x + \frac{\pi}{3})\cos (2x + \frac{\pi}{3}) \\<br>则有 y’ = -2\sin (4x + \frac{2\pi}{3})<br>$$</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>如果有函数自变量个数大于一，如<br>$$<br>f(x, y) = x^2 + xy + y^2<br>$$<br>那么可以固定一个平面，如 $x$ 平面，那么 $f(x, y)$ 可以看作是关于 $y$ 的参数函数 $f_x(y)$，也就是说每个 $x$ 定义了一个一元函数 $f_x(y)$</p><p>比如现在令 $x = a$，则有<br>$$<br>f_a(y) = a^2 + ay + y^2<br>$$<br>对其求导，则有<br>$$<br>f’_a(y) = a + 2y<br>$$<br>那么对于所有 $x$ 的取值，定义<br>$$<br>\frac{\partial f}{\partial y}(x, y) = x + 2y<br>$$<br>这就是 $f$ 关于 $y$ 的偏导数</p><p>那么对于多元函数 $f(x_1, x_2, …, x_n)$ 在点 $(a_1, a_2, …, a_n)$ 关于 $x_k$ 的偏导数定义为<br>$$<br>\frac{\partial f}{\partial x_k}(a_1, …, a_n) = \lim\limits_{\Delta x_k \to -} \frac{f(a_1, …, a_k + \Delta x_k, …, a_n) - f(a_1, …, a_n)}{\Delta x_k}<br>$$<br>这就做到了偏导数通过一元函数进行计算</p><p>这说明<br>$$<br>\frac{\partial f}{\partial x_k}(a_1, …, a_n) = \frac{\mathrm{d} f(a_1, …, a_{k - 1}, a_{k + 1}, …, a_n)}{\mathrm{d} x_k}(a_1, …, a_n)<br>$$</p><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><h4 id="二阶导数"><a href="#二阶导数" class="headerlink" title="二阶导数"></a>二阶导数</h4><p>如何函数的导数 $f’(x)$ 在 $x$ 处可导，则称 $[f’(x)]’$ 为 $x$ 的二阶导数</p><h4 id="高阶导数-1"><a href="#高阶导数-1" class="headerlink" title="高阶导数"></a>高阶导数</h4><p>那么高阶导数的定义即为二阶导数的扩展</p><p>$n$ 阶导数记作 $f^{(n)}(x), y^{(n)}, \frac{\mathrm{d}^ny}{\mathrm{d}x^n}$ 或 $\frac{\mathrm{d}^nf(x)}{\mathrm{d}x^n}$</p><h4 id="高阶导数求导法则"><a href="#高阶导数求导法则" class="headerlink" title="高阶导数求导法则"></a>高阶导数求导法则</h4><p>$$<br>\frac{\mathrm{d}^n}{\mathrm{d}^nx^n}(cu) = c\frac{\mathrm{d}}{\mathrm{d}x^n}u \\<br>\frac{\mathrm{d}^n}{\mathrm{d}x^n}(u \pm v) = \frac{\mathrm{d}^n}{\mathrm{d}x^n}u \pm \frac{\mathrm{d}^n}{\mathrm{d}x^n}v \\<br>\frac{\mathrm{d}^n}{\mathrm{d}x^n}(u \times v) = \sum\limits_{k = 0}^n \dbinom{n}{k}\frac{\mathrm{d}^{d - k}}{\mathrm{d}x^{d - k}}u\frac{\mathrm{d^k}}{\mathrm{d}x^k}v 「莱布尼兹公式」<br>$$</p><h4 id="常用高阶导数公式"><a href="#常用高阶导数公式" class="headerlink" title="常用高阶导数公式"></a>常用高阶导数公式</h4><p>$$<br>(x^{\alpha})^{(n)} = x^{\alpha - n} \prod\limits_{k = 0}^{n - 1}(\alpha - k) \\<br>(\frac{1}{x})^{(n)} = (- 1)^n\frac{n!}{x^{n + 1}} \\<br>(\ln x)^{(n)} = (- 1)^{n - 1}\frac{(n - 1)!}{x^n} \\<br>(e^x)^{(n)} = e^x \\<br>(a^x){(n)} = a^x \cdot \ln^n a (a &gt; 0) \\<br>(\sin (kx + b))^{(n)} = k^n\sin (kx + b + \frac{n\pi}{2}) \\<br>(\cos (kx + b))^{(n)} = k^n\cos (kx + b + \frac{n\pi}{2})<br>$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><p>函数 $f(x)$ 在区间 $[a, b]$ 上连续，用分点 $a = x_0 &lt; x_1 &lt; … &lt; x_{i - 1} &lt; x_i &lt; … &lt; x_n = b$，在每个小区间 $[x_{i - 1}, x_i]$ 上人去一点 $\xi (i = 1, 2, …, n)$，作和式 $S_n = \sum\limits_{i = 1}^n f(\xi_i)\Delta x = \sum\limits_{i = 1}^n \frac{b - a}{n} f(\xi_i)$，当 $n \to \infty$ 时，和式无限接近的常数被称作函数 $f(x)$ 在区间 $[a, b]$ 上的定积分，记作 $\int_a^b f(x) \mathrm{d} x = \lim\limits_{n \to \infty} \sum\limits_{i = 1}^n \frac{b - a}{n} f(\xi_i)$ ，$a, b$ 分别称作积分下限与积分上限，区间 $[a, b]$ 称作积分区间，$f(x)$ 称作被积函数，$x$ 称作积分变量，$f(x)\, \mathrm{d} x$ 称作积式</p><p>其几何意义表示由直线 $x = a, x = b, y = 0​$ 及曲线 $y = f(x)​$ 所围成的曲边梯形面积</p><p>当 $x \in [a, b]​$ 时，若 $f(x) &lt; 0​$，则直线 $x = a, x = b, x​$ 轴和曲线 $f(x)​$ 围成的图形的面积应为 $- \int_a^b f(x) \mathrm{d} x​$</p><h4 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h4><p>$$<br>\int_a^b kf(x) \mathrm{d} x = k\int_a^b f(x) \mathrm{d} \\<br>\int_a^b[f_1(x) \pm f_2(x)] \mathrm{d} x = \int_a^b f_1(x) \mathrm{d} x \pm \int_a^b f_2(x) \mathrm{d} x \\<br>\int_a^b f(x) \mathrm{d} = \int_a^c f(x) \mathrm{d} x + \int_c^b f(x) \mathrm{d} x (其中 a &lt; c &lt; b)<br>$$</p><h3 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h3><p>一般地，如果 $f(x)$ 是区间 $[a, b]$ 上的连续函数，并且 $F’(x) = f(x)$，那么<br>$$<br>\int_a^b f(x) \mathrm{d} x = F(x) \big|_a^b = F(b) - F(a)<br>$$</p><h3 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h3><p>不定积分实际上就是 $f(x)$ 的原函数 $F(x)$，$F(x)$ 也被称作 $f(x)$ 的不定积分</p><p>函数族 $f = \{F(x) + C | C \in \mathbb{R}\}​$ 称为函数 $f = k​$ 的原函数族，也就是 $f = k(x)​$ 的所有可能的原函数的集合，其中 $f = C​$ 称作积分常数，是 $f = k(x)​$ 经过垂直平移得到的一组常数「因为不管怎么样对于每个 $x​$ 它们的导数是相同的」</p><h3 id="常见不定积分公式表"><a href="#常见不定积分公式表" class="headerlink" title="常见不定积分公式表"></a>常见不定积分公式表</h3><table><thead><tr><th align="center">$\int_a^b c \mathrm{d}x = cx \mid_a^b$</th></tr></thead><tbody><tr><td align="center">$\int_a^b x^n \mathrm{d}x = \frac{1}{n + 1}x^{n + 1} \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \frac{1}{x} \mathrm{d}x = \ln x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \sin x \mathrm{d}x = - \cos x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b \cos x \mathrm{d}x = \sin x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b e^x \mathrm{d}x = e^x \mid_a^b$</td></tr><tr><td align="center">$\int_a^b a^x \mathrm{d}x = \frac{a^x}{\ln a} \mid_a^b$ $(a &gt; 0$ 且 $a \neq 1)$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串类题记录</title>
      <link href="/2020/08/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><h3 id="在文本串中寻找子串"><a href="#在文本串中寻找子串" class="headerlink" title="在文本串中寻找子串"></a>在文本串中寻找子串</h3><p>在文本串 $T$ 中寻找模式串 $S$，那么 $S$ 一定是 $T$ 的某个后缀的前缀，后缀排序后，在 $SA$ 中二分 $S$ 的位置，每次 $check$ 比较时间 $O (|S|)$，总时间复杂度 $O (|S| \log |T|)$</p><h3 id="比较两个子串的大小关系"><a href="#比较两个子串的大小关系" class="headerlink" title="比较两个子串的大小关系"></a>比较两个子串的大小关系</h3><p>比较 $S$ 的子串 $A = S[l_1…r_1], B = S[l_2…r_2]$ 的大小关系</p><p>若 $lcp (l_1, l_2) \ge \min (|A|, |B|)$，则 $A &lt; B \Longleftrightarrow |A| &lt; |B|$，反之 $A &lt; B \Longleftrightarrow rk_{l_1} &lt; rk_{l_2}$</p><h3 id="本质不同子串数目"><a href="#本质不同子串数目" class="headerlink" title="本质不同子串数目"></a>本质不同子串数目</h3><p>设字符串 $S$ 长度为 $n$</p><p>$ans = \frac{n(n + 1)}2 - \sum\limits_{i = 2}^n height[i]$</p><h3 id="从字符串首或尾取字符构成最小字典序的字符串"><a href="#从字符串首或尾取字符构成最小字典序的字符串" class="headerlink" title="从字符串首或尾取字符构成最小字典序的字符串"></a>从字符串首或尾取字符构成最小字典序的字符串</h3><p><a href="https://www.luogu.com.cn/problem/P2870" target="_blank" rel="noopener">[USACO07DEC]Best Cow Line G</a></p><p>最基本贪心，若两端字符不同，优先取大的，那么问题就在于两端相同</p><p>设 $pre_i, suf_i$ 分别表示字符串 $i$ 开始的前、后缀，那么每次只要比较 $pre_i$ 和 $suf_i$ 的大小就可以决定，但是这样是 $O (n^2)$ 的</p><p>考虑将反串隔一个特殊字符插在原串后，跑一边后缀数组，假设此时原串剩余 $[l, r]$ 没处理，那么只要比较 $SA[2n - l + 2]$ 和 $SA[r]$ 即可（串以 $1$ 为起始位置）</p><h3 id="判断字符串中是否存在某子串不重叠地出现了两次"><a href="#判断字符串中是否存在某子串不重叠地出现了两次" class="headerlink" title="判断字符串中是否存在某子串不重叠地出现了两次"></a>判断字符串中是否存在某子串不重叠地出现了两次</h3><p>二分子串长度 $L$，则 $height$ 数组能被分为若干满足段内 $height$ 数组大小都 $\ge L$ 的段，再利用 $RMQ$ 求出段内最大与最小的 $SA$ 值，判断其插值与 $L$ 的关系</p><h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = last, p = ++ m;</span><br><span class="line">last = p;</span><br><span class="line">len[p] = len[fa] + <span class="number">1</span>, subsize[p] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; ! tr[fa][c])</span><br><span class="line">tr[fa][c] = p, fa = father[fa];</span><br><span class="line"><span class="keyword">if</span> (! fa) &#123; father[p] = <span class="number">1</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; father[p] = x; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">len[np] = len[fa] + <span class="number">1</span>, father[np] = father[x];</span><br><span class="line">father[x] = father[p] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质不同子串个数"><a href="#本质不同子串个数" class="headerlink" title="本质不同子串个数"></a>本质不同子串个数</h3><p>建立后缀自动机，在 $parent$ 树上对所有状态 $u$，统计 $\sum\limits_u len(u) - fa(len(u))$ 即可</p><h3 id="所有不同子串的总长度"><a href="#所有不同子串的总长度" class="headerlink" title="所有不同子串的总长度"></a>所有不同子串的总长度</h3><p>建立后缀自动机，在 $parent$ 树上一个点 $u$ 代表的所有后缀的贡献为 $\frac{(1 + len(u))len(u)}2$，然后再减去 $fa(u)$ 相应的贡献即是其净贡献</p><h3 id="字典序第-k-大子串"><a href="#字典序第-k-大子串" class="headerlink" title="字典序第 $k$ 大子串"></a>字典序第 $k$ 大子串</h3><p><a href="https://www.luogu.com.cn/problem/P3975" target="_blank" rel="noopener">[TJOI2015]弦论</a></p><p>其中 $T$ 为 $0$ 则表示不同位置的相同子串算作一个，$T$ 为 $1$ 则表示不同位置的相同子串算作多个</p><p>咱按着路径来走，那么此时走到的每个状态对应唯一一个后缀，设 $sum_i$ 表示节点 $i$ 能够到达的所有子串个数，初始化 $sum_i$，若 $T = 0$ 则 $sum_i = 1$，若 $T = 1$ 则 $sum_i = size(i)$，然后再求个和，即 $sum_i += \sum\limits_c sum_{trans(i, c)}$</p><p>然后按位判断走一下就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">T == <span class="number">0</span> ? Size[i] = Sum[i] = <span class="number">1</span> : Sum[i] = Size[i];</span><br><span class="line">Size[<span class="number">1</span>] = Sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line"><span class="keyword">if</span> (Tree[Topo[i]][j])</span><br><span class="line">Sum[Topo[i]] += Sum[Tree[Topo[i]][j]];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= Size[x]) <span class="keyword">return</span> ;</span><br><span class="line">k -= Size[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = Tree[x][i];</span><br><span class="line"><span class="keyword">if</span> (! t) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; Sum[t]) &#123; k -= Sum[t]; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="built_in">putchar</span> (i + <span class="string">'a'</span>), print (t, k);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小循环移位"><a href="#最小循环移位" class="headerlink" title="最小循环移位"></a>最小循环移位</h3><blockquote><p>给定一个字符串 $S$，求其字典序最小的循环移位</p></blockquote><p>不难发现 $S + S$ 一定包含 $S$ 的最小循环移位，那么构造出 $S + S$ 的后缀自动机，然后贪心访问最小的字符即可</p><h3 id="模式串第一次出现的位置"><a href="#模式串第一次出现的位置" class="headerlink" title="模式串第一次出现的位置"></a>模式串第一次出现的位置</h3><blockquote><p>给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）</p></blockquote><p>设 $firstpos(i)$ 表示状态 $i$ 代表后缀第一次出现的位置</p><p>在 $parent$ 树上考虑，显然底层节点的 $endpos$ 一定是唯一的，那么它们的 $firstpos$ 也可直接确定，那么对一个不在底层的状态 $i$，有 $firstpos(i) = \min\limits_{j \cap fa(j) = i}\{firstpos(j)\}$</p><p>实际上上述过程可以在构造时做完（以下操作前提为 $T$ 位置编号从 $1$ 开始）</p><p>在新加入一个点 $p$ 时，有 $firstpos(p) = len(p)$</p><p>在将节点 $q$ 复制到 $np$ 时，有 $firstpos(np) = \min(firstpos(q), firstpos(p)) = firstpos(q)$</p><p>令 $t$ 表示 $P$ 在 $T$ 中走到的状态，那么答案便为 $firstpos(t) - |P| + 1$</p><h3 id="最短的没有出现过的字符串"><a href="#最短的没有出现过的字符串" class="headerlink" title="最短的没有出现过的字符串"></a>最短的没有出现过的字符串</h3><blockquote><p>给定一个字符串 $S$ 和一个特定的字符集 $M$，我们要找一个长度最短的由 $M$ 中字符构成的没有在 $S$ 中出现过的字符串</p></blockquote><p>在后缀自动机上动态规划，令 $f_u$ 表示已经处理了一段子串，当前在状态 $u$，为找到不连续转移还需要添加的最少字符数量，转移也比较简单<br>$$<br>f_u = 1 + \min\limits_{c \in M \cap trans(u, c) \in SAM} f_{trans(u, c)}<br>$$<br>那么最终答案为 $f_0$，输出字符串则逆推回去即可</p><h3 id="两个字符串的最长公共子串"><a href="#两个字符串的最长公共子串" class="headerlink" title="两个字符串的最长公共子串"></a>两个字符串的最长公共子串</h3><blockquote><p>给定字符串 $S$ 和 $T$，求它们的最长公共子串</p></blockquote><p>对 $S$ 构造后缀自动机</p><p>对 $T$ 的每个前缀，设当前前缀 $[1, i]$，求出该前缀的在 $S$ 上的最长后缀长度 $l_i$，那么答案即为 $\max\limits_i \{l_i\}$</p><p>将每个前缀放在后缀自动机上跑，设当前前缀 $i$ 最终走到状态 $u$，那么现在扩展到前缀 $i + 1$，多出字符 $T_{i + 1} = c$，有两种情况</p><ul><li>如果存在 $trans(u, c)$，那么 $u = trans(u, c), l_{i + 1} = l_i + 1$</li><li>如若不然，则在后缀自动机找到前缀 $i$ 第一个点 $p$，使其满足 $trans (p, c)$ 存在，就是 $p$ 在 $parent$ 上是 $u$ 的祖先，同时 $l_{i + 1} = len(p)$，如果最终找不到，那就返回源点，同时 $l_{i + 1} = 0$</li></ul><p>$l_n$ 最多为 $|T|$，而每位又最多被删一次，故最终时间复杂度 $O (|S| + |T|)$</p><h3 id="多个字符串间的最长公共子串"><a href="#多个字符串间的最长公共子串" class="headerlink" title="多个字符串间的最长公共子串"></a>多个字符串间的最长公共子串</h3><blockquote><p>给定 $k$ 个字符串 $S$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$</p></blockquote><p><a href="https://www.spoj.com/problems/LCS2/" target="_blank" rel="noopener">Longest Common Substring II</a></p><p>这和求两个的实际上是差不多的</p><p>先对第一个字符串建一个后缀自动机，剩下的串在上面匹配</p><p>对于每个节点 $i$，设 $mx_i$ 表示当前匹配串走到状态 $i$ 可匹配的最长长度，$pl_i$ 表示走到状态 $i$ 的所有串在该处留下的最长匹配长度的最小值</p><p>当然 $mx_i$ 要先对它的子树的所有 $mx$ 取一个最大值，这样方便统计答案</p><p>那么最后答案便是 $\max\limits_i \{pl_i\}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (~ <span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>)) &#123;</span><br><span class="line">n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; ! tr[p][c])</span><br><span class="line">p = father[p], l = len[p];</span><br><span class="line"><span class="keyword">if</span> (! p) p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l ++, p = tr[p][c];</span><br><span class="line">mx[p] = max (mx[p], l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> x = topo[i];</span><br><span class="line">pl[x] = min (pl[x], mx[x]);</span><br><span class="line">mx[father[x]] = max (mx[father[x]], min (len[father[x]], mx[x]));</span><br><span class="line">mx[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) ans = max (ans, pl[i]);</span><br></pre></td></tr></table></figure><p>对另外一种方法，就是把每个字符串隔一个不同的特殊字符拼在一起，然后把拼好的字符串拿去建后缀自动机的方法，本质上是一样的</p><h3 id="求两个字符串本质不同的的子串总数"><a href="#求两个字符串本质不同的的子串总数" class="headerlink" title="求两个字符串本质不同的的子串总数"></a>求两个字符串本质不同的的子串总数</h3><blockquote><p>给定字符串 $S$ 和 $T$，并给定 $l, r$，求 $T$ 中不在 $S[l…r]$ 内出现的子串个数</p></blockquote><p><a href="https://www.luogu.com.cn/problem/P4770" target="_blank" rel="noopener">[NOI2018]你的名字</a></p><p>先考虑 $l = 1, r = |T|$ 的情况：</p><p>因为任意子串为字符串前缀的某些后缀，那么令 $lim[i]$ 表示 $T[1…i]$ 在 $S$ 上所能匹配的最大长度，$posi[i]$ 表示$T$的后缀自动机上的点 $i$ 的 $endpos$ 集合中最靠前的位置，那么答案即为<br>$$<br>ans = \sum\limits_i \max (0, len(i) - min (len(fa(i)), lim[posi[i]]))<br>$$<br>其中 $i$ 枚举 $T$ 后缀自动机中的所有点</p><p>接下来考虑 $l, r$ 任意的情况：</p><p>原来能否在 $S$ 的后缀自动机上往下走的判断依据只有当前节点是否存在 $c$ 边，那么有了 $l, r$ 的限制，就多需要判断向下的这个节点的 $endpos$ 是否有存在于 $[l + len, r]$（$len$ 表示已匹配长度）区间的位置，$endpos$ 集合用动态开点线段树维护一下就好了</p><p><a href="https://colythme.github.io/2020/07/01/[NOI2018]你的名字/">代码</a></p><h3 id="求所有长度为-k-的子串的最大出现次数"><a href="#求所有长度为-k-的子串的最大出现次数" class="headerlink" title="求所有长度为 $k$ 的子串的最大出现次数"></a>求所有长度为 $k$ 的子串的最大出现次数</h3><blockquote><p>给定字符串 $S$，求 $S$ 中长度为 $k = 1…n$ 的子串的最大出现次数（对每个 $k$ 单独考虑）</p></blockquote><p>考虑对某个 $k$，显然对它有贡献的只可能是 $minlen(i) \le k \le maxlen(i)$ 的所有状态 $i$</p><p>直接算的话得建棵线段树，实际上对某个子串，它的贡献一定是它自己直接给出贡献或是将它作为后缀的子串给出的，所以每次只需在 $maxlen(i)$ 处标记一下，然后再 $parent$ 树上对子树所有的贡献取 $max$ 就好了</p><h3 id="广义后缀自动机"><a href="#广义后缀自动机" class="headerlink" title="广义后缀自动机"></a>广义后缀自动机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> last, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = last;</span><br><span class="line"><span class="keyword">if</span> (tr[fa][c]) &#123; <span class="comment">// 与单串后缀自动机不同处</span></span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; subsize[x][id] = <span class="number">1</span>; <span class="keyword">return</span> x; &#125; <span class="comment">// 特判一</span></span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">father[np] = father[x], len[np] = len[fa] + <span class="number">1</span>;</span><br><span class="line">father[x] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line">subsize[np][id] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> np; <span class="comment">// 特判二</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = ++ m;</span><br><span class="line">len[p] = len[fa] + <span class="number">1</span>, subsize[p][id] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; ! tr[fa][c])</span><br><span class="line">tr[fa][c] = p, fa = father[fa];</span><br><span class="line"><span class="keyword">if</span> (! fa) &#123; father[p] = <span class="number">1</span>; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">int</span> x = tr[fa][c];</span><br><span class="line"><span class="keyword">if</span> (len[x] == len[fa] + <span class="number">1</span>) &#123; father[p] = x; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">int</span> np = ++ m;</span><br><span class="line">father[np] = father[x], len[np] = len[fa] + <span class="number">1</span>;</span><br><span class="line">father[p] = father[x] = np;</span><br><span class="line"><span class="built_in">memcpy</span> (tr[np], tr[x], <span class="keyword">sizeof</span> (tr[x]));</span><br><span class="line"><span class="keyword">while</span> (fa &amp;&amp; tr[fa][c] == x)</span><br><span class="line">tr[fa][c] = np, fa = father[fa];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, str + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span> (str + <span class="number">1</span>);</span><br><span class="line">last = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) last = append (str[j] - <span class="string">'a'</span>, last, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 $size$ 要对每个串分开存</p><h3 id="线段树合并维护广义后缀自动机-size"><a href="#线段树合并维护广义后缀自动机-size" class="headerlink" title="线段树合并维护广义后缀自动机 $size$"></a>线段树合并维护广义后缀自动机 $size$</h3><p><a href="http://codeforces.com/problemset/problem/666/E" target="_blank" rel="noopener">Forensic Examination</a></p><blockquote><p>给你一个串 $S$ 以及 $m$ 个字符串数组 $T_1, T_2, …, T_m$，$q$ 次询问，每次问 $S$ 的子串 $S[p_l…p_r]$ 在 $T_l, …, T_r$ 中的哪个串里的出现次数最多，并输出出现次数。如有多解输出最靠前的那一个</p></blockquote><p>对所有串建立广义后缀自动机，开一棵区间为 $[1, m]$ 的线段树，将每个状态的 $size$ 存下来（类似 $\text{modify} (rt[p], 1, m, id)$，其中 $id$ 表示当前插入的是 $m$ 个字符串中的哪个，注意 $S$ 插入后缀自动机时就不用修改线段树了），并进行线段树合并</p><p>那么每次只要在 $parent$ 树上倍增跳到包含区间 $S[p_l…p_r]$ 的点，就可以直接统计其对应线段树 $[l, r]$ 区间的最大值（即它子树的答案）</p><h3 id="Parent-树上两点间距离"><a href="#Parent-树上两点间距离" class="headerlink" title="$Parent$ 树上两点间距离"></a>$Parent$ 树上两点间距离</h3><p><a href="https://www.luogu.com.cn/problem/P4248" target="_blank" rel="noopener">[AHOI2013]差异</a></p><blockquote><p>给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀，求 $\sum\limits_{1 \le i &lt; j \le n} len(T_i) + len(T_j) - 2 \times LCP(T_i, T_j)$</p></blockquote><p>将串反过来，后缀的最长公共前缀就变成了前缀的最长公共后缀</p><p>以 $len(i) - len(fa(i))$ 作为状态 $i$ 在 $parent$ 树上到父亲的边权，那么原式就可以看作 $parent$ 树上两个前缀对应的点 $u, v$ 之间的路径长度</p><p>由于只有前缀状态的 $size$ 才可能被初始化为 $1$，那么对点 $i$ 到其父亲的边，其贡献即为 $w_i \times size(i) \times (n - size(i))$，对所有边求和即可</p>]]></content>
      
      
      <categories>
          
          <category> 归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 线性DP </tag>
            
            <tag> 归纳 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求逆</title>
      <link href="/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/"/>
      <url>/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先定义多项式的度数 $degA$ 为多项式 $A(x)$ 的最高次数</p><p>那么多项式 $A(x)$ 的逆即为存在多项式 $B(x)$ 使得条件满足：<br>$$<br>A(x)B(x) \equiv 1 \pmod{x^n}<br>$$</p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><h3 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 $FFT$"></a>分治 $FFT$</h3><p>对 $A(x) = \sum\limits_{k = 0}^{n - 1} a_kx^k, B(x) = \sum\limits_{k = 0}^{n - 1} b_kx^k$</p><p>从常数项考虑，有 $b_0 = \frac1{a_0}$，则由 $\sum\limits_{k = 0}^n b_ka_{n - k} = 0$ 可得<br>$$<br>b_k = \sum\limits_{i = 0}^{k - 1} b_i\left(- \frac{a_{k - i}}{a_0}\right)<br>$$</p><h3 id="倍增迭代"><a href="#倍增迭代" class="headerlink" title="倍增迭代"></a>倍增迭代</h3><p>假设存在多项式 $A(x)$ ，以及其逆 $B(x)$ 满足条件 ，那么必定有$A(x)B(x) \equiv 1 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (1)$ ，因为 $x^n$ 是 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 的倍数</p><p>并且存在 $A(x)B’(x) \equiv 1 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (2)$</p><p>$(1) - (2)$ ，得<br>$$<br>\begin{aligned} B(x) - B’(x) &amp;\equiv 0 \pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}  …  (3) \\ B(x)^2 - 2B(x)B’(x) + B’(x)^2 &amp;\equiv 0 \pmod{x^n} \end{aligned}<br>$$<br>上一步解释一下，是两边平方</p><p>至于为什么模数也需要平方，是因为 $(3)$ 式满足左边的多项式在其模意义下为 $0$ ，且式子恒成立，故其除了第 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 项其余系数皆为 $0$ ，那么现在考虑 $0 \le x \le n - 1$ ，又因为 $a_i = \sum\limits_{j = 1}^i a_j b_{i - j}$ ，所以必定存在 $i$ 或者 $i - j$ 小于 $x^{\left\lceil\frac{n}{2}\right\rceil}$ ，故 $a_i = 0$ ，所以平方无妨</p><p>同乘 $A(x)$ ，移项，得<br>$$<br>B(x) \equiv 2B’(x) - A(x)B’(x)^2 \pmod{x^n}<br>$$<br>在递归过程中最后会递归到 $n = 1$ ，那么此时 $A(x)B’’(x) \equiv c \pmod{x}$ ，取 $c^{- 1}$ 就好了</p><p>那么再用 $FFT$ 优化就可以做到 $O (n \log n)$ 求解</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL f[MAXN], invf[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL A[MAXN]= &#123;<span class="number">0</span>&#125;, B[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL omega = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + k + mid] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* ps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">ps[<span class="number">0</span>] = power (f[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">Inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ps);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt; (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">A[i] = f[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++)</span><br><span class="line">B[i] = ps[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">ps[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">f[i] = getnum ();</span><br><span class="line">Inverse (N, invf);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, invf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 6 3 4 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">2 3 3 3 1233 211 23 3 3 322</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式操作</title>
      <link href="/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><p>该部分见 <a href="https://colythme.github.io/2020/07/01/多项式求逆/">多项式求逆</a></p><h2 id="多项式除法-取模"><a href="#多项式除法-取模" class="headerlink" title="多项式除法|取模"></a>多项式除法|取模</h2><p>有 $F(x) = G(x)Q(x) + R(x)$，给定 $F(x)$ 与 $G(x)$，求解 $Q(x), R(x)$，其中 $F(x), G(x)$ 最高次数分别为 $n, m$</p><p>显然地，$Q(x), R(x)$ 的最高次数必定不超过 $n - m, m - 1$，考虑式子变形<br>$$<br>\begin{aligned}<br>&amp;F(x) = G(x)Q(x) + R(x) \\<br>\Rightarrow &amp;F(\frac1x) = G(\frac1x)Q(\frac1x) + R(\frac1x) \\<br>\Rightarrow &amp;x^nF(\frac1x) = x^mG(\frac1x)x^{n - m}Q(\frac1x) + x^{n - m + 1}x^{m - 1}R(\frac1x) \\<br>\end{aligned}<br>$$<br>令 $A_R(x)$ 表示 $A(x)$ 系数翻转后得到的多项式，即 $A(x)$ 系数 $(a_0, a_1, …, a_n)$，$A_R(x)$ 系数 $(a_n, a_{n - 1}, …, a_1)$，有<br>$$<br>\begin{aligned}<br>\Rightarrow &amp;x^nF(\frac1x) = x^mG(\frac1x)x^{n - m}Q(\frac1x) + x^{n - m + 1}x^{m - 1}R(\frac1x) \\<br>\Rightarrow &amp;F_R(x) = G_R(x)Q_R(x) + x^{n - m + 1}R_R(x) \\<br>\Rightarrow &amp;F_R(x) \equiv G_R(x)Q_R(x) \pmod{x^{n - m + 1}} \\<br>\Rightarrow &amp;Q_R(x) \equiv \frac{F_R(x)}{G_R(x)}<br>\end{aligned}<br>$$<br>那么这样就可以求出 $Q(x)$，之后则有 $R(x) = F(x) - G(x)Q(x)$</p><p>时间复杂度 $O (n \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN]= &#123;<span class="number">0</span>&#125;, limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">LL a1 = a[j + k], xa2 = x * a[j + mid + k] % MOD;</span><br><span class="line">a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">a[j + mid + k] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL A[MAXN], B[MAXN], f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span> <span class="params">(LL* X, LL* Y, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= fn + fm; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn; i ++) A[i] = X[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fm; i ++) B[i] = Y[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = A[i] * B[i] % MOD;</span><br><span class="line">NTT (A, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fn + fm; i ++) X[i] = A[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123; a[<span class="number">0</span>] = power (f[<span class="number">0</span>], MOD - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a);</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= (deg &lt;&lt; <span class="number">1</span>); n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">limit = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) A[i] = f[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg &lt;&lt; <span class="number">1</span>; i ++) B[i] = a[i];</span><br><span class="line">NTT (A, <span class="number">1</span>), NTT (B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++) B[i] = B[i] * ((<span class="number">2l</span>l - A[i] * B[i] % MOD + MOD) % MOD) % MOD;</span><br><span class="line">NTT (B, - <span class="number">1</span>);</span><br><span class="line">LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++) a[i] = B[i] * invn % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL F[MAXN], G[MAXN], INVG[MAXN];</span><br><span class="line">LL RF[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) RF[i] = F[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++) f[i] = G[i] = getnum ();</span><br><span class="line">reverse (RF, RF + N + <span class="number">1</span>); reverse (f, f + M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - M + <span class="number">2</span>; i &lt;= M; i ++) f[i] = <span class="number">0</span>;</span><br><span class="line">inverse (N - M + <span class="number">1</span>, INVG); mul (RF, INVG, N, N - M + <span class="number">1</span>);</span><br><span class="line">reverse (RF, RF + N - M + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - M + <span class="number">1</span>; i &lt;= N; i ++) RF[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, RF[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">mul (RF, G, N - M, M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) RF[i] = (F[i] - RF[i] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>, RF[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JOISC2017Day1」烟花棒</title>
      <link href="/2020/08/04/%E3%80%8CJOISC%202017%20Day%201%E3%80%8D%E7%83%9F%E8%8A%B1%E6%A3%92/"/>
      <url>/2020/08/04/%E3%80%8CJOISC%202017%20Day%201%E3%80%8D%E7%83%9F%E8%8A%B1%E6%A3%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $N$ 人站在一条数轴上。他们人手一个烟花，每人手中的烟花都恰好能燃烧 $T$ 秒。每个烟花只能被点燃一次。<br>$1$ 号站在原点，$i$ 号 $(1 \le i \le N)$ 到 $1$ 号的距离为 $X_i$。保证 $X_1 = 0$，$X_1, X_2, …, X_N$ <strong>单调</strong>递增（可能有人位置重叠）<br>开始时，$K$ 号的烟花刚开始燃烧，其他人的烟花均未点燃。他们的点火工具坏了，只能用燃着的烟花将未点燃的烟花点燃。当两人位置重叠且其中一人手中的烟花燃着时，另一人手中的烟花就可以被点燃。忽略点火所需时间。<br>求至少需要以多快的速度跑，才能点燃所有人的烟花（此时可能有些人的烟花已经熄灭了）。<strong>速度必须是一个非负整数</strong></p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对 $100\%$ 的数据，$1 \le K, N \le 10^5, ~ 1 \le T \le 10^9, ~ 0 \le X_i \le 10^9, ~ X_1 = 0$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很显然所有人一定会不断向拿烟花的人靠近</p><p>可以发现，一个拿烟花棒的人和另一个人相遇时，让另一个人跟着拿烟花的人走直至烟花在灭掉的瞬间将烟花传递的情况和在相遇时传递时一样的（注意相对位置，仔细想一下就可以证明）</p><p>也就是说，整个过程可以看作只有一个拿烟花的人，进一步推理可以发现，拿烟花的人和另一个人相遇等价于他的烟花燃烧时间加上 $T$（在最优情况下）</p><p>又两人相向而行时相对速度为 $2v$，那么对于一个区间 $[L, R]$，它满足条件的必要条件即是<br>$$<br>2vT(R - L) \ge x_R - x_L<br>$$<br>而我们从 $K$ 开始不断向两边扩展，使得每次扩展都满足条件，那么扩展到 $[L, R]$ 时，该条件便成为充要条件</p><p>对上式进行变换，有<br>$$<br>x_L - 2vTL \ge x_R - 2vTR<br>$$<br>不妨令 $a_i = x_i - 2vTi$，那么该条件便转化为 $a_L \ge a_R$</p><p>进行二分答案</p><p>在 $check$ 时进行贪心，贪心扩展当前所到区间 $[l, r]$，对 $l$，不断找到一个 $k$，使得 $a_k \ge a_l \cap k &lt; l \cap a_k \ge a_r$，对 $r$ 同理，最终会扩展到一个极大区间 $[ll, lr]$</p><p>若 $ll = 1 \cap lr = N$，那么就可以返回 $true$，如若不然，则观察当前情况</p><p>现在局面是 $l, r$ 不能继续往左右扩展，也就是 $l$ 往左不存在 $a_k \ge a_l$ 或 $a_k \ge a_r$，$r$ 往右不存在 $a_k \le a_r$ 或 $a_k \le a_l$，对不存在 $a_{k_1} \ge a_r \cup a_{k_2} \le a_l$ 的局面，显然就直接返回 $false$，那么对另一种局面，考虑 $l$ 往左，说明一段一段的最大值是递减的，但是不妨将其反过来，那不就和上面 $K$ 往两边扩展的情况一样了吗，$r$ 往右同理，那么现在要做的就是重新令 $l = 1, r = N$，然后向内缩，看能否缩到 $[ll, lr]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e09</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, T;</span><br><span class="line"><span class="keyword">int</span> X[MAXN];</span><br><span class="line"></span><br><span class="line">LL a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = X[i] - <span class="number">2l</span>l * v * T * i;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] &lt; a[N]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> l = K, r = K, ll = K, lr = K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[ll])</span><br><span class="line">ll = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[lr])</span><br><span class="line">lr = i;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &gt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl - <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &lt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &lt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr + <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &gt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">1</span>, r = N;</span><br><span class="line"><span class="keyword">while</span> (l != ll || r != lr) &#123;</span><br><span class="line"><span class="keyword">int</span> pl, pr; <span class="keyword">bool</span> suc = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (pl = l; pl &lt; ll; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pl + <span class="number">1</span>] &lt; a[r]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[++ pl] &gt;= a[l]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; l &amp;&amp; a[pl] &gt;= a[l]) &#123; l = pl; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (pr = r; pr &gt; lr; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[pr - <span class="number">1</span>] &gt; a[l]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[-- pr] &lt;= a[r]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pr &lt; r &amp;&amp; a[pr] &lt;= a[r]) &#123; r = pr; suc = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (! suc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum (), T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) X[i] = getnum ();</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = INF, ans;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check (mid)) &#123; ans = mid; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「省选模拟赛」矩阵（matrix）</title>
      <link href="/2020/08/04/%5B%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B%5D%E7%9F%A9%E9%98%B5%EF%BC%88matrix%EF%BC%89/"/>
      <url>/2020/08/04/%5B%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B%5D%E7%9F%A9%E9%98%B5%EF%BC%88matrix%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $n*m$ 的 $01$ 矩阵，矩阵中 $k$ 个格子的数已经确定，你需要求出有多少种方案使得矩阵每行每列的异或和均为 $1$。对 $998244353$ 取模。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.org/upload/pic/53120.png" alt=""></p><hr><h3 id="Subtask-1"><a href="#Subtask-1" class="headerlink" title="Subtask 1"></a>Subtask 1</h3><p>暴力自不必说</p><h3 id="Subtask-2"><a href="#Subtask-2" class="headerlink" title="Subtask 2"></a>Subtask 2</h3><p>对于 $k = 0$ 的数据，如何做？</p><p>那么我们只要空出一列（或一行或是一行一列），让其它的格子随便填，因为不管怎么样，最后空出的这一列（行）总是可以将整行（列）的异或和变为 $1$</p><p>同理 $k &lt;= m$ 的数据找出一个全空的列就好了</p><h3 id="Subtask-3"><a href="#Subtask-3" class="headerlink" title="Subtask 3"></a>Subtask 3</h3><p>仿照 $Subtask  2$ 的思路，还是找出一个被限制的格子最少的列，令该列被限制的格子数为 $p$，考虑到 $k \le 10m$，故 $p \le 10$，那么对于其它列，只要关注这 $p$ 行以及它们本身列的异或和就好了</p><p>考虑使用 $DP$，设 $f_{i, j, k, state}$ 表示前 $i$ 列前 $j$ 行，目前该列的异或和为 $k$，那 $p$ 行的异或情况状压后为 $state$</p><p>复杂度 $O (nm2^{\frac{k}{m}})$</p><h3 id="Subtask-4"><a href="#Subtask-4" class="headerlink" title="Subtask 4"></a>Subtask 4</h3><p>因为状态数太多，考虑能够直接计算的状态数就直接消去</p><p>对于除了那 $p$ 行以外还存在不被限制的格子的列，可以空出一个格子，然后其它格子随便填，然后将这些列删去</p><p>在删去上述列之前，还要计算它们对于行的贡献</p><p>假设在 $p$ 行的其中一行，在上述列中该行总共有 $k$ 个空格，那么同理还是只要留出一个空格其它随便填，故答案要算上 $2^{k - 1}$</p><p>那么对于未删去的列只需考虑那 $p$ 行就可以了（因为其它行一定是被限制的），然后仿照 $Subtask  3$ 做 $DP$ 即可</p><p>复杂度 $O (\frac{k^2}{nm}2^{\frac{k}{m}})$</p><p>感觉整题就是将空一行算异或的思想完全贯彻的说</p><p>至于代码，感觉理论上那些存在空格的行 $DP$ 之后不管取其异或为 $0$ 或 $1$ 都是可以的（可惜因为写到心态爆炸然后就放弃了代码的说</p><p>（至于考场上连 $Subtask  2$ 都没想出来，只是瞎打了 $k = 0$ 的规律而且还有可能错的我感觉我好菜啊</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「清华集训2016」你的生命已如风中残烛（卡特兰数的另一种组合意义）</title>
      <link href="/2020/08/04/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%5D%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%EF%BC%88%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%EF%BC%89/"/>
      <url>/2020/08/04/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%5D%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%EF%BC%88%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将题意转化一下</p><p>有 $m = \sum\limits_{i = 1}^n w_i$ 个数，前 $n$ 个中第 $i$ 个为 $w_i − 1$ ，剩下的 $m − n$ 个数都是 $− 1$</p><p>求对这 $m$ 个数 $m!$ 种重排的方案中，有多少种满足重排后的序列任意前缀和不为负</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="卡特兰数的另一种组合意义"><a href="#卡特兰数的另一种组合意义" class="headerlink" title="卡特兰数的另一种组合意义"></a>卡特兰数的另一种组合意义</h3><p>首先有一个引理</p><ul><li>给定 $n$ 个 $1$ 和 $n$ 个 $- 1$，它们组成一个长度为 $2n$ 的序列 $a$，则必定存在一个 $i$ 使得序列 $a_{i + 1…2n} + a_{1…i}$ 满足任意前缀都不小于零</li><li>证明也很简单，找到一个使得前缀和最小的位置 $i$，设 $s_{i,j}$ 表示 $a$ 上 $a_i$ 到 $a_j$ 的和，那么显然 $s_{i + 1, 2n} \ge 0$，对 $\forall k \in [1, i]$，$s_{i + 1, 2n} + s_{1, k} \ge 0$</li></ul><p>那么接下来求解 $n$ 个 $1$ 和 $n$ 个 $- 1$ 组成的合法序列（即任意前缀和不小于零）的方案数，也就是卡特兰数</p><p>$1$ 的编号为 $1 \sim n$，$- 1$ 的编号为 $n + 1 \sim 2n$</p><p>现在先假定所有 $1$ 和 $- 1$ 都是有标号的，那么最后乘上一个 $\frac1{n!n!}$ 就好了</p><p>由于直接看 $2n$ 的环可以断的地方较多无法处理，故考虑在后面接上一个编号为 $2n + 1$ 的 $- 1$，那么现在问题就变成给定一个 $2n + 1$ 长度的环，断开其中一处 $- 1$，得到的序列前 $2n$ 项任意前缀和非负，前 $2n + 1$ 项前缀和为 $- 1$</p><p>那么和上面同样取一个使前缀和最小的位置 $i$（若有多个则取最小的那一个），可以证明 $i$ 使唯一的</p><p>就那取第二个为例，设取第二个使前缀和最小的位置为 $j$，那么有 $s_{j + 1, 2n + 1} + s_{1, j} = - 1$，即 $s_{j + 1, 2n + 1} + s_{1, i} = - 1$，这样子就已经不满足条件了</p><p>证明了唯一性，也就是说断开方式是唯一的</p><p>由于此时 $- 1$ 使有标号的，总共有 $n + 1$ 个 $- 1$，也就是说所有 $2n + 1$ 个元素组成的环中平均每 $n + 1$ 个环就存在一个满足条件的，那么就可以得到卡特兰数的通项<br>$$<br>Cat_n = \frac{\frac{(2n + 1)!}{2n + 1}}{(n + 1)(n!)^2} = \frac{\dbinom{2n}{n}}{n + 1}<br>$$</p><h3 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h3><p>同样的，这 $m$ 个数组成的序列同样也满足存在一个位置 $i$ 使得 $s_{i + 1, m} + s_{1, i}$ 不小于零</p><p>故也在该序列后面加入一个编号为 $m + 1$ 的 $- 1$，连成环后断环方式唯一</p><p>那么答案即为 $\frac{m!}{m - n + 1}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">n = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) m += getnum ();</span><br><span class="line">LL fact = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++) fact = fact * i % MOD;</span><br><span class="line">cout &lt;&lt; fact * power (m - n + 1, MOD - 2) % MOD &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 卡特兰数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「国家集训队」middle</title>
      <link href="/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5Dmiddle/"/>
      <url>/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5Dmiddle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一道其实很简单然而我还是瞄了题解的题</p><p>首先考虑二分答案</p><p>显然将小于 $mid$ 的赋为 $-1$，将大于等于 $mid$ 赋为 $1$</p><p>那么显然 $total =  $ $[q_1, q_2]$ 最长后缀 $+$ 中间必选 $+$ $[q_3, q_4]$ 最长前缀</p><p>然后若 $total \ge 0$ 则 $check (mid)$ 返回 $true$</p><p>很好然后我就不会处理了</p><p>于是题解就说将每个 $mid$ 建一棵线段树，然后用主席树就不会 $MLE$（好吧原来本来是想建序列上的主席树的说当然并不可行</p><p>那么每次 $check$ 就在 $mid$ 号版本上的树查询即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = MAXN * MAXLOG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], mapp[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">valueSt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> subsum;</span><br><span class="line">    <span class="keyword">int</span> lmax, rmax;</span><br><span class="line"></span><br><span class="line">    valueSt () &#123;</span><br><span class="line">        subsum = <span class="number">0</span>;</span><br><span class="line">        lmax = rmax = - INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> ctree[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> lson[MAXT]= &#123;<span class="number">0</span>&#125;, rson[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">valueSt value[MAXT];</span><br><span class="line"><span class="keyword">int</span> nodes = <span class="number">0</span>;</span><br><span class="line"><span class="function">valueSt <span class="title">maintain</span> <span class="params">(valueSt A, valueSt B)</span> </span>&#123;</span><br><span class="line">    valueSt res;</span><br><span class="line">    res.subsum = A.subsum + B.subsum;</span><br><span class="line">    res.lmax = max (A.lmax, A.subsum + B.lmax);</span><br><span class="line">    res.rmax = max (B.rmax, A.rmax + B.subsum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    root = ++ nodes;</span><br><span class="line">    value[root] = valueSt ();</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        value[root].subsum = value[root].lmax = value[root].rmax = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build (lson[root], left, mid);</span><br><span class="line">    build (rson[root], mid + <span class="number">1</span>, right);</span><br><span class="line">    value[root] = maintain (value[lson[root]], value[rson[root]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line">    root = ++ nodes;</span><br><span class="line">    lson[root] = lson[pre], rson[root] = rson[pre];</span><br><span class="line">    value[root] = value[pre];</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        value[root].subsum = value[root].lmax = value[root].rmax = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (posi &lt;= mid) update (lson[pre], lson[root], left, mid, posi);</span><br><span class="line">    <span class="keyword">else</span> update (rson[pre], rson[root], mid + <span class="number">1</span>, right, posi);</span><br><span class="line">    value[root] = maintain (value[lson[root]], value[rson[root]]);</span><br><span class="line">&#125;</span><br><span class="line">valueSt tans;</span><br><span class="line"><span class="comment">// 以下注意（以rmax为例）</span></span><br><span class="line"><span class="comment">// 由于query_sum是由左至右走，并且maintain中是取B的rmax或者将A与B合并</span></span><br><span class="line"><span class="comment">// 那么在query_sum中value[root]不可能作为B</span></span><br><span class="line"><span class="comment">// 故最终获得的tans.rmax的起始点一定为q[2]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sum</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">        tans = maintain (tans, value[root]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) query_sum (lson[root], left, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) query_sum (rson[root], mid + <span class="number">1</span>, right, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[<span class="number">2</span>] + <span class="number">1</span> &lt;= q[<span class="number">3</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">        tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">2</span>] + <span class="number">1</span>, q[<span class="number">3</span>] - <span class="number">1</span>);</span><br><span class="line">        total += tans.subsum;</span><br><span class="line">    &#125;</span><br><span class="line">    tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">1</span>], q[<span class="number">2</span>]);</span><br><span class="line">    total += tans.rmax;</span><br><span class="line">    tans = valueSt (), query_sum (ctree[mid], <span class="number">1</span>, N, q[<span class="number">3</span>], q[<span class="number">4</span>]);</span><br><span class="line">    total += tans.lmax;</span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        a[i] = getnum (), mapp[i] = i;</span><br><span class="line">    sort (mapp + <span class="number">1</span>, mapp + N + <span class="number">1</span>, comp);</span><br><span class="line">    build (ctree[<span class="number">1</span>], <span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        ctree[i] = ctree[i - <span class="number">1</span>];</span><br><span class="line">        update (ctree[i - <span class="number">1</span>], ctree[i], <span class="number">1</span>, N, mapp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Q = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= Q; Case ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i ++)</span><br><span class="line">            q[i] = (getnum () + ans) % N + <span class="number">1</span>;</span><br><span class="line">        sort (q + <span class="number">1</span>, q + <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = N;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            check (mid) ? (ans = a[mapp[mid]], left = mid + <span class="number">1</span>) : right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">170337785</span></span><br><span class="line"><span class="comment">271451044</span></span><br><span class="line"><span class="comment">22430280</span></span><br><span class="line"><span class="comment">969056313</span></span><br><span class="line"><span class="comment">206452321</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 1 0 2</span></span><br><span class="line"><span class="comment">2 3 1 4</span></span><br><span class="line"><span class="comment">3 1 4 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「国家集训队」Crash的数字表格</title>
      <link href="/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5DCrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
      <url>/2020/08/04/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5DCrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求 $\sum\limits_{i = 1}^N \sum\limits_{j = 1}^M lcm (i, j)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>易知，原式<br>$$<br>\sum\limits_{i = 1}^N \sum\limits_{j = 1}^M \frac{ij}{\gcd (i, j)}<br>$$<br>枚举 $\gcd (i, j)$ ，且将 $d$ 提出来得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij[(i, j) = 1]<br>$$<br>将公式 $\sum\limits_{k | n} \mu(k) = [n = 1]$ 代入，得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij \sum\limits_{k | (i, j)} \mu(k)<br>$$<br>套路枚举 $k$ ，得</p><p>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} \mu(k) \sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{j = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} ij [k | (i, j)]<br>$$<br>那么 $ij$ 存在贡献时其必定是 $k$ 的倍数，故<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} \mu(k) \sum\limits_{ki = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \sum\limits_{kj = 1}^{\left\lfloor\frac{M}{d}\right\rfloor} k^2 ij<br>$$<br>将 $k$ 提出，得<br>$$<br>\sum\limits_{d = 1}^{\min (N, M)} d \sum\limits_{k = 1}^{\min (\left\lfloor\frac{N}{d}\right\rfloor, \left\lfloor\frac{M}{d}\right\rfloor)} k^2 \mu(k) ( \sum\limits_{i = 1}^{\left\lfloor\frac{N}{kd}\right\rfloor} i) (\sum\limits_{j = 1}^{\left\lfloor\frac{M}{kd}\right\rfloor} j)<br>$$<br>那么就可以预处理 $\sum\limits_{k = 1}^n k^2 \mu(k)$ ，后面的用整除分块就好了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 20101009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e07</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e07</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_Acqu</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! vis[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j]))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX; i ++)</span><br><span class="line">sum[i] = (sum[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * <span class="number">1l</span>l * i % MOD * mu[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">LL fn = (LL) n;</span><br><span class="line"><span class="keyword">return</span> (fn * (fn + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> limit = min (N, M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= limit; d ++) &#123;</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minlim = min (N / d, M / d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= minlim; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min ((N / d) / ((N / d) / l), (M / d) / ((M / d) / l));</span><br><span class="line">total = (total + (sum[r] - sum[l - <span class="number">1</span>] + MOD) % MOD * calc (N / d / l) % MOD * calc (M / d / l) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + (LL) (d) * total % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">prime_Acqu ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; M);</span><br><span class="line">LL ans = Solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「四校联考」密码</title>
      <link href="/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%AF%86%E7%A0%81/"/>
      <url>/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 行 $m$ 列的 $01$ 矩阵，求满足 $\big(\sum_{\forall i \in A, j \in B} value_{i, j}\big) \equiv 0 \pmod{2}$ 的二元组的数量</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑 $n = 1$，令 $1$ 的个数为 $t$，可以发现答案<br>$$<br>\sum\limits_{k = 0}^{\lfloor\frac{m}{2}\rfloor} \dbinom{t}{2k} \times 2^{m - t} - 1 = 2^{m - 1} - 1<br>$$<br>至于证明，可以考虑已经选好的数列 $\{a_1, a_2, …, a_n\}$，那么现在考虑加入第 $n +1$ 个，显然加入 $0, 1$ 都是多了两种选择</p><p>那么现在考虑将行合并成一列</p><p>但是问题是如果需要枚举选的行还是需要 $2^n$ 的复杂度，然后我考场上就想到这就凉了</p><p>那么显然每次选好了行，再选列的时候这若干个列会贯穿所有行，那就可以将每行看作一个数，并且将它们合并（异或）起来，这样就变成做 $n = 1$ 的情况了</p><p>接下来只要考虑有几种情况会使得其异或和为 $1$ （或不为 $1$）就行了</p><p>将它们求线性基，因为表示基的行向量不可能组成 $0$，故异或和为 $0$ 的情况就是 $2^{\text{所有的零向量个数}}$</p><p>令所有零向量个数为 $k$，那么答案即为 $(2^k - 1)(2^m - 1) + (2^n - 2^k)(2^{m - 1} - 1)$</p><p>然后高斯消元再用 $bitset$ 维护一下就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; bit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Guass</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">for</span> (row = <span class="number">1</span>, col = <span class="number">1</span>; row &lt;= N &amp;&amp; col &lt;= M; row ++, col ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (bit[i][col])</span><br><span class="line">swap (bit[row], bit[i]);</span><br><span class="line"><span class="keyword">if</span> (! bit[row][col]) &#123;</span><br><span class="line">row --;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (bit[i][col])</span><br><span class="line">bit[i] ^= bit[row];</span><br><span class="line">&#125;</span><br><span class="line">row --;</span><br><span class="line"><span class="keyword">return</span> N - row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">freopen (<span class="string">"password.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen (<span class="string">"password.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> p = getnum ();</span><br><span class="line">bit[i][j] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> zero = Guass ();</span><br><span class="line">LL ans = ((power (<span class="number">2l</span>l, zero) - <span class="number">1</span> + MOD) % MOD * ((power (<span class="number">2l</span>l, M) - <span class="number">1</span> + MOD) % MOD) % MOD +</span><br><span class="line"> (power (<span class="number">2l</span>l, N) - power (<span class="number">2l</span>l, zero) + MOD) % MOD * ((power (<span class="number">2l</span>l, M - <span class="number">1</span>) - <span class="number">1</span> + MOD) % MOD) % MOD) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">0 1 0</span></span><br><span class="line"><span class="comment">1 0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「四校联考」大水题 「简单prufer序列」</title>
      <link href="/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%A4%A7%E6%B0%B4%E9%A2%98%20%E3%80%8C%E7%AE%80%E5%8D%95prufer%E5%BA%8F%E5%88%97%E3%80%8D/"/>
      <url>/2020/08/04/%5B%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%83%5D%E5%A4%A7%E6%B0%B4%E9%A2%98%20%E3%80%8C%E7%AE%80%E5%8D%95prufer%E5%BA%8F%E5%88%97%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="prufer序列"><a href="#prufer序列" class="headerlink" title="prufer序列"></a>prufer序列</h2><p>prufer序列是一种无根树的序列表示方法，<strong>一个节点个数为 $n$ 的无根树对应着唯一一种长度为 $n - 2$ 的prufer序列</strong></p><h3 id="无根树化prufer序列"><a href="#无根树化prufer序列" class="headerlink" title="无根树化prufer序列"></a>无根树化prufer序列</h3><p>每次取编号最小的叶子节点，将其指向的“父亲”（就是它唯一指向的）节点加入prufer序列中，最终剩余两个连接的节点结束</p><h3 id="prufer序列化无根树"><a href="#prufer序列化无根树" class="headerlink" title="prufer序列化无根树"></a>prufer序列化无根树</h3><p>对于prufer序列 $A= \{a_1, a_2, a_3, …\}$，每次取最前面的元素 $a_s$，在总点集中找到最小的没有在 $A$ 中的节点 $t$，将 $a_s,  t$ 连边并删去 $a_s$，可以使用 $set$ 等维护</p><h3 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h3><ul><li>$n$ 个点的有标号完全图无根树计数：$n^{n - 2}$</li><li>$n$ 个点，每个点的度数为 $\{d_1, d_2, d_3, …\}$ 的有标号无根树计数：$\frac{(n - 2)!}{d_1!d_2!d_3!…}$（实际上就是一个多重集的排列数）</li><li>$n$ 个点的prufer序列中第 $i$ 个点恰好出现 $d_i - 1$ 次</li><li>$n$ 个点度数为 $\{d_1, d_2, …, d_k\}$，剩余 $k + 1 \thicksim n$ 未知度数的节点的有标号无根树计数：设剩余的位置 $d_l = (n - 2) - \sum\limits_{i = 1}^k (d_i- 1) $，先将它们看作一个整体再局部求解得到 $ans = \frac{(n - 2)!}{d_1!d_2!…d_k!d_l!}(n - k)^{d_l}$</li><li>$n$ 个点的有标号有根树计数：$n^{n - 1}$</li><li>$n$ 个点的无标号有根树计数：待续</li><li>$n$ 个点的无标号无根树计数：待续</li></ul><h2 id="本题题解"><a href="#本题题解" class="headerlink" title="本题题解"></a>本题题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 $n$ 个有标号点，第 $i$ 个点的度数上限为 $A_i$</p><p>现在对于每个 $s (1 \le s \le n)$，问从这 $n$ 个点中选出一些点组成大小为 $s$ 的有标号无根树的方案数</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $100\%$ 的数据，$n \le 100$</p><p>考虑直接将无根树转化为prufer序列，由唯一性在序列上直接 $dp$<br>令 $f_{i, j, k}$ 表示前 $i$ 个点选 $j$ 个组成长度为 $k$ 的prufer序列的方案数</p><p>显然<br>$$<br>\begin{aligned}<br>f_{i + 1, j, k} &amp;+= f_{i, j, k} \\<br>f_{i + 1, j + 1, k + l(l \in [0, A_{i + 1} - 1])} &amp;+= f_{i, j, k} \times \dbinom{k + l}{l}<br>\end{aligned}<br>$$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1004535809</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL C[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL f[MAXN][MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> limit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">freopen (<span class="string">"tree.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen (<span class="string">"tree.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">limit[i] = getnum ();</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= N; k ++) &#123; <span class="comment">// 注意需眼神到N</span></span><br><span class="line">f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k &amp;&amp; l &lt; limit[i]; l ++) <span class="comment">// 注意因为可以作叶子所以l需要从0开始枚举</span></span><br><span class="line">f[i][j][k] = (f[i][j][k] + f[i - <span class="number">1</span>][j - <span class="number">1</span>][k - l] * C[k][l] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">write (N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>), write (f[N][i][i - <span class="number">2</span>]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 5 2 4 4 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">6 15 50 160 392 509</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> prufer序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「北京省选集训2019」生成树计数「Matrix-Tree」</title>
      <link href="/2020/08/04/%5B%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%E3%80%8CMatrix-Tree%E3%80%8D/"/>
      <url>/2020/08/04/%5B%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%E3%80%8CMatrix-Tree%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Matrix-Tree定理"><a href="#Matrix-Tree定理" class="headerlink" title="Matrix-Tree定理"></a>Matrix-Tree定理</h3><p>对于无向图 $G$，定义其度数矩阵 $D$<br>$$<br>\left[<br>\begin{matrix}<br>deg_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; deg_2 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; 0 &amp; deg_3 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; deg_n<br>\end{matrix}<br>\right]<br>$$<br>定义其邻接矩阵 $C$<br>$$<br>\left[<br>\begin{matrix}<br>0 &amp; a_{1,2} &amp; a_{1,3} &amp; \cdots &amp; a_{1,n} \\<br>a_{2,1} &amp; 0 &amp; a_{2,3} &amp; \cdots &amp; a_{2,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; a_{n,4} &amp; 0<br>\end{matrix}<br>\right]<br>$$<br>其中 $a_{i, j} \in \{0, ~1\}$</p><p>定于其的基尔霍夫矩阵 $L(G) = D - C$，则有 $L(G)$ 的任意代数余子式即为无向图 $G$ 的生成树个数</p><p>至于求代数余子式则任意删去第 $i$ 行 $i$ 列高斯消元得其斜上三角矩阵最后即有 $ans = \sum\limits_i a_{i,i}$</p><p>至于证明就留坑吧</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ul><li>带权图生成树：定义一棵生成树的权值为边权之积，求解所有生成树的权值之和。      将 $D$ 中的 $deg_i$ 改为连接其的点的权值和，再令 $C$ 中 $a_{i, j} = w_{i, j}$ （$w_{i, j}$ 为边权），最后Matrix-Tree定理即可</li><li>有向图的生成树形图计数：我们将度数矩阵改为入度，邻接矩阵改为有向边的邻接矩阵，以 $p$ 为根的树形图个数是去掉 $p$ 行 $p$ 列后做行列式得的答案</li></ul><h3 id="多项式求逆-O-n-2"><a href="#多项式求逆-O-n-2" class="headerlink" title="多项式求逆 $O (n^2)$"></a>多项式求逆 $O (n^2)$</h3><p>于是我先会 $O (n \log n)$ 再会 $O (n^2)$ 我也很绝望啊</p><p>令 $C(x) = A(x)B(x) \pmod p$，首先有 $C_0 = A_0B_0 = 1 \pmod p$ （此处表示在 $\mod p$ 意义下，然后以 $C_1$ 为例，则有 $C_1 = A_0B_1 + A_1B_0 = 0 \pmod p$，可解得 $B_1 = - \frac{A_1B_0}{A_0}$，其它同理</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对于 $(w_1 + w_2 + w_3 + \wedge ~+ w_n)^k = \sum\prod\limits_{i = 1}^n w_{\forall}$</p><p>那么可以联想到有标号的整数拆分，那么即可将每条边的边权设为原边权的 EGF，即 $value = \sum\limits_{n \ge 0} w^n\frac{x^n}{n!}$ （$w$ 为原边权），接下来Matrix-Tree即可</p><p>最后得到一个多项式 $G(x)$，答案即为 $ans = G_k \cdot fact_k$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL invf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, k;</span><br><span class="line"></span><br><span class="line">LL <span class="built_in">map</span>[MAXN][MAXN][MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL res[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXK]= &#123;<span class="number">0</span>&#125;, tmp[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span> <span class="params">(LL* a, LL* b, LL* ret)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (temp, <span class="number">0</span>, <span class="keyword">sizeof</span> (temp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">temp[i] = (temp[i] + a[j] * b[i - j] % MOD) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span> (ret, temp, <span class="keyword">sizeof</span> (temp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span> <span class="params">(LL* a, LL* ret)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i ++)</span><br><span class="line">temp[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">temp[<span class="number">0</span>] = power (a[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">tmp[i] = a[i] * temp[<span class="number">0</span>] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">temp[i] = (temp[i] - tmp[j] * temp[i - j] % MOD + MOD) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span> (ret, temp, <span class="keyword">sizeof</span> (temp));</span><br><span class="line">&#125;</span><br><span class="line">LL ret[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">multiply (<span class="built_in">map</span>[i][i], res, res);</span><br><span class="line">inv (<span class="built_in">map</span>[i][i], ret);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j ++)</span><br><span class="line">multiply (<span class="built_in">map</span>[i][j], ret, <span class="built_in">map</span>[i][j]);</span><br><span class="line"><span class="built_in">memset</span> (<span class="built_in">map</span>[i][i], <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="built_in">map</span>[i][i]));</span><br><span class="line"><span class="built_in">map</span>[i][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = N - <span class="number">1</span>; t &gt;= i; t --) &#123;</span><br><span class="line">multiply (<span class="built_in">map</span>[i][t], <span class="built_in">map</span>[j][i], ret);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l ++) &#123;</span><br><span class="line"><span class="built_in">map</span>[j][t][l] = (<span class="built_in">map</span>[j][t][l] - ret[l] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), k = getnum ();</span><br><span class="line">invf[<span class="number">0</span>] = invf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i ++)</span><br><span class="line">invf[i] = (- MOD / i + MOD) % MOD * invf[MOD % i] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">invf[i] = invf[i] * invf[i - <span class="number">1</span>] % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123;</span><br><span class="line">LL delta = getnum ();</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">LL <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l ++) &#123;</span><br><span class="line">LL value = <span class="built_in">pow</span> * invf[l] % MOD;</span><br><span class="line"><span class="built_in">map</span>[i][j][l] = <span class="built_in">map</span>[j][i][l] = (- value + MOD) % MOD;</span><br><span class="line"><span class="built_in">map</span>[i][i][l] = (<span class="built_in">map</span>[i][i][l] + value) % MOD;</span><br><span class="line"><span class="built_in">map</span>[j][j][l] = (<span class="built_in">map</span>[j][j][l] + value) % MOD;</span><br><span class="line"><span class="built_in">pow</span> = <span class="built_in">pow</span> * delta % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Gauss ();</span><br><span class="line">LL ans = res[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">ans = ans * i % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">1 1 0 0</span></span><br><span class="line"><span class="comment">1 1 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵树定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 5280 - [ZJOI2019]线段树</title>
      <link href="/2020/08/04/%5BZJOI2019%5D%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/08/04/%5BZJOI2019%5D%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看题解里有人说这题实在太水</p><p>但我连第一步对点分类都不会（虽然分类完后的确不会很难）</p><p>我依旧是太菜</p><p>好了进入正题</p><p>线段树上打 $\text{tag}$，因为它一直复制来复制去，不可能在没棵线段树上都进行修改，就考虑点的共同性质，相同性质的点可以一起修改，那么此时相当于只进行一次 $\text{modify}$ 就行了</p><p>可以将点分成五类：</p><ul><li>一类点：半覆盖（就是修改时会经过但是不打标记）</li><li>二类点：全覆盖，打标记（区间被修改区间完全覆盖，会被访问到，被打标记）</li><li>三类点：全覆盖，不打标记（区间被修改区间完全覆盖，但不会被访问到，就是打标记全覆盖节点的子节点，不被打标记）</li><li>四类点：访问不到，会被下传标记</li><li>五类点：访问不到，不会被下传标记</li></ul><p>那么此时方案数转概率，令 $f_u$ 表示节点 $u$ 有被打标记的概率，即 $u$ 有被打标记的线段树占比，那么最终被打标记的节点 $u$ 个数即为 $f_u \times 2^n$（其中 $n$ 表示被修改次数）</p><p>但是会发现写四类点的时候还需要知道它祖先有没有被打标记，所以还需要设一个 $g_u$ 表示节点 $u$ 及其祖先被打标记的概率，开始转移</p><p>对一类点，复制后一半保持原样，一半必定无标记（因为是经过点肯定会被下传），其祖先同理<br>$$<br>f_u = \frac12(f_u + 0), g_u = \frac12(g_u + 0)<br>$$<br>对二类点，复制后一半保持原样，一半必定会被打标记<br>$$<br>f_u = \frac12(f_u + 1), g_u = \frac12(g_u + 1)<br>$$<br>对三类点，复制后一半保持原样，一半必定不会被下传标记，但其祖先必定会被标记<br>$$<br>f_u = f_u, g_u = \frac12(g_u + 1)<br>$$<br>对四类点，复制后一半保持原样，一半可能会被下传标记（必定会经过其父节点，否则它不可能成为四类点，同时是否会被下传标记取决于它祖先是否有标记，即 $g_u$）<br>$$<br>f_u = \frac12(f_u + g_u), g_u = g_u<br>$$<br>对五类点，复制后一半保持原样，一半也不会被影响<br>$$<br>f_u = f_u, g_u = g_u<br>$$<br>故五类点可不做处理</p><p>但是三类点的数目很多，是 $O (n)$ 级别，故对三类点的修改还需要打懒标记</p><p>再开一个 $sumf_u$ 维护其子树答案</p><p>最终答案即为 $sumf_1 \times 2^n$</p><p>时间复杂度 $O (m\log n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL inv2 = <span class="number">499122177</span>;</span><br><span class="line"></span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;, g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumf[MAXN]= &#123;<span class="number">0</span>&#125;, lazy[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">lazy[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid);</span><br><span class="line">build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; sumf[root] = (f[root] + sumf[lson] + sumf[rson]) % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushG</span> <span class="params">(<span class="keyword">int</span> root, LL value)</span> </span>&#123;</span><br><span class="line">g[root] = (g[root] * value % MOD + <span class="number">1l</span>l - value + MOD) % MOD;</span><br><span class="line">lazy[root] = lazy[root] * value % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushF</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; f[root] = (f[root] + g[root]) % MOD * inv2 % MOD; maintain (root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy[root] == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">pushG (lson, lazy[root]); pushG (rson, lazy[root]);</span><br><span class="line">lazy[root] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">f[root] = (f[root] + <span class="number">1</span>) % MOD * inv2 % MOD; <span class="comment">// 二类点</span></span><br><span class="line">g[root] = (g[root] + <span class="number">1</span>) % MOD * inv2 % MOD;</span><br><span class="line">pushG (lson, inv2); pushG (rson, inv2); <span class="comment">// 三类点</span></span><br><span class="line">maintain (root);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown (root); <span class="comment">// 三类点pushdown</span></span><br><span class="line">f[root] = f[root] * inv2 % MOD; <span class="comment">// 一类点</span></span><br><span class="line">g[root] = g[root] * inv2 % MOD;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R);</span><br><span class="line"><span class="keyword">else</span> pushF (lson); <span class="comment">// 四类点</span></span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R);</span><br><span class="line"><span class="keyword">else</span> pushF (rson); <span class="comment">// 四类点</span></span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line">LL down = <span class="number">1</span>;</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> type = getnum ();</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">2</span>) &#123; write (sumf[<span class="number">1</span>] * down % MOD); <span class="built_in">puts</span> (<span class="string">""</span>); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">down = down * <span class="number">2l</span>l % MOD;</span><br><span class="line"><span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ZJOI2016」大森林</title>
      <link href="/2020/08/04/%5BZJOI2016%5D%E5%A4%A7%E6%A3%AE%E6%9E%97/"/>
      <url>/2020/08/04/%5BZJOI2016%5D%E5%A4%A7%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>（貌似整个代码不能用 $makeroot$ ？是因为是有根树？）</p><p>因为是区间操作，所以可以考虑在区间内与区间外的差异</p><p>对于操作 $1$ ，可以看作一个生成节点包含了到下一个 $1$ 操作之间长出的节点，那么对于一个操作 $l, r$ ，相当于是在 $l$ 处将当前生成节点及其包含的节点整个移植到它更改后的位置，到 $r + 1$ 时再移植回去，所以可以考虑将一个 $1$ 操作分解为两个操作（一个移植，一个移植回去），故可以将所有操作按端点、时间排序（以及同位置修改操作必定在查询操作前，因为可以先把树建完再查询对结果没有影响），扫描一遍即可</p><p>同时，为了方便移植，将每个生成节点看作新建的一个虚点</p><p>对于操作 $0$ ，直接在虚点下 $link$ 即可，因为就算已经建了一些对于当前操作不存在的虚点，也不会对答案造成影响</p><p>对于操作 $2$ ，无法正面在 $LCT$ 上算出两点的距离，故可考虑差分，得到 $Ans = Sum_x + Sum_y - 2 * Sum_{lca}$ ，其中实点贡献为 $1$ ，虚点贡献为 $0$</p><p>对于求 $LCA$ ，先 $access (y)$ ，再在 $access (x)$ 的时候得到的最后一个跳虚边的点即是它们的 $LCA$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuerySt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, time;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    QuerySt () &#123;&#125;</span><br><span class="line">    QuerySt (<span class="keyword">int</span> fpos, <span class="keyword">int</span> ftime, <span class="keyword">int</span> fx, <span class="keyword">int</span> fy) :</span><br><span class="line">        pos (fpos), time (ftime), x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> QuerySt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos == p.pos ? time &lt; p.time : pos &lt; p.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">QuerySt Query[MAXN];</span><br><span class="line"><span class="keyword">int</span> que = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Sum[MAXN]= &#123;<span class="number">0</span>&#125;, value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Sum[p] = Sum[son[p][<span class="number">0</span>]] + Sum[son[p][<span class="number">1</span>]] + value[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line">    <span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">    son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[fa][s])</span><br><span class="line">        father[son[fa][s]] = fa;</span><br><span class="line">    <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">        son[anc][sonbel (fa)] = p;</span><br><span class="line">    father[p] = anc;</span><br><span class="line">    son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">    pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line">        <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">            sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; p; tp = p, p = father[p])</span><br><span class="line">        splay (p), son[p][<span class="number">1</span>] = tp, pushup (p);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 注意此时没有makeroot所以需要注意是将y连到x下</span></span><br><span class="line">    splay (y);</span><br><span class="line">    father[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Access (x), splay (x);</span><br><span class="line">    father[son[x][<span class="number">0</span>]] = <span class="number">0</span>, son[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup (x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sort (Query + <span class="number">1</span>, Query + que + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> time = Query[i].time;</span><br><span class="line">        <span class="keyword">int</span> x = Query[i].x, y = Query[i].y;</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Access (x), splay (x), ans[time] += Sum[x];</span><br><span class="line">            <span class="keyword">int</span> lca = Access (y);</span><br><span class="line">            splay (y), ans[time] += Sum[y];</span><br><span class="line">            Access (lca), splay (lca), ans[time] -= (Sum[lca] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cut (x), link (y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ind[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> liml[MAXN], limr[MAXN];</span><br><span class="line"><span class="keyword">int</span> nodes = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">int</span> lastr = <span class="number">1</span>, real = <span class="number">1</span>;</span><br><span class="line">    ind[<span class="number">1</span>] = Sum[<span class="number">1</span>] = value[<span class="number">1</span>] = <span class="number">1</span>, liml[<span class="number">1</span>] = <span class="number">1</span>, limr[<span class="number">1</span>] = N;</span><br><span class="line">    link (<span class="number">1</span>, nodes = lastr = <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">            link (lastr, ind[++ real] = ++ nodes);</span><br><span class="line">            value[nodes] = Sum[nodes] = <span class="number">1</span>;</span><br><span class="line">            liml[real] = l, limr[real] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = getnum (), r = getnum (), x = getnum ();</span><br><span class="line">            l = max (l, liml[x]), r = min (r, limr[x]);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            link (lastr, ++ nodes);</span><br><span class="line">            Query[++ que] = QuerySt (l, i - M, nodes, ind[x]); <span class="comment">// 由nodes离开link向index[x]</span></span><br><span class="line">            Query[++ que] = QuerySt (r + <span class="number">1</span>, i - M, nodes, lastr);</span><br><span class="line">            lastr = nodes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getnum (), u = getnum (), v = getnum ();</span><br><span class="line">            Query[++ que] = QuerySt (x, ++ totq, ind[u], ind[v]); <span class="comment">// 由index[u]到index[v]的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Solve ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totq; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">0 1 5</span></span><br><span class="line"><span class="comment">1 2 4 2</span></span><br><span class="line"><span class="comment">0 1 4</span></span><br><span class="line"><span class="comment">2 1 1 3</span></span><br><span class="line"><span class="comment">2 2 1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ynoi2013」D1T1</title>
      <link href="/2020/08/04/%5BYnoi2013%5DD1T1/"/>
      <url>/2020/08/04/%5BYnoi2013%5DD1T1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$\text{opt} = 1$ 时，代表把一个区间  $l, r$ 内的所有数都 $\text{xor}$ 上 $v$。</p><p>$\text{opt} = 2$ 时， 查询一个区间 $[l, r]$ 内选任意个数（包括 $0$ 个）数 $\text{xor}$ 起来，这个值与 $v$ 的最大 $\text{xor}$ 和是多少。</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>几乎没写过差分，看完这题之后顿时感觉到了差分的强大</p><p>首先显然第二个操作需要维护线性基，然后 $O (\log{n})$ 求解</p><p>然后因为有 $1$ 操作，所以若是直接维护区间线性基，在计算答案时不知道 $1$ 操作中的 $v$ 在当前答案中被异或上了奇数还是偶数次，故无法求解</p><p>但是在单点修改的情景下就不会有上述问题，故现在的问题是如何将区间问题转化为单点问题</p><p>于是就需要差分，让每个 $b_{i + 1} = a_{i + 1} ~ \text{xor} ~ a_i$，那么此时 $v$ 的贡献就只作用于 $b_l$ 与 $b_{r + 1}$，可直接单点修改，然后在线段树上同时维护区间线性基，查询时只需查询 $1…l$ 的前缀和（即 $b_l$），再将之与 $l + 1…r$ 的区间线性基合并即可求解答案</p><p>复杂度 $O (n \log^2{n})$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">baseSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> subsum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (b, <span class="number">0</span>, <span class="keyword">sizeof</span> (b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (! b[j]) &#123;</span><br><span class="line">b[j] = x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> x ^= b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">baseSt base[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function">baseSt <span class="title">merge</span> <span class="params">(baseSt A, baseSt B)</span> </span>&#123;</span><br><span class="line">baseSt ret; ret.init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --) &#123;</span><br><span class="line"><span class="keyword">if</span> (A.b[j]) ret.b[j] = A.b[j];</span><br><span class="line"><span class="keyword">else</span> ret.b[j] = B.b[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (A.b[j] &amp;&amp; B.b[j])</span><br><span class="line">ret.append (B.b[j]);</span><br><span class="line">ret.subsum = A.subsum ^ B.subsum;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">base[root].init ();</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">base[root].subsum = a[left];</span><br><span class="line">base[root].append (base[root].subsum);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid);</span><br><span class="line">build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">base[root] = merge (base[lson], base[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">base[root].init ();</span><br><span class="line">base[root].subsum ^= delta, base[root].append (base[root].subsum);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson, left, mid, posi, delta);</span><br><span class="line"><span class="keyword">else</span> modify (rson, mid + <span class="number">1</span>, right, posi, delta);</span><br><span class="line">base[root] = merge (base[lson], base[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">baseSt <span class="title">query_base</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line"><span class="keyword">return</span> base[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">baseSt ret; ret.init ();</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) ret = merge (ret, query_base (lson, left, mid, L, R));</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) ret = merge (ret, query_base (rson, mid + <span class="number">1</span>, right, L, R));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_value</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span> base[root].subsum;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> query_value (lson, left, mid, posi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query_value (rson, mid + <span class="number">1</span>, right, posi) ^ base[lson].subsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> x, baseSt A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">ret = max (ret, ret ^ A.b[j]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">a[i + <span class="number">1</span>] ^= a[i];</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), l = getnum (), r = getnum (), x = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, l, x);</span><br><span class="line"><span class="keyword">if</span> (r &lt; N) modify (<span class="number">1</span>, <span class="number">1</span>, N, r + <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> delta = query_value (<span class="number">1</span>, <span class="number">1</span>, N, l);</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, max (x ^ delta, x));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">baseSt bas = query_base (<span class="number">1</span>, <span class="number">1</span>, N, l + <span class="number">1</span>, r);</span><br><span class="line">bas.append (delta);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, solve (x, bas));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 14 51 4</span></span><br><span class="line"><span class="comment">2 1 3 0</span></span><br><span class="line"><span class="comment">1 2 3 3</span></span><br><span class="line"><span class="comment">2 1 4 10</span></span><br><span class="line"><span class="comment">1 1 4 514</span></span><br><span class="line"><span class="comment">2 3 4 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ynoi2012」D2T1</title>
      <link href="/2020/08/04/%5BYnoi2012%5DD2T1/"/>
      <url>/2020/08/04/%5BYnoi2012%5DD2T1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先有一个性质</p><blockquote><p>对于 $n \ge 11$，操作 $1$ 必定有解</p></blockquote><p>一个来自 $\text{Okami}$ 的严谨证明：</p><p>考虑互不相同的数 $x, y, z, …$，则有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">x y x+y</span><br><span class="line">x y z x+y x+z y+z x+y+z</span><br></pre></td></tr></table></figure><p>也就是对于 $n$ 个互不相同的数它们显然可以拼出 $2^n - 1$，那么根据抽屉原理，则有 $2^n - 1 \ge 1000$ 时必定有解，则命题成立</p><p>那么剩下的就直接 $\text{bitset}$ 优化背包就好了（注意可以直接背包因为若集合 $X$ 和 $Y$ 同时选了一个数，那么它们同时去除该数也是相等的），至于操作 $2$ 的影响则直接树状数组统计每个数要立方几次，由于 $\bmod V$，那么直接倍增处理即可</p><p>单词询问复杂度 $O (\frac{(r - l + 1)^2V}{32})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, V;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> powv[MAXV][<span class="number">25</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i ++) powv[i][<span class="number">0</span>] = i * i * i % V;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i ++)</span><br><span class="line">powv[i][j] = powv[powv[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">x = powv[x][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (- x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= N) &#123;</span><br><span class="line">subsum[x] += delta;</span><br><span class="line">x += lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt += subsum[x];</span><br><span class="line">x -= lowbit (x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;12 * MAXV&gt; f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), V = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= M; q ++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt = getnum (), l = getnum (), r = getnum ();</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= <span class="number">12</span>) <span class="built_in">puts</span> (<span class="string">"Yuno"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f.reset(); <span class="keyword">bool</span> suc = <span class="literal">false</span>; f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = calc (a[i], query (i));</span><br><span class="line"><span class="keyword">if</span> ((f &amp; (f &lt;&lt; x)).any()) &#123;</span><br><span class="line">suc = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = f | (f &lt;&lt; x);</span><br><span class="line">&#125;</span><br><span class="line">suc ? <span class="built_in">puts</span> (<span class="string">"Yuno"</span>) : <span class="built_in">puts</span> (<span class="string">"Yuki"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> add (l, <span class="number">1</span>), add (r + <span class="number">1</span>, - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20 20 152</span></span><br><span class="line"><span class="comment">3 26 133 54 79 81 72 109 66 91 82 100 35 23 104 17 51 114 12 58</span></span><br><span class="line"><span class="comment">2 1 17</span></span><br><span class="line"><span class="comment">2 6 12</span></span><br><span class="line"><span class="comment">1 1 12</span></span><br><span class="line"><span class="comment">2 3 5</span></span><br><span class="line"><span class="comment">2 11 11</span></span><br><span class="line"><span class="comment">2 7 19</span></span><br><span class="line"><span class="comment">2 6 15</span></span><br><span class="line"><span class="comment">1 5 12</span></span><br><span class="line"><span class="comment">1 1 9</span></span><br><span class="line"><span class="comment">1 10 19</span></span><br><span class="line"><span class="comment">2 3 19</span></span><br><span class="line"><span class="comment">2 6 20</span></span><br><span class="line"><span class="comment">2 1 13</span></span><br><span class="line"><span class="comment">2 1 15</span></span><br><span class="line"><span class="comment">2 1 9</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">2 1 7</span></span><br><span class="line"><span class="comment">2 7 19</span></span><br><span class="line"><span class="comment">2 6 19</span></span><br><span class="line"><span class="comment">2 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「WC2018」通道</title>
      <link href="/2020/08/04/%5BWC2018%5D%E9%80%9A%E9%81%93/"/>
      <url>/2020/08/04/%5BWC2018%5D%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这题真的是写到心态爆炸。。</p><p>一道边分治 + 虚树</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="边分治"><a href="#边分治" class="headerlink" title="边分治"></a>边分治</h3><p>顾名思义，就是选择一条边，类似点分治对所有经过该边的路径进行处理，但与点分治不同的是，边分治可能会被菊花图卡到 $O (n^2)$，故此时需要重构树，将之变为度数不超过三的二叉树</p><h4 id="树重构"><a href="#树重构" class="headerlink" title="树重构"></a>树重构</h4><p>通过建立新的虚点进行重构，但要满足加入的虚点不影响最后答案计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (! nf) &#123;</span><br><span class="line">Insert (root, v, w), Insert (v, root, w);</span><br><span class="line">nf = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = ++ m; <span class="comment">// 虚点</span></span><br><span class="line">Insert (nf, k, <span class="number">0</span>), Insert (k, nf, <span class="number">0</span>);</span><br><span class="line">Insert (k, v, w), Insert (v, k, w);</span><br><span class="line">nf = k;</span><br><span class="line">&#125;</span><br><span class="line">rebuild (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求中心边"><a href="#求中心边" class="headerlink" title="求中心边"></a>求中心边</h4><p>于点分治的求重心略有不同，但本质是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cet, mini; <span class="comment">// 重心边</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAXM &lt;&lt; <span class="number">3</span>]= &#123;<span class="literal">false</span>&#125;; <span class="comment">// 边是否已经被经过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">findc (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">int</span> maxpart = max (subsize[v], n - subsize[v]); <span class="comment">// 注意此处</span></span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) &#123; mini = maxpart; cet = i; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>现在开始边分治，分治到某一边 $E$，将相应点分为两个连通块 $A, B$</p><p>考虑原式，其中 $d_T(x)$ 表示在树 $T$ 中 $x$ 距根节点（或分治中心）的长度，对两点 $i \in A, j \in B$<br>$$<br>ans = \max \{d_{T_1}(i) + d_{T_1}(j) + dist_{T_2}(i, j) + dist_{T_3}(i, j)\}<br>$$<br>此时对 $A \cup B$ 建立虚树，在虚树上跑 $\text{DFS}$，设此时访问到虚树上点 $p$，则式子可变为<br>$$<br>\begin{aligned}<br>ans &amp;= \max \{d_{T_1}(i) + d_{T_1}(j) + d_{T_2}(i) + d_{T_2}(j) - 2 \times d_{T_2}(p) + dist_{T_3}(i, j)\} \\<br>&amp;= \max \{(d_{T_1} + d_{T_2})(i) + (d_{T_1} + d_{T_2})(j)- 2 \times d_{T_2}(p) + dist_{T_3}(i, j)\}<br>\end{aligned}<br>$$<br>这就相当于给 $T_3$ 的点 $i, j$ 分别赋上权值 $value_i = d_{T_1}(i) + d_{T_2}(i), value_j = d_{T_1}(j) + d_{T_2}(j)$，然后求 $T_3$ 上点 $i \in A, j \in B$ 的 $i, j$ 间边权和在加上 $i, j$ 点权的最大值即可求得答案，就是给 $T_3$ 上的点黑白染色，求白点到黑点的端点点权即边权和的最大值</p><p>那么此时发现边权 $w_i$ 都是正整数，说明它们满足直径合并的定理，即新直径必定由原来两条直径的端点产生，这样就可以直接求了，在 $T_2$ 上 $\text{dp}$ 时顺便合并 $T_3$ 的答案</p><p>这么直接做时 $O (n \log^2 n)$ 的，常数一大那就玩球</p><p>其实优化到 $O (n \log n)$ 也是很显然的，写个 $\text{RMQ}$ 的 $\text{LCA}$，并且在建虚树时不用 $\text{sort}$ 而是基数排序就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>357行（包含少量注释）。。都不知多久没有打代码打的这么带感过了。。</p><p>$\text{debug}$ 真的就够受了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">LL num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T3</span></span><br><span class="line">LL val[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree3</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], ord, cnt;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], value[MAXN &lt;&lt; <span class="number">1</span>], bel[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">LL d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">dfn[root] = ++ ord;</span><br><span class="line">value[ord] = depth[root], bel[ord] = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">d[v] = d[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">value[++ ord] = depth[root];</span><br><span class="line">bel[ord] = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ord; i ++) ST[i][<span class="number">0</span>] = make_pair (value[i], bel[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= ord; i ++)</span><br><span class="line"><span class="keyword">if</span> (ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first) ST[i][j] = ST[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> ST[i][j] = ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2 (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ST[l][k].first &lt; ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first) <span class="keyword">return</span> ST[l][k].second;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &gt; dfn[y]) swap (x, y);</span><br><span class="line"><span class="keyword">int</span> lca = LCA (dfn[x], dfn[y]);</span><br><span class="line"><span class="keyword">return</span> val[x] + val[y] + d[x] + d[y] - <span class="number">2l</span>l * d[lca];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">ord = <span class="number">0</span>;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); RMQ ();</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree3 T3;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">diam</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y; LL d;</span><br><span class="line">diam (<span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, LL fd = <span class="number">0</span>) : x (fx), y (fy), d (fd) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">diam f[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span> <span class="params">(diam A, diam B)</span> </span>&#123;</span><br><span class="line">LL d1 = max (T3.dist (A.x, B.x), T3.dist (A.x, B.y));</span><br><span class="line">LL d2 = max (T3.dist (A.y, B.x), T3.dist (A.y, B.y));</span><br><span class="line"><span class="keyword">return</span> max (d1, d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">diam <span class="title">merge</span> <span class="params">(diam A, diam B)</span> </span>&#123;</span><br><span class="line">LL maxi; diam ret;</span><br><span class="line">ret = A.d &gt; B.d ? diam (A.x, A.y, maxi = A.d) : diam (B.x, B.y, maxi = B.d);</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.x, B.x) &gt; maxi) &#123; ret = diam (A.x, B.x, maxi = T3.dist (A.x, B.x)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.x, B.y) &gt; maxi) &#123; ret = diam (A.x, B.y, maxi = T3.dist (A.x, B.y)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.y, B.x) &gt; maxi) &#123; ret = diam (A.y, B.x, maxi = T3.dist (A.y, B.x)); &#125;</span><br><span class="line"><span class="keyword">if</span> (T3.dist (A.y, B.y) &gt; maxi) &#123; ret = diam (A.y, B.y, maxi = T3.dist (A.y, B.y)); &#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"><span class="comment">//T2</span></span><br><span class="line"><span class="keyword">int</span> dye[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> iskey[MAXN]= &#123;<span class="number">0</span>&#125;, isdye[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree2</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ord;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], value[MAXN &lt;&lt; <span class="number">1</span>], bel[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">LL d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">dfn[root] = ++ ord;</span><br><span class="line">value[ord] = depth[root], bel[ord] = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[root] + <span class="number">1</span>;</span><br><span class="line">d[v] = d[root] + w;</span><br><span class="line">DFS (v, root);</span><br><span class="line">value[++ ord] = depth[root];</span><br><span class="line">bel[ord] = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ST[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ord; i ++) ST[i][<span class="number">0</span>] = make_pair (value[i], bel[i]);</span><br><span class="line"><span class="keyword">int</span> MAX = log2 (ord) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MAX; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= ord; i ++)</span><br><span class="line"><span class="keyword">if</span> (ST[i][j - <span class="number">1</span>].first &lt; ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>].first) ST[i][j] = ST[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> ST[i][j] = ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &gt; dfn[y]) swap (x, y);</span><br><span class="line"><span class="keyword">int</span> l = dfn[x], r = dfn[y];</span><br><span class="line"><span class="keyword">int</span> k = log2 (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ST[l][k].first &lt; ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].first) <span class="keyword">return</span> ST[l][k].second;</span><br><span class="line"><span class="keyword">return</span> ST[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXN], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! top) &#123; <span class="built_in">stack</span>[++ top] = x; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">int</span> lca = LCA (<span class="built_in">stack</span>[top], x);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; depth[lca] &lt; depth[<span class="built_in">stack</span>[top - <span class="number">1</span>]]) &#123;</span><br><span class="line">Insert (<span class="built_in">stack</span>[top - <span class="number">1</span>], <span class="built_in">stack</span>[top], <span class="number">0</span>); top --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (depth[lca] &lt; depth[<span class="built_in">stack</span>[top]]) &#123; Insert (lca, <span class="built_in">stack</span>[top], <span class="number">0</span>); top --; &#125;</span><br><span class="line"><span class="keyword">if</span> (! top || <span class="built_in">stack</span>[top] != lca) <span class="built_in">stack</span>[++ top] = lca;</span><br><span class="line"><span class="built_in">stack</span>[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cstr</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 虚树构建</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">top = <span class="number">0</span>; <span class="keyword">if</span> (a[l] != <span class="number">1</span>) <span class="built_in">stack</span>[++ top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123; add (a[i]); val[a[i]] += d[a[i]]; iskey[a[i]] = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123; Insert (<span class="built_in">stack</span>[top - <span class="number">1</span>], <span class="built_in">stack</span>[top], <span class="number">0</span>); top --; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// dp</span></span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (iskey[u]) &#123;</span><br><span class="line">isdye[u][dye[u]] = <span class="literal">true</span>;</span><br><span class="line">f[u][dye[u]] = diam (u, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">dp (v);</span><br><span class="line"><span class="keyword">if</span> (isdye[u][<span class="number">0</span>] &amp;&amp; isdye[v][<span class="number">1</span>]) ans = max (ans, query (f[u][<span class="number">0</span>], f[v][<span class="number">1</span>]) - <span class="number">2l</span>l * d[u]);</span><br><span class="line"><span class="keyword">if</span> (isdye[u][<span class="number">1</span>] &amp;&amp; isdye[v][<span class="number">0</span>]) ans = max (ans, query (f[u][<span class="number">1</span>], f[v][<span class="number">0</span>]) - <span class="number">2l</span>l * d[u]);</span><br><span class="line"><span class="keyword">if</span> (isdye[v][<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (! isdye[u][<span class="number">0</span>]) f[u][<span class="number">0</span>] = f[v][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> f[u][<span class="number">0</span>] = merge (f[u][<span class="number">0</span>], f[v][<span class="number">0</span>]);</span><br><span class="line">isdye[u][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isdye[v][<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (! isdye[u][<span class="number">1</span>]) f[u][<span class="number">1</span>] = f[v][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> f[u][<span class="number">1</span>] = merge (f[u][<span class="number">1</span>], f[v][<span class="number">1</span>]);</span><br><span class="line">isdye[u][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to; del (v);</span><br><span class="line">&#125;</span><br><span class="line">Head[u] = val[u] = dye[u] = <span class="number">0</span>; iskey[u] = isdye[u][<span class="number">0</span>] = isdye[u][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">Insert (u, v, w), Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">ord = <span class="number">0</span>;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>); RMQ ();</span><br><span class="line">size = <span class="number">0</span>; <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) a[i] = i;</span><br><span class="line">sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree2 T2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree1_ori</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span> <span class="keyword">int</span> to, next; LL w; &#125; ;</span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN], size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v; Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u]; Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Tree1_ori T1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line">LL w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size = - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = T1.Head[root]; i; i = T1.Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = T1.Link[i].to;</span><br><span class="line">LL w = T1.Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (! nf) &#123;</span><br><span class="line">Insert (root, v, w), Insert (v, root, w);</span><br><span class="line">nf = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = ++ m;</span><br><span class="line">Insert (nf, k, <span class="number">0</span>), Insert (k, nf, <span class="number">0</span>);</span><br><span class="line">Insert (k, v, w), Insert (v, k, w);</span><br><span class="line">nf = k;</span><br><span class="line">&#125;</span><br><span class="line">rebuild (v, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cet, mini; <span class="comment">// 重心边</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAXM &lt;&lt; <span class="number">3</span>]= &#123;<span class="literal">false</span>&#125;; <span class="comment">// 边是否已经被经过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findc</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">findc (n, v, root);</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line"><span class="keyword">int</span> maxpart = max (subsize[v], n - subsize[v]);</span><br><span class="line"><span class="keyword">if</span> (maxpart &lt; mini) &#123; mini = maxpart; cet = i; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coll</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> root, <span class="keyword">int</span> father, LL d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root &lt;= N) &#123; dye[root] = p; val[root] = d; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; ~ i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">LL w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (visit[i &gt;&gt; <span class="number">1</span>] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">coll (p, v, root, d + w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tp[<span class="number">2</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">cet = - <span class="number">1</span>, mini = INF; findc (n, u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cet == - <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">visit[cet &gt;&gt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x = Link[cet].to, y = Link[cet ^ <span class="number">1</span>].to;</span><br><span class="line">coll (<span class="number">0</span>, x, y, Link[cet].w); coll (<span class="number">1</span>, y, x, <span class="number">0</span>);</span><br><span class="line">T2.cstr (l, r); T2.dp (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) tp[dye[a[i]]][++ cnt[dye[a[i]]]] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= l + cnt[<span class="number">0</span>] - <span class="number">1</span>; i ++) a[i] = tp[<span class="number">0</span>][i - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l + cnt[<span class="number">0</span>]; i &lt;= r; i ++) a[i] = tp[<span class="number">1</span>][i - l - cnt[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">T2.del (<span class="number">1</span>); <span class="keyword">int</span> szr = n - subsize[x];</span><br><span class="line">divide (x, subsize[x], l, l + cnt[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">divide (y, szr, l + cnt[<span class="number">0</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">LL w = getnum ();</span><br><span class="line">T1.Insert (u, v, w), T1. Insert (v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">T2.build (); T3.build ();</span><br><span class="line"><span class="built_in">memset</span> (Head, - <span class="number">1</span>, <span class="keyword">sizeof</span> (Head));</span><br><span class="line">m = N; rebuild (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">divide (<span class="number">1</span>, m, <span class="number">1</span>, N);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 0</span></span><br><span class="line"><span class="comment">1 4 1</span></span><br><span class="line"><span class="comment">4 5 7</span></span><br><span class="line"><span class="comment">1 2 0</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">2 5 3</span></span><br><span class="line"><span class="comment">1 5 2</span></span><br><span class="line"><span class="comment">2 3 8</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">4 5 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上DP </tag>
            
            <tag> 边分治 </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「WC2008」游览计划 「斯坦那树模板」</title>
      <link href="/2020/08/04/%5BWC2008%5D%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92%20%E3%80%8C%E6%96%AF%E5%9D%A6%E9%82%A3%E6%A0%91%E6%A8%A1%E6%9D%BF%E3%80%8D/"/>
      <url>/2020/08/04/%5BWC2008%5D%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92%20%E3%80%8C%E6%96%AF%E5%9D%A6%E9%82%A3%E6%A0%91%E6%A8%A1%E6%9D%BF%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="斯坦那树"><a href="#斯坦那树" class="headerlink" title="斯坦那树"></a>斯坦那树</h3><p>百度释义</p><blockquote><p>斯坦纳树问题是组合优化问题，与最小生成树相似，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</p></blockquote><p>即最小斯坦那树即为并非选择所有的结点，而是选择一部分结点，为保证它们连通，且求解最小开销</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>斯坦那树模板</p><p>发现直接表示点的存在性没有意义</p><p>设函数 $f[i][state]$ 表示：对于点 $i$，其它结点与其连通情况</p><p>那么有两种转移</p><p>其一、由其子集转移<br>$$<br>f[i][state] = \min\limits_{sub \in state} \{f[i][sub] + f[i][\complement_{state}sub] - value_i\}<br>$$<br>之所以要减去 $value_i$ 是因为会算重</p><p>附：枚举子集的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sub = state &amp; (state - <span class="number">1</span>); sub; sub = (sub - <span class="number">1</span>) &amp; state)</span><br></pre></td></tr></table></figure><p>其二、由相邻当前状态下结点转移<br>$$<br>f[i][state] = \min\limits_{state_p = true} \{f[p][state] + value_i\}<br>$$<br>发现很像三角形不等式，故考虑 $SPFA$ 转移</p><p>总复杂度 $O (n3^n + kE2^n)$，$3^n$ 为枚举子集总复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NextX[<span class="number">4</span>]= &#123;- <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, NextY[<span class="number">4</span>]= &#123;<span class="number">0</span>, - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> Map[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">preSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">preSt (<span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, <span class="keyword">int</span> fs = <span class="number">0</span>) :</span><br><span class="line">x (fx), y (fy), state (fs) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXM];</span><br><span class="line">preSt pre[MAXN][MAXN][MAXM];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span> <span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; top = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = top.first, y = top.second;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + NextX[i];</span><br><span class="line"><span class="keyword">int</span> ty = y + NextY[i];</span><br><span class="line"><span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; N || ty &lt; <span class="number">1</span> || ty &gt; M)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (f[x][y][state] + Map[tx][ty] &lt; f[tx][ty][state]) &#123;</span><br><span class="line">f[tx][ty][state] = f[x][y][state] + Map[tx][ty];</span><br><span class="line">pre[tx][ty][state] = preSt (x, y, state);</span><br><span class="line">que.push(make_pair (tx, ty));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! x || ! y)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">tag[x][y] = <span class="number">1</span>;</span><br><span class="line">preSt pr = pre[x][y][state];</span><br><span class="line">traceback (pr.x, pr.y, pr.state);</span><br><span class="line"><span class="keyword">if</span> (pr.x == x &amp;&amp; pr.y == y)</span><br><span class="line">traceback (pr.x, pr.y, state - pr.state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">int</span> px, py;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line">Map[i][j] = getnum ();</span><br><span class="line"><span class="keyword">if</span> (! Map[i][j]) &#123;</span><br><span class="line">cnt ++, f[i][j][<span class="number">1</span> &lt;&lt; (cnt - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">px = i, py = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">1</span>; state &lt;= limit; state ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sub = state &amp; (state - <span class="number">1</span>); sub; sub = (sub - <span class="number">1</span>) &amp; state) <span class="comment">// from subset</span></span><br><span class="line"><span class="keyword">if</span> (f[i][j][sub] + f[i][j][state - sub] - Map[i][j] &lt; f[i][j][state]) &#123;</span><br><span class="line">f[i][j][state] = f[i][j][sub] + f[i][j][state - sub] - Map[i][j];</span><br><span class="line">pre[i][j][state] = preSt (i, j, sub);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f[i][j][state] &lt; INF)</span><br><span class="line">que.push(make_pair (i, j));</span><br><span class="line">&#125;</span><br><span class="line">SPFA (state); <span class="comment">// from other nodes</span></span><br><span class="line">&#125;</span><br><span class="line">traceback (px, py, limit);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[px][py][limit]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! Map[i][j])</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tag[i][j] ? <span class="built_in">putchar</span> (<span class="string">'o'</span>) : <span class="built_in">putchar</span> (<span class="string">'_'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">2 5 5 1</span></span><br><span class="line"><span class="comment">1 5 5 1</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SDOI2009」HH去散步 「矩阵乘法计数」</title>
      <link href="/2020/08/04/%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%20%E3%80%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E8%AE%A1%E6%95%B0%E3%80%8D/"/>
      <url>/2020/08/04/%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%20%E3%80%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E8%AE%A1%E6%95%B0%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计数问题也许可以转化为矩阵乘法形式</p><p>比如若该题没有不能在一条边上重复走的条件限制，那么直接将邻接矩阵转化为矩阵乘法即可</p><p>故</p><h3 id="矩阵乘法计数"><a href="#矩阵乘法计数" class="headerlink" title="矩阵乘法计数"></a>矩阵乘法计数</h3><p>对于计数问题，若可以将 $n$ 个点表示成 $n \times n$ 的矩阵，并且可以保证中途转移对象不会变化，即可用矩阵乘法计数</p><h3 id="至于该题"><a href="#至于该题" class="headerlink" title="至于该题"></a>至于该题</h3><p>那么考虑该题，加入了不能重复在一条边上走的限制，那么最简单的思想就是拆点，并且让改点屏蔽掉当前方向，但是如果考虑边，一条无向边可以拆成两条有向边，那拆出来的就比点少很多了，故考虑点边转化</p><p>那么只要在起始点加一条超级源边，同样矩阵乘法即可统计答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 45989</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">120</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> st, ed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">LL a[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; j ++)</span><br><span class="line">a[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">Matrix newmat;</span><br><span class="line">newmat.init ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= size; k ++)</span><br><span class="line">newmat.a[i][j] = (newmat.a[i][j] + a[i][k] * p.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> newmat;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix mats, bem;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">mats = mats * bem;</span><br><span class="line">bem = bem * bem;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[ed]; i; i = Link[i].next)</span><br><span class="line">ans = (ans + mats.a[<span class="number">1</span>][i ^ <span class="number">1</span>]) % MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), K = getnum (), st = getnum () + <span class="number">1</span>, ed = getnum () + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum () + <span class="number">1</span>, v = getnum () + <span class="number">1</span>;</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[st]; i; i = Link[i].next)</span><br><span class="line">bem.a[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= size; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[v]; j; j = Link[j].next) &#123;</span><br><span class="line"><span class="keyword">if</span> ((j ^ <span class="number">1</span>) == i)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">bem.a[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i ++)</span><br><span class="line">mats.a[i][i] = <span class="number">1</span>;</span><br><span class="line">LL ans = power (K);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 3 0 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">0 3</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SCOI2016」萌萌哒</title>
      <link href="/2020/08/04/%5BSCOI2016%5D%E8%90%8C%E8%90%8C%E5%93%92/"/>
      <url>/2020/08/04/%5BSCOI2016%5D%E8%90%8C%E8%90%8C%E5%93%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次做到这种倍增题，有点有趣</p><p>首先区间内的每个点对应相等用并查集维护一下就好了，显然最后的答案就是（并查集个数为 $t$） $9 \cdot 10^{t - 1}$</p><p>当然这样会造成 $O (n^2)$ 的复杂度，那么通过倍增来优化，即将区间二进制拆分，然后每次将 $[l_1, l_1 + 2^k - 1]$ 与 $[l_2, l_2 +2^k - 1]$ 合并，其中 $k$ 为二进制拆分结果所得幂次的部分，那么这样修改就变成 $O (n \log n)$ 了</p><p>对于查询，显然是不能直接查询了，那么就通过由大区间到小区间的传递（即将大区间拆分为左右两段，然后分别与之祖先拆分得左右两段合并）来将信息转移到最小的（即以点为单位的）区间段上</p><p>那么最后即 $O (n)$ 查询并查集个数即可</p><p>故该倍增整体思想即为：将以点为单位处理改为以幂次区间段为单位处理 $\rightarrow$ 将幂次区间段的信息转移到小区间直至单位区间 $\rightarrow$ 答案处理</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> father[x][j] == x ? x : father[x][j] = find (father[x][j], j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (x, j), fy = find (y, j);</span><br><span class="line">father[fx][j] = fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (i, j);</span><br><span class="line">merge (i, fx, j - <span class="number">1</span>);</span><br><span class="line">merge (i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)), fx + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)), j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; j ++)</span><br><span class="line">father[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> l1 = getnum (), r1 = getnum ();</span><br><span class="line"><span class="keyword">int</span> l2 = getnum (), r2 = getnum ();</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line"><span class="keyword">if</span> (l1 + p + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= r1) &#123;</span><br><span class="line">merge (l1 + p, l2 + p, j);</span><br><span class="line">p += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pushdown ();</span><br><span class="line"><span class="keyword">int</span> group = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (find (i, <span class="number">0</span>) == i)</span><br><span class="line">group ++;</span><br><span class="line">LL ans = <span class="number">9l</span>l * power (<span class="number">10l</span>l, group - <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">3 3 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">100000 1</span></span><br><span class="line"><span class="comment">1 99999 2 100000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「POI2009」LYZ-Ice Skates</title>
      <link href="/2020/08/04/%5BPOI2009%5DLYZ-Ice%20Skates/"/>
      <url>/2020/08/04/%5BPOI2009%5DLYZ-Ice%20Skates/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前置「Hall定理」"><a href="#前置「Hall定理」" class="headerlink" title="前置「Hall定理」"></a>前置「Hall定理」</h3><blockquote><p> 二分图G中的两部分顶点组成的集合分别为X, Y(假设有|X|≤|Y||X|≤|Y|)。G中有一组无公共点的边，一端恰好为组成X的点(也就是存在完美匹配)的充分必要条件是：X中的任意k个点至少与Y中的k个点相邻，即对于X中的一个点集W ，令N(W)为W的所有邻居， 霍尔定理即对于任意W，|W|≤|N(W)</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于最坏情况任选 $k$ 个是选一端连续的区间 $[l, r]$，根据Hall定理的 $|W| \le N(W)$ 可以得到<br>$$<br>\begin{aligned}<br>sum[l, r] &amp;\le (r - l + 1 + d) \cdot k \\<br>sum[l, r] - (r - l +1) \cdot k &amp;\le d \cdot k<br>\end{aligned}<br>$$<br>那么就可以在线段树中将每个点的权值设为 $value - k$，然后维护最大子段和 $sumax$</p><p>那么最后 $sumax \le d \cdot k  ?  TAK  :  NIE$ 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> limit, N, k, d;</span><br><span class="line"></span><br><span class="line">LL subsum[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL lmax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;, rmax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumax[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">subsum[root] = subsum[lson] + subsum[rson];</span><br><span class="line">lmax[root] = max (lmax[lson], subsum[lson] + lmax[rson]);</span><br><span class="line">rmax[root] = max (rmax[rson], rmax[lson] + subsum[rson]);</span><br><span class="line">sumax[root] = max (sumax[lson], max (sumax[rson], rmax[lson] + lmax[rson]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">subsum[root] = lmax[root] = rmax[root] = sumax[root] = - k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid), build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">subsum[root] += delta;</span><br><span class="line">lmax[root] += delta, rmax[root] += delta;</span><br><span class="line">sumax[root] += delta;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">posi &lt;= mid ? modify (lson, left, mid, posi, delta) : modify (rson, mid + <span class="number">1</span>, right, posi, delta);</span><br><span class="line">maintain (root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">bool</span> isneg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) isneg = <span class="literal">true</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">limit = getnum (), N = getnum (), k = getnum (), d = getnum ();</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, limit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> posi = getnum (), delta = getnum ();</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, limit, posi, delta);</span><br><span class="line">LL deal = sumax[<span class="number">1</span>];</span><br><span class="line">deal &lt;= <span class="number">1l</span>l * k * d ? <span class="built_in">puts</span> (<span class="string">"TAK"</span>) : <span class="built_in">puts</span> (<span class="string">"NIE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4 2 1</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">2 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「POI2006」MET-Subway</title>
      <link href="/2020/08/04/%5BPOI2006%5DMET-Subway/"/>
      <url>/2020/08/04/%5BPOI2006%5DMET-Subway/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一棵树上选出 $k$ 条可相交的链使得被覆盖的点数最多，求该最大值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>说实话这个解法是真的厉害</p><p>显然题目可以看作选出 $k \times 2$ 个叶子节点，然后将它们互相连接最终覆盖的点的最大值</p><p>再考虑删去选中的 $k \times 2$ 个叶子节点后，向内一层的点最多只会有 $k \times 2$ 个点有贡献</p><p>同理继续内推</p><p>于是上述过程即由叶子节点开始拓扑，对于拓扑的每一层，令点 $i$ 拓扑深度为 $depth_i$，$total_i$ 表示拓扑深度为 $i$ 的点的个数，即，将每一个拓扑层重新看作叶子节点，再在当前拓扑层中选出至多 $k \times 2$ 个“叶子节点”，故<br>$$<br>\min (k \times 2, total_i)<br>$$<br>即为拓扑深度为 $i$ 的层的答案贡献</p><p>将它们累加起来即可</p><p>复杂度 $O (n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> degree[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> total[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (degree[i] == <span class="number">1</span>) &#123;</span><br><span class="line">que.push(i);</span><br><span class="line">total[depth[i] = <span class="number">1</span>] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> ((-- degree[v]) == <span class="number">1</span>) &#123;</span><br><span class="line">total[depth[v] = depth[u] + <span class="number">1</span>] ++;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">degree[u] ++, degree[v] ++;</span><br><span class="line">&#125;</span><br><span class="line">toposort ();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">ans += min (K &lt;&lt; <span class="number">1</span>, total[i]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">17 3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">9 8</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">10 13</span></span><br><span class="line"><span class="comment">13 14</span></span><br><span class="line"><span class="comment">10 12</span></span><br><span class="line"><span class="comment">12 11</span></span><br><span class="line"><span class="comment">15 17</span></span><br><span class="line"><span class="comment">15 16</span></span><br><span class="line"><span class="comment">15 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2018」你的名字</title>
      <link href="/2020/08/04/%5BNOI2018%5D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/"/>
      <url>/2020/08/04/%5BNOI2018%5D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="主要题意"><a href="#主要题意" class="headerlink" title="主要题意"></a>主要题意</h3><p>求字符串$S$与$T$不同的子串总数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑$l = 1, r = |T|$的情况：</p><p>因为任意子串为字符串前缀的某些后缀，那么令$Lim[i]$表示$T[1…i]$在$S$上所能匹配的最大长度，$Posi[i]$表示$T$的后缀自动机上的点$i$的$endpos$集合中最靠前的位置，那么答案即为</p><p>$$Ans = \sum\limits_{i = 1}^{nodes} \max (0, Len[i] - min (Len[Father[i]], Lim[Posi[i]]))$$</p><p>接下来考虑$l, r$任意的情况：</p><p>原来能否在$S$的后缀自动机上往下走的判断依据只有当前节点是否存在$c$边，那么有了$l, r$的限制，就多需要判断向下的这个节点的$endpos$是否有存在于$[l + len, r]$（$len$表示已匹配长度）区间的位置，$endpos$集合用动态开点线段树维护一下就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">char</span> Orig[MAXN], Str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Root[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Left[MAXN * MAXL]= &#123;<span class="number">0</span>&#125;, Right[MAXN * MAXL]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tnodes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! root)</span><br><span class="line">        root = ++ tnodes;</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pos &lt;= mid ? Modify (Left[root], left, mid, pos) : Modify (Right[root], mid + <span class="number">1</span>, right, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tree_Merge</span> <span class="params">(<span class="keyword">int</span> sl, <span class="keyword">int</span> sr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! sl || ! sr)</span><br><span class="line">        <span class="keyword">return</span> sl + sr;</span><br><span class="line">    <span class="keyword">int</span> p = ++ tnodes;</span><br><span class="line">    Left[p] = Tree_Merge (Left[sl], Left[sr]);</span><br><span class="line">    Right[p] = Tree_Merge (Right[sl], Right[sr]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! root || left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)</span><br><span class="line">        <span class="keyword">if</span> (Query (Left[root], left, mid, L, R))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)</span><br><span class="line">        <span class="keyword">if</span> (Query (Right[root], mid + <span class="number">1</span>, right, L, R))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Tree[MAXN][<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> Father[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Len[MAXN], Posi[MAXN];</span><br><span class="line">    <span class="keyword">int</span> last, nodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span> (Tree[i], <span class="number">0</span>, <span class="keyword">sizeof</span> (Tree[i]));</span><br><span class="line">            Father[i] = <span class="number">0</span>, Posi[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nodes = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> pos, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = last, p = ++ nodes;</span><br><span class="line">        last = p;</span><br><span class="line">        Len[p] = Len[fa] + <span class="number">1</span>, Posi[p] = pos;</span><br><span class="line">        <span class="keyword">while</span> (fa &amp;&amp; ! Tree[fa][c])</span><br><span class="line">            Tree[fa][c] = p, fa = Father[fa];</span><br><span class="line">        <span class="keyword">if</span> (! fa)</span><br><span class="line">            Father[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Tree[fa][c];</span><br><span class="line">            <span class="keyword">if</span> (Len[x] == Len[fa] + <span class="number">1</span>)</span><br><span class="line">                Father[p] = x;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> np = ++ nodes;</span><br><span class="line">                Len[np] = Len[fa] + <span class="number">1</span>, Father[np] = Father[x], Posi[np] = Posi[x];</span><br><span class="line">                Father[p] = Father[x] = np;</span><br><span class="line">                <span class="built_in">memcpy</span> (Tree[np], Tree[x], <span class="keyword">sizeof</span> (Tree[x]));</span><br><span class="line">                <span class="keyword">while</span> (fa &amp;&amp; Tree[fa][c] == x)</span><br><span class="line">                    Tree[fa][c] = np, fa = Father[fa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">            Modify (Root[p], <span class="number">1</span>, N, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Minp[MAXN];</span><br><span class="line">    <span class="keyword">int</span> buck[MAXN];</span><br><span class="line">    <span class="comment">/*void Merge_Minp () &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= nodes; i ++)</span></span><br><span class="line"><span class="comment">            buck[i] = 0, Minp[i] = Posi[i];</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= nodes; i ++)</span></span><br><span class="line"><span class="comment">            buck[Len[i]] ++;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= N; i ++)</span></span><br><span class="line"><span class="comment">            buck[i] += buck[i - 1];</span></span><br><span class="line"><span class="comment">        for (int i = nodes; i &gt;= 1; i --)</span></span><br><span class="line"><span class="comment">            Topo[buck[Len[i]] --] = i;</span></span><br><span class="line"><span class="comment">        for (int i = nodes; i &gt;= 1; i --)</span></span><br><span class="line"><span class="comment">            Minp[Father[Topo[i]]] = min (Minp[Father[Topo[i]]], Minp[Topo[i]]);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge_Tree</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">            buck[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">            buck[Len[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">            buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">            Topo[buck[Len[i]] --] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">            Root[Father[Topo[i]]] = Tree_Merge (Root[Father[Topo[i]]], Root[Topo[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">SAM S, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Lim[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/*void Match (int l, int r) &#123;</span></span><br><span class="line"><span class="comment">    int p = 1, len = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= M; i ++) &#123;</span></span><br><span class="line"><span class="comment">        int c = Str[i] - 'a';</span></span><br><span class="line"><span class="comment">        while (p &amp;&amp; ! S.Tree[p][c])</span></span><br><span class="line"><span class="comment">            p = S.Father[p], len = S.Len[p];</span></span><br><span class="line"><span class="comment">        while (p &amp;&amp; ! Query (Root[S.Tree[p][c]], 1, N, l + len, r))</span></span><br><span class="line"><span class="comment">            p = S.Father[p], len = S.Len[p];</span></span><br><span class="line"><span class="comment">        S.Tree[p][c] ? (p = S.Tree[p][c], len ++) : (p = 1, len = 0);</span></span><br><span class="line"><span class="comment">        Lim[i] = len;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = Str[j] - <span class="string">'a'</span>;</span><br><span class="line">        T.Append (c, j, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.Tree[p][c] &amp;&amp; Query (Root[S.Tree[p][c]], <span class="number">1</span>, N, l + len, r)) &#123;</span><br><span class="line">                p = S.Tree[p][c], len ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! len)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            len --;</span><br><span class="line">            <span class="keyword">if</span> (len == S.Len[S.Father[p]])</span><br><span class="line">                p = S.Father[p];</span><br><span class="line">        &#125;</span><br><span class="line">        Lim[j] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// T.Merge_Minp ();</span></span><br><span class="line">    <span class="comment">// Match (l, r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T.nodes; i ++)</span><br><span class="line">        ans += max (<span class="number">0</span>, T.Len[i] - max (T.Len[T.Father[i]], Lim[T.Posi[i]]));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Orig + <span class="number">1</span>);</span><br><span class="line">    N = <span class="built_in">strlen</span> (Orig + <span class="number">1</span>);</span><br><span class="line">    S.init ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        S.Append (Orig[i] - <span class="string">'a'</span>, i, <span class="number">1</span>);</span><br><span class="line">    S.Merge_Tree ();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp; Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = getnum (), r = getnum ();</span><br><span class="line">        T.init ();</span><br><span class="line">        M = <span class="built_in">strlen</span> (Str + <span class="number">1</span>);</span><br><span class="line">        Work (l, r);</span><br><span class="line">        LL ans = Solve ();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">scbamgepe</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">smape 1 9</span></span><br><span class="line"><span class="comment">sbape 1 9</span></span><br><span class="line"><span class="comment">sgepe 1 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">scbamgepe</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">smape 2 7</span></span><br><span class="line"><span class="comment">sbape 3 8</span></span><br><span class="line"><span class="comment">sgepe 1 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2016」循环之美</title>
      <link href="/2020/08/04/%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/"/>
      <url>/2020/08/04/%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求解 $1 \le x \le n, ~ 1 \le y \le m$ 中满足在 $k$ 进制下 $\frac{x}{y}$ 是有限循环小数的个数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很好然后我一开始在计算器上敲了半个小时然后由于眼瞎并且归纳能力差并没有发现规律</p><p>设 $\frac{x}{y}$ 的循环节长度为 $l$，则有<br>$$<br>\begin{aligned}<br>\frac{xk^l}{y} - \left\lfloor\frac{xk^l}{y}\right\rfloor &amp;= \frac{x}{y} - \left\lfloor\frac{x}{y}\right\rfloor \\<br>xk^l - \left\lfloor\frac{xk^l}{y}\right\rfloor y &amp;= x - \left\lfloor\frac{x}{y}\right\rfloor y \\<br>xk^l &amp;\equiv x \pmod y \\<br>k &amp;\equiv 1 \pmod y<br>\end{aligned}<br>$$<br>也就是说只要满足 $y \bot k$ 即可满足题意，故可将问题化为<br>$$<br>\begin{aligned}<br>Ans &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1][(j, k) = 1] \\<br>&amp;= \sum\limits_{j = 1}^m [(j, k) = 1]\sum\limits_{d | j} \mu(d)\left\lfloor\frac{n}{d}\right\rfloor \\<br>&amp;= \sum\limits_{d = 1}^n \mu(d)\left\lfloor\frac{n}{d}\right\rfloor\sum\limits_{d | j}[(j, k) = 1] \\<br>&amp;将j除以d, 此时若后半部分的\sum要有贡献则需满足d \bot k \\<br>&amp;= \sum\limits_{d = 1}^n [(d, k) = 1]\mu(d)\left\lfloor\frac{n}{d}\right\rfloor\big(\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor}[(j, k) = 1]\big)<br>\end{aligned}<br>$$<br>于是接下来变为处理<br>$$<br>f_1(n, k) = \sum\limits_{d = 1}^n [(d, k) = 1]\mu(d) \\<br>f_2(n) = \sum\limits_{d = 1}^n [(d, k) = 1]<br>$$<br>先说 $f_2(n)$，较好处理，即考虑长度为 $k$ 的区间将 $n$ 分段，其中除了最后多出来的那一段其余的段得到的贡献是相同的，即 $\varphi(k)$，故<br>$$<br>f_2(n) = \left\lfloor\frac{n}{k}\right\rfloor\varphi(k) + f_2(n \% k)<br>$$<br>那么对于 $f_1(n, k)$，容易变换得<br>$$<br>f_1(n, k) = \sum\limits_{d | k}^n \mu(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(ld)<br>$$<br>然后我就不会了，看了下题解，可以发现若 $\mu(ld)$ 有贡献，<strong>则需满足 $l \bot d$，此时有 $\mu(ld) = \mu(l)\mu(d)$</strong>，故<br>$$<br>\begin{aligned}<br>f_1(n, k) &amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(l)\mu(d)[(d, l) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu^2(d)\sum\limits_{l = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(l)[(d, l) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu^2(d)f_1(\left\lfloor\frac{n}{d}\right\rfloor, d)<br>\end{aligned}<br>$$<br>很好我还是第一次写到莫反带递归的</p><p>注意边界条件 $n = 0$ 与 $k = 1$，对于 $n = 0$ 返回 $0$ 即可，对于 $k = 1$，$f_1(n, 1)$ 即为 $\sum\limits_{d = 1}^n \mu(d)$，杜教筛一下即可</p><p>最后再整除分块一次求总答案就好了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e06</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e06</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM / <span class="number">10</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXM]= &#123;<span class="number">0</span>&#125;, sumu[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linear_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">sumu[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! visit[i]) &#123;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line">mu[i] = - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= MAX; j ++) &#123;</span><br><span class="line">visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! (i % prime[j])) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = - mu[i];</span><br><span class="line">&#125;</span><br><span class="line">sumu[i] = sumu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapmu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sieve</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MAX) <span class="keyword">return</span> sumu[n];</span><br><span class="line"><span class="keyword">if</span> (mapmu[n]) <span class="keyword">return</span> mapmu[n];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">total -= (r - l + <span class="number">1</span>) * mu_sieve (n / l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapmu[n] = total;</span><br><span class="line">&#125;</span><br><span class="line">LL f[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL sumr[MAXM]= &#123;<span class="number">0</span>&#125;; <span class="comment">// sigma ([(j, k) = 1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ! b ? a : GCD (b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + (GCD (i, K) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rval</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n / K) * f[K] + f[n % K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mapl;</span><br><span class="line"><span class="function">LL <span class="title">l_solve</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// S(n, K)</span></span><br><span class="line"><span class="keyword">if</span> (! n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = make_pair (n, k);</span><br><span class="line"><span class="keyword">if</span> (mapl[ret]) <span class="keyword">return</span> mapl[ret];</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> mu_sieve (n);</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= k; i ++)</span><br><span class="line"><span class="keyword">if</span> (! (k % i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mu[i]) total += l_solve (n / i, i);</span><br><span class="line"><span class="keyword">if</span> (i * i != k &amp;&amp; mu[k / i])</span><br><span class="line">total += l_solve (n / (k / i), k / i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapl[ret] = total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">linear_sieve ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>, &amp; N, &amp; M, &amp; K);</span><br><span class="line">r_sieve ();</span><br><span class="line">LL ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min (N, M); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min (N / (N / l), M / (M / l));</span><br><span class="line">LL pl = l_solve (r, K);</span><br><span class="line">ans += <span class="number">1l</span>l * (pl - pre) * (N / l) * rval (M / l);</span><br><span class="line">pre = pl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 6 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">99 7689 100</span></span><br><span class="line"><span class="comment">ans: 257777</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>我没有写这种方法，但是这种真的很简单的说<br>$$<br>\begin{aligned}<br>f(n, m, k) &amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1][(j, k) = 1] \\<br>&amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1]\sum\limits_{d | j, d | k} \mu(d) \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{d | j}^m [(i, j) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} [(i, jd) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)\sum\limits_{i = 1}^n\sum\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} [(i, j) = 1][(i, d) = 1] \\<br>&amp;= \sum\limits_{d | k} \mu(d)f(\left\lfloor\frac{m}{d}\right\rfloor, n, d)<br>\end{aligned}<br>$$<br>边界 $n = 0$ 或者 $m = 0$ 返回 $0$，$k = 1$ 返回 $\sum\limits_{i = 1}^n\sum\limits_{j = 1}^m [(i, j) = 1] = \sum\limits_{i = 1}^{\min (n, m)} \mu(d) \left\lfloor\frac{n}{d}\right\rfloor \left\lfloor\frac{m}{d}\right\rfloor$ 即可</p><p>不过说实话这个虽然简单但是至少对于我不大容易想到，毕竟我会先拆 $[(i, j) = 1]$ 部分，因为总感觉 $[(j, k) = 1]$ 会多出一个 $d | k$ 的限制条件</p><p>但是这个解法是真的厉害</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2014」购票 「树上斜率优化」</title>
      <link href="/2020/08/04/%5BNOI2014%5D%E8%B4%AD%E7%A5%A8%20%E3%80%8C%E6%A0%91%E4%B8%8A%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/"/>
      <url>/2020/08/04/%5BNOI2014%5D%E8%B4%AD%E7%A5%A8%20%E3%80%8C%E6%A0%91%E4%B8%8A%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先易得方程，且经过变换有</p><p>$$\begin{aligned} f_i &amp;= \min\limits_{dist_i - lim_i \le dist_j} \{f_j + (dist_i - dist_j)p_i + q_i\} \\ f_j &amp;= p_idist_j + f_i - dist_ip_i - q_i \end{aligned}​$$</p><p>在一条直线上时，斜率优化可以用普通$CDQ​$分治实现（会不会过于麻烦？），那么对于在树上斜率优化时，考虑点分治</p><p>这时就在点分治中运用$CDQ$分治的思想，即使用在当前重心管辖范围内的通向根节点的那一条链上的节点来更新其它节点就好了</p><p>注意在分治中的斜率优化时在凸包上加点和更新右侧节点答案要同时进行，不然当前最优解可能会在后面由于斜率被删去，导致答案错误，还有由于下面代码是由深度由小到大处理的，所以是反着维护下凸包，即上凸包</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-08</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dcmp</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Link[++ size].to = v;</span><br><span class="line">    Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">    Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CitySt</span> &#123;</span></span><br><span class="line">    LL p, q, lim;</span><br><span class="line"></span><br><span class="line">    CitySt () &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">CitySt City[MAXN];</span><br><span class="line"></span><br><span class="line">LL f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL Fdist[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL Dist[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Dist[v] = Dist[root] + Fdist[v];</span><br><span class="line">        DFS (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Vis[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> grvy, minval = INF;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grvy_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    Size[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxpart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Grvy_Acqu (v, root);</span><br><span class="line">        Size[root] += Size[v];</span><br><span class="line">        maxpart = max (maxpart, Size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxpart = max (maxpart, total - Size[root]);</span><br><span class="line">    <span class="keyword">if</span> (maxpart &lt; minval)</span><br><span class="line">        grvy = root, minval = maxpart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[MAXN];</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Que[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dist[a] == Dist[b])</span><br><span class="line">        <span class="keyword">return</span> INFLL * <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (f[b] - f[a]) * <span class="number">1.0</span> / (<span class="keyword">double</span>) (Dist[b] - Dist[a]) * <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> listq[MAXN];</span><br><span class="line"><span class="keyword">int</span> lp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Dist[a] - City[a].lim &gt; Dist[b] - City[b].lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listq_Acqu</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father)</span><br><span class="line">        listq[++ lp] = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[root]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == father || Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        listq_Acqu (v, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[Que[mid + <span class="number">1</span>]] - f[Que[mid]] &lt;= p * (Dist[Que[mid + <span class="number">1</span>]] - Dist[Que[mid]]))</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = Binary_Search (left, right, City[tp].p);</span><br><span class="line">    f[tp] = min (f[tp], f[Que[p]] + (Dist[tp] - Dist[Que[p]]) * City[tp].p + City[tp].q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span> <span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    minval = INF, total = Size[root], Grvy_Acqu (root, <span class="number">0</span>);</span><br><span class="line">    Vis[grvy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> fgrvy = grvy;</span><br><span class="line">    <span class="keyword">if</span> (grvy != root) &#123;</span><br><span class="line">        Size[root] -= Size[grvy];</span><br><span class="line">        Solve (root);</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    temp[++ p] = fgrvy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = fgrvy; nd != root; nd = Father[nd]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dist[fgrvy] - City[fgrvy].lim &lt;= Dist[Father[nd]])</span><br><span class="line">            f[fgrvy] = min (f[fgrvy], f[Father[nd]] + (Dist[fgrvy] - Dist[Father[nd]]) * City[fgrvy].p + City[fgrvy].q);</span><br><span class="line">        temp[++ p] = Father[nd];</span><br><span class="line">    &#125;</span><br><span class="line">    lp = <span class="number">0</span>;</span><br><span class="line">    listq_Acqu (fgrvy, <span class="number">0</span>);</span><br><span class="line">    sort (listq + <span class="number">1</span>, listq + lp + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p &amp;&amp; j &lt;= lp; i ++) &#123; <span class="comment">// 斜率优化</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= lp &amp;&amp; Dist[temp[i]] &lt; Dist[listq[j]] - City[listq[j]].lim)</span><br><span class="line">            Update (left, right, listq[j ++]);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; Dcmp (slope (Que[right - <span class="number">1</span>], Que[right]) - slope (Que[right], temp[i])) &lt;= <span class="number">0</span>) <span class="comment">// 注意是上凸包</span></span><br><span class="line">            right --;</span><br><span class="line">        Que[++ right] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= lp)</span><br><span class="line">        Update (left, right, listq[j ++]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[fgrvy]; i; i = Link[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">        <span class="keyword">if</span> (Vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Solve (v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">getLL</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen ("Output.txt", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">    f[Root] = <span class="number">0</span>;</span><br><span class="line">    N = getint (), getint ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = getint ();</span><br><span class="line">        Father[i] = fa;</span><br><span class="line">        Fdist[i] = getLL ();</span><br><span class="line">        City[i].p = getLL (), City[i].q = getLL (), City[i].lim = getLL ();</span><br><span class="line">        Insert (fa, i), Insert (i, fa);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS (Root, <span class="number">0</span>);</span><br><span class="line">    Size[Root] = N;</span><br><span class="line">    Solve (Root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 3</span></span><br><span class="line"><span class="comment">1 2 20 0 3</span></span><br><span class="line"><span class="comment">1 5 10 100 5</span></span><br><span class="line"><span class="comment">2 4 10 10 10</span></span><br><span class="line"><span class="comment">2 9 1 100 10</span></span><br><span class="line"><span class="comment">3 5 20 100 10</span></span><br><span class="line"><span class="comment">4 4 20 0 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 树上DP </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2007」货币兑换 「CDQ分治实现斜率优化」</title>
      <link href="/2020/08/04/%5BNOI2007%5D%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2%20%E3%80%8CCDQ%E5%88%86%E6%B2%BB%E5%AE%9E%E7%8E%B0%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/"/>
      <url>/2020/08/04/%5BNOI2007%5D%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2%20%E3%80%8CCDQ%E5%88%86%E6%B2%BB%E5%AE%9E%E7%8E%B0%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先每次买卖一定是在某天 $k$ 以当时的最大收入买入，再到第 $i$ 天卖出，那么易得方程：</p><p>$$f_i = \max \{\frac{A_iRate_kf_k}{A_kRate_k + B_k} + \frac{B_if_k}{A_kRate_k + B_k}\}$$</p><p>再令</p><p>$$\left\{\begin{aligned} x_k = \frac{Rate_kf_k}{A_kRate_k + B_k} \\ y_k = \frac{f_k}{A_kRate_k + B_k}\end{aligned}\right.$$</p><p>则有</p><p>$$\begin{aligned} f_i &amp;= \max \{A_ix_k + B_iy_k\} \\ y_k &amp;= - \frac{A_i}{B_i}x_k + \frac{f_i}{B_i} \end{aligned}$$</p><p>那么现在需要找到一个点 $(x_k, y_k)$ 使得直线的截距最大</p><p>由于斜率和横坐标皆不满足单调性，可以用平衡树等维护，这里使用CDQ分治实现</p><p>实现过程如下：</p><p>Ⅰ 将数据按照斜率$\frac{A_i}{B_i}$降序排序</p><p>Ⅱ 将区间按照操作顺序分为左右两部分处理</p><p>Ⅲ 先处理左半部分，维护左半边凸包（注意，此时左半边已按照 $x$ 排序）</p><p>Ⅳ 处理左半边对右半边的影响，由于已按照斜率降序排序，所以普通斜率优化即可</p><p>Ⅴ 将区间按照 $x$ 排序</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-08</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dcmp</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span> (p) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p &lt; <span class="number">0</span> ? - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CashSt</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b, rate;</span><br><span class="line">    <span class="keyword">double</span> k, x, y;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    CashSt () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> CashSt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Dcmp (x - p.x) == <span class="number">0</span> ? Dcmp (y - p.y) &lt; <span class="number">0</span> : Dcmp (x - p.x) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">CashSt Cash[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> CashSt&amp; a, <span class="keyword">const</span> CashSt&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Dcmp (a.k - b.k) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span> <span class="params">(CashSt a, CashSt b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dcmp (b.x - a.x) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> (b.y - a.y) / (b.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CashSt Que[MAXN];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">CashSt temp[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        f[left] = max (f[left], f[left - <span class="number">1</span>]);</span><br><span class="line">        Cash[left].y = f[left] / (Cash[left].a * Cash[left].rate + Cash[left].b);</span><br><span class="line">        Cash[left].x = Cash[left].y * Cash[left].rate;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = left - <span class="number">1</span>, p2 = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i ++)</span><br><span class="line">        Cash[i].index &lt;= mid ? temp[++ p1] = Cash[i] : temp[++ p2] = Cash[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i ++)</span><br><span class="line">        Cash[i] = temp[i];</span><br><span class="line">    CDQ (left, mid);</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= mid; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; Dcmp (slope (Que[r - <span class="number">1</span>], Que[r]) - slope (Que[r], Cash[i])) &lt; <span class="number">0</span>)</span><br><span class="line">            r --;</span><br><span class="line">        Que[++ r] = Cash[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; Dcmp (slope (Que[l], Que[l + <span class="number">1</span>]) - Cash[i].k) &gt; <span class="number">0</span>)</span><br><span class="line">            l ++;</span><br><span class="line">        f[Cash[i].index] = max (f[Cash[i].index], Cash[i].a * Que[l].x + Cash[i].b * Que[l].y);</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ (mid + <span class="number">1</span>, right);</span><br><span class="line">    l = left, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// if (Dcmp (Cash[l].x - Cash[r].x) &lt; 0 || (Dcmp (Cash[l].x - Cash[r].x) == 0 &amp;&amp; Dcmp (Cash[l].y - Cash[r].y) &lt; 0))</span></span><br><span class="line">        <span class="keyword">if</span> (Cash[l] &lt; Cash[r])</span><br><span class="line">            temp[++ p] = Cash[l], l ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[++ p] = Cash[r], r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid)</span><br><span class="line">        temp[++ p] = Cash[l], l ++;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= right)</span><br><span class="line">        temp[++ p] = Cash[r], r ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i ++)</span><br><span class="line">        Cash[i + left - <span class="number">1</span>] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">double</span> T = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = num * <span class="number">10.0</span> + (ch - <span class="string">'0'</span>) * <span class="number">1.0</span>, ch = getchar ();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">            num = num + (T /= <span class="number">10.0</span>) * (ch - <span class="string">'0'</span>), ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen ("Input.txt", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%lf"</span>, &amp; N, &amp; f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">double</span> a = getnum (), b = getnum (), rate = getnum ();</span><br><span class="line">        Cash[i].a = a, Cash[i].b = b, Cash[i].rate = rate;</span><br><span class="line">        Cash[i].index = i;</span><br><span class="line">        Cash[i].k = - a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort (Cash + <span class="number">1</span>, Cash + N + <span class="number">1</span>, comp);</span><br><span class="line">    CDQ (<span class="number">1</span>, N);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%.3f\n"</span>, f[N]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 100</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">2 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2007」生成树计数</title>
      <link href="/2020/08/04/%5BNOI2007%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/"/>
      <url>/2020/08/04/%5BNOI2007%5D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>后面发现这是某次考试的原题来着</p><p>怕是太久没打过状压然后连 $k \le 5$ 可能要状压这么明显的提示都给无视了然后就随便敲了个矩阵树骗了 $50$。。。</p><p>好所以这题是一道状压</p><p>令 $state$ 表示对于 $i$ 点（包括它本身）的前 $k$ 个点的连通状态，$e.g.   \{1, 1, 2\}$ 表示 $\{1, 2\}, \{3\}$ 点分别连通</p><p>注意为了去重要用最小表示，于是即使当 $k = 5$ 时状态数也不过就 $52$ 个而已了</p><p>再令 $f_{i, j}$ 表示前 $i$ 个点且 $i$ 点连通状态为 $j$ 时的方案数，$g_{i, j}$ 表示状态 $i$ 转移到状态 $j$ 时的方案数，则有方程<br>$$<br>f_{i, j} = \sum_k f_{i - 1, k} * g_{k, j}<br>$$<br>可以发现这就是一个矩阵转移式，故直接矩阵乘法即可</p><p>那么至于计算 $g_{i, j}$ 则枚举 $i$，及当前点与前面点的连通状态 $state$（二进制表示），然后并查集维护一下，判断当前 $state$ 是否会与之前冲突（连边后无环且原状态中的最前点（即会被刷掉的点）与当前的 $k$ 个点中至少一个点连边），然后计算出 $j$，最后累加即可</p><p>当然要注意考虑 $f$ 矩阵的初始状态，即对于 $i  \in [1, k]$，那么计算出里面每个连通块的大小 $a_i$，然后用 $Calley$ 公式 $n^{n - 2}$ 算一下就好了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 65521</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">52</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">6e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line">LL N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allst[MAXM], M = <span class="number">0</span>; <span class="comment">// 压位表示</span></span><br><span class="line"><span class="keyword">int</span> mapp[MAXT]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> state, <span class="keyword">int</span> maxi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == K + <span class="number">1</span>) &#123;</span><br><span class="line">        allst[++ M] = state;</span><br><span class="line">        mapp[state] = M;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min (maxi + <span class="number">1</span>, K); i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nst = state * <span class="number">10</span> + i;</span><br><span class="line">        DFS (p + <span class="number">1</span>, nst, max (i, maxi));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    LL a[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line">    Matrix () &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; A, <span class="keyword">const</span> Matrix&amp; B) &#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= M; k ++)</span><br><span class="line">ret.a[i][j] = (ret.a[i][j] + A.a[i][k] * B.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">Matrix f, g;</span><br><span class="line"><span class="function">LL <span class="title">matpower</span> <span class="params">(LL p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">f = f * g;</span><br><span class="line">g = g * g;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[x] == x ? x : father[x] = find (father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> visit[MAXK]= &#123;<span class="number">0</span>&#125;, bit[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span> <span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> con)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K + <span class="number">1</span>; i ++)</span><br><span class="line">        father[i] = i, visit[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> st = state, i = K; i &gt; <span class="number">0</span>; i --, st /= <span class="number">10</span>)</span><br><span class="line">        bit[i] = st % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= K; j ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find (i), fy = find (j);</span><br><span class="line">            <span class="keyword">if</span> (bit[i] != bit[j] || fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++)</span><br><span class="line">        <span class="keyword">if</span> (con &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find (K + <span class="number">1</span>), fy = find (j);</span><br><span class="line">            <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> ;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K + <span class="number">1</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span> (find (<span class="number">1</span>) == find (i)) &#123;</span><br><span class="line">            fail = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (fail) <span class="keyword">return</span> ; <span class="comment">// 之前的点都联通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        bit[i] = find (i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! visit[bit[i]])</span><br><span class="line">            visit[bit[i]] = ++ cnt;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">        <span class="keyword">final</span> = <span class="keyword">final</span> * <span class="number">10</span> + visit[bit[i]];</span><br><span class="line">    g.a[mapp[state]][mapp[<span class="keyword">final</span>]] ++, g.a[mapp[state]][mapp[<span class="keyword">final</span>]] %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prep</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123; <span class="comment">// i in [1, k]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++) cnt[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> st = allst[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j ++, st /= <span class="number">10</span>)</span><br><span class="line">            cnt[st % <span class="number">10</span>] ++;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; cnt[j] &gt; <span class="number">0</span>; j ++)</span><br><span class="line">    ret = ret * power (cnt[j], cnt[j] - <span class="number">2</span>) % MOD;</span><br><span class="line">    f.a[<span class="number">1</span>][i] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) <span class="comment">// 枚举当前点及其与之前的连通状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= limit; state ++)</span><br><span class="line">            maintain (allst[i], state);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt;= M; i ++) &#123;</span></span><br><span class="line"><span class="comment">        for (int j = 1; j &lt;= M; j ++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; g.a[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        puts ("");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N;</span><br><span class="line">    DFS (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), prep ();</span><br><span class="line">    LL ans = matpower (N - K);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 23333333333333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JSOI2012」分零食</title>
      <link href="/2020/08/04/%5BJSOI2012%5D%E5%88%86%E9%9B%B6%E9%A3%9F/"/>
      <url>/2020/08/04/%5BJSOI2012%5D%E5%88%86%E9%9B%B6%E9%A3%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先普通 $DP$ 式子很好列</p><p>令 $f[i][j]$ 表示 $i$ 个小朋友分 $j$ 个糖果且每人至少一颗的答案，则有<br>$$<br>f[i][j] = \sum\limits_{k = 1}^j f[i - 1][j - k](Ok^2 + Sk + U)<br>$$<br>接下来用生成函数优化该式</p><p>令 $g[k] = Ok^2 + Sk + U$，则<br>$$<br>f_i(x) = f_{i - 1}(x)g(x)<br>$$<br>其中 $f_0(x) = 1$</p><p>所以答案即为<br>$$<br>[x^M] \sum\limits_{i = 0}^A f_i(x) = [x^M] \sum\limits_{i = 0}^A (g(x))^i = [x^M] \frac{1 - (g(x))^{A + 1}}{1 - g(x)}<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL MOD;</span><br><span class="line">LL O, S, U;</span><br><span class="line">LL a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> a, b;</span><br><span class="line"></span><br><span class="line">mcomplex (<span class="keyword">double</span> fa = <span class="number">0.0</span>, <span class="keyword">double</span> fb = <span class="number">0.0</span>) :</span><br><span class="line">a (fa), b (fb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a + p.a, b + p.b);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a - p.a, b - p.b);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (a * p.a - b * p.b, a * p.b + b * p.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">swap (a[i], a[oppo[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">mcomplex omega = mcomplex (<span class="built_in">cos</span> (PI / (<span class="keyword">double</span>) mid), inv * <span class="built_in">sin</span> (PI / (<span class="keyword">double</span>) mid));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">mcomplex x = mcomplex (<span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * omega) &#123;</span><br><span class="line">mcomplex a1 = a[j + k], xa2 = x * a[j + mid + k];;</span><br><span class="line">a[j + k] = a1 + xa2;</span><br><span class="line">a[j + k + mid] = a1 - xa2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aclimit</span> <span class="params">(<span class="keyword">int</span> maxl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, lim;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>, lim = <span class="number">0</span>; n &lt;= maxl; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">limit = n;</span><br><span class="line">&#125;</span><br><span class="line">mcomplex a1[MAXN &lt;&lt; <span class="number">2</span>], a2[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span> <span class="params">(LL* A, LL* B, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">aclimit (n + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a2[i] = mcomplex ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">a1[i] = mcomplex ((<span class="keyword">double</span>) A[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">a2[i] = mcomplex ((<span class="keyword">double</span>) B[i], <span class="number">0</span>);</span><br><span class="line">FFT (a1, <span class="number">1</span>), FFT (a2, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">a1[i] = a1[i] * a2[i];</span><br><span class="line">FFT (a1, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++)</span><br><span class="line">A[i] = (LL) (a1[i].a / limit + <span class="number">0.5</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL inv[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span> <span class="params">(<span class="keyword">int</span> deg, LL* A, LL* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">inverse ((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B);</span><br><span class="line">aclimit (deg &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">temp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">temp[i] = A[i];</span><br><span class="line">multiply (temp, B, deg, deg);</span><br><span class="line">multiply (temp, B, deg, deg);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i ++)</span><br><span class="line">B[i] = (<span class="number">2</span> * B[i] % MOD - temp[i] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span> <span class="params">(LL* A, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">multiply (ans, a, M, M);</span><br><span class="line">multiply (a, a, M, M);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">isneg = <span class="number">1</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">M = getnum (), MOD = getnum (), N = getnum ();</span><br><span class="line">O = getnum (), S = getnum (), U = getnum ();</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">a[i] = (O * i * i + S * i + U) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)</span><br><span class="line">b[i] = (- a[i] + MOD) % MOD;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">power (ans, N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">ans[i] = (- ans[i] + MOD) % MOD;</span><br><span class="line">ans[<span class="number">0</span>] = (ans[<span class="number">0</span>] + <span class="number">1</span>) % MOD;</span><br><span class="line">inverse (M + <span class="number">1</span>, b, inv);</span><br><span class="line">multiply (ans, inv, M, M);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 100</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JLOI2013」地形生成</title>
      <link href="/2020/08/04/%5BJLOI2013%5D%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/"/>
      <url>/2020/08/04/%5BJLOI2013%5D%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>挺有趣的一道 $dp$，两问实际上就相当于是第一问是第二问的部分分</p><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>一开始以为要 $dp$，然而并不用</p><p>对于这种高度然后求方案数的题，可以只考虑其相对位置，因为只要所有相对位置确定了，那么整个序列就唯一确定了</p><p>首先肯定要先将它们以高度为第一关键字（由大到小），关键值为第二关键字（从小到大）排序</p><p>那么对于第 $i$ 座山，它就会有 $\min (i, key_i)$ 个相对位置可以占，因为有相同高度的山峰，所以还会多出 $same$ （$i$ 前面与其高度相同的山峰的个数）个位置</p><p>那么 $ans_1 = \prod\limits_{i = 1}^n min (i, key_i + same)$</p><h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>症结还是在于相同高度的山峰会产生重复</p><p>但是显然如果一次性确定好所有相同山峰的位置是不会产生重复的，故考虑将每一组相同高度的山峰放在一起处理</p><p>为了避免重复，需要强制令这些相同高度的山峰放置有序，即后放的一定在先放的后面，那么就可以令 $f_{i, j}$ 表示（当前组相同高度山峰）前 $i$ 个放在前 $j$ 个位置上，并且第 $i$ 放在第 $j$ 个位置的方案数，则有（下示方程表示区间 $[l, r]$ 的相同高度山峰组）<br>$$<br>\begin{aligned}<br>f_{i, j} &amp;= \sum\limits_{k = 1}^j f_{i - 1, k}  (j \in [0, \min (l, key_i) - 1]) \\<br>&amp;= f_{i - 1, j} + f_{i, j - 1}<br>\end{aligned}<br>$$<br>然后实际上第一维是没用的，再省掉就行了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 2011</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL f[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hillSt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">hillSt (<span class="keyword">int</span> fhigh = <span class="number">0</span>, <span class="keyword">int</span> fkey = <span class="number">0</span>) :</span><br><span class="line">high (fhigh), key (fkey) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> hillSt&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (high == p.high)</span><br><span class="line"><span class="keyword">return</span> key &lt; p.key;</span><br><span class="line"><span class="keyword">return</span> high &gt; p.high;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">hillSt hill[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">hill[i].high = getnum (), hill[i].key = getnum ();</span><br><span class="line">sort (hill + <span class="number">1</span>, hill + N + <span class="number">1</span>);</span><br><span class="line">LL ans1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">hill[i].high == hill[i - <span class="number">1</span>].high ? same ++ : same = <span class="number">0</span>;</span><br><span class="line">ans1 = ans1 * <span class="number">1l</span>l * min (i, hill[i].key + same) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL ans2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N; l ++) &#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">for</span> (r = l; r &lt;= N &amp;&amp; hill[r + <span class="number">1</span>].high == hill[r].high; r ++);</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min (l, hill[i].key) - <span class="number">1</span>; j ++)</span><br><span class="line">f[j] = (f[j - <span class="number">1</span>] + f[j]) % MOD;</span><br><span class="line">LL total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min (l, hill[r].key) - <span class="number">1</span>; j ++)</span><br><span class="line">total = (total + f[j]) % MOD;</span><br><span class="line">ans2 = ans2 * total % MOD;</span><br><span class="line">swap (l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">' '</span> &lt;&lt; ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HNOI2007」梦幻岛宝珠 「套路：分层DP」</title>
      <link href="/2020/08/04/%5BHNOI2007%5D%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E3%80%8C%E5%A5%97%E8%B7%AF%EF%BC%9A%E5%88%86%E5%B1%82DP%E3%80%8D/"/>
      <url>/2020/08/04/%5BHNOI2007%5D%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E3%80%8C%E5%A5%97%E8%B7%AF%EF%BC%9A%E5%88%86%E5%B1%82DP%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>显然直接 $01$ 背包会超时并且超空间</p><p><strong>套路：分层 $DP$</strong></p><p>「考虑将每个子结构看作一层（也就是包含了不止 $1$ 个物品的信息），并且大层不会对小层造成影响，可以考虑先进行每一层的自我更新（即用当前层物品更新当前层答案），再进行层的合并，此时考虑低层对高层的影响」</p><p><strong>正题</strong></p><p>那么这题有一个特殊性质： $V_i = a \times 2^b$</p><blockquote><p>b值大的物品不会影响零碎剩余的重量上限。</p><p>将物品按b值分阶段处理。</p></blockquote><p>那么就是分层 $DP$</p><p>先通过普通的 $01$ 背包更新当前层自身最优解</p><p>再进行层合并：</p><p>令 $g_{i, j}​$ 表示第 $i​$ 层，$a​$ 为 $j​$ 的最优解，$f_{i, j}​$ 表示第 $i​$ 层，$a​$ 为 $j​$，并且再加上 $V_{total}​$ 的 $1…i - 1​$ 位的最优解</p><p>那么对于第 $i$ 层，枚举当前 $j$</p><p>对于转移，枚举在自身层内消耗的空间 $(j - k) \times 2^i$，那么还剩下 $k \times 2^i + V_{total}\{1…i - 1\}$ 的空间，分配给上一层，那么可得转移方程为</p><p>（注：$w_i$ 表示 $V_{total}$ 第 $i$ 位）<br>$$<br>f_{i, j} = \max \{g_{i, j - k} + f_{i - 1, 2k + w_i}\}<br>$$<br>同时，$g_{i, j}$ 可以通过由大到小枚举来消除</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">isneg = <span class="number">1</span>;</span><br><span class="line">ch = getchar ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~ (N = getnum ())) &#123;</span><br><span class="line">M = getnum ();</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> vol = getnum (), value = getnum ();</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (! (vol &amp; <span class="number">1</span>))</span><br><span class="line">vol &gt;&gt;= <span class="number">1</span>, b ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1000</span>; j &gt;= vol; j --)</span><br><span class="line">f[b][j] = max (f[b][j], f[b][j - vol] + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xm = M, maxb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (xm)</span><br><span class="line">xm &gt;&gt;= <span class="number">1</span>, maxb ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxb; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1000</span>; j ++)</span><br><span class="line">f[i][j] = max (f[i][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxb; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = min (<span class="number">1000</span>, M &gt;&gt; i); j &gt;= <span class="number">0</span>; j --) <span class="comment">// 注意此处上限是 min (100, M &gt;&gt; i)，M &gt;&gt; i 保证不会将高位拿多了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k ++) &#123;</span><br><span class="line">f[i][j] = max (f[i][j], f[i][j - k] + f[i - <span class="number">1</span>][min ((k &lt;&lt; <span class="number">1</span>) + ((M &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>), <span class="number">1000</span>)]);</span><br><span class="line">ans = max (ans, f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">4 13</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">16 75594681</span></span><br><span class="line"><span class="comment">393216 5533</span></span><br><span class="line"><span class="comment">2 77</span></span><br><span class="line"><span class="comment">32768 467</span></span><br><span class="line"><span class="comment">29360128 407840</span></span><br><span class="line"><span class="comment">112 68</span></span><br><span class="line"><span class="comment">24576 372</span></span><br><span class="line"><span class="comment">768 60</span></span><br><span class="line"><span class="comment">33554432 466099</span></span><br><span class="line"><span class="comment">16384 318</span></span><br><span class="line"><span class="comment">33554432 466090</span></span><br><span class="line"><span class="comment">2048 111</span></span><br><span class="line"><span class="comment">24576 350</span></span><br><span class="line"><span class="comment">9216 216</span></span><br><span class="line"><span class="comment">12582912 174768</span></span><br><span class="line"><span class="comment">16384 295</span></span><br><span class="line"><span class="comment">1024 76</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「FJOI2016」建筑师</title>
      <link href="/2020/08/04/%5BFJOI2016%5D%E5%BB%BA%E7%AD%91%E5%B8%88/"/>
      <url>/2020/08/04/%5BFJOI2016%5D%E5%BB%BA%E7%AD%91%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这题一直往 $\text{dp}$ 去想，然后就没了</p><p>所以其实并不用注意之前的可看见的建筑的最大值是多少，若把那些能够被看见的建筑之间构成的区间看作一个小组，那么能够被看见的建筑不过是在当前小组中选择一个最大值最为代表排在左（右）边罢了</p><p>所以现在问题转化为将 $n - 1$ 个建筑分在 $A + B - 2$ 个盒子，然后盒子内可以随意排列的个数</p><p>然后上述问题实际上可以将每个盒子看作一个圆，故问题又转化为 $n - 1$ 个建筑构成的 $A + B - 2$ 个圆排列方案数，即斯特林数 $S (n - 1, A + B - 2)$</p><p>然后要在其中选择一些放左（右）边，故答案即为<br>$$<br>ans = S (n - 1, A + B - 2) \times \dbinom{A + B - 2}{A - 1}<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXAB = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n, A, B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NMAX = <span class="number">5e04</span>, ABMAX = <span class="number">200</span>;</span><br><span class="line">LL S[MAXN][MAXAB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL fact[MAXAB]= &#123;<span class="number">0</span>&#125;, invfact[MAXAB]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= NMAX; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min (i, ABMAX); j ++)</span><br><span class="line">S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + S[i - <span class="number">1</span>][j] * (i - <span class="number">1</span>) % MOD) % MOD;</span><br><span class="line">fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">0</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= ABMAX; i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ABMAX; i ++)</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * invfact[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">init ();</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">n = getnum (), A = getnum (), B = getnum ();</span><br><span class="line">LL ans = S[n - <span class="number">1</span>][A + B - <span class="number">2</span>] * C (A + B - <span class="number">2</span>, A - <span class="number">1</span>) % MOD;</span><br><span class="line">write (ans), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3 2 2</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CTSC2008」祭祀（DAG最长反链及其方案构造）</title>
      <link href="/2020/08/04/%5BCTSC2008%5D%E7%A5%AD%E7%A5%80%EF%BC%88DAG%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%8F%8A%E5%85%B6%E6%96%B9%E6%A1%88%E6%9E%84%E9%80%A0%EF%BC%89/"/>
      <url>/2020/08/04/%5BCTSC2008%5D%E7%A5%AD%E7%A5%80%EF%BC%88DAG%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%8F%8A%E5%85%B6%E6%96%B9%E6%A1%88%E6%9E%84%E9%80%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求一个 $n$ 点 $m$ 边的 $DAG$ 的最长反链，在第二行输出构造的其中一种方案，在第三行输出在保证最长反链的前提下，每个点是否能够设置为反链中的点</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反正证明也不会，就记录一下具体方法</p><blockquote><p>最长反链：对 $DAG$ 点集 $V$，最长反链为一个集合 $S \subseteq V$，满足 $\forall u \in S, v \in S$，$u$ 不能到达 $v$，$v$ 也不能到达 $u$</p></blockquote><p>根据 $\text{Dilworth}$ 定理，一个 $DAG$ 的最长反链大小等于其最小可重链覆盖大小</p><p>对 $DAG$ 传递闭包后，最小可重链覆盖大小可转化为最小<strong>不</strong>可重链覆盖大小，即最小路径点覆盖</p><blockquote><p>最小路径点覆盖：将 $DAG$ 用若干不相交的链覆盖，即每个点最多被经过一次，最小使用链的个数</p></blockquote><p>那么最小可重链覆盖则是类似，不同之处仅在于每个点可被经过多次</p><blockquote><p>最小路径点覆盖大小 $=$ $n$ $-$ 该 $DAG$ 拆点二分图的最大匹配大小</p></blockquote><p>那么 $\text{Subtask1}$ 就做完了</p><p>把 $DAG$ 拆点后最小路径点覆盖就相当于是求该拆点二分图的最大独立集</p><p>接下来开始构造方案</p><ul><li>找到拆点二分图中右侧的所有非匹配点</li><li>由这些非匹配点出发，右侧点只走非匹配边，左侧点只走匹配边</li><li>那么一种最小点覆盖的合法方案就是取左侧中被 $DFS$ 到的点，右侧中没被 $DFS$ 到的点</li><li>那么该拆点二分图的最大独立集的一种合法方案构造就是上述构造的补集</li></ul><p>这样就求出了最小路径点覆盖的一种方案，即最长反链的一种构造</p><p>那么 $\text{Subtask2}$ 就做完了</p><p>对 $\text{Subtask3}$，枚举每个点，将它会到达的点和会到达它的点删掉，强制假如该点，再跑一遍最长反链，若其得到最长反链长度等于原答案减一，则说明该点可以被设置为反链中的点</p><p>那么 $\text{Subtask3}$ 就做完了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">2</span> * MAXN + MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFS</span> &#123;</span> <span class="keyword">int</span> to, cap, next; &#125; ;</span><br><span class="line">LFS Link[MAXL &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;, size = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].cap = cap;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">Insert (x, y, cap); Insert (y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T, _N;</span><br><span class="line"><span class="keyword">int</span> depth[MAXN &lt;&lt; <span class="number">1</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span> (depth, <span class="number">0</span>, <span class="keyword">sizeof</span> (depth));</span><br><span class="line">depth[S] = <span class="number">1</span>, que.push(S);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] || ! cap) <span class="keyword">continue</span>;</span><br><span class="line">depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[MAXL]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == T) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest = flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[p]; i &amp;&amp; rest; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, cap = Link[i].cap;</span><br><span class="line"><span class="keyword">if</span> (depth[v] != depth[p] + <span class="number">1</span> || ! cap) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = Dinic (v, min (cap, rest));</span><br><span class="line"><span class="keyword">if</span> (! k) depth[v] = - <span class="number">1</span>;</span><br><span class="line">Link[i].cap -= k, Link[i ^ <span class="number">1</span>].cap += k;</span><br><span class="line">rest -= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAXFLOW</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (BFS ()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _N; i ++) cur[i] = Head[i];</span><br><span class="line">ret += Dinic (S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subtask2</span></span><br><span class="line"><span class="keyword">bool</span> tagl[MAXN]= &#123;<span class="literal">false</span>&#125;, tagr[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">tagr[u - N] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][u - N] &amp;&amp; ! tagl[i]) &#123;</span><br><span class="line">tagl[i] = <span class="literal">true</span>;</span><br><span class="line">DFS (match[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subtask3</span></span><br><span class="line"><span class="keyword">bool</span> del[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">g[u][v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][k])</span><br><span class="line">g[i] |= g[k];</span><br><span class="line">S = <span class="number">2</span> * N + <span class="number">1</span>, _N = T = <span class="number">2</span> * N + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = N - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! Link[<span class="number">4</span> * i - <span class="number">2</span>].cap)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = Head[i]; j; j = Link[j].next)</span><br><span class="line"><span class="keyword">if</span> (! Link[j].cap) &#123;</span><br><span class="line">match[i] = Link[j].to;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (Link[<span class="number">4</span> * i].cap)</span><br><span class="line">DFS (i + N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">printf</span> (<span class="string">"%d"</span>, ! tagl[i] &amp;&amp; tagr[i]);</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> (Head)); size = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span> (del, <span class="literal">false</span>, <span class="keyword">sizeof</span> (del));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (i == j || g[i][j] || g[j][i])</span><br><span class="line">del[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! del[i]) &#123;</span><br><span class="line">add (S, i, <span class="number">1</span>), add (i + N, T, <span class="number">1</span>);</span><br><span class="line">m ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! del[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line"><span class="keyword">if</span> (g[i][j] &amp;&amp; ! del[j])</span><br><span class="line">add (i, j + N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ret = m - MAXFLOW ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, ret == ans - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces Round 558 (Div. 2).F」Indecisive Taxi Fee</title>
      <link href="/2020/08/04/%5BCodeforces%20Round%20#558%20(Div.%202).F%5DIndecisive%20Taxi%20Fee/"/>
      <url>/2020/08/04/%5BCodeforces%20Round%20#558%20(Div.%202).F%5DIndecisive%20Taxi%20Fee/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>题意即为带修（临时）最短路</p><p>先随便提一条最短路出来，那么修改可分为四种情况：</p><ul><li>该边在最短路上，且数值变小</li><li>该边在最短路上，且数值变大</li><li>该边在最短路外，且数值变小</li><li>该边在最短路外，且数值变大</li></ul><p>那么对于情况 $1, 3, 4$，显然是十分容易处理的，那么问题就在情况 $2$</p><p>设最短路经过点 $e_1, e_2, e_3, …$</p><p>考虑到新的最短路必定与原最短路有相同的一段前缀与后缀（可以为空），设 $dis2_{i, j} (i &lt; j)$ 表示不经过路径 $e_ie_j$ 的最短路，所以答案即为 $\min \{dis2 (e_ie_j) (i &lt; j)\}$</p><p>那么便两遍 $Dijstra$ 分别求出 $1, n$ 到每个点 $p$ 的最短路 $pre_p, suf_p$，并且对于最短路上的点 $e_i$，求出其在最短路上的前驱边 $from_{e_i}$ 与后继边 $nxt_{e_i}$，对于每个不在最短路上的点 $p$，求出点 $1$ 至 $p$ 中最后一个在原最短路上的点的后继边 $from_p$ 及点 $p$ 至 $n$ 中第一个在原最短路上的点的后继边 $nxt_p$，故对于每个不在最短路上的边 $(u, v)$，它可以对 $dis2 (from_u, nxt_v - 1), dis2 (from_v, nxt_u - 1)$ 做贡献，然后用线段树维护一下就好了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要注意下列代码对于最短路上的点 $e_i$ 其 $from_{e_i}$ 实际上是后继边，这样子修改的区间才是对的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> w, id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].w = w;</span><br><span class="line">Link[size].id = id;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line">LL dist;</span><br><span class="line"></span><br><span class="line">node (<span class="keyword">int</span> fp = <span class="number">0</span>, LL fdist = <span class="number">0</span>) :</span><br><span class="line">p (fp), dist (fdist) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dist &gt; p.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;node&gt; heap;</span><br><span class="line">LL dist[<span class="number">3</span>][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> from[MAXN]= &#123;<span class="number">0</span>&#125;, nxt[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> occp[MAXN]= &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">dist[p][i] = INF, visit[i] = <span class="literal">false</span>;</span><br><span class="line">dist[p][S] = <span class="number">0</span>, heap.push(node (S, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (! heap.empty()) &#123;</span><br><span class="line">node top = heap.top();</span><br><span class="line">heap.pop();</span><br><span class="line"><span class="keyword">int</span> u = top.p;</span><br><span class="line">LL d = top.dist;</span><br><span class="line"><span class="keyword">if</span> (visit[u]) <span class="keyword">continue</span>;</span><br><span class="line">visit[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to, w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (d + w &lt; dist[p][v]) &#123;</span><br><span class="line">dist[p][v] = d + w;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">2</span>) from[v] = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; ! occp[v]) from[v] = from[u];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">1</span> &amp;&amp; ! occp[v]) nxt[v] = nxt[u];</span><br><span class="line">heap.push(node (v, dist[p][v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> path[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v != N;) &#123;</span><br><span class="line"><span class="keyword">int</span> ps = Link[from[v]].id;</span><br><span class="line">path[ps] = ++ pcnt, occp[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> nxn = Link[from[v] ^ <span class="number">1</span>].to;</span><br><span class="line">from[v] = nxt[v] = pcnt; <span class="comment">// attention</span></span><br><span class="line">v = nxn;</span><br><span class="line">&#125;</span><br><span class="line">occp[N] = <span class="literal">true</span>;</span><br><span class="line">from[N] = nxt[N] = pcnt + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL minv[MAXN &lt;&lt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">minv[root] = INF;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build (lson, left, mid), build (rson, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R, LL delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R) &#123;</span><br><span class="line">minv[root] = min (minv[root], delta);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) modify (lson, left, mid, L, R, delta);</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) modify (rson, mid + <span class="number">1</span>, right, L, R, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span> minv[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) <span class="keyword">return</span> min (minv[root], query (lson, left, mid, posi));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min (minv[root], query(rson, mid + <span class="number">1</span>, right, posi));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum (), Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line"><span class="keyword">int</span> w = getnum ();</span><br><span class="line">Insert (u, v, w, i), Insert (v, u, w, i);</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra (<span class="number">2</span>, N), deal ();</span><br><span class="line">Dijkstra (<span class="number">0</span>, <span class="number">1</span>), Dijkstra (<span class="number">1</span>, N);</span><br><span class="line">build (<span class="number">1</span>, <span class="number">1</span>, pcnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= size; i += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> u = Link[i].to, v = Link[i ^ <span class="number">1</span>].to;</span><br><span class="line"><span class="keyword">int</span> w = Link[i].w;</span><br><span class="line"><span class="keyword">if</span> (path[Link[i].id]) <span class="keyword">continue</span>;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, pcnt, from[u], nxt[v] - <span class="number">1</span>, dist[<span class="number">0</span>][u] + dist[<span class="number">1</span>][v] + w);</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, pcnt, from[v], nxt[u] - <span class="number">1</span>, dist[<span class="number">0</span>][v] + dist[<span class="number">1</span>][u] + w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = getnum () &lt;&lt; <span class="number">1</span>, delta = getnum ();</span><br><span class="line"><span class="keyword">int</span> u = Link[cur].to, v = Link[cur ^ <span class="number">1</span>].to;</span><br><span class="line"><span class="keyword">int</span> w = Link[cur].w;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (path[Link[cur].id]) ans = min (dist[<span class="number">0</span>][N] - w + delta, query (<span class="number">1</span>, <span class="number">1</span>, pcnt, path[Link[cur].id]));</span><br><span class="line"><span class="keyword">else</span> ans = min (dist[<span class="number">0</span>][N], min (dist[<span class="number">0</span>][u] + dist[<span class="number">1</span>][v] + delta, dist[<span class="number">0</span>][v] + dist[<span class="number">1</span>][u] + delta));</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 6</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">1 4 7</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 1 1</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CERC2014」Outer space invaders</title>
      <link href="/2020/08/04/%5BCERC2014%5DOuter%20space%20invaders/"/>
      <url>/2020/08/04/%5BCERC2014%5DOuter%20space%20invaders/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个线段，每个线段有一个权值 $w_i$，每次取轴上一点，获得的权值为选择的覆盖在当前点上的线段的最大权值，求最终覆盖所有线段后需要的最小权值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>好吧是一道非常水的区间 $dp$ 然而我并没有想出来所以我是真的绝望</p><p>先把 $l_i, r_i$ 离散化后令 $f_{l, r}$ 表示<strong>完全覆盖</strong>区间 $[l, r]$ 的线段的最小权值，设完全处于 $[l, r]$ 的线段中权值取最大值的线段 $p$，则有转移方程<br>$$<br>f_{l, r} = \min \{f_{l, k - 1} + f_{k + 1, r} + w_p\} (l_p \le k \le r_p)<br>$$<br>所以注意一定要完全覆盖，$[l, k - 1], [k + 1, r]$ 才不会对 $[l, r]$ 造成影响，于是我就卡这儿了</p><p>谨以此文纪念我逝去的智商</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> l[MAXN], r[MAXN], value[MAXN];</span><br><span class="line"><span class="keyword">int</span> vcol[MAXN &lt;&lt; <span class="number">1</span>], vcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case ++) &#123;</span><br><span class="line">N = getnum ();</span><br><span class="line">vcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">l[i] = getnum (), r[i] = getnum (), value[i] = getnum ();</span><br><span class="line">vcol[++ vcnt] = l[i], vcol[++ vcnt] = r[i];</span><br><span class="line">&#125;</span><br><span class="line">sort (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>);</span><br><span class="line">vcnt = unique (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>) - vcol - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">l[i] = lower_bound (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>, l[i]) - vcol;</span><br><span class="line">r[i] = lower_bound (vcol + <span class="number">1</span>, vcol + vcnt + <span class="number">1</span>, r[i]) - vcol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= vcnt; len ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vcnt - len + <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxv = - <span class="number">1</span>, sl, sr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line"><span class="keyword">if</span> (i &lt;= l[k] &amp;&amp; r[k] &lt;= j) <span class="comment">// 完全覆盖</span></span><br><span class="line"><span class="keyword">if</span> (value[k] &gt; maxv) &#123;</span><br><span class="line">maxv = value[k];</span><br><span class="line">sl = l[k], sr = r[k];</span><br><span class="line">&#125;</span><br><span class="line">f[i][j] = maxv == - <span class="number">1</span> ? <span class="number">0</span> : INF;</span><br><span class="line"><span class="keyword">if</span> (maxv != - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sl; k &lt;= sr; k ++)</span><br><span class="line">f[i][j] = min (f[i][j], f[i][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][j] + maxv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[<span class="number">1</span>][vcnt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 4 4</span></span><br><span class="line"><span class="comment">4 7 5</span></span><br><span class="line"><span class="comment">3 4 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「APIO2013」机器人</title>
      <link href="/2020/08/04/%5BAPIO2013%5D%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2020/08/04/%5BAPIO2013%5D%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先因为点数不多，可以考虑先在 $4r \times c$ 时间内将每个点朝每个方向可以到达的位置预处理出来，建成图</p><p>那么现在容易看出是斯坦那树问题，所以考虑将问题简化一下：</p><blockquote><p>现在给定 $n$ 个不同级别的机器人，将两段级别的机器人合并需要花费 $c_i$，那么将所有机器人合并的最小花费是多少</p></blockquote><p>这个问题显然使用区间 $DP$ 可以解决，那么扩展到斯坦那树上即可</p><p>令 $f[l][r][i]$ 表示区间 $l, r$ 的机器人合并后位于位置 $i$ 的最小花费，则有<br>$$<br>f[l][r][i] = \min \{f[l][k][i] + f[k + 1][r][i]\}<br>$$<br>以及<br>$$<br>f[l][r][i] = \min\limits_{p  link  to  i} \{f[l][r][p] + 1\}<br>$$<br>第二个式子直接 $SPFA$ 会超时</p><p><strong>但是观察每条边的贡献都为 $1$，所以可以将 $SPFA$ 优化成 $BFS$ 的复杂度</strong></p><p>类似堆优化的思想，开两个队列，一个存初始的经过 $f$ 排序的点，一个存被松弛的点，由于边的性质及 $que1$ 经过排序的原因，所以 $que2$ 一定也是按 $f$ 递增的，从而优化成 $BFS$ 的复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXI = MAXL * MAXL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4</span> * MAXI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NextX[<span class="number">4</span>]= &#123;- <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, NextY[<span class="number">4</span>]= &#123;<span class="number">0</span>, - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, R, C;</span><br><span class="line"><span class="keyword">char</span> Map[MAXL][MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * C + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fto[MAXL][MAXL][<span class="number">4</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXL][MAXL][<span class="number">4</span>]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x][y][k])</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k] = - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (fto[x][y][k])</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k];</span><br><span class="line"><span class="keyword">int</span> tx = x + NextX[k], ty = y + NextY[k];</span><br><span class="line">vis[x][y][k] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (Map[tx][ty] == <span class="string">'x'</span>)</span><br><span class="line">fto[x][y][k] = encode (x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Map[tx][ty] == <span class="string">'A'</span>)</span><br><span class="line">fto[x][y][k] = move (tx, ty, (k + <span class="number">1</span>) % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Map[tx][ty] == <span class="string">'C'</span>)</span><br><span class="line">fto[x][y][k] = move (tx, ty, (k + <span class="number">3</span>) % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fto[x][y][k] = move (tx, ty, k);</span><br><span class="line">vis[x][y][k] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> fto[x][y][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXI];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que1, que2;</span><br><span class="line"><span class="keyword">int</span> inque[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXI]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> save[MAXI];</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsort</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">limit = max (limit, f[l][r][i]), total ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i ++)</span><br><span class="line">buck[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">buck[f[l][r][i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i ++)</span><br><span class="line">buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = R * C; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line"><span class="keyword">if</span> (f[l][r][i] &lt; INF)</span><br><span class="line">save[buck[f[l][r][i]] --] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">fsort (l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; i ++)</span><br><span class="line">que1.push(save[i]), inque[save[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (! que1.empty() || ! que2.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">int</span> f1 = ! que1.empty() ? que1.front() : INF;</span><br><span class="line"><span class="keyword">int</span> f2 = ! que2.empty() ? que2.front() : INF;</span><br><span class="line">f1 &lt; f2 ? (u = f1, que1.pop()) : (u = f2, que2.pop());</span><br><span class="line">inque[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][u] + <span class="number">1</span> &lt; f[l][r][v]) &#123;</span><br><span class="line">f[l][r][v] = f[l][r][u] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (! inque[v])</span><br><span class="line">que2.push(v), inque[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>, &amp; N, &amp; C, &amp; R);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, Map[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line">Map[i][<span class="number">0</span>] = Map[i][C + <span class="number">1</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line">Map[<span class="number">0</span>][j] = Map[R + <span class="number">1</span>][j] = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Map[i][j] == <span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++) &#123;</span><br><span class="line">move (i, j, k);</span><br><span class="line"><span class="keyword">if</span> ((~ fto[i][j][k]) &amp;&amp; fto[i][j][k] != encode (i, j))</span><br><span class="line">Insert (encode (i, j), fto[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (f));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span> (Map[i][j]))</span><br><span class="line">f[Map[i][j] - <span class="string">'0'</span>][Map[i][j] - <span class="string">'0'</span>][encode (i, j)] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= N; len ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N - len + <span class="number">1</span>; l ++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k ++)</span><br><span class="line">f[l][r][i] = min (f[l][r][i], f[l][k][i] + f[k + <span class="number">1</span>][r][i]);</span><br><span class="line">&#125;</span><br><span class="line">SPFA (l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R * C; i ++)</span><br><span class="line">ans = min (ans, f[<span class="number">1</span>][N][i]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans == INF ? - <span class="number">1</span> : ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 10 5</span></span><br><span class="line"><span class="comment">1.........</span></span><br><span class="line"><span class="comment">AA...x4...</span></span><br><span class="line"><span class="comment">..A..x....</span></span><br><span class="line"><span class="comment">2....x....</span></span><br><span class="line"><span class="comment">..C.3.A...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n点基环树个数问题</title>
      <link href="/2020/08/04/n%E7%82%B9%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/04/n%E7%82%B9%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于 $n$ 个点组成的环大小为 $m$ 的基环树个数的问题，目前已知三种解法</p><h2 id="解法一「动态规划」"><a href="#解法一「动态规划」" class="headerlink" title="解法一「动态规划」"></a>解法一「动态规划」</h2><p>在环上每个点下面搭树的方案数，相当于是在完全图中制造生成树，然后提一个点（即环上那个点）为根，故可用 $n^{n - 2}$ 来计算</p><p>然后就可以很容易想到一种背包解法，把环随便找个地方断一下，把它看成序列，即可令 $f_{i, j}$ 表示环序列前 $i$ 个点，已经使用了 $j$ 个点做环下的树的方案数，显然<br>$$<br>f_{i, j} = \sum\limits_{k = 0}^j f_{i - 1, j - k} \times \dbinom{n - m - (j - k)}{k} \cdot (k + 1)^{k - 1}<br>$$<br>然后答案要对环进行圆排列，即 $ans = f_{m, n - m} \times \frac{A_n^m}{2m}$</p><p>复杂度 $O (n^3)$</p><p>当然这样复杂度比较高，可以考虑将已经拼好的连通块和已经拼好的一棵树连接起来，令 $f_n$ 表示 $n$ 个点的答案</p><p>当然，为了保证不会算重，需要有一个特征点，即保证点 $1$ 不会在环上，即<br>$$<br>f_n = \frac{n}{n - m}\sum\limits_{i = m}^{n - 1} f_i \times i \cdot (n - i)^{n - i - 2} \cdot \dbinom{n - 1}{i}<br>$$<br>注意，前面的 $\frac{n}{n - m}$ 是因为在你令每个点作为那个不在环上的那个点的时候，实际上对于每个点它会被其它点作为不在环上的点时算重 $n - m$ 次，故需要除以 $n - m$</p><p>复杂度 $O (n^2)$</p><h2 id="解法二「prufer序列」"><a href="#解法二「prufer序列」" class="headerlink" title="解法二「prufer序列」"></a>解法二「prufer序列」</h2><p>考虑在做prufer序列的时候，对于序列长度来讲，将其缩成一个点，即有 $n - m + 1$ 个位置，但是在实际放点的时候，却应当是有 $n$ 种选择，因为环上不同点作为父亲的情况是不一样的，即有 $n^{n - m - 1}$ 个位置，然后再做一次圆排列，即乘上 $\frac{A_n^m}{2m}$，但是可以发现环所称的点作为非根节点（相对意义上）的时候，需要选定一个环上的点作为与父节点连接的点，即还需要乘上 $m$</p><p>故最后答案为，$ans = \frac{A_n^m}{2m} \cdot n^{n - m - 1} \cdot m$</p><p>复杂度 $O (n)$</p><h2 id="解法三「生成函数」"><a href="#解法三「生成函数」" class="headerlink" title="解法三「生成函数」"></a>解法三「生成函数」</h2><p>考虑将基环树拆分为若干棵树的拼凑</p><p>注意此时需考虑的是有根树，即先将节点看作组合对象，根据 $Cayley$ 定理，$n$ 个节点的完全图有 $n^{n - 1}$ 棵有根树，则有根树的 EGF $T(x)$ 为<br>$$<br>T(x) = \sum\limits_{n = 1}^{\infty} n^{n - 1}\frac{x^n}{n!}<br>$$<br>那么此时将有根树看作组合对象，则将它们组成环，即基环树的 EGF $G(x)$ 为<br>$$<br>\begin{aligned}<br>G(x) &amp;= \frac{1}{2}\sum\limits_{k = 3}^{\infty} \frac{T(x)^k}{k} \\<br>&amp;= - \frac{1}{2}\ln (1 - T(x)) - \sum\limits_{k = 1}^2 \frac{T(x)^k}{k}<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> prufer序列 </tag>
            
            <tag> 归纳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTT（快速数论变换）</title>
      <link href="/2020/08/04/NTT%EF%BC%88%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%89/"/>
      <url>/2020/08/04/NTT%EF%BC%88%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><h3 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h3><p>对于$p \in N_+$且$(a,  p) = 1$，满足$a^r \equiv 1 (mod  p)$的最小的非负$r$为$a$模$p$意义下的阶，记作$\delta_p(a)$</p><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>定义：若$p \in N_+$且$a \in N$，若$\delta_p(a) = \phi(p)$，则称$a$为模$p$的一个原根<br>相关定理：</p><ul><li>若一个数$m$拥有原根，那么它必定为$2,  4,  p^t,  2p^t  (p$为奇质数$)$的其中一个<br>   每个数$p$都有$\phi(\phi(p))$个原根<br>   　　证明：若$p \in N_+$且$(a,  p) = 1$，正整数$r$满足$a^r \equiv 1 (mod  p)$，那么$\delta(p) | r$，由此推广，可知$\delta(p) | \phi(p)$，所以$p$的原根个数即为$p$之前与$\phi(p)$互质的数，即$\phi(p)$故定理成立<br>   　　　　　　- 若$g$是$m$的一个原根，则$g,  g^1,  g^2,  …,  g^{\phi(m)} (mod  p)$两两不同<br>   　　　　原根求法：<br>   　　将$\phi(m)$质因数分解，得$\phi(m) = p_1^{c_1} * p_2^{c_2} * … * p_k^{c_k}$<br>   　　那么所有$g$满足$g^{\frac{\phi(m)}{p_i}} \neq 1 (mod  m)$即为$m$的原根</li></ul><h2 id="NTT"><a href="#NTT" class="headerlink" title="$NTT$"></a>$NTT$</h2><p>　　由于$FTT$涉及到复数的运算，所以常数很大，而$NTT$仅需使用长整型，可大大优化常数</p><p>　　能够将原根代替单位根进行计算，是因为它们的性质相似，至少在单位根需要的那几个性质原根都满足，当然，要能够进行$NTT$，需要满足模数$p$为质数，且$p = ax + 1$其中$x$为$2$的次幂，那么一般能满足条件的数（常用）有：<br>　　$|            p             |    g     |$</p><p>　　$|    469762049     |    3     |$</p><p>　　$|    998244353     |    3     |$</p><p>　　$|   1004535809    |    3     |$<br>　　那么，就可以将单位根$\omega_n$替换为$g^{\frac{p - 1}{n}}$进行$NTT$了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % MOD;</span><br><span class="line"></span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL invg = power (g, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ome = power (inv == <span class="number">1</span> ? g : invg, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD) &#123;</span><br><span class="line">                LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD;</span><br><span class="line">                a[j + k] = (a1 + xa2) % MOD;</span><br><span class="line">                a[j + k + mid] = (a1 - xa2 + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i] = (<span class="keyword">int</span>) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i] = (<span class="keyword">int</span>) getnum ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    limit = n;</span><br><span class="line">    NTT (A, <span class="number">1</span>);</span><br><span class="line">    NTT (B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        A[i] = A[i] * B[i] % MOD;</span><br><span class="line">    NTT (A, - <span class="number">1</span>);</span><br><span class="line">    LL invn = power (n, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i] * invn % MOD));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意模数-NTT-（三模数-NTT-法）"><a href="#任意模数-NTT-（三模数-NTT-法）" class="headerlink" title="任意模数$NTT$（三模数$NTT$法）"></a>任意模数$NTT$（三模数$NTT$法）</h3><p>有公式</p><p>$$<br>\left\{\begin{aligned} x \equiv a_1 (mod  m_1) \\ x \equiv a_2 (mod  m_2) \\ x \equiv a_3 (mod  m_3) \end{aligned}\right.<br>$$<br>直接乘会爆$long  long$，就先将上面的用$CRT$合并，得</p><p>$$<br>\left\{\begin{aligned} x \equiv A (mod  M) \\ x \equiv a_3 (mod  m_3) \end{aligned}\right.<br>$$<br>那么设$Ans = kM + A$，则有<br>$$<br>\begin{aligned}<br>kM + A &amp;\equiv a_3 \pmod{m_3} \\<br>k &amp;\equiv (a_3 - A)M^{- 1} \pmod{m_3}<br>\end{aligned}<br>$$<br>直接处理即可</p><h4 id="代码（任意模数-NTT-）"><a href="#代码（任意模数-NTT-）" class="headerlink" title="代码（任意模数$NTT$）"></a>代码（任意模数$NTT$）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL MOD[<span class="number">3</span>]= &#123;<span class="number">469762049</span>, <span class="number">998244353</span>, <span class="number">1004535809</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> LL g = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> eps = <span class="number">1e-03</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">multi</span> <span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">return</span> ((a * b - (LL) ((LL) ((<span class="keyword">long</span> <span class="keyword">double</span>) a / p * b + eps) * p)) % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p, LL mod)</span> </span>&#123;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            cnt = cnt * x % mod;</span><br><span class="line"></span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL invg[<span class="number">3</span>]= &#123;power (g, MOD[<span class="number">0</span>] - <span class="number">2</span>, MOD[<span class="number">0</span>]), power (g, MOD[<span class="number">1</span>] - <span class="number">2</span>, MOD[<span class="number">1</span>]), power (g, MOD[<span class="number">2</span>] - <span class="number">2</span>, MOD[<span class="number">2</span>])&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL P;</span><br><span class="line"></span><br><span class="line">LL A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span> <span class="params">(LL* a, <span class="keyword">int</span> inv, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL ome = power (inv == <span class="number">1</span> ? g : invg[type], (MOD[type] - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>), MOD[type]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            LL x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome % MOD[type]) &#123;</span><br><span class="line">                LL a1 = a[j + k], xa2 = x * a[j + k + mid] % MOD[type];</span><br><span class="line">                a[j + k] = (a1 + xa2) % MOD[type];</span><br><span class="line">                a[j + k + mid] = (a1 - xa2 + MOD[type]) % MOD[type];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ntta[<span class="number">3</span>][MAXN], nttb[<span class="number">3</span>][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_Main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    limit = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            ntta[i][j] = A[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            nttb[i][j] = B[j];</span><br><span class="line">        NTT (ntta[i], <span class="number">1</span>, i);</span><br><span class="line">        NTT (nttb[i], <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            ntta[i][j] = ntta[i][j] * nttb[i][j] % MOD[i];</span><br><span class="line">        NTT (ntta[i], - <span class="number">1</span>, i);</span><br><span class="line">        LL invn = power (n, MOD[i] - <span class="number">2</span>, MOD[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N + M; j ++)</span><br><span class="line">            ntta[i][j] = ntta[i][j] * invn % MOD[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRT</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    LL m = MOD[<span class="number">0</span>] * MOD[<span class="number">1</span>];</span><br><span class="line">    LL M1 = MOD[<span class="number">1</span>], M2 = MOD[<span class="number">0</span>];</span><br><span class="line">    LL t1 = power (M1, MOD[<span class="number">0</span>] - <span class="number">2</span>, MOD[<span class="number">0</span>]), t2 = power (M2, MOD[<span class="number">1</span>] - <span class="number">2</span>, MOD[<span class="number">1</span>]), invM = power (m % MOD[<span class="number">2</span>], MOD[<span class="number">2</span>] - <span class="number">2</span>, MOD[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        LL a1 = ntta[<span class="number">0</span>][i], a2 = ntta[<span class="number">1</span>][i], a3 = ntta[<span class="number">2</span>][i];</span><br><span class="line">        LL A = (multi (a1 * M1 % m, t1 % m, m) + multi (a2 * M2 % m, t2 % m, m)) % m;</span><br><span class="line">        LL k = ((a3 - A % MOD[<span class="number">2</span>]) % MOD[<span class="number">2</span>] + MOD[<span class="number">2</span>]) % MOD[<span class="number">2</span>] * invM % MOD[<span class="number">2</span>];</span><br><span class="line">        ans[i] = ((k % P * (m % P) % P + A % P) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum (), P = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i] = (LL) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i] = (LL) getnum ();</span><br><span class="line"></span><br><span class="line">    NTT_Main ();</span><br><span class="line">    CRT ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ6039 - 「雅礼集训 2017 Day5」珠宝 「重量较小的大数据01背包」</title>
      <link href="/2020/08/04/LOJ%206039%20-%20%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202017%20Day5%E3%80%8D%E7%8F%A0%E5%AE%9D%20%E3%80%8C%E9%87%8D%E9%87%8F%E8%BE%83%E5%B0%8F%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE01%E8%83%8C%E5%8C%85%E3%80%8D/"/>
      <url>/2020/08/04/LOJ%206039%20-%20%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202017%20Day5%E3%80%8D%E7%8F%A0%E5%AE%9D%20%E3%80%8C%E9%87%8D%E9%87%8F%E8%BE%83%E5%B0%8F%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE01%E8%83%8C%E5%8C%85%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$01$ 背包，数据范围 $1 \le n \le 1e06, 1 \le weight_i \le 300$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>神仙 $01$ 背包</p><p>考虑重量较小，故可以考虑根据重量分层处理</p><p>令 $f_{i, j}$ 表示使用前 $i$ 个重量，总共花费 $j$ 容量的最大价值</p><p>容易注意到在同一重量中显然要优先选择价值大的，故将每种重量按价值排序，令 $sumv_{i, j}$ 表示重量为 $i$ 的前 $j$ 大的价值前缀和，则有<br>$$<br>f_{i, j} = \max\limits_k \{f_{i - 1, j - ki} + sumv_{i, k}\}<br>$$<br>然后（通过看题解）可以发现，因为是 $j - ki$，故可以考虑按照 $j \mod i$ 分类处理，这样是满足决策单调性的</p><p>至于证明，为了方便可以将式子简化成 $f_i = \max \{f_j +sumv_{i - j}\}$ 的形式，然后用反证法或是四边形不等式都容易证明</p><p>那么最后就可以用决策单调性的套路代码或者是用分治解决了</p><p>分治比较简单，大概就是看在处理区间 $[u, v]$， $[l, r]$ 决策区间内对于 $mid$ 位置在 $[l, r]$ 中最有决策在哪个位置，然后左右递归即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5e04</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXC = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, C = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value[MAXC];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; prefix[MAXC];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXC][MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL trans[MAXK]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">w</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = (i - j) / s;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= (<span class="keyword">int</span>) prefix[s].size())</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">return</span> f[s - <span class="number">1</span>][j] + prefix[s][p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 层数 处理区间 决策区间</span></span><br><span class="line"><span class="keyword">int</span> mid = (u + v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">LL maxi = - <span class="number">1</span>, posi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min (mid, r); i ++) &#123;</span><br><span class="line">LL cont = w (trans[mid], trans[i], p);</span><br><span class="line"><span class="keyword">if</span> (cont &gt; maxi)</span><br><span class="line">maxi = cont, posi = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">f[p][trans[u]] = maxi;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">solve (p, u, mid, l, posi);</span><br><span class="line">solve (p, mid + <span class="number">1</span>, v, posi, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> c = getnum (), v = getnum ();</span><br><span class="line">C = max (C, c), value[c].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i ++) &#123;</span><br><span class="line">sort (value[i].begin(), value[i].end(), comp);</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line">prefix[i].push_back(sum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) value[i].size(); j ++)</span><br><span class="line">sum += value[i][j], prefix[i].push_back(sum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line">trans[limit = <span class="number">1</span>] = j;</span><br><span class="line"><span class="keyword">while</span> (trans[limit] + i &lt;= K)</span><br><span class="line">limit ++, trans[limit] = trans[limit - <span class="number">1</span>] + i;</span><br><span class="line">solve (i, <span class="number">1</span>, limit, <span class="number">1</span>, limit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">write (f[C][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">1 48</span></span><br><span class="line"><span class="comment">3 25</span></span><br><span class="line"><span class="comment">2 76</span></span><br><span class="line"><span class="comment">4 83</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT（快速傅里叶变换）</title>
      <link href="/2020/08/04/FFT%EF%BC%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%89/"/>
      <url>/2020/08/04/FFT%EF%BC%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>　　<strong>- 点值表示</strong><br>　　　　对于一个$n - 1$次多项式$A(x)$，可以通过确定$n$个点与值（即$x$和$y$）来表示这唯一的$A(x)$</p><p>　　<strong>- 复数</strong><br>　　　　对于一元二次方程<br>　　　　$$x^2 + 1 = 0$$<br>　　　　在实数范围内无解，那么我们将实数范围扩充，就得到了复数，再令$i$为该方程的解，即<br>　　　　$$i^2 = - 1$$<br>　　　　那么就定义$z = a + bi$的数为复数，则有<br>　　　　当$b = 0$时，$z$为实数<br>　　　　当$b \neq 0$时，$z$为虚数<br>　　　　当$a = 0  \&amp;\&amp;  b \neq 0$时，$z$为纯虚数<br>　　　　其中，复数满足加法交换律、结合律、乘法分配率等</p><p>　　　　复数相乘：$z_1 = a_1 + b_1i,  z_2 = a_2 + b_2i$，则$z_1 × z_2 = (a_1 + b_1i)(a_2 + b_2i) = (a_1a_2 - b_1b_2) + (a_1b_2 + b_1a_2)i$，它们相乘还是一个复数，在复平面上理解，就是模长相乘，幅角相加</p><p>　　　　共轭复数：当两个复数实部相同，虚部为相反数时，两个复数被称为共轭复数</p><p>　　　　对于一个复数$z = a + bi$，还可以在复数平面上用向量表示出来，即有$\overrightarrow{OZ}$一一对应每个$z = a + bi$，那么就有复数的模等于$\overline{Z}$，即$|z| = \sqrt{a^2 + b^2}$<br>　　　　复数直接比较大小没有意义，除非它是一个实数</p><h3 id="FFT-作用"><a href="#FFT-作用" class="headerlink" title="$FFT$作用"></a>$FFT$作用</h3><p>　　那么，有了点值表示，对于多项式$A(x)$和$B(x)$相乘，就不需要$O(n^2)$，而只需要$O(n)$，因为$C(x_i) = A(x_i) * B(x_i)$，然后枚举$x_i$即可<br>　　于是现在的复杂度症结就在于将多项式转化成点值表示的$O(n^2)$了，于是就有$FFT$，可以实现在$O(n  logn)$的时间内转化</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>　　于是傅里叶规定，点值中的$x$为模长为$1$的复数<br>　　至于为什么要取复数而不是实数，因为它有很神奇的性质<br>　　那么对于这$n$个复数的取法，取的是复平面上半径为$1$的一个圆，将其$n$等分后得到的点，令第$i$个点表示为$\omega_n^k(0 \le k \le n - 1)$，那么这个点在复平面中的表示即为$(cos\frac{k}{n}2\pi,  sin\frac{k}{n}2\pi)$，那么根据复数乘法在复平面上的意义为模长相乘，幅长相加，即$\omega_n^k$相当于$(\omega_n^1)^k$，那么称$\omega_n^1$为单位根<br>　　我们就把这$\omega_n^0,  \omega_n^1,  …,  \omega_n^{n - 1}$作为点值表示的$x$，称作离散傅里叶变换的结果<br>　　先给出关于傅里叶逆变换的结论：<br>　　　　- 将多项式$A(x)$的离散傅里叶变换结果作为系数代入多项式$B(x)$，再将每个离散傅里叶变换结果的倒数，即$\omega_n^0,  \omega_n^{- 1},  …,  \omega_n^{- (n - 1)}$作为$x$代入$B(x)$得到点值表示，那么这些表示除以$n$就得到了$A(x)$的原系数 [至于证明：不存在的]<br>　　这就是傅里叶变换神奇的性质</p><h2 id="FFT"><a href="#FFT" class="headerlink" title="$FFT$"></a>$FFT$</h2><p>　　有了傅里叶变换，虽然多项式与点值表示相互转化已经很轻松了，但是复杂度仍然不理想，就有了快速傅里叶变换<br>　　结论：</p><ul><li>$\omega_{2n}^{2k} = \omega_n^k$ [证明：代进原公式显然]<ul><li>$\omega_n^{k + \frac{n}{2}} = - \omega_n^k$ [证明：关于复平面原点中心对称]<br>  对于多项式$A(x) = \sum\limits_{i = 0}^{n - 1} a_ix^i$，将它的奇偶项拆开，并将$x$转为$x^2$得到（此处先假定$n$为偶数）</li></ul></li></ul><p>$$<br>N(x) = a_0 + a_2x + a_4x^2 + … + a_{n - 2}x^{\frac{n}{2} - 1} \\<br>M(x) = a_1 + a_3x + a_5x^2 + … + a_{n - 1}x^{\frac{n}{2} - 1}<br>$$</p><p>　　    当然此时代入的是$N(x^2),  M(x^2)$，则有</p><p>$$<br>A(x) = N(x^2) + xM(x^2)<br>$$<br>​    　　此时就需要把$\omega_n^k$代入，分情况讨论：<br>　　    若$k &lt; \frac{n}{2}$，则有<br>$$<br>\begin{aligned}<br>A(\omega_n^k) &amp;= N(\omega_n^{2k}) + \omega_n^kM(\omega_n^{2k}) \\<br>&amp;= N(\omega_{\frac{n}{2}}^k) + \omega_n^kM(\omega_{\frac{n}{2}}^k)<br>\end{aligned}<br>$$</p><p>​    　　反之</p><p>$$<br>\begin{aligned}<br>A(\omega_n^k) &amp;= N(\omega_n^{2k + n}) + \omega_n^{k + \frac{n}{2}}M(\omega_n^{2k + n}) \\<br>&amp;= N(\omega_n^{2k} × \omega_n^n) + \omega_n^{k + \frac{n}{2}}M(\omega_n^{2k} × \omega_n^n)（这一步是通过复数乘法复平面上的意义化简的） \\<br>&amp;= N(\omega_{\frac{n}{2}}^k) - \omega_n^kM(\omega_{\frac{n}{2}}^k)<br>\end{aligned}<br>$$</p><p>　　于是，我们只要求得$\{\omega_{\frac{n}{2}}^0,  \omega_{\frac{n}{2}}^1,  …,  \omega_{\frac{n}{2}}^{\frac{n}{2} - 1}\}$，就可以得到$A(x)$的所有关于所有离散傅里叶变换结果的点值表示了，可用分治实现，复杂度$O(n  logn)$</p><h3 id="代码（分治FFT）"><a href="#代码（分治FFT）" class="headerlink" title="代码（分治FFT）"></a>代码（分治FFT）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e06</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">mcomplex () &#123;&#125;</span><br><span class="line">mcomplex (<span class="keyword">double</span> fx, <span class="keyword">double</span> fy) :</span><br><span class="line">x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x + p.x, y + p.y);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x - p.x, y - p.y);</span><br><span class="line">&#125;</span><br><span class="line">mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (x * p.x - y * p.y, x * p.y + y * p.x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">mcomplex <span class="title">omega</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mcomplex (<span class="built_in">cos</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n), <span class="number">1.0</span> * inv * <span class="built_in">sin</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n));</span><br><span class="line">&#125;</span><br><span class="line">mcomplex A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">mcomplex a1[n &gt;&gt; <span class="number">1</span>], a2[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">a1[i &gt;&gt; <span class="number">1</span>] = a[i];</span><br><span class="line">a2[i &gt;&gt; <span class="number">1</span>] = a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">FFT (a1, m, inv);</span><br><span class="line">FFT (a2, m, inv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">mcomplex x = omega (n, i, inv);</span><br><span class="line">a[i] = a1[i] + x * a2[i];</span><br><span class="line">a[i + m] = a1[i] - x * a2[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">A[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">B[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">FFT (A, n, <span class="number">1</span>);</span><br><span class="line">FFT (B, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">A[i] = A[i] * B[i];</span><br><span class="line">FFT (A, n, - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i)</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i].x / n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>　　于是这样还是会超时，那么还需要优化<br>　　根据表格，有一个考眼力的性质<br>　　$|0  1  2  3|$<br>　　$|0  2 | 1  3|$<br>　　$|0 | 2 | 1 | 3|$<br>　　会发现每个数字的目标位置的二进制是原数的二进制翻转的结果，比如$1 = (01)_2,  2 = (10)_2$恰好是相对应的，于是就可以根据这个性质先将每个数排列到最终位置，再逐一合并</p><h4 id="代码（迭代优化-FFT-）"><a href="#代码（迭代优化-FFT-）" class="headerlink" title="代码（迭代优化$FFT$）"></a>代码（迭代优化$FFT$）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span> (- <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mcomplex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    mcomplex () &#123;&#125;</span><br><span class="line">    mcomplex (<span class="keyword">double</span> fx, <span class="keyword">double</span> fy) :</span><br><span class="line">        x (fx), y (fy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    mcomplex <span class="keyword">operator</span> + (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x + p.x, y + p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    mcomplex <span class="keyword">operator</span> - (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x - p.x, y - p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    mcomplex <span class="keyword">operator</span> * (<span class="keyword">const</span> mcomplex&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mcomplex (x * p.x - y * p.y, x * p.y + y * p.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">mcomplex <span class="title">omega</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mcomplex (<span class="built_in">cos</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n), <span class="number">1.0</span> * inv * <span class="built_in">sin</span> (<span class="number">2.0</span> * PI * (<span class="keyword">double</span>) k / (<span class="keyword">double</span>) n));</span><br><span class="line">&#125;</span><br><span class="line">mcomplex A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oppo[MAXN];</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span> <span class="params">(mcomplex* a, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oppo[i])</span><br><span class="line">            swap (a[i], a[oppo[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        mcomplex ome = mcomplex (<span class="built_in">cos</span> (PI / (<span class="keyword">double</span>) mid), inv * <span class="built_in">sin</span> (PI / (<span class="keyword">double</span>) mid));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; limit; j += n) &#123;</span><br><span class="line">            mcomplex x = mcomplex (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k ++, x = x * ome) &#123;</span><br><span class="line">                mcomplex a1 = a[j + k], xa2 = x * a[j + k + mid];</span><br><span class="line">                a[j + k] = a1 + xa2;</span><br><span class="line">                a[j + k + mid] = a1 - xa2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++)</span><br><span class="line">        A[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)</span><br><span class="line">        B[i].x = (<span class="keyword">double</span>) getnum ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, lim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= N + M; n &lt;&lt;= <span class="number">1</span>, lim ++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        oppo[i] = (oppo[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lim - <span class="number">1</span>));</span><br><span class="line">    limit = n;</span><br><span class="line">    FFT (A, <span class="number">1</span>);</span><br><span class="line">    FFT (B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        A[i] = A[i] * B[i];</span><br><span class="line">    FFT (A, - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d"</span>, (<span class="keyword">int</span>) (A[i].x / n + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　这样的$FFT$可以在$O(n  logn)$的时间内求出多项式乘法的各项系数，主要流程：将两个多项式分别转化成点值表示 $\dashrightarrow$ 通过点值表示将两个多项式合并 $\dashrightarrow$ 通过离散傅里叶逆变换将点值表示转化成系数表示，即得解</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/RabbitHu/p/FFT.html" target="_blank" rel="noopener">[小学生都能看懂的FFT！！！]</a></p><p><a href="https://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">[快速傅里叶变换(FFT)详解]</a></p><p><a href="https://blog.csdn.net/qq_39670434/article/details/79678103" target="_blank" rel="noopener">[复数——概念和代数运算]</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF917D Stranger Trees</title>
      <link href="/2020/08/04/CF917D%20Stranger%20Trees/"/>
      <url>/2020/08/04/CF917D%20Stranger%20Trees/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Solution-Ⅰ"><a href="#Solution-Ⅰ" class="headerlink" title="Solution Ⅰ"></a>Solution Ⅰ</h2><p>一道有点有趣的树形 $dp$ + 容斥，反正绕了我半天，这么神仙我也不可能写出来</p><p>首先考虑基本思路，直接求解恰好 $k$ 个较难，故考虑先求解大于等于 $k$ 的相似度的方案数，然后再容斥</p><p>考虑选定了必选的若干条边后计算方案数。显然此时整个图被分成了若干连通块，假设有 $k$ 个连通块，将连通块缩点，考虑它们可以组成的树的方案数，本来应该是 $k^{k - 2}$，然而对于每个连通块的缩点，它可以向其它连通块中包含的任意一点连接，也就是说，在 purfer 序列中，应当考虑连通块内的点编号在序列中的出现情况，而不是仅仅考虑连通块编号出现在序列中，故 prufer 序列中的每个位置可以填 $n$ 个数，即 $n^{k - 2}$，然而考虑了父亲，还需要考虑儿子，作为叶子节点的缩点后的连通块，同样的里面也是任意点向外连边，故还需乘上 $\prod size_i$，其中，$size_i$ 为连通块 $i$ 的大小，那么综上，对于一个存在 $k$ 个连通块的图，其构造的生成树的方案数为 $n^{k - 2} \times \prod size_i$</p><p>那么现在考虑求解 $\prod size_i$，使用树形 $dp$ 求解</p><p>令 $f_{root, i, j}$ 表示以 $root$ 为根，总计 $j$ 个连通块，$root$ 所在的连通块大小为 $j$ 的方案数，那么对于 $root$ 的每个儿子有选或不选的两种情况，枚举其儿子 $son$ 的连通块个数 $k$ 及 $son$ 所在连通块大小 $l$：</p><ul><li>选：$f_{root, i + k - 1, j + l} += f_{root, i, j} \times f_{son, k, l}$</li><li>不选：$f_{root, i + k, j} = f_{root, i, j} \times f_{son, k, l} \times l$</li></ul><p>注意每次的 $\times size_i$ 是在整个连通块 $i$ 已经确定下来的时候才能乘，故在其父亲扫描到当前节点的时候才乘上其所在连通块大小</p><p>再给出 $g_i = \sum\limits_{i = 1}^n\sum\limits_{j = 1}^{n - i + 1} n^{i - 2}f_{1, i, j} \times j$</p><p>注意此时的 $g_k$ 并不是严格意义上的大于等于 $k$ 的相似度的答案，而是对于每一种使用大于等于 $k$ 条重复边分割连通块的方案数，再扩展成树时会重复，故 $g_i - g_{i + 1}$ 并不是 $ans_i$，那么此时再进行容斥，即<br>$$<br>g_i = g_i - \sum\limits_{j = i + 1}^{n - 1} g_j\dbinom{j}{i}<br>$$<br>即对于每一组恰好 $j$ 条重复边的方案数，那么在每一组方案中选出任意 $i$ 条边即可组成 $g_i$ 中的一种方案，故其方案数的总和即为 $g_i$ 多算的方案数</p><p>此时 $g_i$ 即为解</p><p>复杂度 $O (n^4)$</p><p>复杂度证明</p><p>求解 $S = \sum\limits_{i = 1}^n size_i^2 \big(\sum\limits size_{son}^2\big)$ 最大值</p><p>现在考虑对于每一个节点 $i$，求解 $size_i^2 \big(\sum\limits size_{son}^2\big)$ 最大值</p><p>令 $i$ 的儿子集合为 $SON$，则有 $\sum\limits_{j \in SON} size_j = size_i - 1$，求解 $\sum\limits_{j \in SON} size_j^2$ 最大值</p><p>因为 $(size_i - 1)^2 = (\sum\limits_{j \in SON} size_j)^2 \ge \sum\limits_{j \in SON} size_j^2$，故当 $SON$ 大小为 $1$ 时上式取最大值</p><p>显然 $S_{max}$ 随着 $n$ 而递增，又由于对于所有 $SON$ 大小为 $1$ 时的点 $i$ 其 $size_i^2 = t_1$，对于其它任意情况点 $i$ 的 $size_i^2 = t_2$，显然可以对这些有标号点找到一种排列使得对于 $\forall i$， 存在 $t_1 \ge t_2$，故这样则可使得 $S$ 取最大值，此时该树为一条链，$S_{max} = \sum\limits_{i = 1}^n i^2 = \frac{(2n +1)n(n + 1)}{6}$，故复杂度上限为 $O (n^4)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">p = (p + MOD - <span class="number">1</span>) % (MOD - <span class="number">1</span>);</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL fact[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact[n] * power (fact[m], MOD - <span class="number">2</span>) % MOD * power (fact[n - m], MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subsize[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL temp[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">subsize[root] = f[root][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = Head[root]; p; p = Link[p].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[p].to;</span><br><span class="line"><span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">DFS (v, root);</span><br><span class="line"><span class="built_in">memset</span> (temp, <span class="number">0</span>, <span class="keyword">sizeof</span> (temp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= subsize[root]; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= subsize[root] - i + <span class="number">1</span>; j ++)</span><br><span class="line"><span class="keyword">if</span> (f[root][i][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= subsize[v]; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= subsize[v] - k + <span class="number">1</span>; l ++) &#123;</span><br><span class="line">temp[i + k - <span class="number">1</span>][j + l] = (temp[i + k - <span class="number">1</span>][j + l] + f[root][i][j] * f[v][k][l] % MOD) % MOD; <span class="comment">// select</span></span><br><span class="line">temp[i + k][j] = (temp[i + k][j] + f[root][i][j] * f[v][k][l] % MOD * l % MOD) % MOD; <span class="comment">// do not select</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span> (f[root], temp, <span class="keyword">sizeof</span> (f[root]));</span><br><span class="line">subsize[root] += subsize[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL g[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) output (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">Insert (u, v), Insert (v, u);</span><br><span class="line">&#125;</span><br><span class="line">DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 相似度 n - k</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL base = power (<span class="number">1l</span>l * N, i - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N - i + <span class="number">1</span>; j ++) &#123;</span><br><span class="line">g[N - i] = (g[N - i] + base * f[<span class="number">1</span>][i][j] % MOD * j % MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (N - i == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Test: "</span> &lt;&lt; f[<span class="number">1</span>][i][j] % MOD % MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line">g[i] = (g[i] - g[j] * C (j, i) % MOD + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">output (g[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Solution-Ⅱ"><a href="#Solution-Ⅱ" class="headerlink" title="Solution Ⅱ"></a>Solution Ⅱ</h2><p>这是一个矩阵树定理的解法</p><p>这与「<a href="https://www.luogu.org/problem/P5296" target="_blank" rel="noopener">[北京省选集训2019]生成树计数</a>」极为相似，都是多项式矩阵树定理</p><p>对于不在给定树上的边将其权值赋为 $1$，对于在给定树上的边将其权值赋为 $x$（即多项式 $x$），然后矩阵树定理即可</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1187F Expected Square Beauty</title>
      <link href="/2020/08/04/CF1187F%20Expected%20Square%20Beauty/"/>
      <url>/2020/08/04/CF1187F%20Expected%20Square%20Beauty/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次做到这种类似代数方法运用期望性质的题的说</p><p>期望性质：</p><ul><li>对于两个独立的对象 $A, B$，则有 $E (AB) = E(A)E(B)​$</li><li>线性性：对于对象 $X, Y​$，存在 $E(aX + bY) = aE(x) + bE(Y)​$</li></ul><p>首先设计函数 $I_i(x) = \begin{cases} 1     x_i \neq x_{i - 1} \ 0     x_i = x_{i - 1} \end{cases} (i &gt; 1), ~ I_1(x) = 1​$，则有 $B(x) = \sum\limits_{i = 1}^n I_i(x)​$，故<br>$$<br>\begin{aligned}<br>E (B^2(x)) &amp;= E (\sum\limits_{i = 1}^n I_i(x)\sum\limits_{j = 1}^n I_j(x)) \\<br>&amp;= E (\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n I_i(x)I_j(x)) \\<br>&amp;= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n E(I_i(x)I_j(x))<br>\end{aligned}<br>$$<br>易知，若 $x_i = x_{i - 1}​$ 的概率 $p_i = \frac{\min(r_{i - 1}, r_i) - \max (l_{i - 1}, l_i) + 1}{(r_{i - 1} - l_{i - 1} + 1)(r_i - l_i + 1)}​$，那么 $x_i \neq x_{i - 1}​$ 的概率，即 $E(I_i(x)) = 1 - p_i​$，特别地，$p_1 = 0, E(I_1(x)) = 1​$</p><p>那么此时对 $E (I_i(x)I_j(x))​$ 进行讨论：</p><p>若 $i = j$，则 $E(I_i(x)I_j(x)) = E(I_i(x))$</p><p>若 $|i - j| &gt; 1​$，那么 $I_i(x)​$ 与 $I_j(x)​$ 分别独立，故 $E(I_i(x)I_j(x)) = E(I_i(x))E(I_j(x))​$</p><p>若 $|i - j| = 1​$，令 $i + 1 = j​$，那么进行容斥，即 $E(I_i(x)I_{i- 1}(x)) = 1 - p_{i - 1} - p_i + P ((x_{i - 2} == x_{i - 1}) \bigcup (x_{i - 1} == x_i))​$，根据 $E(I_i(x))​$ 的计算方法，易知，$P ((x_{i - 2} = x_{i - 1}) \bigcup (x_{i - 1} = x_i)) =  \frac{\min(r_{i - 2}, r_{i - 1}, r_i) - \max (l_{i - 2}, l_{i - 1}, l_i) + 1}{(r_{i - 2} - l_{i - 2} + 1)(r_{i - 1} - l_{i - 1} + 1)(r_i - l_i + 1)}​$，特别地，$E(I_1(x)I_2(x)) = E(I_2(x))​$</p><p>综上，最后答案为</p><p>$E(B^2(x)) = \sum\limits_{i = 1}^n(p_i + \sum\limits_{|i - j| &gt; 1} p_j) + 2\sum\limits_{i = 2}^n E(I_i(x)I_{i - 1}(x))$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> l[MAXN], r[MAXN];</span><br><span class="line"><span class="keyword">int</span> size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">LL p[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL psum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) l[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) r[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) size[i] = r[i] - l[i] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL nume = max (<span class="number">0</span>, min (r[i - <span class="number">1</span>], r[i]) - max (l[i - <span class="number">1</span>], l[i]) + <span class="number">1</span>);</span><br><span class="line">LL base = <span class="number">1l</span>l * size[i - <span class="number">1</span>] * size[i] % MOD;</span><br><span class="line">p[i] = nume * power (base, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">psum[i] = (psum[i - <span class="number">1</span>] + (<span class="number">1l</span>l - p[i] + MOD) % MOD) % MOD;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">1</span>) ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD * psum[i - <span class="number">2</span>] % MOD) % MOD;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">2</span> &lt;= N)</span><br><span class="line">ans = (ans + (<span class="number">1l</span>l - p[i] + MOD) % MOD * ((psum[N] - psum[i + <span class="number">1</span>] + MOD) % MOD) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">LL part3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (N &gt; <span class="number">1</span>) part3 = (<span class="number">1l</span>l - p[<span class="number">2</span>] + MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL nume = max (<span class="number">0</span>, min (r[i - <span class="number">2</span>], min (r[i - <span class="number">1</span>], r[i])) - max (l[i - <span class="number">2</span>], max (l[i - <span class="number">1</span>], l[i])) + <span class="number">1</span>);</span><br><span class="line">LL base = <span class="number">1l</span>l * size[i - <span class="number">2</span>] * size[i - <span class="number">1</span>] % MOD * size[i] % MOD;</span><br><span class="line">LL per = ((<span class="number">1l</span>l - p[i - <span class="number">1</span>] - p[i] + nume * power (base, MOD - <span class="number">2</span>) % MOD) % MOD + MOD) % MOD;</span><br><span class="line">part3 = (part3 + per) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">part3 = part3 * <span class="number">2l</span>l % MOD;</span><br><span class="line">ans = (ans + part3) % MOD;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 1</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">4 5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3277 - 串</title>
      <link href="/2020/08/04/BZOJ3277%20-%20%E4%B8%B2/"/>
      <url>/2020/08/04/BZOJ3277%20-%20%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>现在给定你n个字符串，询问每个字符串有多少子串（不包括空串）是所有n个字符串中至少k个字符串的子串（注意包括本身）。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先是广义后缀自动机，就是每次将$last$归为$Root$，从而将几个后缀自动机拼在一起处理</p><p>那么现在需要知道每个字串在$n$个母串中的出现次数，所谓字串，就是所有前缀的所有后缀，所以可以顺着前缀走，那么通过$Parent$树找后缀，一直往上跳，那么需要加一的所有后缀就是所属母串并非当前母串的那几个</p><p>此时再整理出每个所属母串个数$Size &gt;= K$的初始贡献，即$Len[i] - Len[Father[i]]$，反之赋$0$</p><p>又子串为前缀的后缀，那么一个节点的贡献即为它祖先至它本身的贡献前缀和，即它所有后缀能够构成的子串数</p><p>最后再遍历一遍前缀统计答案即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="built_in">string</span> Str[MAXN &gt;&gt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Tree[MAXN][<span class="number">30</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Len[MAXN]= &#123;<span class="number">0</span>&#125;, Size[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Belong[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = Root, nodes = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Append</span> <span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> bel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = last, p = ++ nodes;</span><br><span class="line">    last = p;</span><br><span class="line">    Len[p] = Len[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fa &amp;&amp; ! Tree[fa][c])</span><br><span class="line">        Tree[fa][c] = p, fa = Father[fa];</span><br><span class="line">    <span class="keyword">if</span> (! fa)</span><br><span class="line">        Father[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Tree[fa][c];</span><br><span class="line">        <span class="keyword">if</span> (Len[x] == Len[fa] + <span class="number">1</span>)</span><br><span class="line">            Father[p] = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> np = ++ nodes;</span><br><span class="line">            Len[np] = Len[fa] + <span class="number">1</span>, Father[np] = Father[x];</span><br><span class="line">            Father[p] = Father[x] = np;</span><br><span class="line">            <span class="built_in">memcpy</span> (Tree[np], Tree[x], <span class="keyword">sizeof</span> (Tree[x]));</span><br><span class="line">            <span class="keyword">while</span> (fa &amp;&amp; Tree[fa][c] == x)</span><br><span class="line">                Tree[fa][c] = np, fa = Father[fa];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Topo[MAXN];</span><br><span class="line"><span class="keyword">int</span> W[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buck[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        <span class="keyword">int</span> p = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            p = Tree[p][Str[i][j] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> fa = p;</span><br><span class="line">            <span class="keyword">while</span> (fa &amp;&amp; Belong[fa] != i) &#123;</span><br><span class="line">                Size[fa] ++;</span><br><span class="line">                Belong[fa] = i;</span><br><span class="line">                fa = Father[fa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        buck[Len[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        buck[i] += buck[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nodes; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        Topo[buck[Len[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Size[i] &gt;= K)</span><br><span class="line">            W[i] = Len[i] - Len[Father[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodes; i ++)</span><br><span class="line">        W[Topo[i]] += W[Father[Topo[i]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Answer[MAXN &gt;&gt; <span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Str[i];</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        last = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            Append (Str[i][j] - <span class="string">'a'</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Merge ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Str[i].size();</span><br><span class="line">        <span class="keyword">int</span> p = Root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            p = Tree[p][Str[i][j] - <span class="string">'a'</span>], Answer[i] += W[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">putchar</span> (<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld"</span>, Answer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">ab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aaa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2959 - 长跑</title>
      <link href="/2020/08/04/BZOJ%202959%20-%20%E9%95%BF%E8%B7%91/"/>
      <url>/2020/08/04/BZOJ%202959%20-%20%E9%95%BF%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>每个点有各自的权值，要求维护操作：动态加边、动态修改权值、询问在每个点只能经过一次的情况下两点间路程中的最大权值和</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对于一个静态的图，将其缩点，可以得到一棵树，那么两点间询问的答案即为它们之间经过的 $BCC$ 的权值和</p><p>支持动态加边，就需要用到 $LCT$ 去维护 $BCC$</p><p>如果两个点所在 $BCC$ 在不同树上，那么直接连边即可；反之，则说明形成了环，就暴力将这条链拖出来，用选定一个标准节点，用并查集将链上其它节点连到标准节点上，容易证明，这样的复杂度是均摊 $O (\log n)$ 的</p><p>查询即修改容易实现，不加赘述</p><p>注意，此题没有删边，所以 $findroot$ 可用另一个并查集代替，不然会 $T$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e04</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ances[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == ances[p] ? p : ances[p] = find (ances[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lctanc[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lctfind</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == lctanc[p] ? p : lctanc[p] = lctfind (lctanc[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL realval[MAXN];</span><br><span class="line"><span class="keyword">int</span> father[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> son[MAXN][<span class="number">2</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">LL Sum[MAXN]= &#123;<span class="number">0</span>&#125;, value[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> revtag[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">0</span>] != p &amp;&amp; son[father[p]][<span class="number">1</span>] != p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sonbel</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[father[p]][<span class="number">1</span>] == p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! p)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    swap (son[p][<span class="number">0</span>], son[p][<span class="number">1</span>]);</span><br><span class="line">    revtag[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Sum[p] = Sum[son[p][<span class="number">0</span>]] + Sum[son[p][<span class="number">1</span>]] + value[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (revtag[p]) &#123;</span><br><span class="line">        reverse (son[p][<span class="number">0</span>]), reverse (son[p][<span class="number">1</span>]);</span><br><span class="line">        revtag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = father[p], anc = father[fa];</span><br><span class="line">    <span class="keyword">int</span> s = sonbel (p);</span><br><span class="line">    son[fa][s] = son[p][s ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[fa][s])</span><br><span class="line">        father[son[fa][s]] = fa;</span><br><span class="line">    <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">        son[anc][sonbel (fa)] = p;</span><br><span class="line">    father[p] = anc;</span><br><span class="line">    son[p][s ^ <span class="number">1</span>] = fa, father[fa] = p;</span><br><span class="line">    pushup (fa), pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    top = <span class="number">0</span>, Stack[++ top] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = p; ! isroot (nd); nd = father[nd])</span><br><span class="line">        Stack[++ top] = father[nd];</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">        pushdown (Stack[top]), top --;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa = father[p]; ! isroot (p); rotate (p), fa = father[p])</span><br><span class="line">        <span class="keyword">if</span> (! isroot (fa))</span><br><span class="line">            sonbel (p) == sonbel (fa) ? rotate (fa) : rotate (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Access</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tp = <span class="number">0</span>; p; tp = p, p = father[tp] = find (father[p])) <span class="comment">// 注意因为有并查集，所以也要同时更新father[tp]</span></span><br><span class="line">        splay (p), son[p][<span class="number">1</span>] = tp, pushup (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Makeroot</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Access (p), splay (p), reverse (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Makeroot (x);</span><br><span class="line">    Access (y), splay (y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Makeroot (x);</span><br><span class="line">    father[x] = y;</span><br><span class="line">    <span class="keyword">int</span> fx = lctfind (x), fy = lctfind (y);</span><br><span class="line">    lctanc[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> root)</span> </span>&#123; <span class="comment">// 暴力合并</span></span><br><span class="line">    <span class="keyword">if</span> (! p)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p != root)</span><br><span class="line">        ances[p] = root, value[root] += value[p];</span><br><span class="line">    merge (son[p][<span class="number">0</span>], root), merge (son[p][<span class="number">1</span>], root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (lctfind (fx) != lctfind (fy)) &#123;</span><br><span class="line">        link (fx, fy);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Split (fx, fy);</span><br><span class="line">    merge (fy, fy);</span><br><span class="line">    son[fy][<span class="number">0</span>] = son[fy][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup (fy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x);</span><br><span class="line">    splay (fx);</span><br><span class="line">    value[fx] -= realval[x] - val, realval[x] = val;</span><br><span class="line">    pushup (fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line">    <span class="keyword">if</span> (lctfind (fx) != lctfind (fy))</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    Split (fx, fy);</span><br><span class="line">    <span class="keyword">return</span> Sum[fy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar ();</span><br><span class="line">    <span class="keyword">int</span> isneg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            isneg = <span class="number">1</span>;</span><br><span class="line">        ch = getchar ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isneg ? - num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> answer[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = getnum (), M = getnum ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        Sum[i] = value[i] = realval[i] = getnum (), lctanc[i] = ances[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = getnum ();</span><br><span class="line">        <span class="keyword">int</span> x = getnum (), y = getnum ();</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">            Add (x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">            Modify (x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query (x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 31</span></span><br><span class="line"><span class="comment">10 20 30 40 50 60 70 80 90</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">1 8 9</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 4 6</span></span><br><span class="line"><span class="comment">1 4 7</span></span><br><span class="line"><span class="comment">3 1 8</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">1 8 9</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">3 7 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">1 4 1</span></span><br><span class="line"><span class="comment">3 7 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">1 5 7</span></span><br><span class="line"><span class="comment">3 6 5</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 5 5</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">2 8 180</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">2 9 190</span></span><br><span class="line"><span class="comment">3 9 9</span></span><br><span class="line"><span class="comment">2 5 150</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">2 1 210</span></span><br><span class="line"><span class="comment">3 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论,数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC003解题报告</title>
      <link href="/2020/08/04/AGC003%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2020/08/04/AGC003%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="D-Anticube"><a href="#D-Anticube" class="headerlink" title="D - Anticube"></a>D - Anticube</h2><p>说实话质因数分解的题都挺有意思的</p><p>首先对于每个数，显然里面存在的质数三次方的因子都是无贡献的，那么将其的每个质因数化简，即对于质因子 $p^k$，将其变为 $p^{k ~ mod ~  3}$</p><p>那么两个数若乘积为完全立方数，则必须满足它们的每一个相同质因子都是“互补的”（即次数相加为 $0$ 或 $3$），同时显然一定不存在大于一个 $&gt; \sqrt[3]n$ 的质因数 $p$，那么解法就很显然了</p><p>就是筛出 $[2, \sqrt[3]n]$ 的质数，然后对每一个数进行化简，然后将化简后的数的计数器加一，最后在所有两两“互补”的数中取 $max$ 求和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">LL a[MAXN], newa[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXM]= &#123;<span class="number">0</span>&#125;, pcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXM]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">prime[++ pcnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= MAX; j += i)</span><br><span class="line">visit[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr1::<span class="built_in">unordered_map</span>&lt;LL, <span class="keyword">int</span>&gt; mapp, ccnt;</span><br><span class="line"><span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span> <span class="params">(LL x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; j ++)</span><br><span class="line">cnt *= x;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;LL, LL&gt; save[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">save[++ ind] = make_pair (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">mapp[<span class="number">0</span>] = mapp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">LL p = a[i];</span><br><span class="line">LL cnt = <span class="number">1</span>, ano = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j ++)</span><br><span class="line"><span class="keyword">if</span> (! (p % prime[j])) &#123;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (! (p % prime[j]))</span><br><span class="line">p /= prime[j], times ++;</span><br><span class="line">times %= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (times &gt; <span class="number">0</span>)</span><br><span class="line">ano *= power (prime[j], <span class="number">3</span> - times);</span><br><span class="line">cnt *= power (prime[j], times);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] != <span class="number">1</span> &amp;&amp; cnt == <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) &#123;</span><br><span class="line">ccnt[<span class="number">0</span>] ++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ccnt[cnt * p] ++, newa[i] = cnt * p;</span><br><span class="line"><span class="keyword">if</span> (mapp[cnt * p]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">LL sqr = <span class="built_in">sqrt</span> (p);</span><br><span class="line"><span class="keyword">if</span> (sqr * sqr == p) &#123;</span><br><span class="line">save[++ ind] = make_pair (cnt * p, ano * sqr);</span><br><span class="line">mapp[cnt * p] = mapp[ano * sqr] = ind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">save[++ ind] = make_pair (cnt, ano);</span><br><span class="line">mapp[cnt] = mapp[ano] = ind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ccnt[<span class="number">0</span>] = min (ccnt[<span class="number">0</span>], <span class="number">1</span>), ccnt[<span class="number">1</span>] = min (ccnt[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ind; i ++)</span><br><span class="line">ans += max (ccnt[save[i].first], ccnt[save[i].second]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! mapp[newa[i]])</span><br><span class="line">ans ++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T num = T ();</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum&lt;<span class="keyword">int</span>&gt; ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum&lt;LL&gt; ();</span><br><span class="line">sieve ();</span><br><span class="line"><span class="keyword">int</span> ans = solve ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1000000007</span></span><br><span class="line"><span class="comment">10000000000</span></span><br><span class="line"><span class="comment">1000000009</span></span><br><span class="line"><span class="comment">999999999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">2368593037</span></span><br><span class="line"><span class="comment">38192375</span></span><br><span class="line"><span class="comment">218391929</span></span><br><span class="line"><span class="comment">572421321</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="E-Sequential-operations-on-Sequence"><a href="#E-Sequential-operations-on-Sequence" class="headerlink" title="E - Sequential operations on Sequence"></a>E - Sequential operations on Sequence</h2><p>先考虑所有只存在增加长度的操作</p><p>那么可以从后往前枚举，考虑后面的操作对前面的贡献</p><p>那么对于每一个位置 $p$，它相当于是第一个小于它的位置 $q$ 算 $p / q$ 次，然后再算一次 $p ~ mod ~ q$，故递归即可</p><p>然后对于减少长度的操作，显然该操作之前所有长度大于等于当前长度的操作都是无用的，故只需初始化时取递增的操作即可转化为只存在增加长度的操作的集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL que[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LL suffix[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findpos</span> <span class="params">(<span class="keyword">int</span> limit, LL delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; que[<span class="number">1</span>]) <span class="keyword">return</span> delta;</span><br><span class="line"><span class="keyword">int</span> posi = upper_bound (que + <span class="number">1</span>, que + limit, delta) - que - <span class="number">1</span>;</span><br><span class="line">LL add = delta / que[posi], rest = delta % que[posi];</span><br><span class="line">suffix[posi] += suffix[limit] * add;</span><br><span class="line"><span class="keyword">return</span> findpos (limit, rest);</span><br><span class="line">&#125;</span><br><span class="line">LL subsum[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">value[<span class="number">1</span>] = que[<span class="number">1</span>], suffix[tail] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tail; i &gt;= <span class="number">2</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> val = findpos (i, que[i]);</span><br><span class="line">value[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tail; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">subsum[value[i]] += suffix[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">subsum[i] += subsum[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">T num = T ();</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write (x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">write (x), <span class="built_in">puts</span> (<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum&lt;<span class="keyword">int</span>&gt; (), M = getnum&lt;<span class="keyword">int</span>&gt; ();</span><br><span class="line">que[++ tail] = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">LL posi = getnum&lt;LL&gt; ();</span><br><span class="line"><span class="keyword">while</span> (tail &gt;= <span class="number">1</span> &amp;&amp; que[tail] &gt;= posi) tail --;</span><br><span class="line">que[++ tail] = posi;</span><br><span class="line">&#125;</span><br><span class="line">solve ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">println (subsum[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">22</span></span><br><span class="line"><span class="comment">27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">22</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">26</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">24</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="F-Fraction-of-Fractal"><a href="#F-Fraction-of-Fractal" class="headerlink" title="F - Fraction of Fractal"></a><strong>F - Fraction of Fractal</strong></h2><p>于是我又看错了一次题目。。</p><p>对于左右、上下复制后都连通的情况，显然答案为 $1$</p><p>对于左右、上下复制后都不连通的情况，设其黑点个数为 $p$，则答案显然为 $p^{k - 1}$</p><p>那么现在假设左右复制后连通，上下复制后不连通，令其最终状态黑点个数 $x_n$，左右连通的点组（即 $##$）个数为 $y_n$，那么思考一下，答案即为 $x_n - y_n$，考虑转移，那么 $y_i$ 会只会在最左端和最右端连通时增加，故令 $z_i$ 表示 $i$ 状态时最左和最右连通的个数，则转移即为<br>$$<br>\begin{aligned}<br>x_i &amp;= x_{i - 1}^2 \\<br>y_i &amp;= x_{i - 1} \times y_{i - 1} + z_{i - 1} \times y_{i - 1} \\<br>z_i &amp;= z_{i - 1}^2<br>\end{aligned}<br>$$<br>然后发现这样子满足矩阵乘法，即可构造矩阵<br>$$<br>\begin{bmatrix}<br>x_1 &amp; y_1 \\<br>0 &amp; z_1<br>\end{bmatrix}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span> <span class="params">(LL x, LL p)</span> </span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">cnt = cnt * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">LL a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">Matrix () &#123;</span><br><span class="line"><span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; A, <span class="keyword">const</span> Matrix&amp; B) &#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k ++)</span><br><span class="line">ret.a[i][j] = (ret.a[i][j] + A.a[i][k] * B.a[k][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">matpower</span> <span class="params">(Matrix x, LL k)</span> </span>&#123;</span><br><span class="line">Matrix ret = Matrix ();</span><br><span class="line">ret.a[<span class="number">1</span>][<span class="number">1</span>] = ret.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">ret = ret * x;</span><br><span class="line">x = x * x;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ret.a[<span class="number">1</span>][<span class="number">1</span>] - ret.a[<span class="number">1</span>][<span class="number">2</span>] + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">LL k;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d%lld"</span>, &amp; N, &amp; M, &amp; k);</span><br><span class="line"><span class="keyword">int</span> tol = <span class="number">0</span>, toup = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lr = <span class="number">0</span>, ud = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>, <span class="built_in">map</span>[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">cnt ++;</span><br><span class="line">tol += <span class="built_in">map</span>[i][j - <span class="number">1</span>] == <span class="string">'#'</span>;</span><br><span class="line">toup += <span class="built_in">map</span>[i - <span class="number">1</span>][j] == <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[i][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; <span class="built_in">map</span>[i][M] == <span class="string">'#'</span>) lr ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[<span class="number">1</span>][j] == <span class="string">'#'</span> &amp;&amp; <span class="built_in">map</span>[N][j] == <span class="string">'#'</span>) ud ++;</span><br><span class="line"><span class="keyword">if</span> (! lr &amp;&amp; ! ud) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; power (<span class="number">1l</span>l * cnt, k - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lr &amp;&amp; ud) &#123;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! lr) swap (lr, ud), swap (tol, toup);</span><br><span class="line">Matrix x = Matrix ();</span><br><span class="line">x.a[<span class="number">1</span>][<span class="number">1</span>] = cnt, x.a[<span class="number">1</span>][<span class="number">2</span>] = tol, x.a[<span class="number">2</span>][<span class="number">2</span>] = lr;</span><br><span class="line">LL ans = matpower (x, k - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 3 3</span></span><br><span class="line"><span class="comment">.#.</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment">#.#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11 15 1000000000000000000</span></span><br><span class="line"><span class="comment">.....#.........</span></span><br><span class="line"><span class="comment">....###........</span></span><br><span class="line"><span class="comment">....####.......</span></span><br><span class="line"><span class="comment">...######......</span></span><br><span class="line"><span class="comment">...#######.....</span></span><br><span class="line"><span class="comment">..##.###.##....</span></span><br><span class="line"><span class="comment">..##########...</span></span><br><span class="line"><span class="comment">.###.....####..</span></span><br><span class="line"><span class="comment">.####...######.</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment">#.##..##..##..#</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC002解题报告</title>
      <link href="/2020/08/04/AGC002%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2020/08/04/AGC002%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="D-Stamp-Rally"><a href="#D-Stamp-Rally" class="headerlink" title="D - Stamp Rally"></a>D - Stamp Rally</h2><p>整体二分 + 并查集常规操作</p><p>不过记得每次仅将当前递归时使用的并查集删去即可，之前的保留，所以对于那些被忽略的答案的位置，也需要递归到然后加入并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> answer[MAXQ]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">querySt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"></span><br><span class="line">querySt (<span class="keyword">int</span> find = <span class="number">0</span>, <span class="keyword">int</span> fx = <span class="number">0</span>, <span class="keyword">int</span> fy = <span class="number">0</span>, <span class="keyword">int</span> flim = <span class="number">0</span>) :</span><br><span class="line">index (find), x (fx), y (fy), lim (flim) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">querySt query[MAXQ];</span><br><span class="line"></span><br><span class="line">querySt q1[MAXQ], q2[MAXQ];</span><br><span class="line"><span class="keyword">int</span> father[MAXN], subsize[MAXN];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">stack</span>[MAXM];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> father[x] == x ? x : find (father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] &gt; subsize[fy]) swap (fx, fy);</span><br><span class="line">father[fx] = fy, subsize[fy] += subsize[fx];</span><br><span class="line"><span class="built_in">stack</span>[++ top] = make_pair (fx, fy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="comment">// if (left &gt; right || l &gt; r) return ; 注意若 l &gt; r 就退出那么有一些点无法加入并查集</span></span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "Test: " &lt;&lt; left &lt;&lt; ' ' &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line">answer[query[i].index] = left;</span><br><span class="line">merge (edge[left].first, edge[left].second);</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= mid; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = edge[i].first, v = edge[i].second;</span><br><span class="line">merge (u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = query[i].x, y = query[i].y;</span><br><span class="line"><span class="keyword">int</span> lim = query[i].lim;</span><br><span class="line"><span class="keyword">int</span> fx = find (x), fy = find (y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] &gt;= lim) q1[++ t1] = query[i];</span><br><span class="line"><span class="keyword">else</span> q2[++ t2] = query[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (subsize[fx] + subsize[fy] &gt;= lim) q1[++ t1] = query[i];</span><br><span class="line"><span class="keyword">else</span> q2[++ t2] = query[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1; i ++)</span><br><span class="line">query[l + i - <span class="number">1</span>] = q1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2; i ++)</span><br><span class="line">query[l + t1 + i - <span class="number">1</span>] = q2[i];</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">stack</span>[top].first, y = <span class="built_in">stack</span>[top].second;</span><br><span class="line">top --;</span><br><span class="line">father[x] = x, subsize[y] -= subsize[x];</span><br><span class="line">&#125;</span><br><span class="line">solve (left, mid, l, l + t1 - <span class="number">1</span>), solve (mid + <span class="number">1</span>, right, l + t1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen ("stamp.in", "r", stdin);</span></span><br><span class="line"><span class="comment">// freopen ("stamp.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">N = getnum (), M = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getnum (), v = getnum ();</span><br><span class="line">edge[i] = make_pair (u, v);</span><br><span class="line">&#125;</span><br><span class="line">Q = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = getnum (), y = getnum (), z = getnum ();</span><br><span class="line">query[i] = querySt (i, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">father[i] = i, subsize[i] = <span class="number">1</span>;</span><br><span class="line">solve (<span class="number">1</span>, M, <span class="number">1</span>, Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, answer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">2 4 5</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 13</span></span><br><span class="line"><span class="comment">8 5</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">10 9</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">7 10</span></span><br><span class="line"><span class="comment">7 1</span></span><br><span class="line"><span class="comment">2 7</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">8 10</span></span><br><span class="line"><span class="comment">6 9</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4 9 11</span></span><br><span class="line"><span class="comment">6 2 2</span></span><br><span class="line"><span class="comment">5 4 5</span></span><br><span class="line"><span class="comment">10 8 4</span></span><br><span class="line"><span class="comment">2 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="E-Candy-Piles"><a href="#E-Candy-Piles" class="headerlink" title="E - Candy Piles"></a>E - Candy Piles</h2><p>神仙博弈论 + 模型转化</p><p>算是目前做过的为数极少的博弈论题之一，然而并不用 $SG$ 函数什么的</p><p>注意 $2$ 操作是对于每一堆都吃一个而不是任选一堆吃，然而我看完题解才发现我题目看错了。。。</p><p>将糖果堆按照个数排序后，得到如下图</p><blockquote><p>000</p><p>000</p><p>0000</p><p>00000</p></blockquote><p>将其看做以左下角为点 $(1, 1)$ 的坐标系，那么，对于吃最大的一堆糖果，就相当于向上移一格，对于每堆吃一个糖果，就相当于向右移一格，然后吃到不能吃为止，即到达点 $(3, 4), ~ (4, 2), ~ (1, 5)$ 的其中一个</p><p>显然，上述无法继续走动的三点是必输点，那么就可以通过上述点扩张将整幅图的必赢必输状态表示出来</p><p>根据定理</p><blockquote><p>若一个点是必赢点当且仅当其可转移的状态中存在必输点；若一个点是必输点当且仅当其可转移的状态中皆是必赢点</p></blockquote><p>就可以实现</p><p>当然，这样还是 $T$ 的，所以经过观察，可以发现</p><ul><li>一个点的必赢必输状态与其左上角的状态相同</li></ul><p>证明的话枚举然后简单反证一下就好了</p><p>故现在可以将点 $(1, 1)$ 一直向右上角移动到直到无法移动为止的点 $(k, k)$，那么它现在必处于图形的“边缘”上，显然，对于边缘的情况，一个点的状态必与其右（上）的点相反，那么只要判断一下 $(k, k)$ 可以向上或向右扩张直到无法移动的步数的奇偶性，若存在奇数，则为先手必赢；反之，则后手必赢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line">sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>, comp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt;= i) &#123;</span><br><span class="line"><span class="keyword">bool</span> win = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> ((a[i] - i) &amp; <span class="number">1</span>)</span><br><span class="line">win = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (! win &amp;&amp; a[i + <span class="number">1</span>] == i) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; i) <span class="keyword">break</span>;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! (cnt &amp; <span class="number">1</span>))</span><br><span class="line">win = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">win ? <span class="built_in">puts</span> (<span class="string">"First"</span>) : <span class="built_in">puts</span> (<span class="string">"Second"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="F-Leftmost-Ball"><a href="#F-Leftmost-Ball" class="headerlink" title="F - Leftmost Ball"></a>F - Leftmost Ball</h2><p>动态规划</p><p>一开始我是按照常规思路想，并且将一个白球与一类颜色球当做一个整体来处理的，即设 $f_{i, j}$ 表示前 $i$ 个位置放置 $j$ 个白球的方案数，然而首先这样会 $T$，并且容易算重，于是我去康了眼题解</p><p>然后发现实际上白球不能与类颜色球整体考虑，不然会算重，但是显然一类颜色球是可以整体考虑的，故设状态 $f_{i, j}$ 表示放了 $i$ 个白球和 $j$ 个类颜色球的方案数 $(j \le i)$</p><p>那么问题来了，要如何知道每个球在当前状态下的位置关系呢？因为感觉不知道没法确定球的可放置方案数</p><p>当然假如真的要知道位置关系是不可能的，所以仔细思考一下，可以发现，若当前你要放一个白球，那么在你放当前白球的位置之前的位置必须已经被完全填满，不然必会存在该白球之后的类颜色球放置在当前白球前，使得方案不合法，故当前白球放置的相对位置一定只有一个，即 $f_{i, j} += f_{i - 1,j }$</p><p>对于放置类颜色球，由于当前类颜色球的白球已经放置完毕，故它还剩下 $n \times k - i - (k - 1) \times(j - 1)$ 个位置放其 $k - 1$ 个球，且当前还剩下 $n - (j - 1)$ 个颜色可供选择，故得 $f_{i, j} += f_{i, j - 1} \times (n - j + 1) \times \dbinom{n \times k - i - (k - 1) \times (j - 1)}{k - 1}$</p><p>然而你会发现这样连样例都过不了，因为你又算重了</p><p>比如对于</p><blockquote><p>{0, 0, 1, 2}</p></blockquote><p>就会存在先放 $\{0, 1\}$ 还是 $\{0, 2\}$ 的问题，然后会放两遍，所以理论上只要是存在连续的 $0$ 的都会算重</p><p>于是一时脑抽，又只能瞄题解了</p><p>其实解决方案极其简单，只要满足当前放的类颜色球的第一个一定是最接近 $0$ 的就行了，也就是规定其放置顺序</p><p>故综上所述，转移方程为<br>$$<br>f_{i, j} = f_{i - 1, j} + f_{i, j - 1} \times (n - j + 1) \times \dbinom{n \times k - i - (k - 1) \times (j - 1) - 1}{k - 2}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"></span><br><span class="line">LL fact[MAXM]= &#123;<span class="number">0</span>&#125;, invfact[MAXM]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = invfact[<span class="number">0</span>] = invfact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N * K; i ++) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N * K; i ++)</span><br><span class="line">invfact[i] = invfact[i - <span class="number">1</span>] * invfact[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f[MAXN][MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>, &amp; N, &amp; K);</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">init ();</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">LL delta = f[i][j - <span class="number">1</span>] * (N - j + <span class="number">1</span>) % MOD * C (N * K - i - (K - <span class="number">1</span>) * (j - <span class="number">1</span>) - <span class="number">1</span>, K - <span class="number">2</span>) % MOD;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) delta = <span class="number">0</span>;</span><br><span class="line">f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j] + delta) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N][N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2000 2000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC001 E - Wide Swap</title>
      <link href="/2020/08/04/AGC001%20E%20-%20Wide%20Swap/"/>
      <url>/2020/08/04/AGC001%20E%20-%20Wide%20Swap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先显然要先把原数组重新映射一下，令映射过后的数组为 $a_i$</p><p>因为题目要求 $|a_j - a_i| &gt;= K$ 的可以置换，那么反之，则有 $|a_j - a_i| &lt; K$ 的 $i, j$ 相对位置不变</p><p>故最简单的方法就是对于每个 $i$，将其与所有满足 $|a_j - a_i| &lt; K$ 的 $j$ 连边，然后跑一边拓扑，复杂度 $O (n^2)$</p><p>然后考虑在 $a_i$ 连的这么多边中，若是存在边 $(i, j), (j, k), (i, k)$，其中 $i &lt; j &lt; k$，那么显然 $(i, k)$ 的存在性是无关紧要的</p><p>又 $a_i$ 可连边的权值范围是 $(a_i - K, a_i) \cup (a_i, a_i + K)$，那么只需要分别向两个区间中标号最小的那个点连边就好了（单向边，并且一定向标号比自己大的点连），这样就相当于是将原来的乱七八糟连接的图变成了一条条单向的链，并且这些链可以覆盖原来的所有情况</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson root &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson root &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5e05</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedForwardStar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">LinkedForwardStar Link[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Head[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">Link[++ size].to = v;</span><br><span class="line">Link[size].next = Head[u];</span><br><span class="line"></span><br><span class="line">Head[u] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]= &#123;<span class="number">0</span>&#125;, b[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minv[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> posi, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">minv[root] = value;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (posi &lt;= mid) modify (lson, left, mid, posi, value);</span><br><span class="line"><span class="keyword">else</span> modify (rson, mid + <span class="number">1</span>, right, posi, value);</span><br><span class="line">minv[root] = min (minv[lson], minv[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= left &amp;&amp; right &lt;= R)</span><br><span class="line"><span class="keyword">return</span> minv[root];</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mv = INF;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) mv = min (mv, query (lson, left, mid, L, R));</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) mv = min (mv, query (rson, mid + <span class="number">1</span>, right, L, R));</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indeg[MAXN]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="keyword">int</span> ret[MAXN]= &#123;<span class="number">0</span>&#125;, rcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="keyword">if</span> (! indeg[i])</span><br><span class="line">que.push(i);</span><br><span class="line"><span class="keyword">while</span> (! que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.top();</span><br><span class="line">que.pop();</span><br><span class="line">ret[p] = ++ rcnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[p]; i; i = Link[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Link[i].to;</span><br><span class="line">indeg[v] --;</span><br><span class="line"><span class="keyword">if</span> (! indeg[v]) que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (! <span class="built_in">isdigit</span> (ch))</span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span> (ch))</span><br><span class="line">num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">N = getnum (), K = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">a[i] = getnum ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">b[a[i]] = i;</span><br><span class="line"><span class="built_in">memset</span> (minv, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (minv));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line"><span class="keyword">int</span> p1 = query (<span class="number">1</span>, <span class="number">1</span>, N, max (<span class="number">1</span>, b[i] - K + <span class="number">1</span>), b[i] - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> p2 = query (<span class="number">1</span>, <span class="number">1</span>, N, b[i] + <span class="number">1</span>, min (N, b[i] + K - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (p1 &gt;= <span class="number">1</span> &amp;&amp; p1 &lt;= N) Insert (b[i], b[p1]), indeg[b[p1]] ++;</span><br><span class="line"><span class="keyword">if</span> (p2 &gt;= <span class="number">1</span> &amp;&amp; p2 &lt;= N) Insert (b[i], b[p2]), indeg[b[p2]] ++;</span><br><span class="line">modify (<span class="number">1</span>, <span class="number">1</span>, N, b[i], i);</span><br><span class="line">&#125;</span><br><span class="line">topo ();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ret[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">4 2 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">5 4 3 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 3</span></span><br><span class="line"><span class="comment">4 5 7 8 3 1 2 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
